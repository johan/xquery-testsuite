<?xml version="1.0"?>
<!DOCTYPE spec SYSTEM "../schema/xsl-query.dtd" [ 
<!-- <!DOCTYPE spec SYSTEM "xsl-query.dtd" [ -->
<!ENTITY date.day "23">
<!ENTITY date.DD "23">
<!ENTITY date.month "January">
<!ENTITY date.MM "01">
<!ENTITY date.year "2007">
<!ENTITY xdt-schema-app SYSTEM "../data-model/xdt-schema-app.xml">
<!ENTITY prevdate.day "21">
<!ENTITY prevdate.DD "21">
<!ENTITY prevdate.month "November">
<!ENTITY prevdate.MM "11">
<!ENTITY prevdate.year "2006">
<!ENTITY doc.date "&date.year;&date.MM;&date.DD;">
<!ENTITY doc.prevdate "&prevdate.year;&prevdate.MM;&prevdate.DD;">

<!--* AC.close date: what is the expected end date of the PR
    * review period?  This can go away when we exit PR. *-->
<!ENTITY AC.close.date "31 December 2006">

<!ENTITY w3c.tr "http://www.w3.org/TR">
<!ENTITY doc.shortname "xpath-functions">
<!ENTITY doc.nsname "xpath-functions">
<!-- Changed this version back to correspond to other XQuery specs... JM 2001-08-22
<!ENTITY doc.publoc "&w3c.tr;/&date.year;/&date.MM;/&doc.shortname;"> -->
<!ENTITY doc.publoc "&w3c.tr;/&date.year;/REC-&doc.shortname;-&doc.date;/">
<!ENTITY doc.prevloc "&w3c.tr;/&prevdate.year;/PR-&doc.shortname;-&doc.prevdate;/">
<!ENTITY doc.latestloc "&w3c.tr;/&doc.shortname;/">
<!ENTITY doc.version "">
<!ENTITY codepoint.collation "http://www.w3.org/2005/xpath-functions/collation/codepoint">
<!-- Added several entities for characters used in this document JM 2001-08-20 -->
<!ENTITY currency "&#x00A4;">
<!ENTITY divide "&#x00F7;">
<!-- DIVISION SIGN -->
<!ENTITY times "&#x00D7;">
<!-- MULTIPLICATION SIGN -->
<!ENTITY eacute "&#x00E9;">
<!ENTITY ocircumflex "&#x00F4;">
<!ENTITY aumlaut "&#x00E4;">
<!ENTITY uumlaut "&#x00FC;">

<!ENTITY t1 "&#x0905;">
<!ENTITY t2 "&#x0936;">
<!ENTITY t3 "&#x094A;">
<!ENTITY t4 "&#x0915;">

<!ENTITY e1 "&#x00E8;">
<!ENTITY e2 "&#x00E9;">

<!ENTITY egrave "&#x00E8;">
<!ENTITY Egrave "&#x00C8;">


<!ENTITY % status-entities SYSTEM "../etc/status-entities.dtd">
%status-entities;

<!ENTITY status-section-id "status">
<!ENTITY spec-devby    "&fo-devby;">
<!ENTITY changelog-id  "&fo-changelog-id;">
<!ENTITY changes-para  "&post.PR.changes;">
<!ENTITY implementation-para  "&no-implementation-report-exists;">
<!ENTITY Bugzilla-key "[&fo-Bugzilla-key;]">
<!ENTITY patent-policy-paragraph "&ppp-two;">

<!ENTITY status-section SYSTEM "../etc/status-REC.xml">


]>
<!--
<?xml-stylesheet type="text/xsl" href="E:\XMLdocs\XML Query Language (XQuery)\Functions and Operators\Current Functions and Operators Build Files\xquery-operators.xsl"?> -->
<spec w3c-doctype="rec" status="ext-review">
    <header>
        <title>XQuery 1.0 and XPath 2.0 Functions and Operators</title>
        <version>&doc.version;</version>
        <w3c-designation>REC-&doc.shortname;</w3c-designation>
        <w3c-doctype>W3C Recommendation</w3c-doctype>
        <pubdate>
            <day>&date.day;</day>
            <month>&date.month;</month>
            <year>&date.year;</year>
        </pubdate>
        <publoc>
            <loc href="&doc.publoc;">&doc.publoc;</loc>
        </publoc>
  <altlocs>
    <loc href="&doc.publoc;xpath-functions.xml">XML</loc>
    <loc href="&doc.publoc;diff-from-20061121.html">Recent revisions</loc>
  </altlocs>
        <latestloc>
            <loc href="&doc.latestloc;">&doc.latestloc;</loc>
        </latestloc>
        <prevlocs>
            <loc href="&doc.prevloc;">&doc.prevloc;</loc>    
<!--*	    <loc href="http://www.w3.org/TR/2006/CR-xpath-functions-20060608/">http://www.w3.org/TR/2006/CR-xpath-functions-20060608/</loc> 
	    <loc href="http://www.w3.org/TR/2005/CR-xpath-functions-20051103/">http://www.w3.org/TR/2005/WD-xpath-functions-20051103/</loc> *-->
<!--
            <loc href="http://www.w3.org/TR/2005/WD-xpath-functions-20050404/">http://www.w3.org/TR/2005/WD-xpath-functions-20050404/</loc> 
-->
        </prevlocs>
        <authlist>
            <author>
                <name>Ashok Malhotra (XML Query and XSL WGs)</name>
                <affiliation>Oracle Corporation</affiliation>
                <email href="mailto:ashok.malhotra@alum.mit.edu">ashok.malhotra@alum.mit.edu</email>
            </author>
            <author>
                <name>Jim Melton (XML Query WG)</name>
                <affiliation>Oracle Corporation</affiliation>
                <email href="mailto:jim.melton@acm.org">jim.melton@acm.org</email>
            </author>
            <author>
                <name>Norman Walsh (XSL WG)</name>
                <affiliation>Sun Microsystems</affiliation>
                <email href="mailto:Norman.Walsh@Sun.COM">Norman.Walsh@Sun.COM</email>
            </author>
        </authlist>

<errataloc xmlns:xlink = "http://www.w3.org/1999/xlink"
              href="http://www.w3.org/XML/2007/qt-errata/xpath-functions-errata.html" xlink:type="simple"/>

        <translationloc
   href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xpath-functions"
                      /> 
        <abstract>
            <p>This document defines constructor functions, operators and functions on the datatypes defined in
                    <bibref ref="xmlschema-2"/> and the datatypes defined in <bibref ref="xpath-datamodel"/>. It also discusses
                functions and operators on nodes and node sequences as defined in the <bibref
                ref="xpath-datamodel"/>.  These functions and operators are defined for use in <bibref ref="xpath20"/>, <bibref ref="xquery"/> and
                    <bibref ref="xslt20"/> and other related XML standards.  The signatures and summaries of functions defined in this document are available at:
<loc href="http://www.w3.org/2005/xpath-functions">http://www.w3.org/2005/xpath-functions</loc>.</p>
</abstract>

&status-section;

<!--*
<status id="status">
 <p><emph>This section describes the status of this
          document at the time of its publication.
          Other documents may supersede this document.
          A list of current W3C publications and the latest
          revision of this technical report can be found in the
          <loc href="http://www.w3.org/TR/">W3C technical reports index</loc>
          at http://www.w3.org/TR/.</emph></p>

       <p>This is one document in a set of eight documents that have progressed to
          Recommendation together (XQuery 1.0, XQueryX 1.0, XSLT 2.0,
          Data Model, Functions and Operators, Formal Semantics,
          Serialization, XPath 2.0). </p>

       <p>This is a <loc
          href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsREC">Recommendation</loc>
          of the W3C.  This document has been
          jointly developed by the W3C XML Query Working Group and
          the W3C XSL Working Group, each part of the XML Activity.

          It has been reviewed by W3C Members and other interested parties
          and has been endorsed by the Director.
          It is a stable document and may be used as reference material
          or cited as a normative reference from another document.
          W3C's role in making the Recommendation is to draw attention to
          the specification and to promote its widespread deployment.
          This enhances the functionality and interoperability of the Web. </p>

       <p>This document incorporates minor changes made against the
          <loc
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed
          Recommendation</loc>
          of 21 November 2006; please see the public disposition of comments for details.
          Changes to this document since the
          <loc
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed
          Recommendation</loc>
          are detailed in the
          <specref ref="changelog">Change Log for this Version of the Document</specref>. </p> 
          <p>Please report errors in this document using W3C's
          <loc href="http://www.w3.org/Bugs/Public/">public Bugzilla system</loc>
          (instructions can be found at
          <loc
href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
          If access to that system is not feasible, you may send your comments
          to the W3C XSLT/XPath/XQuery public comments mailing list,
          <loc
href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</loc>.
          It will be very helpful if you include the string
          [FO] in the subject line of your report, whether made in Bugzilla or in email.
          Each Bugzilla entry and email message should contain only one error report.
          Archives of the comments and responses are available at
          <loc
href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</loc>.
</p>

          <p>This document was produced by a group operating under the
          <loc
href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004
          W3C Patent Policy</loc>.  The Working Groups maintain
          a public list of patent disclosures relevant to this document;
          that page also includes instructions for disclosing [and excluding]
          a patent.
          An individual who has actual knowledge of a patent which the individual believes
          contains
          <loc
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
          Claim(s)</loc>
          must disclose the information in accordance with
          <loc
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
          6 of the W3C Patent Policy</loc>. </p>

</status>
*-->
        <langusage>
            <language id="EN">English</language>
        </langusage>
        <revisiondesc>
           <p></p>
        </revisiondesc>
    </header>
    <body>
        <div1 id="intro">
            <head>Introduction</head>
            <p>The purpose of this document is to catalog the functions and operators required for
                XPath 2.0, XML Query 1.0 and XSLT 2.0. The exact syntax used to invoke these
                functions and operators is specified in <bibref ref="xpath20"/>, <bibref
                ref="xquery"/> and <bibref ref="xslt20"/>. </p>
            <p>This document defines constructor functions and functions that take typed values as
                arguments. Some of the functions define the semantics of operators discussed in
                    <bibref ref="xquery"/>.</p>
            <p>
                <bibref ref="xmlschema-2"/> defines a number of primitive and derived datatypes,
                collectively known as built-in datatypes. This document defines functions and
                operations on these datatypes as well as the datatypes defined in <xspecref
                    spec="DM" ref="types"/> of the <bibref ref="xpath-datamodel"/>.
                These functions and operations are defined for use in <bibref ref="xpath20"/>,
                    <bibref ref="xquery"/> and <bibref ref="xslt20"/> and related XML standards. This
                document also discusses functions and operators on nodes and node sequences as
                defined in the <bibref ref="xpath-datamodel"/> for use in <bibref ref="xpath20"/>, <bibref
                ref="xquery"/> and <bibref ref="xslt20"/> and other related XML standards. </p>
            <p>References to specific sections of some of the above documents are indicated by
                cross-document links in this document. Each such link consists of a pointer to a
                specific section followed a superscript specifying the linked document. The
                superscripts have the following meanings: 'XQ' <bibref ref="xquery"/>, 'XT' <bibref
                ref="xslt20"/>, 'XP' <bibref ref="xpath20"/>, 'DM' <bibref ref="xpath-datamodel"/> and 'FS'
                    <bibref ref="xquery-semantics"/>.</p>
            <div2 id='conformance'>
                <head>Conformance</head>
<p>
The Functions and Operators specification is intended primarily as a
component that can be used by other specifications. Therefore, Functions
and Operators relies on specifications that use it (such as 
<bibref ref="xpath20"/>, <bibref ref="xslt20"/> and <bibref ref='xquery'/>)
to specify conformance criteria for their respective environments.</p> 
<p>
Authors of conformance criteria for the use of the Functions and
Operators should pay particular attention to the following features:</p>
<ulist>
<item>
<p>It is <termref def="implementation-defined"/> which version of Unicode is supported, but it is recommended that the most recent version of Unicode be used.  </p>
</item>
<item><p>Support for XML 1.0 and XML 1.1 by the datatypes used in Functions and Operators.</p></item>
</ulist>
<note><p>At the time of writing there is no published version of XML Schema
    that references the XML 1.1 specifications. This means that
    datatypes such as <code>xs:NCName</code> and <code>xs:ID</code> are 
    constrained by the XML 
    1.0 rules. Authors of conformance requirements for the use of
    Functions and Operators should state clearly the implications for
    conformance of any changes to the rules in later versions of XML
    Schema.</p></note>
</div2>
            <div2 id="namespace-prefixes">
                <head>Namespaces and Prefixes</head>
                <p>The functions and operators discussed in this document are contained in one of
                    three namespaces (see <bibref ref="REC-xml-names"/>) and referenced using an
                    <code>xs:QName</code>. The datatypes and constructor functions for the built-in datatypes defined
                    in <bibref ref="xmlschema-2"/> and in <xspecref spec="DM" ref="types"/>
                   of <bibref ref="xpath-datamodel"/> and discussed in <specref ref="constructor-functions"/>  are in the XML Schema namespace, <code>http://www.w3.org/2001/XMLSchema</code>,
                    and named in this document using the <code>xs</code> prefix. The namespace
                    prefix used in this document for functions that are available to users is
                    <code>fn</code>. Operator functions are named with the prefix <code>op</code>. </p>
<!--
                <p>The datatypes defined in <bibref ref='xpath-datamodel'/> <xspecref spec="DM" ref="types"/> 
                    and <specref ref="duration-subtypes"/> in this document are contained in a
                    separate namespace and are named using the prefix <code>xdt</code>.</p> -->
                <p>This document uses the prefix <code>err</code> to represent the namespace URI <code>http://www.w3.org/2005/xqt-errors</code>, which is the namespace for all XPath and XQuery error codes and messages. This namespace prefix is not predeclared and its use in this document is not normative.</p>
                <p> The namespace prefix used for the functions, datatypes and errors can vary, as
                    long as the prefix is bound to the correct URI.</p>
                <p>The URIs of the namespaces and the default prefixes associated with them are:</p>
                <ulist>
                    <item>
                        <p>
                            <code>http://www.w3.org/2001/XMLSchema</code> for constructors --
                            associated with <code>xs</code>.
                        </p>
                    </item>
                    <!--					<item>
						<p>
							<code>http://www.w3.org/2005/xpath-operators</code> for operators</p>
					</item> -->
                    <item>
                        <p>

                            <code>http://www.w3.org/2005/&doc.nsname;</code>
                            for functions -- associated with <code>fn</code>. </p>
                    </item>
                 <!--   <item>
                        <p>

                            <code>http://www.w3.org/&date.year;/xpath-datatypes</code>
                            for the datatypes associated with <code>xdt</code>. </p>
                    </item> -->
                    <item>
                        <p>
                            <code>http://www.w3.org/2005/xqt-errors</code> -- associated with
                            <code>err</code>. </p>
                    </item>
                </ulist>
                <note>
                    <p>The namespace URI associated with the <code>err</code> prefix is not
                        expected to change from one version of this document to another. The
                        contents of this namespace may be extended to allow additional errors to be returned.</p>
                </note>
                <p>The functions defined with an <code>fn</code> prefix are callable by the user.
                    Functions defined with the <code>op</code> prefix are described here to
                    underpin the definitions of the operators in <bibref ref="xpath20"/>, <bibref
                    ref="xquery"/> and <bibref ref="xslt20"/>. These functions are not available
                    directly to users, and there is no requirement that implementations should
                    actually provide these functions. For this reason, no namespace is associated
                    with the <code>op</code> prefix. For example, multiplication is generally
                    associated with the <code>*</code> operator, but it is described as a function
                    in this document:</p>
                <example role="signature">
                    <proto role="example" name="numeric-multiply" return-type="numeric" isOp="yes">
                        <arg name="arg1" type="numeric"/>
                        <arg name="arg2" type="numeric"/>
                    </proto>
                </example>
            </div2>
            <div2 id="func-overloading">
                <head>Function Overloading</head>
                <p> In general, the specifications named above do not support function overloading
                    in the sense that functions that have multiple signatures with the same name and
                    the same number of parameters are not supported. Consequently, there are no such
                    overloaded functions in this document except for legacy <bibref ref="xpath"/>
                    functions such as <code>fn:string()</code>, which accepts a single parameter of
                    a variety of types. In addition, it should be noted that the functions defined
                    in <specref ref="numeric-functions"/> that accept <code>numeric</code>
                    parameters accept arguments of type <code>xs:integer</code>,
                    <code>xs:decimal</code>, <code>xs:float</code> or <code>xs:double</code>. See
                        <specref ref="func-signatures"/>. Operators such as "+" may be overloaded.
                    This document does define some functions with more than one signature with the
                    same name and different number of parameters. User-defined functions with more
                    than one signature with the same name and different number of parameters are
                    also supported. </p>
            </div2>
            <div2 id="func-signatures">
                <head>Function Signatures and Descriptions</head>
                <p>Each function is defined by specifying its signature, a description of the return
                    type and each of the parameters and its semantics. For many functions, examples
                    are included to illustrate their use. </p>
                <p>Each function's signature is presented in a form like this:</p>
                <example role="signature">
                    <proto role="example" name="function-name" return-type="return-type">
                        <arg name="parameter-name" type="parameter-type"/>
                        <arg name="..." type=""/>
                    </proto>
                </example>
                <p>In this notation, <term>function-name</term>, in bold-face, is the name of the
                    function whose signature is being specified. If the function takes no
                    parameters, then the name is followed by an empty parameter list:
                    "<code>()</code>"; otherwise, the name is followed by a parenthesized list of
                    parameter declarations, each declaration specifies the static type of the
                    parameter, in italics, and a descriptive, but non-normative, name. If there are
                    two or more parameter declarations, they are separated by a comma. The <emph>
                        <code>return-type</code>
                    </emph>, also in italics, specifies the static type of the value returned by the
                    function. The dynamic type returned by the function is the same as its static
                    type or derived from the static type. All parameter types and return types are
                    specified using the SequenceType notation defined in <xspecref spec="XP" ref="id-sequencetype-syntax"/>.</p>
                <p>In some cases the word <quote>
                        <code>numeric</code>
                    </quote> is used in function signatures as a shorthand to indicate the four
                    numeric types: <code>xs:integer</code>, <code>xs:decimal</code>,
                    <code>xs:float</code> and <code>xs:double</code>. For example, a function with
                    the signature <example role="signature">
                        <proto role="example" name="numeric-function" return-type="...">
                            <arg name="arg" type="numeric"/>
                        </proto>
                    </example> represents the following four function signatures:<example role="signature">
                        <proto role="example" name="numeric-function" return-type="...">
                            <arg name="arg" type="xs:integer"/>
                        </proto>
                    </example>
                    <example role="signature">
                        <proto role="example" name="numeric-function" return-type="...">
                            <arg name="arg" type="xs:decimal"/>
                        </proto>
                    </example>
                    <example role="signature">
                        <proto role="example" name="numeric-function" return-type="...">
                            <arg name="arg" type="xs:float"/>
                        </proto>
                    </example>
                    <example role="signature">
                        <proto role="example" name="numeric-function" return-type="...">
                            <arg name="arg" type="xs:double"/>
                        </proto>
                    </example>
                    <!--
In most cases, numeric functions operate on 
parameters of the same type and return the same type. The exceptions
are <code>op:numeric-divide</code>, which returns an
<code>xs:decimal</code> if called with two <code>xs:integer</code>
operands and <code>op:numeric-integer-divide</code> which always
returns an <code>xs:integer</code>. -->
                </p>
                <p>For most functions there is an initial paragraph describing what the function
                    does followed by semantic rules. These rules are meant to be followed in the
                    order that they appear in this document.</p>
                <p>In some cases, the static type returned by a function depends on the type(s) of
                    its argument(s). These special functions are indicated by using <emph>
                        <term>bold italics</term>
                    </emph> for the return type. The semantic rules specifying the type of the value
                    returned are documented in the function definition. The rules are described more
                    formally in <xspecref spec="FS" ref="function_rules"/>.</p>
                <p>The function name is a <code>QName</code> as defined in <bibref ref="xmlschema-2"/>
                    and must adhere to its syntactic conventions. Following <bibref ref="xpath"/>,
                    function names are composed of English words separated by hyphens,"-". If a
                    function name contains a <bibref ref="xmlschema-2"/> datatype name, it may have
                    intercapitalized spelling and is used in the function name as such. For example, <code>fn:timezone-from-dateTime</code>.</p>
                <p>Rules for passing parameters to operators are described in the relevant sections
                    of <bibref ref="xquery"/> and <bibref ref="xpath20"/>. For example, the rules for
                    passing parameters to arithmetic operators are described in <xspecref spec="XP"
                    ref="id-arithmetic"/>. Specifically, rules for parameters of
                    type <code>xs:untypedAtomic</code> and the empty sequence are specified in this section.</p>
                <p>As is customary, the parameter type name indicates that the function or operator
                    accepts arguments of that type, or types derived from it, in that position. This
                    is called <emph>subtype substitution</emph> (See <xspecref spec="XP"
                    ref="id-sequencetype-matching"/>). In addition, numeric type instances and
                    instances of type <code>xs:anyURI</code> can be promoted to produce an argument
                    of the required type. (See <xspecref spec="XP" ref="promotion"/>). 
                  <olist>
                        <item>
                            <p>
                                <emph>Subtype Substitution</emph>: A derived type may substitute for
                                its base type. In particular, <code>xs:integer</code> may be used
                                where <code>xs:decimal</code> is expected.</p>
                        </item>
                        <item>
                            <p>
                                <emph>Numeric Type Promotion</emph>: <code>xs:decimal</code> may be
                                promoted to <code>xs:float</code> or <code>xs:double</code>. Promotion to <code>xs:double</code> should be done directly, not via <code>xs:float</code>, to avoid loss of precision. 
</p>
                        </item>
                        <item>
                            <p>
                                <emph>anyURI Type Promotion</emph>: A value of
                                type <code>xs:anyURI</code> can be promoted to the
                                type <code>xs:string</code>. </p>
                        </item>
                    </olist>
                </p>
                <p>Some functions accept a single value or the empty sequence as an argument and
                    some may return a single value or the empty sequence. This is indicated in the
                    function signature by following the parameter or return type name with a
                    question mark: "<code>?</code>", indicating that either a single value or the
                    empty sequence must appear. See below.</p>
                <example role="signature">
                    <proto role="example" name="function-name" return-type="return-type" returnEmptyOk="yes">
                        <arg name="parameter-name" type="parameter-type" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Note that this function signature is different from a signature in which the
                    parameter is omitted. See, for example, the two signatures
                    for <code>fn:string()</code>. In the first signature, the parameter is omitted
                    and the argument defaults to the context item, referred to as <quote>.</quote>.
                    In the second signature, the argument must be present but may be the empty
                    sequence, referred to as <quote>().</quote>
                </p>
                <p>Some functions accept a sequence of zero or more values as an argument. This is
                    indicated by following the name of type of the items in the sequence with
                    <code>*</code>. The sequence may contain zero or more items of the named type.
                    For example, the function below accepts a sequence of <code>xs:double</code> and
                    returns a <code>xs:double</code> or the empty sequence.</p>
                <example role="signature">
                    <proto role="example" name="median" return-type="xs:double" returnEmptyOk="yes">
                        <arg name="arg" type="xs:double*" emptyOk="no"/>
                    </proto>
                </example>
            </div2>
            <div2 id="namespace-terminology">
                <head>Namespace Terminology</head>
                <p>This document uses the phrase "namespace URI" to identify the concept identified
                    in <bibref ref="REC-xml-names"/> as "namespace name", and the phrase "local name"
                    to identify the concept identified in <bibref ref="REC-xml-names"/> as "local part".</p>
                <p>It also uses the term <quote>expanded-QName</quote> defined below.</p>
                <glist>
                    <gitem>
                        <label>
                            <termdef id="expanded-Qname" term="Expanded-QName">
                                <term>Expanded-QName</term>
                            </termdef>
                        </label>
                        <def>
                            <p> An expanded-QName is a pair of values consisting of a namespace URI
                                and a local name. They belong to the value space of the <bibref
                                ref="xmlschema-2"/> datatype <code>xs:QName</code>. When this document
                                refers to <code>xs:QName</code> we always mean the value space, i.e.
                                a namespace URI, local name pair (and not the lexical space
                                referring to constructs of the form prefix:local-name).</p>
                        </def>
                    </gitem>
                </glist>
            </div2>
            <div2 id="datatypes">
                <head>Type Hierarchy</head>
                <p>The diagram below shows the types for which functions are defined in this
                    document. These include the built-in types defined by <bibref ref="xmlschema-2"/>
                    (shown on the right) as well as types defined in <bibref ref="xpath-datamodel"/>
                    (shown on the left). Solid lines connect a base datatype above to a derived
                    datatype.<code>xs:IDREFS</code>, <code>xs:NMTOKENS</code>,
                    <code>xs:ENTITIES</code> and <code>user-defined list and union types</code> are
                    special types in that these types are lists or unions rather than true subtypes.
                    Dashed lines connect a union type above with its component types below.</p>
                <graphic source="type-hierarchy.png" alt="Type hierarchy graphic"/>
                <p>The information in the above diagram is reproduced below in tabular form. For
                    ease of presentation the information is divided into three tables. The first
                    table shows the top three layers of the hierarchy starting at
                    <code>xs:anyType</code>. The second table shows the types derived from
                    <code>xs:anyAtomicType</code>. The third table shows the types defined in
                        <bibref ref="xpath-datamodel"/>
                </p>
                <p>Each type whose name is indented is derived from the type whose name appears nearest above it with one less level of indentation.</p>
                <table border="0" summary="Type summary" role="hierarchy">
                   <tbody>
                        <tr>
                            <td>xs:anyType</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>user-defined complex types</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>xs:untyped</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>xs:anySimpleType</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>user-defined list and union types</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>xs:IDREFS</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>xs:NMTOKENS</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>xs:ENTITIES</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>xs:anyAtomicType</td>
                        </tr>
                    </tbody>
                </table>
                <p>The table below shows the datatypes derived from <code>xs:anyAtomicType</code>.
                    This includes all the <bibref ref="xmlschema-2"/> built-in datatypes as well as the
                    two totally ordered subtypes of duration defined in <xspecref
                    spec="DM" ref="types"/>. </p>
                <p>Each type whose name is indented is derived from the type whose name appears
                    nearest above it with one less level of indentation.</p>
                <table border="0" summary="Type summary" role="hierarchy">
                    <tbody>
                        <tr>
                            <td>xs:untypedAtomic</td>
                        </tr>
                        <tr>
                            <td>xs:dateTime</td>
                        </tr>
                        <tr>
                            <td>xs:date</td>
                        </tr>
                        <tr>
                            <td>xs:time</td>
                        </tr>
                        <tr>
                            <td>xs:duration</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>xs:yearMonthDuration</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>xs:dayTimeDuration</td>
                        </tr>
                        <tr>
                            <td>xs:float</td>
                        </tr>
                        <tr>
                            <td>xs:double</td>
                        </tr>
                        <tr>
                            <td>xs:decimal</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>xs:integer</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>xs:nonPositiveInteger</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:negativeInteger</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>xs:long</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:int</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:short</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:byte</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>xs:nonNegativeInteger</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:unsignedLong</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:unsignedInt</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:unsignedShort</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:unsignedByte</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:positiveInteger</td>
                        </tr>
                        <tr>
                            <td>xs:gYearMonth</td>
                        </tr>
                        <tr>
                            <td>xs:gYear</td>
                        </tr>
                        <tr>
                            <td>xs:gMonthDay</td>
                        </tr>
                        <tr>
                            <td>xs:gDay</td>
                        </tr>
                        <tr>
                            <td>xs:gMonth</td>
                        </tr>
                        <tr>
                            <td>xs:string</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>xs:normalizedString</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>xs:token</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:language</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:NMTOKEN</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:Name</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:NCName</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:ID</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:IDREF</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:ENTITY</td>
                        </tr>
                        <tr>
                            <td>xs:boolean</td>
                        </tr>
                        <tr>
                            <td>xs:base64Binary</td>
                        </tr>
                        <tr>
                            <td>xs:hexBinary</td>
                        </tr>
                        <tr>
                            <td>xs:anyURI</td>
                        </tr>
                        <tr>
                            <td>xs:QName</td>
                        </tr>
                        <tr>
                            <td>xs:NOTATION</td>
                        </tr>
                    </tbody>
                </table>
                <p>The table below shows the type hierarchy for the types introduced in <bibref
                    ref="xpath-datamodel"/>. For these types, each type whose name is indented is a
                    component of the union type whose name appears nearest above with one less level
                    of indentation.</p>
                <table border="0" summary="Type summary" role="hierarchy">
                    <tbody>
                        <tr>
                            <td>item</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>xs:anyAtomicType</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>node</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>attribute</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>user-defined attribute types</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>comment</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>document</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>user-defined document types</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>element</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>user-defined element types</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>processing-instruction</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>text</td>
                        </tr>
                    </tbody>
                </table>
            </div2>
            
            <div2 id="terminology">
                <head>Terminology</head>
                <p>The terminology used to describe the functions and operators on <bibref
                    ref="xmlschema-2"/> is defined in the body of this specification. The terms defined
                    in the following list are used in building those definitions:</p>
                <glist>
                    <gitem>
                        <label>
                            <termdef id="compatibility" term="for compatibility">
                                <term>for compatibility</term>
                            </termdef>
                        </label>
                        <def>
                            <p>A feature of this specification included to ensure that
                                implementations that use this feature remain compatible with <bibref ref="xpath"/>
                            </p>
                        </def>
                    </gitem>
                    <gitem>
                        <label>
                            <termdef id="may" term="may">
                                <term>may</term>
                            </termdef>
                        </label>
                        <def>
                            <p>Conforming documents and processors are permitted to, but need not,
                                behave as described. </p>
                        </def>
                    </gitem>
                    <gitem>
                        <label>
                            <termdef id="must" term="must">
                                <term>must</term>
                            </termdef>
                        </label>
                        <def>
                            <p>Conforming documents and processors are required to behave as
                                described; otherwise, they are either non-conformant or else in error.</p>
                        </def>
                    </gitem>
                    <gitem>
                        <label>
                            <termdef id="implementation-defined" term="implementation-defined">
                                <term>implementation-defined</term>
                            </termdef>
                        </label>
                        <def>
                            <p>Possibly differing between implementations, but specified and
                                documented by the implementor for each particular implementation.</p>
                        </def>
                    </gitem>
                    <gitem>
                        <label>
                            <termdef id="implementation-dependent" term="implementation dependent">
                                <term>implementation-dependent</term>
                            </termdef>
                        </label>
                        <def>
                            <p>Possibly differing between implementations, but not specified by this
                                or other W3C specification, and not required to be specified by the
                                implementor for any particular implementation. </p>
                        </def>
                    </gitem>
                    <gitem>
                        <label>
                            <termdef id="execution-scope" term="execution scope">
                                <term>execution scope</term>
                            </termdef>
                        </label>
                        <def>
                            <p>The scope over which any two calls on a function would be executed.
                                In XSLT, it applies to any two calls on the function executed during
                                the same transformation. In XQuery, it applies to any two calls
                                executed during the evaluation of a top-level expression i.e. an
                                expression not contained in any other expression. In other contexts,
                                the scope is specified by the host environment that invokes the
                                function library.</p>
                        </def>
                    </gitem>
                    <gitem>
                        <label>
                            <termdef id="stable" term="stable">
                                <term>stable</term>
                            </termdef>
                        </label>
                        <def>
                            <p> Most of the functions in the core library have the property that
                                calling the same function twice within an <termref
                                def="execution-scope"/> with the same arguments returns the same
                                result: these functions are said to be <term>stable</term>. This
                                category includes a number of functions such as
                                <code>fn:doc()</code>, <code>fn:collection()</code>,
                                <code>fn:current-dateTime()</code>, <code>fn:current-date</code> and
                                <code>fn:current-time()</code> whose result depends on the external
                                environment. Where the function returns nodes, stability means that
                                the returned nodes are identical, not merely equal and are returned
                                in the same order.</p>
<note>
<p>in the case of <code>fn:collection()</code> and <code>fn:doc()</code>, the
requirement for stability may be relaxed: see the function definitions for details.</p>
</note>
                            <p> Some other functions, for example <code>fn:position()</code> and
                                <code>fn:last()</code>, depend on the dynamic context and may,
                                therefore, produce different results each time they are called.
                                These functions are said to be <term>contextual</term>.</p>
                        </def>
                    </gitem>
 					<gitem>
                        <label>
                            <termdef id="uri" term="URI and URI reference">
                                <term>URI and URI reference</term>
                            </termdef>
                        </label>
                        <def>
                        <p>
                        Within this specification, the term "URI" refers to Universal Resource Identifiers as
defined in <bibref ref='rfc3986'/> and extended in <bibref ref='rfc3987'/> with a new name "IRI".  The term "URI   
Reference", unless otherwise stated, refers to a string in the lexical space of the <code>xs:anyURI</code> datatype as defined in <bibref ref="xmlschema-2"/>. Note that this means, in practice, that where this specification requires a "URI Reference", an IRI as defined in <bibref ref='rfc3987'/> will be accepted, provided that other relevant specifications also permit an IRI. The term URI has been retained in preference to IRI to avoid introducing new names for concepts such as "Base URI" that are defined or referenced across the whole family of XML specifications.  Note also that the definition of <code>xs:anyURI</code> is a wider definition than the definition in <bibref ref='rfc3987'/>; for example it does not require non-ASCII characters to be escaped.
						</p></def>
                    </gitem>
                </glist>
            </div2>
        </div1>
        <div1 id="accessors">
            <head>Accessors</head>
            <p>Accessors and their semantics are described in <bibref ref="xpath-datamodel"/>. Some of
                these accessors are exposed to the user through the functions described below.</p>
            <table border="1" width="80%" summary="Function summary">
                <col width="25%"/>
                <col width="25%"/>
                <col width="25%"/>
                <col width="25%"/>
                <thead>
                    <tr>
                        <th>Function</th>
                        <th>Accessor</th>
                        <th>Accepts</th>
                        <th>Returns</th>
                    </tr>
                </thead>
                <tbody>
                    <!--		<tr>
						<td>
							<code>fn:node-kind</code>
						</td>
						<td>
							<code>node-kind</code>
						</td>
						<td>any kind of node</td>
						<td><code>xs:string</code></td>
					</tr> -->
                    <tr>
                        <td>
                            <code>fn:node-name</code>
                        </td>
                        <td>
                            <code>node-name</code>
                        </td>
                        <td>an optional node</td>
                        <td>zero or one <code>xs:QName</code>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:nilled</code>
                        </td>
                        <td>
                            <code>nilled</code>
                        </td>
                        <td>a node</td>
                        <td>an optional <code>xs:boolean</code>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:string</code>
                        </td>
                        <td>
                            <code>string-value</code>
                        </td>
                        <td>an optional item or no argument</td>
                        <td>
                            <code>xs:string</code>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:data</code>
                        </td>
                        <td>
                            <code>typed-value</code>
                        </td>
                        <td>zero or more items</td>
                        <!-- Don Chamberlin email, 2002-07-27 -->
                        <td>a sequence of atomic values</td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:base-uri</code>
                        </td>
                        <td>
                            <code>base-uri</code>
                        </td>
                        <td>an optional node or no argument</td>
                        <td>zero or one <code>xs:anyURI</code>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:document-uri</code>
                        </td>
                        <td>
                            <code>document-uri</code>
                        </td>
                        <td>an optional node</td>
                        <td>zero or one <code>xs:anyURI</code>
                        </td>
                    </tr>
                </tbody>
            </table>
            <div2 id="func-node-name">
                <head>fn:node-name</head>
                <example role="signature">
                    <proto name="node-name" return-type="xs:QName" returnEmptyOk="yes">
                        <arg name="arg" type="node()" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Summary: Returns an expanded-QName for node kinds that can have names. For other
                    kinds of nodes it returns the empty sequence. If <code>$arg</code> is the empty
                    sequence, the empty sequence is returned.</p>
            </div2>
            <div2 id="func-nilled">
                <head>fn:nilled</head>
                <example role="signature">
                    <proto name="nilled" return-type="xs:boolean" returnEmptyOk="yes">
                        <arg name="arg" type="node()" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Summary: Returns an <code>xs:boolean</code> indicating whether the argument node
                    is <quote>nilled</quote>. If the argument is not an element node, returns the
                    empty sequence. If the argument is the empty sequence, returns the empty sequence.</p>
            </div2>
            <div2 id="func-string">
                <head>fn:string</head>
                <example role="signature">
                    <proto name="string" return-type="xs:string"/>
                    <proto name="string" return-type="xs:string">
                        <!-- Don Chamberlin email, 2002-07-27 changed item* to item -->
                        <!-- JM editorial, 2002-08-23 changed item to item? -->
                        <arg name="arg" type="item()" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Summary: Returns the value of <code>$arg</code> represented as a
                    <code>xs:string</code>. If no argument is supplied, the context item (<code>.</code>) is used as the default argument. The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.</p> 
<p>If the context item is undefined, error <xerrorref spec="XP" class="DY" code="0002" type="type"/> is raised.</p>
             <p>If <code>$arg</code> is the empty sequence, the zero-length string is returned.</p>
                <p>If <code>$arg</code> is a node, the function returns the string-value of the
                    node, as obtained using the <code>dm:string-value</code> accessor defined in the
                        <xspecref spec="DM" ref="dm-string-value"/>.</p>
                <p>If <code>$arg</code> is an atomic value, then the function returns the same
                    string as is returned by the expression <quote>
                        <code>$arg</code> cast as <code>xs:string</code>
                    </quote> (see <specref ref="casting"/>).</p>
                      
             </div2>
            <div2 id="func-data">
                <head>fn:data</head>
                <example role="signature">
                    <proto name="data" return-type="xs:anyAtomicType*" returnEmptyOk="no" returnVaries="yes">
                        <arg name="arg" type="item()*"/>
                    </proto>
                </example>
                <p>Summary: <code>fn:data</code> takes a sequence of items and returns a sequence of
                    atomic values.</p>
                <p> The result of <code>fn:data</code> is the sequence of atomic values produced by
                    applying the following rules to each item in <code>$arg</code>:</p>
                <ulist>
                    <item>
                        <p>If the item is an atomic value, it is returned.</p>
                    </item>
                    <item>
                        <p> If the item is a node:</p>
                        <ulist>
                            <item>
                                <p>If the node does not have a typed value an error is
                                        raised  <errorref class="TY" code="0012" type="dynamic"/>. </p>
                            </item>
                            <item>
                                <p>Otherwise, <code>fn:data()</code> returns the typed value of the
                                    node as defined by the accessor function
                                    <code>dm:typed-value</code> in <xspecref spec="DM" ref="dm-typed-value"/>.</p>
                            </item>
                        </ulist>
                    </item>
                </ulist>
            </div2>
            <div2 id="func-base-uri">
                <head>fn:base-uri</head>
                <example role="signature">
                    <proto name="base-uri" return-type="xs:anyURI" returnEmptyOk="yes"/>
                </example>
                <example role="signature">
                    <proto name="base-uri" return-type="xs:anyURI" returnEmptyOk="yes">
                        <arg name="arg" type="node()" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Summary: Returns the value of the base-uri URI property for <code>$arg</code> as
                    defined by the accessor function <code>dm:base-uri()</code> for that kind of
                    node in <xspecref spec="DM" ref="dm-base-uri"/>. If <code>$arg</code> is not
                    specified, the behavior is identical to calling the function with the context item (<code>.</code>) as argument. The following errors may be raised:  if the context item is undefined <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node 
<xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
                <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned.</p>
                <p>Document, element and processing-instruction nodes have a base-uri property which
                    may be empty. The base-uri property of all other node types is the empty
                    sequence. The value of the base-uri property is returned if it exists and is not
                    empty. Otherwise, if the node has a parent, the value of
                    <code>dm:base-uri()</code> applied to its parent is returned, recursively. If the node does not have a parent, or if the recursive ascent up the ancestor chain encounters a node whose base-uri property is empty and it does not have a parent, the empty sequence is returned.</p>
               
                <p>See also <code>fn:static-base-uri</code>.</p>
            </div2>
            <div2 id="func-document-uri">
                <head>fn:document-uri</head>
                <example role="signature">
                    <proto name="document-uri" return-type="xs:anyURI" returnEmptyOk="yes">
                        <arg name="arg" type="node()" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Summary: Returns the value of the document-uri property for <code>$arg</code> as
                    defined by the <code>dm:document-uri</code> accessor function defined in
                        <xspecref spec="DM" ref="DocumentNodeAccessors"/>.</p>
                <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned.</p>
              <p>Returns the empty sequence if the node is not a document node. Otherwise, returns
                    the value of the <code>dm:document-uri</code> accessor of the document node.</p>
               <!-- <p>If <code>fn:document-uri($arg)</code> does not return the empty sequence, then
                    the following expression always holds:</p>
                <eg> fn:doc(fn:document-uri($arg)) is $arg</eg> -->
<p>In the case of a document node <code>$D</code> returned by the <code>fn:doc</code> function, or a document node at the root of a tree containing a node returned by the <code>fn:collection</code> function, it will always be true that either <code>fn:document-uri($D)</code> returns the empty sequence, or that the following expression is true: <code>fn:doc(fn:document-uri($D))</code> is <code>$D</code>. It is implementation-defined whether this guarantee also holds for document nodes obtained by other means, for example a document node passed as the initial context node of a query or transformation.</p>
            </div2>
            <!--		<div2 id="func-unique-ID">
				<head>fn:unique-ID</head>
				<example role="signature">
					<proto name="unique-ID" return-type="ID" returnEmptyOk="yes">
						<arg name="arg" type="node"/>
					</proto>
				</example>
				<p>This function accepts an element node and returns the identifier (ID) which may have been assigned by the user. It corresponds to the normalized value property of the attribute information item in the attributes property that has a type ID, if one exists.  If no ID attribute exists the empty sequence is returned.</p>
			</div2> -->
        </div1>
        <div1 id="func-error">
            <head>The Error Function</head>
            <p>In this document, as well as in <bibref ref="xquery"/>, <bibref ref="xpath20"/>, and
                    <bibref ref="xquery-semantics"/>, the phrase <quote>an error is raised</quote>
                is used. Raising an error is equivalent to invoking the <code>fn:error</code>
                function defined in this section with the provided error code.</p>
            <p> The above phrase is normally accompanied by specification of a specific error, to
                wit: <quote>an error is raised [<emph>error code</emph>]</quote>. Each error defined
                in this document is identified by an <code>xs:QName</code> that is in the
                <code>http://www.w3.org/2005/xqt-errors</code> namespace, represented in this document by the <code>err</code> prefix. It is this
                <code>xs:QName</code> that is actually passed as an argument to the
                <code>fn:error</code> function invocation. Invocation of this function raises an error.  For a
                more detailed treatment of error handing, see <xspecref spec="XP"
                ref="id-handling-dynamic"/> and <xspecref spec="FS" ref="sec_fnerror"/>.</p>
            <p>The <code>fn:error</code> function is a general function that may be invoked as above
                but may also be invoked from <bibref ref="xquery"/> or <bibref ref="xpath20"/>
                applications with, for example, an <code>xs:QName</code> argument. </p>
            <example role="signature">
                <proto name="error" return-type="none"/>
            </example>
            <example role="signature">
                <proto name="error" return-type="none">
                    <arg name="error" type="xs:QName" emptyOk="no"/>
                </proto>
            </example>
            <example role="signature">
                <proto name="error" return-type="none">
                    <arg name="error" type="xs:QName" emptyOk="yes"/>
                    <arg name="description" type="xs:string" emptyOk="no"/>
                </proto>
            </example>
            <example role="signature">
                <proto name="error" return-type="none">
                    <arg name="error" type="xs:QName" emptyOk="yes"/>
                    <arg name="description" type="xs:string" emptyOk="no"/>
                    <arg name="error-object" type="item()*" emptyOk="no"/>
                </proto>
            </example>
            <p>Summary: The <code>fn:error</code> function raises an error. While this function never returns a value, an
                error is returned to the external processing environment as an
                <code>xs:anyURI</code> or an <code>xs:QName</code>. The error <code>xs:anyURI</code>
                is derived from the error <code>xs:QName</code>. An error <code>xs:QName</code> with
                namespace URI NS and local part LP will be returned as the <code>xs:anyURI</code>
                NS#LP. The method by which the <code>xs:anyURI</code> or <code>xs:QName</code> is
                returned to the external processing environment is <termref def="implementation-dependent"/>.</p>
            <p> If an invocation provides <code>$description</code> and <code>$error-object</code>,
                then these values may also be returned to the external processing environment. The
                method by which these values are provided to the external environment is <termref
                def="implementation-dependent"/>. </p>
<note><p>
The value of the <code>$description</code> parameter may need to be localized.
</p></note>
            <p>Note that <quote>none</quote> is a special type defined in <bibref
                ref="xquery-semantics"/> and is not available to the user. It indicates that the
                function never returns and ensures that it has the correct static type.</p>
            <p>If <code>fn:error</code> is invoked with no arguments, then its behavior is the same
                as the invocation of the following expression: </p>
            <eg> fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')) </eg>
            <p> If the first argument in the third or fourth signature is the empty sequence it is
                assumed to be the <code>xs:QName</code> constructed by:</p>
            <eg> fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')</eg>
            <div2 id='func-error-examples'>
                <head>Examples</head>
                <ulist>
                    <item>
                        <p>
                            <code>fn:error()</code> returns
                            <code>http://www.w3.org/2005/xqt-errors#FOER0000</code> (or the corresponding <code>xs:QName</code>) to the
                            external processing environment.</p>
                    </item>
                    <item>
                        <p>
                            <code>fn:error(fn:QName('http://www.example.com/HR', 'myerr:toohighsal'),
                                'Does not apply because salary is too high')</code> returns
                            <code>http://www.example.com/HR#toohighsal</code> and the <code>xs:string</code>
                            <code>"Does not apply because salary is too high"</code> (or the corresponding <code>xs:QName</code>) to the external
                            processing environment.</p>
                    </item>
                </ulist>
            </div2>
        </div1>
        <div1 id="func-trace">
            <head>The Trace Function</head>
<!--*
            <p>This function is intended to be used in debugging queries by providing a trace of
                their execution.</p>
*-->
            <example role="signature">
                <proto name="trace" return-type="item()*" returnVaries="yes">
                    <arg name="value" type="item()*" emptyOk="no"/>
                    <arg name="label" type="xs:string" emptyOk="no"/>
                </proto>
            </example>
            <p>Summary:  Provides an execution trace intended to be used in debugging 
            queries.</p>

            <p>The input <code>$value</code> is returned, unchanged, as the result of the function.
                In addition, the inputs <code>$value</code>, converted to an <code>xs:string</code>,
                and <code>$label</code> may be directed to a trace data set. The destination of the
                trace output is <termref def="implementation-defined"/>. The format of the trace
                output is <termref def="implementation-dependent"/>. The ordering of output from
                invocations of the <code>fn:trace()</code> function is <termref def="implementation-dependent"/>.</p>
            <div2 id='func-trace-examples'>
                <head>Examples</head>
                <ulist>
                    <item>
                        <p>Consider a situation in which a user wants to investigate the actual
                            value passed to a function. Assume that in a particular execution,
                            <code>$v</code> is an <code>xs:decimal</code> with value
                            <code>124.84</code>. Writing <code>fn:trace($v, 'the value of $v
                            is:')</code> will put the strings <code>"124.84"</code> and <code>"the
                                value of $v is:"</code> in the trace data set in implementation
                            dependent order.</p>
                    </item>
                </ulist>
            </div2>
        </div1>
        <div1 id="constructor-functions">
            <head>Constructor Functions</head>
            <div2 id="constructor-functions-for-xsd-types">
                <head>Constructor Functions for XML Schema Built-in Types</head>
                <p>Every built-in atomic type that is defined in <bibref ref="xmlschema-2"/>, except <code>xs:anyAtomicType</code> and <code>xs:NOTATION</code>, has an
                    associated constructor function. <code>xs:untypedAtomic</code>, defined
                    in <xspecref spec="DM" ref="types"/> and the two derived types
                    <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code> defined
                    in <xspecref spec="DM" ref="types"/> also have associated constructor functions.</p>
<p>
A constructor function is not defined for <code>xs:anyAtomicType</code> as there are no atomic values with type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type.
A constructor function is not defined for <code>xs:NOTATION</code> since it is defined as an abstract type in <bibref ref="xmlschema-2"/>.  If the static context (See <xspecref spec="XP" ref="static_context"/>) contains a type derived from
<code>xs:NOTATION</code> then a constructor function is defined for it.
See <specref ref = 'constructor-functions-for-user-defined-types'/>.
</p>
<p> 
The form of the constructor function for a type
                    <emph>prefix:TYPE</emph> is:</p>
                <example role="signature">
                    <proto name="prefix:TYPE" return-type="prefix:TYPE" role="example"
                        returnEmptyOk="yes" isSpecial="yes">
                        <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                    </proto>
                </example>
                <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned. For
                    example, the signature of the constructor function corresponding to the
                    <code>xs:unsignedInt</code> type defined in <bibref ref="xmlschema-2"/> is:</p>
                <example role="signature">
                    <proto name="unsignedInt" return-type="xs:unsignedInt" isSchema="yes"
                        returnEmptyOk="yes" role="example">
                        <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Invoking the constructor function <code>xs:unsignedInt(12)</code> returns
                    the <code> xs:unsignedInt</code> value 12. Another invocation of that constructor
                    function that returns the same <code>xs:unsignedInt</code> value is
                    <code>xs:unsignedInt("12")</code>. The same result would also be returned if the
                    constructor function were to be invoked with a node that had a typed value equal
                    to the <code>xs:unsignedInt</code> 12. The standard features described in
                        <xspecref spec="XP" ref="id-atomization"/> would 'atomize' the node to
                    extract its typed value and then call the constructor with that value. If the
                    value passed to a constructor is illegal for the datatype to be constructed, an
                    error is raised <errorref class="RG" code="0001"/>.</p>
                    <p>The semantics of the constructor function <quote>
                        <code>xs:TYPE(arg)</code>
                    </quote> are identical to the semantics of <quote>
                        <code>arg</code> cast as <code>xs:TYPE?</code>
                    </quote>. See <specref ref="casting"/>.</p>
  <p>If the argument to a constructor function is a literal, the result of the
                    function may be evaluated statically; if an error is found during such
                    evaluation, it may be reported as a static error. </p>
 <p>Special rules apply to constructor functions for <code>xs:QName</code> and types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>. See 
<specref ref="constructor-qname-notation"/>.
</p>
                <p>The following constructor functions for the built-in types are supported:</p>
                <ulist>
                    <item>
                        <proto name="string" return-type="xs:string" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="boolean" return-type="xs:boolean" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="decimal" return-type="xs:decimal" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="float" return-type="xs:float" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                        <p>Implementations <termref def="may"/> return negative zero for <code>xs:float("-0.0E0")</code>.  <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.
                        </p>
                    </item>
                    <item>
                        <proto name="double" return-type="xs:double" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                        <p>Implementations <termref def="may"/> return negative zero for <code>xs:double("-0.0E0").</code> <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.
                        </p>
                    </item>
                    <item>
                        <proto name="duration" return-type="xs:duration" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="dateTime" return-type="xs:dateTime" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="time" return-type="xs:time" returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="date" return-type="xs:date" returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="gYearMonth" return-type="xs:gYearMonth" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="gYear" return-type="xs:gYear" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="gMonthDay" return-type="xs:gMonthDay" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="gDay" return-type="xs:gDay" returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="gMonth" return-type="xs:gMonth" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="hexBinary" return-type="xs:hexBinary" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="base64Binary" return-type="xs:base64Binary" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="anyURI" return-type="xs:anyURI" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="QName" return-type="xs:QName" returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="no"/>
                        </proto>
                        <p>
                            See <specref ref='constructor-qname-notation'/> for special rules.</p>
                    </item>
               <!--     <item>
                        <proto name="NOTATION" return-type="xs:NOTATION" returnEmptyOk="no"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:string" emptyOk="no"/>
                        </proto>
                        <p>
                            <code>$arg</code> must be a <code>xs:string</code> literal.</p>
                    </item> -->
                </ulist>
                <ulist>
                    <item>
                        <proto name="normalizedString" return-type="xs:normalizedString"
                            returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="token" return-type="xs:token" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="language" return-type="xs:language" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="NMTOKEN" return-type="xs:NMTOKEN" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <!-- <item><proto name="NMTOKENS" return-type="xs:NMTOKENS" returnEmptyOk='yes' isSchema="yes" role='example'>
					<arg name="arg" type="xs:anyAtomicType" emptyOk='yes'/></proto></item> -->
                    <item>
                        <proto name="Name" return-type="xs:Name" returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="NCName" return-type="xs:NCName" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="ID" return-type="xs:ID" returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="IDREF" return-type="xs:IDREF" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <!-- <item><proto name="IDREFS" return-type="xs:IDREFS" returnEmptyOk='yes' isSchema="yes" role='example'>
					<arg name="arg" type="xs:anyAtomicType" emptyOk='yes'/></proto></item> -->
                    <item>
                        <proto name="ENTITY" return-type="xs:ENTITY" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
 <p>See <specref ref='casting-to-ENTITY'/> for rules related to constructing values of type <code>xs:ENTITY</code> and types derived from it.</p>
                    </item>
                    <!-- <item><proto name="ENTITIES" return-type="xs:ENTITIES" returnEmptyOk='yes' isSchema="yes" role='example'>
					<arg name="arg" type="xs:anyAtomicType" emptyOk='yes'/></proto></item> -->
                    <item>
                        <proto name="integer" return-type="xs:integer" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="nonPositiveInteger" return-type="xs:nonPositiveInteger"
                            returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="negativeInteger" return-type="xs:negativeInteger"
                            returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="long" return-type="xs:long" returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="int" return-type="xs:int" returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="short" return-type="xs:short" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="byte" return-type="xs:byte" returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="nonNegativeInteger" return-type="xs:nonNegativeInteger"
                            returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="unsignedLong" return-type="xs:unsignedLong" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="unsignedInt" return-type="xs:unsignedInt" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="unsignedShort" return-type="xs:unsignedShort"
                            returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="unsignedByte" return-type="xs:unsignedByte" returnEmptyOk="yes"
                            isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="positiveInteger" return-type="xs:positiveInteger"
                            returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                </ulist>
                <ulist>
                    <item>
                        <proto name="yearMonthDuration" return-type="xs:yearMonthDuration"
                            returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="dayTimeDuration" return-type="xs:dayTimeDuration"
                            returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="untypedAtomic" return-type="xs:untypedAtomic"
                            returnEmptyOk="yes" isSchema="yes" role="example">
                            <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </item>
                </ulist>
            </div2>
            <div2 id="func-dateTime">
                <head>A Special Constructor Function for xs:dateTime</head>
                <p>A special constructor function is provided for constructing a
                    <code>xs:dateTime</code> value from a <code>xs:date</code> value and a
                    <code>xs:time</code> value.</p>
                <example role="signature">
                    <proto name="dateTime" return-type="xs:dateTime" returnEmptyOk="yes">
                        <arg name="arg1" type="xs:date" emptyOk="yes"/>
                        <arg name="arg2" type="xs:time" emptyOk="yes"/>
                    </proto>
                </example>
                <p>The result <code>xs:dateTime</code> has a date component whose value is equal to
                    <code>$arg1</code> and a time component whose value is equal
                    to <code>$arg2</code>. The result is the empty sequence if either of the parameters is the empty sequence.</p>
<p>
The timezone of the result is computed as follows:</p>
                <ulist>
                    <item>
                        <p>If neither argument has a timezone, the result has no timezone.</p>
                    </item>
                    <item>
                        <p>If exactly one of the arguments has a timezone, or if both arguments have
                            the same timezone, the result has this timezone.</p>
                    </item>
                    <item>
                        <p>If the two arguments have different timezones, an error is
                                raised:<errorref class="RG" code="0008"/>
                        </p>
                    </item>
                </ulist>
 				<div3 id="func-dateTime-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:dateTime(xs:date("1999-12-31"), xs:time("12:00:00"))</code> returns <code>xs:dateTime("1999-12-31T12:00:00").</code></p></item>
<item><p>
<code>fn:dateTime(xs:date("1999-12-31"), xs:time("24:00:00"))</code> returns
<code>xs:dateTime("1999-12-31T00:00:00")</code> because <code>"24:00:00"</code> is an alternate lexical form for <code>"00:00:00".</code> 
                                </p>
                            </item>
                        </ulist>
               </div3>
            </div2>
           <div2 id="constructor-qname-notation">
                <head>Constructor Functions for xs:QName and xs:NOTATION</head>
<p>Special rules apply to constructor functions for the types <code>xs:QName</code> and <code>xs:NOTATION</code>, for two reasons:</p>
<ulist>
<item><p>
The lexical representation of these types uses namespace prefixes, whose
meaning is context-dependent.</p></item>
<item><p>
Values cannot belong directly to the type <code>xs:NOTATION</code>, only to its subtypes.
</p></item>
</ulist>
<p>
These constraints result in the following restrictions:</p>
<ulist>
<item><p>
Conversion from an <code>xs:string</code> to a value of type <code>xs:QName</code>, a type derived from  <code>xs:QName</code> or a type derived from <code>xs:NOTATION</code> is permitted only if the <code>xs:string</code> is written as a string literal. This applies whether the conversion is expressed using a constructor function or using the "cast as" syntax. Such a conversion can be regarded as a pseudo-function, which is always evaluated statically. It is also permitted for these constructors and casts to take a dynamically-supplied argument in the normal manner, but as the casting table (see <specref ref='casting-from-primitive-to-primitive'/>) indicates, the only
arguments that are supported in this case are values of type <code>xs:QName</code> or <code>xs:NOTATION</code> respectively.</p></item>
<item><p>
There is no constructor function for <code>xs:NOTATION</code>. Constructors are defined, however, for <code>xs:QName</code>, for types derived from <code>xs:QName</code>, and for types derived from <code>xs:NOTATION</code>.
</p></item>
</ulist>
<p>
When converting from an <code>xs:string</code>, the prefix within the lexical 
<code>xs:QName</code> supplied
as the argument is resolved to a namespace URI using the statically known
namespaces from the static context. If the lexical <code>xs:QName</code>
has no prefix, the
namespace URI of the resulting expanded-QName is the default element/type
namespace from the static context. Components of the static context are
discussed in <xspecref spec="XP" ref="static_context"/>. A static error is raised <errorref class="NS" code="0004"/>
if the prefix is not bound in the static context. As described in
<xspecref spec="DM" ref="terminology"/>, the supplied prefix is retained as part of the
expanded-QName value.
</p>
           </div2>
            <div2 id="constructor-functions-for-user-defined-types">
                <head>Constructor Functions for User-Defined Types</head>
                <p> For every atomic type in the static context (See <xspecref spec="XP"
                    ref="static_context"/>) that is derived from a primitive type, there is a
                    constructor function (whose name is the same as the name of the type) whose
                    effect is to create a value of that type from the supplied argument. The rules
                    for constructing user-defined types are defined in the same way as the rules for
                    constructing built-in derived types discussed in <specref
                    ref="constructor-functions-for-xsd-types"/>. </p>
<p>
                            Special rules apply to constructor functions for types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>. See <specref ref='constructor-qname-notation'/>.</p>
                <p>Consider a situation where the static context contains a type
                    called <code>hatSize</code> defined in a schema whose target namespace is bound
                    to the prefix <code>my</code>. In such a case the constructor function:</p>
                <example role="signature">
                    <proto name="my:hatSize" return-type="my:hatSize" isSpecial="yes" returnEmptyOk='yes' role="example">
                        <arg name="arg" type="xs:anyAtomicType" emptyOk='yes'/>
                    </proto>
                </example>
                <p>is available to users.</p>
                <p> To construct an instance of an atomic type that is not in a namespace, it is
                    necessary to use a cast expression or undeclare the default function namespace. For example, if the user-defined type <code>apple</code> is derived
                    from <code>xs:integer</code> but is not in a namespace, an instance of this type
                    can be constructed as follows using a cast expression (this requires that the
                    default element/type namespace is no namespace):</p>
                <eg>17 cast as apple</eg>
                <p> The following shows the use of the constructor function:</p>
                <eg>declare default function namespace ""; apple(17)</eg>
            </div2>
        </div1>
        <div1 id="numeric-functions">
            <head>Functions and Operators on Numerics</head>
            <p>This section discusses arithmetic operators on the numeric datatypes defined in
                    <bibref ref="xmlschema-2"/>. It uses an approach that permits lightweight
                implementation whenever possible. </p>
            <div2 id='numeric-types'>
                <head>Numeric Types</head>
                <p>The operators described in this section are defined on the following numeric
                    types. Each type whose name is indented is derived from the type whose name
                    appears nearest above with one less level of indentation.</p>
                <table border="0" width="288" summary="Numeric types" role="hierarchy">
                    <tbody>
                        <tr>
                            <td>xs:decimal</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>xs:integer</td>
                        </tr>
                        <tr>
                            <td>xs:float</td>
                        </tr>
                        <tr>
                            <td>xs:double</td>
                        </tr>
                    </tbody>
                </table>
                <p>They also apply to types derived by restriction from the above types. </p>
                <note>
                    <p>
This specification uses  <bibref ref="ieee754"/> arithmetic for <code>xs:float</code> and <code>xs:double</code> values.
This differs from <bibref ref="xmlschema-2"/> which defines
<code>NaN</code> as being equal to itself and defines only a single zero in the value space while <bibref ref="ieee754"/> arithmetic  treats <code>NaN</code> as unequal to all other values including itself and can produce distinct results of positive zero and negative zero. (These are two different machine representations for the same <bibref ref="xmlschema-2"/>  value.) The text accompanying several functions discusses behaviour for both positive and negative zero inputs and outputs in the interest of alignment with <bibref ref="ieee754"/>.
</p>
                </note>
            </div2>
            <div2 id="op.numeric">
                <head>Operators on Numeric Values</head>
                <p>The following functions define the semantics of operators defined in <bibref
                    ref="xquery"/> and <bibref ref="xpath20"/> on these numeric types. </p>
                <table border="1" summary="Operator summary">
                    <thead>
                        <tr>
                            <th>Operators</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>op:numeric-add</code>
                            </td>
                            <td>Addition</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:numeric-subtract</code>
                            </td>
                            <td>Subtraction</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:numeric-multiply</code>
                            </td>
                            <td>Multiplication</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:numeric-divide</code>
                            </td>
                            <td>Division</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:numeric-integer-divide</code>
                            </td>
                            <td>Integer division</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:numeric-mod</code>
                            </td>
                            <td>Modulus</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:numeric-unary-plus</code>
                            </td>
                            <td>Unary plus</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:numeric-unary-minus</code>
                            </td>
                            <td>Unary minus (negation)</td>
                        </tr>
                    </tbody>
                </table>
                <p>The parameters and return types for the above operators are the basic numeric
                    types: <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>
                    and <code>xs:double</code>, and types derived from them. The word <quote><code>numeric</code></quote> in function signatures signifies these four types. For simplicity, each
                    operator is defined to operate on operands of the same type and return the same
                    type. The exceptions are <code>op:numeric-divide</code>, which returns
                    an <code>xs:decimal</code> if called with two <code>xs:integer</code> operands
                    and <code>op:numeric-integer-divide</code> which always returns an <code>xs:integer</code>.</p>
                <p>If the two operands are not of the same type, <emph>subtype substitution</emph>
                    and <emph>numeric type promotion</emph> are used to obtain two operands of the
                    same type. <xspecref
                        spec="XP" ref="promotion"/> and <xspecref
                        spec="XP" ref="mapping"/> describe the semantics of these operations in
                    detail. </p>
                <p>The result type of operations depends on their argument datatypes and is defined
                    in the following table:</p>
                <table border="1" summary="Function/operator summary">
                    <col width="50%"/>
                    <col width="50%"/>
                    <thead>
                        <tr>
                            <th>Operator</th>
                            <th>Returns</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>op:operation(xs:integer, xs:integer)</code>
                            </td>
                            <td>
                                <code>xs:integer</code> (except for <code>op:numeric-divide(integer,
                                integer)</code>, which returns <code>xs:decimal</code>)</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:operation(xs:decimal, xs:decimal)</code>
                            </td>
                            <td>
                                <code>xs:decimal</code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:operation(xs:float, xs:float)</code>
                            </td>
                            <td>
                                <code>xs:float</code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:operation(xs:double, xs:double)</code>
                            </td>
                            <td>
                                <code>xs:double</code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:operation(xs:integer)</code>
                            </td>
                            <td>
                                <code>xs:integer</code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:operation(xs:decimal)</code>
                            </td>
                            <td>
                                <code>xs:decimal</code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:operation(xs:float)</code>
                            </td>
                            <td>
                                <code>xs:float</code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:operation(xs:double)</code>
                            </td>
                            <td>
                                <code>xs:double</code>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <p>These rules define any operation on any pair of arithmetic types. Consider the
                    following example:</p>
                <eg>op:operation(xs:int, xs:double) =&gt; op:operation(xs:double, xs:double)</eg>
                <p>For this operation, <code>xs:int</code> must be converted to
                    <code>xs:double</code>. This can be done, since by the rules above:
                    <code>xs:int</code> can be substituted for <code>xs:integer</code>,
                    <code>xs:integer</code> can be substituted for <code>xs:decimal</code>,
                    <code>xs:decimal</code> can be promoted to <code>xs:double</code>. As far as possible, the promotions should be done in a
                    single step. Specifically, when an <code>xs:decimal</code> is promoted to an
                    <code>xs:double</code>, it should not be converted to an <code>xs:float</code>
                    and then to <code>xs:double</code>, as this risks loss of precision.</p>
                <p>As another example, a user may define <code>height</code> as a derived type of
                    <code>xs:integer</code> with a minimum value of 20 and a maximum value of 100.
                    He may then derive <code>fenceHeight</code> using an enumeration to restrict the
                    permitted set of values to, say, 36, 48 and 60.</p>
                <eg>op:operation(fenceHeight, xs:integer) =&gt; op:operation(xs:integer, xs:integer)</eg>
                <p>
                    <code>fenceHeight</code> can be substituted for its base type
                    <code>height</code> and <code>height</code> can be substituted for its base type
                    <code>xs:integer</code>. </p>
                <p>On overflow and underflow situations during arithmetic operations conforming
                    implementations <termref def="must"/> behave as follows:</p>
                <ulist>
                    <item>
                        <p>For <code>xs:float</code> and <code>xs:double</code> operations, overflow
                            behavior <termref def="must"/> be conformant with <bibref
                            ref="ieee754"/>. This specification allows the following options:</p>
                        <ulist>
                            <item>
                                <p>Raising an error <errorref class="AR" code="0002"/> via an
                                    overflow trap.</p>
                            </item>
                            <item>
                                <p>Returning <code>INF</code> or <code>-INF</code>.</p>
                            </item>
                            <item>
                                <p>Returning the largest (positive or negative) non-infinite number.</p>
                            </item>
                        </ulist>
                    </item>
                    <item>
                        <p>For <code>xs:float</code> and <code>xs:double</code> operations,
                            underflow behavior <termref def="must"/> be conformant with <bibref
                            ref="ieee754"/>. This specification allows the following options:</p>
                        <ulist>
                            <item>
                                <p>Raising an error <errorref class="AR" code="0002"/> via an
                                    underflow trap.</p>
                            </item>
                            <item>
                                <p>Returning <code>0.0E0</code> or <code>+/- 2**Emin</code> or a
                                    denormalized value; where <code>Emin</code> is the smallest
                                    possible <code>xs:float</code> or <code>xs:double</code> exponent.</p>
                            </item>
                        </ulist>
                    </item>
                    <item>
                        <p>For <code>xs:decimal</code> operations, overflow behavior <termref
                            def="must"/> raise an error <errorref class="AR" code="0002"/>. On
                            underflow, <code>0.0</code> must be returned.</p>
                    </item>
                    <item>
                        <p>For <code>xs:integer</code> operations, implementations that support
                            limited-precision integer operations <termref def="must"/> select from
                            the following options:</p>
                        <ulist>
                            <item>
                                <p> They <termref def="may"/> choose to always raise an
                                        error <errorref class="AR" code="0002"/>.</p>
                            </item>
                            <item>
                                <p> They <termref def="may"/> provide an <termref
                                    def="implementation-defined"/> mechanism that allows users to
                                    choose between raising an error and returning a result that is
                                    modulo the largest representable integer value. See <bibref ref="ISO10967"/>.</p>
                            </item>
                        </ulist>
                    </item>
                </ulist>
                <p>The functions <code>op:numeric-add</code>, <code>op:numeric-subtract</code>,
                    <code>op:numeric-multiply</code>, <code>op:numeric-divide</code>,
                    <code>op:numeric-integer-divide</code> and <code>op:numeric-mod</code> are each
                    defined for pairs of numeric operands, each of which has the same
                    type:<code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, or
                    <code>xs:double</code>. The functions <code>op:numeric-unary-plus</code> and
                    <code>op:numeric-unary-minus</code> are defined for a single operand whose type
                    is one of those same numeric types.</p>
                <p> For <code>xs:float</code> and <code>xs:double</code> arguments, if either
                    argument is <code>NaN</code>, the result is <code>NaN</code>.</p>
                <p>For <code>xs:decimal</code> values the number of digits of precision returned by
                    the numeric operators is <termref def="implementation-defined"/>. If the number
                    of digits in the result exceeds the number of digits that the implementation
                    supports, the result is truncated or rounded in an <termref
                    def="implementation-defined"/> manner.</p>
                <div3 id="func-numeric-add">
                    <head>op:numeric-add</head>
                    <example role="signature">
                        <proto name="numeric-add" return-type="numeric" returnVaries="yes" isOp="yes">
                            <arg name="arg1" type="numeric"/>
                            <arg name="arg2" type="numeric"/>
                        </proto>
                    </example>
                    <p>Summary: Backs up the "+" operator and returns the arithmetic sum of its
                        operands: (<code>$arg1 + $arg2</code>).</p>
<note>                   
                        <p> For <code>xs:float</code> or <code>xs:double</code> values, if one of
                            the operands is a zero or a finite number and the other
                            is <code>INF</code> or <code>-INF</code>, <code>INF</code> or
                            <code>-INF</code> is returned. If both operands are <code>INF</code>,
                            <code>INF</code> is returned. If both operands are <code>-INF</code>,
                            <code>-INF</code> is returned. If one of the operands is
                            <code>INF</code> and the other is <code>-INF</code>, <code>NaN</code> is returned.</p>
</note>                   
                </div3>
                <div3 id="func-numeric-subtract">
                    <head>op:numeric-subtract</head>
                    <example role="signature">
                        <proto name="numeric-subtract" return-type="numeric" returnVaries="yes" isOp="yes">
                            <arg name="arg1" type="numeric"/>
                            <arg name="arg2" type="numeric"/>
                        </proto>
                    </example>
                    <p>Summary: Backs up the "-" operator and returns the arithmetic difference of
                        its operands: (<code>$arg1 - $arg2</code>).</p>
<note>                   
                        <p> For <code>xs:float</code> or <code>xs:double</code> values, if one of
                            the operands is a zero or a finite number and the other
                            is <code>INF</code> or <code>-INF</code>, an infinity of the appropriate
                            sign is returned. If both operands are <code>INF</code> or
                            <code>-INF</code>, <code>NaN</code> is returned. If one of the operands
                            is <code>INF</code> and the other is <code>-INF</code>, an infinity of
                            the appropriate sign is returned.</p>
</note>                   
                </div3>
                <div3 id="func-numeric-multiply">
                    <head>op:numeric-multiply</head>
                    <example role="signature">
                        <proto name="numeric-multiply" return-type="numeric" returnVaries="yes" isOp="yes">
                            <arg name="arg1" type="numeric"/>
                            <arg name="arg2" type="numeric"/>
                        </proto>
                    </example>
                    <p>Summary: Backs up the "*" operator and returns the arithmetic product of its
                        operands: (<code>$arg1 * $arg2</code>).</p>
<note>
                        <p> For <code>xs:float</code> or <code>xs:double</code> values, if one of
                            the operands is a zero and the other is an infinity, <code>NaN</code> is
                            returned. If one of the operands is a non-zero number and the other
                            is an infinity, an infinity with the appropriate sign is returned.</p>
</note>
                </div3>
                <div3 id="func-numeric-divide">
                    <head>op:numeric-divide</head>
                    <example role="signature">
                        <proto name="numeric-divide" return-type="numeric" returnVaries="yes" isOp="yes">
                            <arg name="arg1" type="numeric"/>
                            <arg name="arg2" type="numeric"/>
                        </proto>
                    </example>
                    <p>Summary: Backs up the "div" operator and returns the arithmetic quotient of
                        its operands: (<code>$arg1 div $arg2</code>).</p>
                    <!-- Integer arithmetic proposal -->
                    <!--						<p>For compatibility with <bibref ref="xpath"/>, if the types of both <code>$arg1</code> and <code>$arg2</code> are <code>xs:integer</code>, then the return type is <code>xs:double</code>. </p> -->
                    <p>As a special case, if the types of both <code>$arg1</code> and
                        <code>$arg2</code> are <code>xs:integer</code>, then the return type is <code>xs:decimal</code>.</p>
<notes>
                    <p>For <code>xs:decimal</code> and <code>xs:integer</code> operands, if the
                        divisor is (positive or negative) zero, an error is raised <errorref class="AR" code="0001"/>.
                        For <code>xs:float</code> and <code>xs:double</code> operands, floating point
                        division is performed as specified in <bibref ref="ieee754"/>.</p>
                        <p> For <code>xs:float</code> or <code>xs:double</code> values, a positive
                            number divided by positive zero returns <code>INF</code>. A negative number
                            divided by positive zero returns <code>-INF</code>. Division by negative zero
                            returns <code>-INF</code> and <code>INF</code>, respectively. Positive or negative zero
                            divided by  positive or negative zero returns <code>NaN</code>.  Also, <code>INF</code> or <code>-INF</code> divided
                            by <code>INF</code> or <code>-INF</code> returns <code>NaN</code>.</p></notes>
                   
                </div3>
                <div3 id="func-numeric-integer-divide">
                    <head>op:numeric-integer-divide</head>
                    <example role="signature">
                        <proto name="numeric-integer-divide" return-type="xs:integer" isOp="yes">
                            <arg name="arg1" type="numeric"/>
                            <arg name="arg2" type="numeric"/>
                        </proto>
                    </example>
                    <p>Summary: This function backs up the "idiv" operator and performs an integer
                        division: that is, it divides the first argument by the second, and returns
                        the integer obtained by truncating the fractional part of the result. The
                        division is performed so that the sign of the fractional part is the same as
                        the sign of the dividend. </p>
                    <p>If the dividend, <code>$arg1</code>, is not evenly divided by the divisor,
                        <code>$arg2</code>, then the quotient is the <code>xs:integer</code> value
                        obtained, ignoring (truncating) any remainder that results from the division
                        (that is, no rounding is performed). Thus, the semantics <quote>
                            <code>$a idiv $b</code>
                        </quote> are equivalent to <quote>
                            <code>($a div $b) cast as xs:integer</code>
                        </quote> except for error situations.</p>
                    <p>If the divisor is (positive or negative) zero, then an error is raised <errorref class="AR" code="0001"/>.  If either operand is <code>NaN</code> or if <code>$arg1</code> is <code>INF</code> or <code>-INF</code> then
an error is raised <errorref class="AR" code="0002"/>.</p>
                    <note>
                        <p>The semantics of this function are different from integer division as
                            defined in programming languages such as Java and C++.</p>
                    </note>
                    <div4 id="func-numeric-integer-divide-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:numeric-integer-divide(10,3)</code> returns <code>3</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-integer-divide(3,-2)</code> returns <code>-1</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-integer-divide(-3,2)</code> returns <code>-1</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-integer-divide(-3,-2)</code> returns <code>1</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-integer-divide(9.0,3)</code> returns <code>3</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-integer-divide(-3.5,3)</code> returns <code>-1</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-integer-divide(3.0,4)</code> returns <code>0</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-integer-divide(3.1E1,6)</code> returns <code>5</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-integer-divide(3.1E1,7)</code> returns <code>4</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-numeric-mod">
                    <head>op:numeric-mod</head>
                    <example role="signature">
                        <proto name="numeric-mod" return-type="numeric" returnVaries="yes" isOp="yes">
                            <arg name="arg1" type="numeric"/>
                            <arg name="arg2" type="numeric"/>
                        </proto>
                    </example>
                    <p>Summary: Backs up the "mod" operator. Informally, this function returns the
                        remainder resulting from dividing <code>$arg1</code>, the dividend, by
                        <code>$arg2</code>, the divisor. The operation <code>a mod b</code> for
                        operands that are <code>xs:integer</code> or <code>xs:decimal</code>, or
                        types derived from them, produces a result such that <code>(a idiv b)*b+(a
                            mod b)</code> is equal to <code>a</code> and the magnitude of the result
                        is always less than the magnitude of <code>b</code>. This identity holds
                        even in the special case that the dividend is the negative integer of
                        largest possible magnitude for its type and the divisor is -1 (the remainder
                        is 0). It follows from this rule that the sign of the result is the sign of
                        the dividend.</p>
                    <p>For <code>xs:integer</code> and <code>xs:decimal</code> operands, if
                        <code>$arg2</code> is zero, then an error is raised <errorref class="AR" code="0001"/>.</p>
                    <p> For <code>xs:float</code> and <code>xs:double</code> operands the following
                        rules apply:</p>
                    <ulist>
                        <item>
                            <p>If either operand is <code>NaN</code>, the result is <code>NaN</code>.</p>
                        </item>
                        <item>
                            <p>If the dividend is positive or negative infinity, or the divisor is
                                positive or negative zero (0), or both, the result is <code>NaN</code>.</p>
                        </item>
                        <!--								<item>
									<p>The sign of the result is the same as the sign of the dividend.</p>
								</item> -->
                        <item>
                            <p>If the dividend is finite and the divisor is an infinity, the result
                                equals the dividend.</p>
                        </item>
                        <item>
                            <p>If the dividend is positive or negative zero and the divisor is
                                finite, the result is the same as the dividend.</p>
                        </item>
                        <item>
                            <p>In the remaining cases, where neither positive or negative infinity,
                                nor positive or negative zero, nor <code>NaN</code> is involved, the
                                result obeys <code>(a idiv b)*b+(a mod b)</code> = <code>a</code>.

                                <!--float or double remainder r from a dividend n and a divisor d is defined by the mathematical relation r = n-(d * q) where q is an integer that is negative only if n/d is negative and positive only if n/d is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of n and d.  -->
                                Division is truncating division, analogous to integer division,
                                    not <bibref ref="ieee754"/> rounding division i.e. additional
                                digits are truncated, not rounded to the required precision.</p>
                        </item>
                    </ulist>
                    <div4 id="func-numeric-mod-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:numeric-mod(10,3)</code> returns <code>1</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-mod(6,-2)</code> returns <code>0</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-mod(4.5,1.2)</code> returns <code>0.9</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:numeric-mod(1.23E2, 0.6E1)</code> returns <code>3.0E0</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-numeric-unary-plus">
                    <head>op:numeric-unary-plus</head>
                    <example role="signature">
                        <proto name="numeric-unary-plus" return-type="numeric" returnVaries="yes" isOp="yes">
                            <arg name="arg" type="numeric"/>
                        </proto>
                    </example>
                    <p>Summary: Backs up the unary "+" operator and returns its operand with the
                        sign unchanged: (+ <code>$arg</code>). Semantically, this operation performs
                        no operation.</p>
                </div3>
                <div3 id="func-numeric-unary-minus">
                    <head>op:numeric-unary-minus</head>
                    <example role="signature">
                        <proto name="numeric-unary-minus" return-type="numeric" returnVaries="yes" isOp="yes">
                            <arg name="arg" type="numeric"/>
                        </proto>
                    </example>
                    <p>Summary: Backs up the unary "-" operator and returns its operand with the
                        sign reversed: (- <code>$arg</code>). If <code>$arg</code> is positive, its
                        negative is returned; if it is negative, its positive is returned.</p>
                    <p>For <code>xs:integer</code> and <code>xs:decimal</code> arguments,
                        <code>0</code> and <code>0.0</code> return <code>0</code> and
                        <code>0.0</code>, respectively. For <code>xs:float</code> and
                        <code>xs:double</code> arguments, <code>NaN</code> returns <code>NaN</code>,
                        <code>0.0E0</code> returns <code>-0.0E0</code> and vice versa.
                        <code>INF</code> returns <code>-INF</code>. <code>-INF</code> returns <code>INF</code>.</p>
                </div3>
            </div2>
            <div2 id="comp.numeric">
                <head>Comparison Operators on Numeric Values</head>
                <p>This specification defines the following comparison operators on numeric values.
                    Comparisons take two arguments of the same type. If the arguments are of
                    different types, one argument is promoted to the type of the other as described
                    above in <specref ref="op.numeric"/>. Each comparison operator returns a boolean
                    value. If either, or both, operands are <code>NaN</code>, <code>false</code> is
                    returned. </p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Operator</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>op:numeric-equal</code>
                            </td>
                            <td>Equality comparison</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:numeric-less-than</code>
                            </td>
                            <td>Less-than comparison</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:numeric-greater-than</code>
                            </td>
                            <td>Greater-than comparison</td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-numeric-equal">
                    <head>op:numeric-equal</head>
                    <example role="signature">
                        <proto name="numeric-equal" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="numeric" emptyOk="no"/>
                            <arg name="arg2" type="numeric" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns true if and only if the value of <code>$arg1</code> is equal
                        to the value of <code>$arg2</code>. For <code>xs:float</code> and
                        <code>xs:double</code> values, positive zero and negative zero compare
                        equal. <code>INF</code> equals <code>INF</code> and <code>-INF</code> equals
                        <code>-INF</code>. <code>NaN</code> does not equal itself.</p>
                    <p>This function backs up the "eq", "ne", "le" and "ge" operators on numeric values.</p>
                </div3>
                <div3 id="func-numeric-less-than">
                    <head>op:numeric-less-than</head>
                    <example role="signature">
                        <proto name="numeric-less-than" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="numeric" emptyOk="no"/>
                            <arg name="arg2" type="numeric" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if <code>$arg1</code> is less
                        than <code>$arg2</code>. For <code>xs:float</code> and
                        <code>xs:double</code> values, positive infinity is greater than all other
                        non-<code>NaN</code> values; negative infinity is less than all other
                        non-<code>NaN</code> values. If <code>$arg1</code> or <code>$arg2</code> is
                        <code>NaN</code>, the function returns <code>false</code>.</p>
                    <p>This function backs up the "lt" and "le" operators on numeric values.</p>
                </div3>
                <div3 id="func-numeric-greater-than">
                    <head>op:numeric-greater-than</head>
                    <example role="signature">
                        <proto name="numeric-greater-than" return-type="xs:boolean"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="numeric" emptyOk="no"/>
                            <arg name="arg2" type="numeric" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if <code>$arg1</code> is
                        greater than <code>$arg2</code>. For <code>xs:float</code> and
                        <code>xs:double</code> values, positive infinity is greater than all other
                        non-<code>NaN</code> values; negative infinity is less than all other
                        non-<code>NaN</code> values. If <code>$arg1</code> or <code>$arg2</code> is
                        <code>NaN</code>, the function returns <code>false</code>.</p>
                    <p>This function backs up the "gt" and "ge" operators on numeric values.</p>
                </div3>
            </div2>
            <div2 id='numeric-value-functions'>
                <head>Functions on Numeric Values</head>
                <p>The following functions are defined on numeric types. Each function returns a
                    value of the same type as the type of its argument.</p>
                <ulist>
                    <item>
                        <p>If the argument is the empty sequence, the empty sequence is returned.</p>
                    </item>
                    <item>
                        <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the
                            argument is "NaN", "NaN" is returned.</p>
                    </item>
                    <item>
                        <p>Except for <code>fn:abs()</code>, for <code>xs:float</code> and
                            <code>xs:double</code> arguments, if the argument is positive or
                            negative infinity, positive or negative infinity is returned.</p>
                    </item>
                </ulist>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:abs</code>
                            </td>
                            <td>Returns the absolute value of the argument.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:ceiling</code>
                            </td>
                            <td>Returns the smallest number with no fractional part that is greater
                                than or equal to the argument.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:floor</code>
                            </td>
                            <td>Returns the largest number with no fractional part that is less than
                                or equal to the argument.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:round</code>
                            </td>
                            <td>Rounds to the nearest number with no fractional part.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:round-half-to-even</code>
                            </td>
                            <td>Takes a number and a precision and returns a number rounded to the
                                given precision. If the fractional part is exactly half, the result
                                is the number whose least significant digit is even.</td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-abs">
                    <head>fn:abs</head>
                    <example role="signature">
                        <proto name="abs" return-type="numeric" returnEmptyOk="yes" returnVaries="yes">
                            <arg name="arg" type="numeric" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the absolute value of <code>$arg</code>. If
                        <code>$arg</code> is negative returns <code>-$arg</code> otherwise returns
                        <code>$arg</code>. If type of <code>$arg</code> is one of the four numeric
                        types <code>xs:float</code>, <code>xs:double</code>, <code>xs:decimal</code>
                        or <code>xs:integer</code> the type of the result is the same as the type of
                        <code>$arg</code>. If the type of <code>$arg</code> is a type derived from
                        one of the numeric types, the result is an instance of the base numeric type.</p>
                    <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the
                        argument is positive zero or negative zero, then positive zero
                        is returned. If the argument is positive or negative infinity, positive
                        infinity is returned.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_abs_ceil_floor_round"/>
                    </p>
                    <div4 id="func-abs-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:abs(10.5)</code> returns <code>10.5</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:abs(-10.5)</code> returns <code>10.5</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-ceiling">
                    <head>fn:ceiling</head>
                    <example role="signature">
                        <proto name="ceiling" return-type="numeric" returnEmptyOk="yes" returnVaries="yes">
                            <arg name="arg" type="numeric" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the smallest (closest to negative infinity) number with no
                        fractional part that is not less than the value of <code>$arg</code>. If
                        type of <code>$arg</code> is one of the four numeric types
                        <code>xs:float</code>, <code>xs:double</code>, <code>xs:decimal</code> or
                        <code>xs:integer</code> the type of the result is the same as the type of
                        <code>$arg</code>. If the type of <code>$arg</code> is a type derived from
                        one of the numeric types, the result is an instance of the base numeric type.</p>
                    <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the
                        argument is positive zero, then positive zero is returned. If the
                        argument is negative zero, then negative zero is returned. If the
                        argument is less than zero and greater than -1, negative zero is returned.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_abs_ceil_floor_round"/>
                    </p>
                   <div4 id="func-ceiling-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:ceiling(10.5)</code> returns <code>11</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:ceiling(-10.5)</code> returns <code>-10</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-floor">
                    <head>fn:floor</head>
                    <example role="signature">
                        <proto name="floor" return-type="numeric" returnEmptyOk="yes" returnVaries="yes">
                            <arg name="arg" type="numeric" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the largest (closest to positive infinity) number with no
                        fractional part that is not greater than the value of <code>$arg</code>. If
                        type of <code>$arg</code> is one of the four numeric types
                        <code>xs:float</code>, <code>xs:double</code>, <code>xs:decimal</code> or
                        <code>xs:integer</code> the type of the result is the same as the type of
                        <code>$arg</code>. If the type of <code>$arg</code> is a type derived from
                        one of the numeric types, the result is an instance of the base numeric type.</p>
                    <p>For <code>float</code> and <code>double</code> arguments, if the argument is
                        positive zero, then positive zero is returned. If the argument is
                        negative zero, then negative zero is returned.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_abs_ceil_floor_round"/>
                    </p>
                    <div4 id="func-floor-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:floor(10.5)</code> returns <code>10</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:floor(-10.5)</code> returns <code>-11</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-round">
                    <head>fn:round</head>
                    <example role="signature">
                        <proto name="round" return-type="numeric" returnEmptyOk="yes" returnVaries="yes">
                            <arg name="arg" type="numeric" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the number with no fractional part that is closest to the
                        argument. If there are two such numbers, then the one that is closest to
                        positive infinity is returned. If type of <code>$arg</code> is one of the
                        four numeric types <code>xs:float</code>, <code>xs:double</code>,
                        <code>xs:decimal</code> or <code>xs:integer</code> the type of the result is
                        the same as the type of <code>$arg</code>. If the type of <code>$arg</code>
                        is a type derived from one of the numeric types, the result is an instance
                        of the base numeric type.</p>
                    <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the
                        argument is positive infinity, then positive infinity is returned. If the
                        argument is negative infinity, then negative infinity is returned. If the
                        argument is positive zero, then positive zero is returned. If the
                        argument is negative zero, then negative zero is returned. If the
                        argument is less than zero, but greater than or equal to -0.5, then
                        negative zero is returned.   In the cases where positive zero or negative zero is returned, negative zero or positive zero may be returned as <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.</p>
                    <p>For the last two cases, note that the result is not the same as <code>fn:floor(x+0.5)</code>.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_abs_ceil_floor_round"/>
                    </p>
                    <div4 id="func-round-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:round(2.5)</code> returns <code>3.</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:round(2.4999)</code> returns <code>2</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:round(-2.5)</code> returns <code>-2</code> (not the
                                    possible alternative, <code>-3</code>). </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-round-half-to-even">
                    <head>fn:round-half-to-even</head>
                    <example role="signature">
                        <proto name="round-half-to-even" return-type="numeric" returnEmptyOk="yes" returnVaries="yes">
                            <arg name="arg" type="numeric" emptyOk="yes"/>
                        </proto>
                    </example>
                    <example role="signature">
                        <proto name="round-half-to-even" return-type="numeric" returnEmptyOk="yes" returnVaries="yes">
                            <arg name="arg" type="numeric" emptyOk="yes"/>
                            <arg name="precision" type="xs:integer" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: The value returned is the nearest (that is, numerically closest)
                        value to <code>$arg</code> that is a multiple of ten to the power of minus
                        <code>$precision</code>. If two such values are equally near (e.g. if the
                        fractional part in <code>$arg</code> is exactly .500...), the function returns the one
                        whose least significant digit is even.</p>
<p>If the type of <code>$arg</code> is one
                        of the four numeric types <code>xs:float</code>, <code>xs:double</code>,
                        <code>xs:decimal</code> or <code>xs:integer</code> the type of the result is
                        the same as the type of <code>$arg</code>. If the type of <code>$arg</code>
                        is a type derived from one of the numeric types, the result is an instance
                        of the base numeric type.</p>
                    <p> The first signature of this function produces the same result as the second
                        signature with <code>$precision=0</code>.</p>
<p>For arguments of type <code>xs:float</code> and <code>xs:double</code>, if the argument is <code>NaN</code>, positive or negative zero, or positive or negative infinity, then the result is the same as the argument. In all other cases, the argument is cast to <code>xs:decimal</code>, the function is applied to this <code>xs:decimal</code> value, and the resulting <code>xs:decimal</code> is cast back to <code>xs:float</code> or <code>xs:double</code> as appropriate to form the function result. If the resulting <code>xs:decimal</code> value is zero, then positive or negative zero is returned according to the sign of the original argument.</p>
<p>
Note that the process of casting to <code>xs:decimal</code> may result in an error <errorref class="CA" code="0001"/>.</p>
                    <p>If <code>$arg</code> is of type <code>xs:float</code>
                        or <code>xs:double</code>, rounding occurs on the value of the mantissa
                        computed with exponent = 0.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_abs_ceil_floor_round"/>
                    </p>
                  <note><p>This function is typically used in financial applications where the argument is of type <code>xs:decimal</code>.  For arguments of type <code>xs:float</code> and <code>xs:double</code> the results may be counterintuitive. For example, consider <code>round-half-to-even(xs:float(150.0150), 2)</code>.</p>
<p>An implementation that supports 18 digits for <code>xs:decimal</code> will convert the argument to the <code>xs:decimal</code> 150.014999389... 
which will then be rounded to the <code>xs:decimal</code> 150.01 
which will be converted back to the <code>xs:float</code> whose exact value is 
150.0099945068... whereas <code>round-half-to-even(xs:decimal(150.0150), 2)</code> will result in the <code>xs:decimal</code> whose exact value is 150.02.</p>
</note>
                    <div4 id="func-round-half-to-even-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:round-half-to-even(0.5)</code> returns <code>0</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:round-half-to-even(1.5)</code> returns <code>2</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:round-half-to-even(2.5)</code> returns <code>2</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:round-half-to-even(3.567812E+3, 2)</code> returns <code>3567.81E0</code>.
                                    <!-- If this were to be serialized, its canonical form <code>"3.56781E3"</code> would be returned. -->
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:round-half-to-even(4.7564E-3, 2)</code> returns
                                    <code>0.0E0</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:round-half-to-even(35612.25, -2)</code> returns
                                    <code>35600</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
        </div1>
        <div1 id='string-functions'>
            <head>Functions on Strings</head>
            <p>This section discusses functions and operators on the <bibref ref="xmlschema-2"/>
                <code>xs:string</code> datatype and the datatypes derived from it.</p>
            <div2 id='string-types'>
                <head>String Types</head>
                <p>The operators described in this section are defined on the following types. Each
                    type whose name is indented is derived from the type whose name appears nearest
                    above with one less level of indentation.</p>
                <table border="0" summary="Type summary" role="hierarchy">
                    <tbody>
                        <tr>
                            <td>xs:string</td>
                        </tr>
                        <tr>
                            <td/>
                            <td>xs:normalizedString</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td>xs:token</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:language</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:NMTOKEN</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:Name</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:NCName</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:ID</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:IDREF</td>
                        </tr>
                        <tr>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td/>
                            <td>xs:ENTITY</td>
                        </tr>
                    </tbody>
                </table>
                <p>They also apply to user-defined types derived by restriction from the above types. </p>

<p>It is <termref def='implementation-defined'/> which version of <bibref ref='Unicode4'/> is supported, but it is recommended that the most recent version of Unicode be used.</p> 

 <p>Unless explicitly stated, the <code>xs:string</code> values returned by the
                    functions in this document are not normalized in the sense of <bibref ref="charmod"/>.</p>
                <notes>
                    <p> This document uses the term "code point", sometimes spelt "codepoint" (also known as "character number" or "code position") to mean a non-negative integer that represents a character in some encoding. See <bibref ref='charmod'/>. The use of the word "character" in this document is in the sense of production [2] of <bibref ref="REC-xml"/>.  <bibref ref="Unicode4"/>, defines code points that range from #x0000 to #x10FFFF inclusive and may include code points
                        that have not yet been assigned to characters.</p>
                    <!--  Code points range from x0000 to x10FFFF
inclusive, except for the range xD800 to xDFFF inclusive, which is the
range reserved for surrogates.</p> -->
                    <p>In functions that involve character counting such
                        as <code>fn:substring</code>, <code>fn:string-length</code> and
                        <code>fn:translate</code>, what is counted is the number of XML characters
                        in the string (or equivalently, the number of Unicode code points). Some
                        implementations may represent a code point above xFFFF using two 16-bit
                        values known as a surrogate. A surrogate counts as one character, not two.</p>
                </notes>
               
            </div2>
            <div2 id='func-assemble-disassemble-string'>
                <head>Functions to Assemble and Disassemble Strings</head>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:codepoints-to-string</code>
                            </td>
                            <td>Creates an <code>xs:string</code> from a sequence of Unicode code points. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:string-to-codepoints</code>
                            </td>
                            <td>Returns the sequence of Unicode code points that constitute an
                                <code>xs:string</code>. </td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-codepoints-to-string">
                    <head>fn:codepoints-to-string</head>
                    <example role="signature">
                        <proto name="codepoints-to-string" return-type="xs:string"
                            returnEmptyOk="no" isOp="no">
                            <arg name="arg" type="xs:integer*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Creates an <code>xs:string</code> from a sequence of <bibref ref="Unicode4"/> code points. Returns the
                        zero-length string if <code>$arg</code> is the empty sequence. If any of the
                        code points in <code>$arg</code> is not a legal XML character, an error is
                        raised <errorref class="CH" code="0001"/>.</p>
                    <div4 id="func-codepoints-to-string-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:codepoints-to-string((2309, 2358, 2378, 2325))</code>
                                    returns "&t1;&t2;&t3;&t4;"</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-string-to-codepoints">
                    <head>fn:string-to-codepoints</head>
                    <example role="signature">
                        <proto name="string-to-codepoints" return-type="xs:integer*"
                            returnEmptyOk="no" isOp="no">
                            <arg name="arg" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the sequence of <bibref ref="Unicode4"/>           
                    code points that constitute an
                        <code>xs:string</code>. If <code>$arg</code> is a zero-length string or the
                        empty sequence, the empty sequence is returned.</p>
                    <div4 id="func-string-to-codepoints-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:string-to-codepoints("Th&e2;r&e1;se")</code>
                                    returns the sequence (84, 104, 233, 114, 232, 115, 101)</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id="string-compare">
                <head>Equality and Comparison of Strings</head>
                <div3 id="collations">
                    <head>Collations</head>
                    <p> A collation is a specification of the manner in which character strings are
                        compared and, by extension, ordered. When values whose type is
                        <code>xs:string</code> or a type derived from <code>xs:string</code> are
                        compared (or, equivalently, sorted), the comparisons are inherently
                        performed according to some collation (even if that collation is defined
                        entirely on code point values). The <bibref ref="charmod"/> observes that
                        some applications may require different comparison and ordering behaviors
                        than other applications. Similarly, some users having particular linguistic
                        expectations may require different behaviors than other users. Consequently,
                        the collation must be taken into account when comparing strings in any
                        context. Several functions in this and the following section make use of a
                        collation. </p>
                    <p>Collations can indicate that two different code points are, in fact, equal
                        for comparison purposes (e.g., "v" and "w" are considered equivalent in
                        Swedish). Strings can be compared codepoint-by-codepoint or in a
                        linguistically appropriate manner, as defined by the collation. </p>
                    <p>Some collations, especially those based on the <bibref
                        ref="Unicode-Collations"/> can be "tailored" for various purposes. This
                        document does not discuss such tailoring, nor does it provide a mechanism to
                        perform tailoring. Instead, it assumes that the collation argument to the
                        various functions below is a tailored and named collation. A specific
                        collation with a distinguished name,
                        <code>&codepoint.collation;</code>,
                        provides the ability to compare strings based on code point values. Every
                        implementation of XQuery/XPath must support the collation based on code
                        point values. </p>
                    <p>In the ideal case, a collation should treat two strings as equal if the two strings are identical after Unicode normalization.  Thus, the <bibref ref="charmod-normalization"/> recommends that all strings be subjected to early Unicode normalization and some collations will raise runtime errors if they encounter strings that are not properly normalized.  However, it is not possible to guarantee that all
                        strings in all XML documents are, in fact, normalized, or that they are
                        normalized in the same manner. In order to maximize interoperability of 
                        operations on XML documents in general, there may be collations that operate
                        on unnormalized strings and other collations that
                        implicitly normalize strings before comparing them. Applications may choose the kind of collation best suited for their needs.  Note that collations based
                        on the Unicode collation algorithm implicitly normalize strings before comparison and produce equivalent results regardless of
                        a string's normalization.</p>
                    <p>This specification assumes that collations are named and that the collation
                        name may be provided as an argument to string functions. Functions that
                        allow specification of a collation do so with an argument whose type is
                        <code>xs:string</code> but whose lexical form must conform to an
                        <code>xs:anyURI</code>. If the collation is specified using a relative URI,
                        it is assumed to be relative to the value of the base-uri property in the
                        static context. This specification also defines the manner in which a
                        default collation is determined if the collation argument is not specified
                        in invocations of functions that use a collation but allow it to be omitted. </p>
<p>
This specification does not define whether or not the collation URI is
dereferenced. The collation URI may be an abstract identifier, or it may
refer to an actual resource describing the collation. If it refers to a
resource, this specification does not define the nature of that resource.
One possible candidate is that the resource is a locale description
expressed using the Locale Data Markup Language: see <bibref ref="LDML"/>.
</p>
                    <p>Functions such as <code>fn:compare</code> and <code>fn:max</code> that
                        compare <code>xs:string</code> values use a single collation URI to identify
                        all aspects of the collation rules. This means that any parameters such as
                        the strength of the collation must be specified as part of the collation
                        URI. For example, suppose there is a collation <quote>
                            <code>http://www.example.com/collations/French</code>
                        </quote> that refers to a French collation that compares on the basis of
                        base characters. Collations that use the same basic rules, but with higher
                        strengths, for example, base characters and accents, or base characters,
                        accents and case, would need to be given different names, say <quote>
                            <code>http://www.example.com/collations/French1</code>
                        </quote> and <quote>
                            <code>http://www.example.com/collations/French2</code>
                        </quote>. Note that some specifications use the term collation to refer to
                        an algorithm that can be parameterized, but in this specification, each
                        possible parameterization is considered to be a distinct collation.</p>
                    <p>The XQuery/XPath static context includes a provision for a default collation
                        that can be used for string comparisons and ordering operations. See the
                        description of the static context in <xspecref spec="XP"
                        ref="static_context"/>. If the default collation is not specified by the
                        user or the system, the default collation is the Unicode code point
                        collation (<code>&codepoint.collation;</code>).</p>
                    <p>The decision of which collation to use for a given comparison or ordering
                        function is determined by the following algorithm:</p>
                    <olist>
                        <item>
                            <p>If the function specifies an explicit collation, CollationA (e.g., if
                                the optional collation argument is specified in an invocation of the
                                <code>fn:compare()</code> function), then:</p>
                            <ulist>
                                <item>
                                    <p>If CollationA is supported by the implementation, then
                                        CollationA is used. </p>
                                </item>
                                <item>
                                    <p>Otherwise, an error is raised <errorref class="CH"
                                        code="0002"/>. </p>
                                </item>
                            </ulist>
                        </item>
                        <!--
			<item><p>If no collation is explicitly specified for the
			function and the function is <code>fn:contains</code>,
			<code>fn:starts-with</code>, <code>fn:ends-with</code>,
			<code>fn:substring-before</code> or
			<code>fn:substring-after</code> the  Unicode code point collation (<code>&codepoint.collation;</code>) is used.</p></item> -->
                        <item>
                            <p>If no collation is explicitly specified for the function
                                <!-- and the function is not one of the above functions --> and the
                                default collation in the XQuery/XPath static context is CollationB, then:</p>
                            <ulist>
                                <item>
                                    <p>If CollationB is supported by the implementation, then
                                        CollationB is used. </p>
                                </item>
                                <item>
                                    <p>Otherwise, an error is raised <errorref class="CH"
                                        code="0002"/>. </p>
                                </item>
                            </ulist>
                        </item>
                    </olist>
                    <note>
                        <p>XML allows elements to specify the <code>xml:lang</code> attribute to
                            indicate the language associated with the content of such an element.
                            This specification does not use <code>xml:lang</code> to identify the
                            default collation
                            <!-- , in part because collations should be determined by the user of -->
                            <!-- the data, not (normally) the data itself, and --> because using
                            <code>xml:lang</code> does not produce desired effects when the two
                            strings to be compared have different <code>xml:lang</code> values or
                            when a string is multilingual. </p>
                    </note>
                    <!--				<note><p>Some data management environments allow collations to be associated with the definition of string items (that is, with the metadata that describes items whose type is string).  While such association may be appropriate for use in environments in which data is held in a repository tightly bound to its descriptive metadata, it is not appropriate in the XML environment in which different documents being processed by a single query may be described by differing schemas.</p></note> -->
                    <table border="1" summary="Function/operator summary">
                        <thead>
                            <tr>
                                <th>Function</th>
                                <th>Meaning</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <code>fn:compare</code>
                                </td>
                                <td> Returns -1, 0, or 1, depending on whether the value of the
                                    first argument is respectively less than, equal to, or greater
                                    than the value of the second argument, according to the rules of
                                    the collation that is used.</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>fn:codepoint-equal</code>
                                </td>
                                <td>Returns <code>true</code> if the two arguments are equal using
                                    the Unicode code point collation. </td>
                                <td/>
                            </tr>
                        </tbody>
                    </table>
                </div3>
                <div3 id="func-compare">
                    <head>fn:compare</head>
                    <example role="signature">
                        <proto name="compare" return-type="xs:integer" returnEmptyOk="yes" isOp="no">
                            <arg name="comparand1" type="xs:string" emptyOk="yes"/>
                            <arg name="comparand2" type="xs:string" emptyOk="yes"/>
                        </proto>
                        <proto name="compare" return-type="xs:integer" returnEmptyOk="yes" isOp="no">
                            <arg name="comparand1" type="xs:string" emptyOk="yes"/>
                            <arg name="comparand2" type="xs:string" emptyOk="yes"/>
                            <arg name="collation" type="xs:string"/>
                        </proto>
                    </example>
                    <p>Summary: Returns -1, 0, or 1, depending on whether the value of the
                        <code>$comparand1</code> is respectively less than, equal to, or greater
                        than the value of <code>$comparand2</code>, according to the rules of the
                        collation that is used. </p>
                    <p>The collation used by the invocation of this function is determined according
                        to the rules in <specref ref="collations"/>. </p>
                    <!--
					<p>If the value of <code>$comparand2</code> begins
					with a string that is equal to the value of
					<code>$comparand1</code> (according to the
					collation that is used) and has additional code
					points following that beginning string, then the
					result is -1.  If the value of
					<code>$comparand1</code> begins with a string that
					is equal to the value of <code>$comparand2</code>
					(according to the collation that is used) and has
					additional code points following that beginning string, then the result is 1.</p>  -->
                    <p>If either argument is the empty sequence, the result is the empty sequence.</p>
                    <p>This function, invoked with the first signature, backs up the "eq", "ne",
                        "gt", "lt", "le" and "ge" operators on string values.</p>
                    <div4 id="func-compare-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:compare('abc', 'abc')</code> returns 0. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:compare('Strasse', 'Stra&#xDF;e')</code> returns 0
                                    if and only if the default collation includes provisions that
                                    equate <quote>ss</quote> and the (German) character
                                    <quote>&#xDF;</quote> (<quote>sharp-s</quote>). (Otherwise,
                                    the returned value depends on the semantics of the default collation.)</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:compare('Strasse', 'Stra&#xDF;e', 'deutsch')</code>
                                    returns 0 if the collation identified by the relative URI
                                    constructed from the <code>string</code> value
                                    <quote>deutsch</quote> includes provisions that equate
                                    <quote>ss</quote> and the (German) character
                                    <quote>&#xDF;</quote> (<quote>sharp-s</quote>). (Otherwise,
                                    the returned value depends on the semantics of that collation.)</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:compare('Strassen', 'Stra&#xDF;e')</code> returns 1
                                    if the default collation includes provisions that treat
                                    differences between <quote>ss</quote> and the (German) character
                                    <quote>&#xDF;</quote> (<quote>sharp-s</quote>) with less
                                    strength than the differences between the base characters, such
                                    as the final <quote>n</quote>.
                                    <!-- (Since the value of <code>$comparand1</code> has an additional
									character, an <quote>n</quote>,
									following the string that is equal
									to <quote>Stra&#xDF;e</quote>, it
									is greater than the value of
									<code>$comparand2</code>.) -->
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-codepoint-equal">
                    <head>fn:codepoint-equal</head>
                    <example role="signature">
                        <proto name="codepoint-equal" return-type="xs:boolean" returnEmptyOk="yes" isOp="no">
                            <arg name="comparand1" type="xs:string" emptyOk="yes"/>
                            <arg name="comparand2" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> or <code>false</code> depending on whether
                        the value of <code>$comparand1</code> is equal to the value of
                        <code>$comparand2</code>, according to the Unicode code point collation (<code>&codepoint.collation;</code>).</p>
                    <p>If either argument is the empty sequence, the result is the empty sequence. </p>
<note>
<p>This function allows <code>xs:anyURI</code> values to be compared without having to specify the Unicode code point collation.</p></note>
                </div3>
            </div2>
            <div2 id='string-value-functions'>
                <head>Functions on String Values</head>
                <p>The following functions are defined on values of type <code>xs:string</code> and
                    types derived from it.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:concat</code>
                            </td>
                            <td>Concatenates two or more <code>xs:anyAtomicType</code> arguments
                                cast to <code>xs:string</code>. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:string-join</code>
                            </td>
                            <td>Returns the <code>xs:string</code> produced by concatenating a
                                sequence of <code>xs:string</code>s using an optional separator. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:substring</code>
                            </td>
                            <td>Returns the <code>xs:string</code> located at a specified place
                                within an argument <code>xs:string</code>. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:string-length</code>
                            </td>
                            <td>Returns the length of the argument. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:normalize-space</code>
                            </td>
                            <td>Returns the whitespace-normalized value of the argument.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:normalize-unicode</code>
                            </td>
                            <td>Returns the normalized value of the first argument in the
                                normalization form specified by the second argument.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:upper-case</code>
                            </td>
                            <td>Returns the upper-cased value of the argument. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:lower-case</code>
                            </td>
                            <td>Returns the lower-cased value of the argument. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:translate</code>
                            </td>
                            <td>Returns the first <code>xs:string</code> argument with occurrences
                                of characters contained in the second argument replaced by the
                                character at the corresponding position in the third argument. </td>
                        </tr>
                       <tr>
                            <td>
                                <code>fn:encode-for-uri</code>
                            </td>
                            <td>Returns the <code>xs:string</code> argument with certain characters escaped to enable the resulting string to be used as a path segment in a URI. </td>
                        </tr>
 						<tr>
                            <td>
                                <code>fn:iri-to-uri</code>
                            </td>
                            <td>Returns the <code>xs:string</code> argument with certain characters escaped to enable the resulting string to be used as (part of) a URI.</td>
                        </tr>
	                     <tr>
                            <td>
                                <code>fn:escape-html-uri</code>
                            </td>
                            <td>Returns the <code>xs:string</code> argument with certain characters escaped in the manner that html user agents handle attribute values that expect URIs.</td>
                        </tr>
                    </tbody>
                </table>
                <notes>
                    <p>When the above operators and functions are applied to datatypes derived from
                        <code>xs:string</code>, they are guaranteed to return legal
                        <code>xs:string</code>s, but they might not return a legal value for the
                        particular subtype to which they were applied. </p>
                <p>The strings returned by <code>fn:concat</code> and <code>fn:string-join</code> are not guaranteed to be normalized.  But see note in <code>fn:concat</code>.
                </p>
                </notes>
                <div3 id="func-concat">
                    <head>fn:concat</head>
                    <example role="signature">
                        <proto name="concat" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg1" type="xs:anyAtomicType" emptyOk="yes"/>
                            <arg name="arg2" type="xs:anyAtomicType" emptyOk="yes"/>
                            <arg name="..." type="" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Accepts two or more <code>xs:anyAtomicType</code> arguments and
                        casts them to <code>xs:string</code>. Returns the <code>xs:string</code>
                        that is the concatenation of the values of its arguments after conversion.
                        If any of the arguments is the empty sequence, the argument is treated as
                        the zero-length string.</p>
                    <p>The <code>fn:concat</code> function is specified to allow an two or more
                        arguments that are concatenated together. This is the only function
                        specified in this document that allows a variable number of arguments. This
                        capability is retained for compatibility with <bibref ref="xpath"/>. </p>
<note>
<p>As mentioned in <specref ref="string-types"/> Unicode normalization is not
automatically applied to the result of <code>fn:concat</code>.  If a normalized result is required, <code>fn:normalize-unicode</code> can be applied to the <code>xs:string</code> returned by <code>fn:concat</code>.  The following XQuery:</p>
<eg><![CDATA[
let $v1 := "I plan to go to Mu"
let $v2 := "?nchen in September"
return concat($v1, $v2)]]></eg>

<p>where the "?" represents either the actual Unicode character COMBINING DIARESIS (Unicode codepoint U+0308) or "<![CDATA[&#x0308;]]>", will return:</p>

<p>"I plan to go to Mu?nchen in September"</p>


<p>where the "?" represents either the actual Unicode character COMBINING DIARESIS (Unicode codepoint U+0308) or "<![CDATA[&#x0308;]]>". It is worth noting that the returned value is not normalized in NFC; however, it is normalized in NFD.
.</p>
<p>
However, the following XQuery:</p>
<eg><![CDATA[
let $v1 := "I plan to go to Mu"
let $v2 := "?nchen in September"
return normalize-unicode(concat($v1, $v2))]]></eg>

<p>where the "?" represents either the actual Unicode character COMBINING DIARESIS (Unicode codepoint U+0308) or "<![CDATA[&#x0308;]]>", will return:</p>
<p>
"I plan to go to M&uumlaut;nchen in September"</p>

<p>This returned result is normalized in NFC.</p>
</note>
                    <div4 id="func-concat-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:concat('un', 'grateful')</code> returns <quote>
                                        <code>ungrateful</code>
                                    </quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:concat('Thy ', (), 'old ', "groans", "", ' ring', '
                                        yet', ' in', ' my', ' ancient',' ears.')</code> returns <quote>
                                        <code>Thy old groans ring yet in my ancient ears.</code>
                                    </quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:concat('Ciao!',())</code> returns <quote>
                                        <code>Ciao!</code>
                                    </quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:concat('Ingratitude, ', 'thou ', 'marble-hearted', '
                                    fiend!')</code> returns <quote>
                                        <code>Ingratitude, thou marble-hearted fiend!</code>
                                    </quote>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-string-join">
                    <head>fn:string-join</head>
                    <example role="signature">
                        <proto name="string-join" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string*" emptyOk="no"/>
                            <arg name="arg2" type="xs:string" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns a <code>xs:string</code> created by concatenating the
                        members of the <code>$arg1</code> sequence using <code>$arg2</code> as a
                        separator. If the value of <code>$arg2</code> is the zero-length string,
                        then the members of <code>$arg1</code> are concatenated without a separator.</p>
                    <p> If the value of <code>$arg1</code> is the empty sequence, the zero-length
                        string is returned.</p>
                    <div4 id="func-string-join-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:string-join(('Now', 'is', 'the', 'time', '...'), '
                                    ')</code> returns <quote>
                                        <code>Now is the time ...</code>
                                    </quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:string-join(('Blow, ', 'blow, ', 'thou ', 'winter ',
                                        'wind!'), '')</code> returns <quote>
                                        <code>Blow, blow, thou winter wind!</code>
                                    </quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:string-join((), 'separator')</code> returns <quote/>. </p>
                            </item>
                            <item>
                                <p>Assume a document:</p>
                                <eg><![CDATA[<doc>
  <chap>
    <section>
    </section>
  </chap>
</doc>]]></eg>
                                <p>with the <code>&lt;section&gt;</code> as the context node,
                                    the <bibref ref="xpath20"/> expression: </p>
                                <p>
                                    <code>fn:string-join(for $n in ancestor-or-self::* return
                                        name($n), '/')</code>
                                </p>
                                <p> returns <quote>
                                        <code>doc/chap/section</code>
                                    </quote>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-substring">
                    <head>fn:substring</head>
                    <example role="signature">
                        <proto name="substring" return-type="xs:string" returnEmptyOk="no">
                            <arg name="sourceString" type="xs:string" emptyOk="yes"/>
                            <arg name="startingLoc" type="xs:double" emptyOk="no"/>
                        </proto>
                        <proto name="substring" return-type="xs:string" returnEmptyOk="no">
                            <arg name="sourceString" type="xs:string" emptyOk="yes"/>
                            <arg name="startingLoc" type="xs:double" emptyOk="no"/>
                            <arg name="length" type="xs:double" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the portion of the value of <code>$sourceString</code>
                        beginning at the position indicated by the value of
                        <code>$startingLoc</code> and continuing for the number of characters
                        indicated by the value of <code>$length</code>. The characters returned do
                        not extend beyond <code>$sourceString</code>. If <code>$startingLoc</code>
                        is zero or negative, only those characters in positions greater than zero
                        are returned.</p>
                    <p>More specifically, the three argument version of the function returns the
                        characters in <code>$sourceString</code> whose position <code>$p</code> obeys:</p>
                    <p>
                        <code>fn:round($startingLoc) &lt;= $p &lt; fn:round($startingLoc) + fn:round($length)</code>
                    </p>
                    <p> The two argument version of the function assumes that <code>$length</code> is
                        infinite and returns the characters in <code>$sourceString</code> whose
                        position <code>$p</code> obeys:</p>
                    <p>
                        <code>fn:round($startingLoc) &lt;= $p &lt; fn:round(INF)</code>
                    </p>
                    <p>In the above computations, the rules for <code>op:numeric-less-than()</code>
                        and <code>op:numeric-greater-than()</code> apply.</p>
                    <p>If the value of <code>$sourceString</code> is the empty sequence, the
                        zero-length string is returned. </p>
                    <!--					
					<p>If <code>$startingLoc</code>
is zero or negative, the substring includes characters from the beginning of the <code>$sourceString</code>.</p>
					<p>If <code>$length</code> is not specified, the substring includes characters to the end of <code>$sourceString</code>. </p>
					<p>If <code>$length</code> is
	  greater than the number of characters in the value of
	  <code>$sourceString</code> following
	  <code>$startingLoc</code>, the substring includes characters
	  to the end of <code>$sourceString</code>. </p> -->
                    <note>
                        <p>The first character of a string is located at position 1, not position 0.</p>
                    </note>
                    <div4 id="func-substring-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:substring("motor car", 6)</code> returns <code>" car"</code>.</p>
                                <p>Characters starting at position 6 to the end of
                                    <code>$sourceString</code> are selected.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring("metadata", 4, 3)</code> returns <code>"ada"</code>.</p>
                                <p>Characters at positions greater than or equal to 4 and less than
                                    7 are selected.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring("12345", 1.5, 2.6)</code> returns <code>"234"</code>.</p>
                                <p>Characters at positions greater than or equal to 2 and less than
                                    5 are selected.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring("12345", 0, 3)</code> returns <code>"12"</code>.</p>
                                <p>Characters at positions greater than or equal to 0 and less than
                                    3 are selected. Since the first position is 1, these are the
                                    characters at positions 1 and 2.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring("12345", 5, -3)</code> returns <code>""</code>.</p>
                                <p>Characters at positions greater than or equal to 5 and less than
                                    2 are selected.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring("12345", -3, 5)</code> returns <code>"1"</code>.</p>
                                <p>Characters at positions greater than or equal to -3 and less than
                                    2 are selected. Since the first position is 1, this is the
                                    character at position 1.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring("12345", 0 div 0E0, 3)</code> returns <code>""</code>.</p>
                                <p>Since <code>0 div 0E0</code> returns <code>NaN</code>, and
                                    <code>NaN</code> compared to any other number returns
                                    <code>false</code>, no characters are selected.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring("12345", 1, 0 div 0E0)</code> returns <code>""</code>.</p>
                                <p>As above.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring((), 1, 3)</code> returns <code>""</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring("12345", -42, 1 div 0E0)</code> returns <code>"12345"</code>.</p>
                                <p>Characters at positions greater than or equal to -42 and less
                                    than INF are selected.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring("12345", -1 div 0E0, 1 div 0E0)</code>
                                    returns <code>""</code>.</p>
                                <p>Since <code>-INF + INF</code> returns <code>NaN</code>, no
                                    characters are selected.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-string-length">
                    <head>fn:string-length</head>
                    <example role="signature">
                        <proto name="string-length" return-type="xs:integer" returnEmptyOk="no"/>
                    </example>
                    <example role="signature">
                        <proto name="string-length" return-type="xs:integer" returnEmptyOk="no">
                            <arg name="arg" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> equal to the length in characters
                        of the value of <code>$arg</code>.</p>
                    <p> If the value of <code>$arg</code> is the empty sequence, the
                        <code>xs:integer</code> 0 is returned.</p>
                    <p>If no argument is supplied, <code>$arg</code> defaults to the string value
                        (calculated using <code>fn:string()</code>) of the context item
                        (<code>.</code>). If no argument is supplied or if the argument is the context item and the context item is
                        undefined an error is raised: <xerrorref spec="XP" class="DY" code="0002" type="type"/>.</p>
                    <div4 id="func-string-length-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:string-length("Harp not on that string, madam; that is
                                    past.")</code> returns <code>45</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:string-length(())</code> returns <code>0</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-normalize-space">
                    <head>fn:normalize-space</head>
                    <example role="signature">
                        <proto name="normalize-space" return-type="xs:string" returnEmptyOk="no"/>
                    </example>
                    <example role="signature">
                        <proto name="normalize-space" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the value of <code>$arg</code> with whitespace normalized by
                        stripping leading and trailing whitespace and replacing sequences of one or
                        more than one whitespace character with a single space, <code>#x20</code>.</p>

 <p>The whitespace characters are defined in the metasymbol S (Production 3)
                    
                    of <bibref ref="REC-xml"/>.</p>

                    <note>
                    <p>The definition of the metasymbol S (Production 3), is unchanged
                    in <bibref ref="xml11"/>. </p>
                    </note>
<p>
If the value of
                        <code>$arg</code> is the empty sequence, returns the zero-length string.</p>
                    <p>If no argument is supplied, <code>$arg</code> defaults to the string value
                        (calculated using <code>fn:string()</code>) of the context item
                        (<code>.</code>). If no argument is supplied or if the argument is the context item and the context item is
                        undefined an error is raised: <xerrorref spec="XP" class="DY" code="0002" type="type"/>.
                    </p>
                    <div4 id="func-normalize-space-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:normalize-space(" The &nbsp;wealthy curled darlings
                                        of &nbsp;&nbsp;our &nbsp;nation. ")</code>
                                    returns <quote>
                                        <code>The wealthy curled darlings of our nation.</code>
                                    </quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:normalize-space(())</code> returns <quote></quote>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-normalize-unicode">
                    <head>fn:normalize-unicode</head>
                    <example role="signature">
                        <proto name="normalize-unicode" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg" type="xs:string" emptyOk="yes"/>
                        </proto>
                        <proto name="normalize-unicode" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg" type="xs:string" emptyOk="yes"/>
                            <arg name="normalizationForm" type="xs:string"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the value of <code>$arg</code> normalized according to the
                        normalization criteria for a normalization form identified by the value of
                        <code>$normalizationForm</code>. The effective value of the
                        <code>$normalizationForm</code> is computed by removing leading and trailing
                        blanks, if present, and converting to upper case.</p>
                    <p> If the value of <code>$arg</code> is the empty sequence, returns the
                        zero-length string.</p>
                    <p>See <bibref ref="charmod-normalization"/> for a description of the normalization forms.</p>
                    <p>If the <code>$normalizationForm</code> is absent, as in the first format
                        above, it shall be assumed to be "NFC"</p>
                    <ulist>
                        <item>
                            <p>If the effective value of <code>$normalizationForm</code> is
                                <quote>NFC</quote>, then the value returned by the function is the
                                value of <code>$arg</code> in Unicode Normalization Form C (NFC).</p>
                        </item>
                        <item>
                            <p>If the effective value of <code>$normalizationForm</code> is
                                <quote>NFD</quote>, then the value returned by the function is the
                                value of <code>$arg</code> in Unicode Normalization Form D (NFD).</p>
                        </item>
                        <item>
                            <p>If the effective value of <code>$normalizationForm</code> is
                                <quote>NFKC</quote>, then the value returned by the function is the
                                value of <code>$arg</code> in Unicode Normalization Form KC (NFKC).</p>
                        </item>
                        <item>
                            <p>If the effective value of <code>$normalizationForm</code> is
                                <quote>NFKD</quote>, then the value returned by the function is the
                                value of <code>$arg</code> in Unicode Normalization Form KD (NFKD).</p>
                        </item>
                        <item>
                            <p>If the effective value of <code>$normalizationForm</code> is
                                <quote>FULLY-NORMALIZED</quote>, then the value returned by the
                                function is the value of <code>$arg</code> in the fully normalized form.
                            </p>
                        </item>
                        <item>
                            <p>If the effective value of <code>$normalizationForm</code> is the
                                zero-length string, no normalization is performed and
                                <code>$arg</code> is returned.</p>
                        </item>
                        <!--						<item>
							<p>Implementations may choose to support other normalization forms in addition to the normalization forms discussed above.</p>
						</item> -->
                    </ulist>
                    <p>Conforming implementations <termref def="must"/> support normalization form
                        "NFC" and <termref def="may"/> support normalization forms "NFD", "NFKC",
                        "NFKD", "FULLY-NORMALIZED". They <termref def="may"/> also support other
                        normalization forms with <termref def="implementation-defined"/> semantics.
                        If the effective value of the <code>$normalizationForm</code> is other than
                        one of the values supported by the implementation, then an error is raised
                            <errorref class="CH" code="0003"/>.</p>
                </div3>
                <div3 id="func-upper-case">
                    <head>fn:upper-case</head>
                    <example role="signature">
                        <proto name="upper-case" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
                    
<p>
Summary: Returns the value of <code>$arg</code> after translating every character to 
its upper-case correspondent as defined in the appropriate case 
mappings section in the Unicode standard <bibref ref='Unicode4'/>. 
For versions of Unicode beginning with the 2.1.8 update, only 
locale-insensitive case mappings should be applied.  Beginning with 
version 3.2.0 (and likely future versions) of Unicode, precise mappings 
are described in default case operations, which are full case mappings
in the absence of tailoring for particular languages and environments.
Every lower-case character that does not have an upper-case correspondent, 
as well as every upper-case character, is included in the returned value 
in its original form. 
</p>
                    <p>If the value of <code>$arg</code> is the empty sequence, the zero-length
                        string is returned.</p>
                    <note>
                        <p>Case mappings may change the length of a string. In general, the two
                            functions are not inverses of each other
                            <code>fn:lower-case(fn:upper-case($arg))</code> is not guaranteed to
                            return <code>$arg</code>, nor
                            is <code>fn:upper-case(fn:lower-case($arg))</code>. The Latin small
                            letter dotless i (as used in Turkish) is perhaps the most prominent
                            lower-case letter which will not round-trip. The Latin capital letter i
                            with dot above is the most prominent upper-case letter which will not
                            round trip; there are others.</p>
                        <p> These functions may not always be linguistically appropriate (e.g.
                            Turkish i without dot) or appropriate for the application (e.g.
                            titlecase). In cases such as Turkish, a simple translation should be
                            used first.</p>
                        <p> Results may violate user expectations (in Quebec, for example, the
                            standard uppercase equivalent of "&egrave;" is "&Egrave;", while
                            in metropolitan France it is more commonly "E"; only one of these is
                            supported by the functions as defined).</p>
                        <p> Many characters of class Ll lack uppercase equivalents in the Unicode
                            case mapping tables; many characters of class Lu lack lowercase equivalents.</p>
                    </note>
                    <div4 id="func-upper-case-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:upper-case("abCd0")</code> returns
                                    <code>"ABCD0"</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-lower-case">
                    <head>fn:lower-case</head>
                    <example role="signature">
                        <proto name="lower-case" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
<p>
Summary: Returns the value of <code>$arg</code> after translating every character to 
its lower-case correspondent as defined in the appropriate case 
mappings section in the Unicode standard <bibref ref='Unicode4'/>. 
For versions of Unicode beginning with the 2.1.8 update, only 
locale-insensitive case mappings should be applied.  Beginning with 
version 3.2.0 (and likely future versions) of Unicode, precise mappings 
are described in default case operations, which are full case mappings
in the absence of tailoring for particular languages and environments.
Every upper-case character that does not have a lower-case correspondent, 
as well as every lower-case character, is included in the returned value 
in its original form. 
</p>
<p>If the value of <code>$arg</code> is the empty sequence, the zero-length
                        string is returned.</p>
                    <note>
                        <p>Case mappings may change the length of a string. In general, the two
                            functions are not inverses of each other
                            <code>fn:lower-case(fn:upper-case($arg))</code> is not guaranteed to
                            return <code>$arg</code>, nor
                            is <code>fn:upper-case(fn:lower-case($arg))</code>. The Latin small
                            letter dotless i (as used in Turkish) is perhaps the most prominent
                            lower-case letter which will not round-trip. The Latin capital letter i
                            with dot above is the most prominent upper-case letter which will not
                            round trip; there are others.</p>
                        <p> These functions may not always be linguistically appropriate (e.g.
                            Turkish i without dot) or appropriate for the application (e.g.
                            titlecase). In cases such as Turkish, a simple translation should be
                            used first.</p>
                        <p> Results may violate user expectations (in Quebec, for example, the
                            standard uppercase equivalent of "&egrave;" is "&Egrave;", while
                            in metropolitan France it is more commonly "E"; only one of these is
                            supported by the functions as defined).</p>
                        <p> Many characters of class Ll lack uppercase equivalents in the Unicode
                            case mapping tables; many characters of class Lu lack lowercase equivalents.</p>
                    </note>
                    <div4 id="func-lower-case-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:lower-case("ABc!D")</code> returns
                                    <code>"abc!d"</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-translate">
                    <head>fn:translate</head>
                    <example role="signature">
                        <proto name="translate" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg" type="xs:string" emptyOk="yes"/>
                            <arg name="mapString" type="xs:string" emptyOk="no"/>
                            <arg name="transString" type="xs:string" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the value of <code>$arg</code> modified so that every
                        character in the value of <code>$arg</code> that occurs at some position
                        <emph>N</emph> in the value of <code>$mapString</code> has been replaced by
                        the character that occurs at position <emph>N</emph> in the value of
                        <code>$transString</code>. </p>
                    <p> If the value of <code>$arg</code> is the empty sequence, the zero-length
                        string is returned.</p>
                    <p>Every character in the value of <code>$arg</code> that does not appear in the
                        value of <code>$mapString</code> is unchanged. </p>
                    <p>Every character in the value of <code>$arg</code> that appears at some
                        position <emph>M</emph> in the value of <code>$mapString</code>, where the
                        value of <code>$transString</code> is less than <emph>M</emph> characters in
                        length, is omitted from the returned value. If <code>$mapString</code> is
                        the zero-length string <code>$arg</code> is returned.</p>
                    <p>If a character occurs more than once in <code>$mapString</code>, then the
                        first occurrence determines the replacement character. If
                        <code>$transString</code> is longer than <code>$mapString</code>, the excess
                        characters are ignored.</p>
                    <div4 id="func-translate-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:translate("bar","abc","ABC")</code> returns <code>"BAr"</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:translate("--aaa--","abc-","ABC")</code> returns <code>"AAA"</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:translate("abcdabc", "abc", "AB")</code> returns
                                    <code>"ABdAB"</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <!--			<div3 id="func-string-pad">
					<head>fn:string-pad</head>
					<example role="signature">
						<proto name="string-pad" return-type="xs:string" returnEmptyOk="yes">
							<arg name="padString" type="xs:string" emptyOk="yes"/>
							<arg name="padCount" type="xs:integer" emptyOk="no"/>
						</proto>
					</example>
					<p> If the value of <code>$padString</code> is the empty sequence, returns the empty sequence.</p>
					<p>Otherwise, returns an <code>xs:string</code> consisting of <code>$padCount</code> copies of <code>$padString</code> concatenated together without any separators. Returns the zero-length string if <code>$padCount</code> is zero (0).</p>
					<p>If the value of <code>$padCount</code> is less than zero (0), an error is raised <errorref class="RG" code="0002"/>.</p>
					<div4 id="func-string-pad-examples">
						<head>Examples</head>
						<ulist>
							<item>
								<p>
									<code>fn:string-pad("XMLQuery", 2)</code> returns <code>"XMLQueryXMLQuery"</code>.</p>
							</item>
							<item>
								<p>
									<code>fn:string-pad(" ", 4)</code> returns a string containing four spaces.</p>
							</item>
							<item>
								<p>
									<code>fn:string-pad(" ", 0)</code> returns the zero-length string.</p>
							</item>
							<item>
								<p>
									<code>fn:string-pad(" ", -3)</code> results in an error being raised <errorref class="RG" code="0002"/>.</p>
							</item>
						</ulist>
					</div4>
				</div3> -->
                <div3 id="func-encode-for-uri">
                    <head>fn:encode-for-uri</head>
                    <example role="signature">
                        <proto name="encode-for-uri" return-type="xs:string" returnEmptyOk="no">
                            <arg name="uri-part" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
<p>
Summary: This function encodes reserved characters in an <code>xs:string</code> that is intended to be used in the path segment of a URI. It is invertible but not idempotent. This function applies the URI escaping rules defined in section 2 of <bibref ref="rfc3986"/> to the <code>xs:string</code> supplied as <code>$uri-part</code>. The effect of the function is to escape reserved characters. Each such character in the string is replaced with its percent-encoded form as described in <bibref ref="rfc3986"/>.</p>
<p>
If <code>$uri-part</code> is the empty sequence, returns the zero-length string.</p>
<p>
All characters are escaped except those identified as "unreserved" by <bibref ref="rfc3986"/>, that is the upper- and lower-case letters A-Z, the digits 0-9, HYPHEN-MINUS ("-"), LOW LINE ("_"), FULL STOP ".", and TILDE "~".</p>
<p>
Note that this function escapes URI delimiters and therefore cannot be used indiscriminately to encode "invalid" characters in a path segment.</p>
<p>
Since <bibref ref="rfc3986"/> recommends that, for consistency, URI producers and normalizers should use uppercase hexadecimal digits for all percent-encodings, this function must always generate hexadecimal values using the upper-case letters A-F.
</p>
                  <div4 id="func-encode-for-uri-examples">
                        <head>Examples</head>
 						<ulist>
                            <item>
                                <p>
<code>fn:encode-for-uri("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")</code> 
      returns  <code>"http%3A%2F%2Fwww.example.com%2F00%2FWeather%2FCA%2FLos%2520Angeles%23ocean"</code>.
      This is probably not what the user intended because all of the delimiters
      have been encoded.

                                </p>
                            </item>
                            <item>
                                <p>
<code>concat("http://www.example.com/", encode-for-uri("~b&eacute;b&eacute;"))</code>
      returns <code>"http://www.example.com/~b%C3%A9b%C3%A9"</code>.

                                </p>
                            </item>
                            <item>
                                <p>
<code>concat("http://www.example.com/", encode-for-uri("100% organic"))</code>
      returns <code>"http://www.example.com/100%25%20organic"</code>.
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
  <div3 id="func-iri-to-uri">
                    <head>fn:iri-to-uri</head>
                    <example role="signature">
                        <proto name="iri-to-uri" return-type="xs:string" returnEmptyOk="no">
                            <arg name="iri" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
<p>
Summary: This function converts an <code>xs:string</code> containing an IRI into a URI according to the rules spelled out in Section 3.1 of <bibref ref="rfc3987"/>.  It is idempotent but not invertible.</p>
<p>If <code>$iri</code> contains a character that is invalid in an IRI, such as the space character (see note below), the invalid character is 
replaced by its percent-encoded form as described in <bibref ref="rfc3986"/> before the conversion is performed.</p>
<p>
If <code>$iri</code> is the empty sequence, returns the zero-length string.</p>
<p>
Since <bibref ref="rfc3986"/> recommends that, for consistency, URI producers and normalizers should use uppercase hexadecimal digits for all percent-encodings, this function must always generate hexadecimal values using the upper-case letters A-F.</p>

<notes>
<p>
This function does not check whether <code>$iri</code> is a legal IRI.  It treats it as an <code>xs:string</code> and operates on the characters in the <code>xs:string</code>.
</p>
<p>
The following printable ASCII characters are invalid in an IRI:
"&lt;", ">", <quote> " </quote> (double quote), space, "{", "}", "|", "\", "^", and "`".  Since these characters should not appear in an IRI, if they do appear in <code>$iri</code> they will be percent-encoded. In addition, characters outside the range x20-x126 will be percent-encoded because they are invalid in a URI.
</p>
<p>
  Since this function does not escape the PERCENT SIGN "%" and this
  character is not allowed in data within a URI, users wishing to
  convert character strings, such as file names, that include "%" to a
  URI should manually escape "%" by replacing it with "%25".
</p></notes>
                <div4 id="func-iri-to-uri-examples">
                        <head>Examples</head>
                        <ulist>
 							<item>
                                <p>
                                  <code>fn:iri-to-uri
                                        ("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")</code> returns <code>"http://www.example.com/00/Weather/CA/Los%20Angeles#ocean"</code>. 
                                </p>
                            </item>
                           <item>
                                <p>
                                    <code>fn:iri-to-uri
                                        ("http://www.example.com/~b&eacute;b&eacute;")</code> returns <code>"http://www.example.com/~b%C3%A9b%C3%A9"</code>.
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
 <div3 id="func-escape-html-uri">
                    <head>fn:escape-html-uri</head>
                    <example role="signature">
                        <proto name="escape-html-uri" return-type="xs:string" returnEmptyOk="no">
                            <arg name="uri" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary:  This function escapes all characters except printable characters of the US-ASCII coded character set, specifically the octets ranging from 32 to 126 (decimal).  The effect of the function is to escape a URI in the manner html user agents handle attribute values that expect URIs.  Each character in <code>$uri</code> to be escaped is replaced by an escape sequence, which is formed by encoding the character as a sequence of octets in UTF-8, and then representing each of these octets in the form %HH, where HH is the hexadecimal representation of the octet.  This function must always generate hexadecimal values using the upper-case letters A-F.
</p>
 <p>If <code>$uri</code> is the empty sequence, returns the zero-length string.</p>
                            
                  
<note>
                        <p>The behavior of this function corresponds to the recommended handling 
of non-ASCII characters in URI attribute values as described in <bibref ref='HTML40'/> Appendix B.2.1.

</p>
                    </note>
                   
                    <div4 id="func-escape-html-uri-examples">
                        <head>Examples</head>
                        <ulist>
 							<item>
                                <p>
                                  <code>fn:escape-html-uri
                                        ("http://www.example.com/00/Weather/CA/Los Angeles#ocean")</code> returns <code>"http://www.example.com/00/Weather/CA/Los Angeles#ocean"</code>. 
                                </p>
                            </item>
                           <item>
                                <p>
                                    <code>fn:escape-html-uri
                                        ("javascript:if (navigator.browserLanguage == 'fr') window.open('http://www.example.com/~b&eacute;b&eacute;');") returns "javascript:if (navigator.browserLanguage == 'fr') window.open('http://www.example.com/~b%C3%A9b%C3%A9');"</code>.
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id="substring.functions">
                <head>Functions Based on Substring Matching</head>
                <p>The functions described in the section examine a string <code>$arg1</code> to see
                    whether it contains another string <code>$arg2</code> as a substring. The result
                    depends on whether <code>$arg2</code> is a substring of <code>$arg1</code>, and
                    if so, on the range of characters in <code>$arg1</code> which <code>$arg2</code> matches.</p>
                <p> When the Unicode code point collation
                    is used, this simply involves determining whether <code>$arg1</code> contains a
                    contiguous sequence of characters whose code points are the same, one for one,
                    with the code points of the characters in <code>$arg2</code>.</p>
                <p> When a collation is specified, the rules are more complex.</p>
                <p>All collations support the capability of deciding whether two strings are
                    considered equal, and if not, which of the strings should be regarded as
                    preceding the other. For functions such as <code>fn:compare()</code>, this is
                    all that is required. For other functions, such as <code>fn:contains()</code>,
                    the collation needs to support an additional property: it must be able to
                    decompose the string into a sequence of collation units, each unit consisting of
                    one or more characters, such that two strings can be compared by pairwise
                    comparison of these units. ("collation unit" is equivalent to "collation
                    element" as defined in <bibref ref="Unicode-Collations"/>.) The string
                    <code>$arg1</code> is then considered to contain <code>$arg2</code> as a
                    substring if the sequence of collation units corresponding to <code>$arg2</code>
                    is a subsequence of the sequence of the collation units corresponding to
                    <code>$arg1</code>. The characters in <code>$arg1</code> that match are the
                    characters corresponding to these collation units.</p>
                <p>This rule may occasionally lead to surprises. For example, consider a collation
                    that treats "Jaeger" and "J&aumlaut;ger" as equal. It might do this by
                    treating "&aumlaut;" as representing two collation units, in which case the
                        expression <code>fn:contains("J&aumlaut;ger", "eg")</code> will return
                    <code>true</code>. Alternatively, a collation might treat "ae" as a single
                    collation unit, in which case the expression <code>fn:contains("Jaeger",
                    "eg")</code> will return <code>false</code>. The results of these functions thus
                    depend strongly on the properties of the collation that is used. In addition,
                    collations may specify that some collation units should be ignored during matching.</p>
                <p> In the definitions below, we say that <code>$arg1</code> contains
                    <code>$arg2</code> at positions <code>m</code> through <code>n</code> if the
                    collation units corresponding to characters in positions <code>m</code> to
                    <code>n</code> of <code>$arg1</code> are the same as the collation units
                    corresponding to all the characters of <code>$arg2</code> modulo ignorable
                    collation units. In the simple case of the Unicode code point collation, the
                    collation units are the same as the characters of the string. See <bibref
                    ref="Unicode-Collations"/> for a detailed discussion of substring matching.</p>
                <p> It is possible to define collations that do not have the ability to decompose a
                    string into units suitable for substring matching. An argument to a function
                    defined in this section may be a URI that identifies a collation that is able to
                    compare two strings, but that does not have the capability to split the string
                    into collation units. Such a collation may cause the function to fail, or to
                    give unexpected results or it may be rejected as an unsuitable argument. The
                    ability to decompose strings into collation units is an <termref
                    def="implementation-defined"/> property of the collation.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:contains</code>
                            </td>
                            <td>Indicates whether one <code>xs:string</code> contains another
                                <code>xs:string</code>. A collation may be specified. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:starts-with</code>
                            </td>
                            <td>Indicates whether the value of one <code>xs:string</code> begins
                                with the collation units of another <code>xs:string</code>. A
                                collation may be specified.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:ends-with</code>
                            </td>
                            <td>Indicates whether the value of one <code>xs:string</code> ends with
                                the collation units of another <code>xs:string</code>. A collation
                                may be specified.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:substring-before</code>
                            </td>
                            <td>Returns the collation units of one <code>xs:string</code> that
                                precede in that <code>xs:string</code> the collation units of
                                another <code>xs:string</code>. A collation may be specified. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:substring-after</code>
                            </td>
                            <td>Returns the collation units of <code>xs:string</code> that follow in
                                that <code>xs:string</code> the collation units of another
                                <code>xs:string</code>. A collation may be specified. </td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-contains">
                    <head>fn:contains</head>
                    <example role="signature">
                        <proto name="contains" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string" emptyOk="yes"/>
                            <arg name="arg2" type="xs:string" emptyOk="yes"/>
                        </proto>
                        <proto name="contains" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string" emptyOk="yes"/>
                            <arg name="arg2" type="xs:string" emptyOk="yes"/>
                            <arg name="collation" type="xs:string"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:boolean</code> indicating whether or not the
                        value of <code>$arg1</code> contains (at the beginning, at the end, or
                        anywhere within) at least one sequence of collation units that provides a
                        minimal match to the collation units in the value of <code>$arg2</code>,
                        according to the collation that is used.</p>
                    <note>
                        <p>"Minimal match" is defined in <bibref ref="Unicode-Collations"/>. </p>
                    </note>
                    <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty
                        sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.</p>
                    <p>If the value of <code>$arg2</code> is the zero-length string, then the
                        function returns <code>true</code>.</p>
                    <p> If the value of <code>$arg1</code> is the zero-length string, the function
                        returns <code>false</code>.</p>
                    <p>The collation used by the invocation of this function is determined according
                        to the rules in <specref ref="collations"/>. If the specified collation does
                        not support collation units an error <termref def="may"/> be raised
                            <errorref class="CH" code="0004"/>.</p>
                    <div4 id="func-contains-examples">
                        <head>Examples</head>
                        <p>CollationA used in these examples is a collation in which both "-" and
                            "*" are ignorable collation units.</p>
                        <note>
                            <p>"Ignorable collation unit" is equivalent to "ignorable collation
                                element" in <bibref ref="Unicode-Collations"/>.</p>
                        </note>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:contains ( "tattoo", "t")</code> returns <code>true</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:contains ( "tattoo", "ttt")</code> returns <code>false</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:contains ( "", ())</code> returns <code>true</code>.  The first rule is applied, followed by the second rule.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:contains ( "abcdefghi", "-d-e-f-", "CollationA")</code>
                                    returns <code>true</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:contains ( "a*b*c*d*e*f*g*h*i*", "d-ef-",
                                    "CollationA")</code> returns <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:contains ( "abcd***e---f*--*ghi", "def",
                                    "CollationA")</code> returns <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:contains ( (), "--***-*---", "CollationA")</code>
                                    returns <code>true</code>. The second argument contains only
                                    ignorable collation units and is equivalent to the zero-length string.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-starts-with">
                    <head>fn:starts-with</head>
                    <example role="signature">
                        <proto name="starts-with" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string" emptyOk="yes"/>
                            <arg name="arg2" type="xs:string" emptyOk="yes"/>
                        </proto>
                        <proto name="starts-with" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string" emptyOk="yes"/>
                            <arg name="arg2" type="xs:string" emptyOk="yes"/>
                            <arg name="collation" type="xs:string"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:boolean</code> indicating whether or not the
                        value of <code>$arg1</code> starts with a sequence of collation units that
                        provides a minimal match to the collation units of <code>$arg2</code>
                        according to the collation that is used.</p>
                    <note>
                        <p>"Minimal match" is defined in <bibref ref="Unicode-Collations"/>. </p>
                    </note>
                    <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty
                        sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.</p>
                    <p>If the value of <code>$arg2</code> is the zero-length string, then the
                        function returns <code>true</code>. If the value of <code>$arg1</code> is
                        the zero-length string and the value of <code>$arg2</code> is not the
                        zero-length string, then the function returns <code>false</code>.</p>
                    <p>The collation used by the invocation of this function is determined according
                        to the rules in <specref ref="collations"/>. If the specified collation does
                        not support collation units an error <termref def="may"/> be raised
                            <errorref class="CH" code="0004"/>.</p>
                    <div4 id="func-starts-with-examples">
                        <head>Examples</head>
                        <p>CollationA used in these examples is a collation in which both "-" and
                            "*" are ignorable collation units.</p>
                        <note>
                            <p>"Ignorable collation unit" is equivalent to "ignorable collation
                                element" in <bibref ref="Unicode-Collations"/>.</p>
                        </note>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:starts-with("tattoo", "tat")</code> returns
                                    <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:starts-with ( "tattoo", "att")</code> returns
                                    <code>false</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:starts-with ((), ())</code> returns <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:starts-with ( "abcdefghi", "-a-b-c-",
                                    "CollationA")</code> returns <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:starts-with ( "a*b*c*d*e*f*g*h*i*", "a-bc-",
                                    "CollationA")</code> returns <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:starts-with ( "abcd***e---f*--*ghi", "abcdef",
                                    "CollationA")</code> returns <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:starts-with ( (), "--***-*---", "CollationA")</code>
                                    returns <code>true</code>. The second argument contains only
                                    ignorable collation units and is equivalent to the zero-length string.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-ends-with">
                    <head>fn:ends-with</head>
                    <example role="signature">
                        <proto name="ends-with" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string" emptyOk="yes"/>
                            <arg name="arg2" type="xs:string" emptyOk="yes"/>
                        </proto>
                        <proto name="ends-with" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string" emptyOk="yes"/>
                            <arg name="arg2" type="xs:string" emptyOk="yes"/>
                            <arg name="collation" type="xs:string"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:boolean</code> indicating whether or not the
                        value of <code>$arg1</code> ends with a sequence of collation units that
                        provides a minimal match to the collation units of <code>$arg2</code>
                        according to the collation that is used.</p>
                    <note>
                        <p>"Minimal match" is defined in <bibref ref="Unicode-Collations"/>. </p>
                    </note>
                    <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty
                        sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.</p>
                    <p>If the value of <code>$arg2</code> is the zero-length string, then the
                        function returns <code>true</code>. If the value of <code>$arg1</code> is
                        the zero-length string and the value of <code>$arg2</code> is not the
                        zero-length string, then the function returns <code>false</code>.</p>
                    <p>The collation used by the invocation of this function is determined according
                        to the rules in <specref ref="collations"/>. If the specified collation does
                        not support collation units an error <termref def="may"/> be raised
                            <errorref class="CH" code="0004"/>.</p>
                    <div4 id="func-ends-with-examples">
                        <head>Examples</head>
                        <p>CollationA used in these examples is a collation in which both "-" and
                            "*" are ignorable collation units.</p>
                        <note>
                            <p>"Ignorable collation unit" is equivalent to "ignorable collation
                                element" in <bibref ref="Unicode-Collations"/>.</p>
                        </note>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:ends-with ( "tattoo", "tattoo")</code> returns
                                    <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:ends-with ( "tattoo", "atto")</code> returns
                                    <code>false</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:ends-with ((), ())</code> returns <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:ends-with ( "abcdefghi", "-g-h-i-",
                                    "CollationA")</code> returns <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:ends-with ( "abcd***e---f*--*ghi", "defghi",
                                    "CollationA")</code> returns <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:ends-with ( "abcd***e---f*--*ghi", "defghi",
                                    "CollationA")</code> returns <code>true</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:ends-with ( (), "--***-*---", "CollationA")</code>
                                    returns <code>true</code>. The second argument contains only
                                    ignorable collation units and is equivalent to the zero-length string.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-substring-before">
                    <head>fn:substring-before</head>
                    <example role="signature">
                        <proto name="substring-before" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string" emptyOk="yes"/>
                            <arg name="arg2" type="xs:string" emptyOk="yes"/>
                        </proto>
                        <proto name="substring-before" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string" emptyOk="yes"/>
                            <arg name="arg2" type="xs:string" emptyOk="yes"/>
                            <arg name="collation" type="xs:string"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the substring of the value of <code>$arg1</code> that
                        precedes in the value of <code>$arg1</code> the first occurrence of a
                        sequence of collation units that provides a minimal match to the collation
                        units of <code>$arg2</code> according to the collation that is used.</p>
                    <note>
                        <p>"Minimal match" is defined in <bibref ref="Unicode-Collations"/>. </p>
                    </note>
                    <p> If the value of <code>$arg1</code> or <code>$arg2</code> is the empty
                        sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.</p>
                    <p>If the value of <code>$arg2</code> is the zero-length string, then the
                        function returns the zero-length string. </p>
                    <p>If the value of <code>$arg1</code> does not contain a string that is equal to
                        the value of <code>$arg2</code>, then the function returns the zero-length
                        string. </p>
                    <p>The collation used by the invocation of this function is determined according
                        to the rules in <specref ref="collations"/> If the specified collation does
                        not support collation units an error <termref def="may"/> be raised
                            <errorref class="CH" code="0004"/>.</p>
                    <div4 id="func-substring-before-example">
                        <head>Examples</head>
                        <p>CollationA used in these examples is a collation in which both "-" and
                            "*" are ignorable collation units.</p>
                        <note>
                            <p>"Ignorable collation unit" is equivalent to "ignorable collation
                                element" in <bibref ref="Unicode-Collations"/>.</p>
                        </note>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:substring-before ( "tattoo", "attoo")</code> returns <quote><code>t</code></quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring-before ( "tattoo", "tatto")</code> returns <quote><code/></quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring-before ((), ())</code> returns <quote><code/></quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring-before ( "abcdefghi", "--d-e-",
                                    "CollationA")</code> returns <quote><code>abc</code></quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring-before ( "abc--d-e-fghi", "--d-e-",
                                    "CollationA")</code> returns <quote><code>abc--</code></quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring-before ( "a*b*c*d*e*f*g*h*i*", "***cde",
                                    "CollationA")</code> returns <quote><code>a*b*</code></quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code> fn:substring-before ( "Eureka!", "--***-*---",
                                    "CollationA")</code> returns <quote/>. The second argument
                                    contains only ignorable collation units and is equivalent to the
                                    zero-length string.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-substring-after">
                    <head>fn:substring-after</head>
                    <example role="signature">
                        <proto name="substring-after" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string" emptyOk="yes"/>
                            <arg name="arg2" type="xs:string" emptyOk="yes"/>
                        </proto>
                        <proto name="substring-after" return-type="xs:string" returnEmptyOk="no">
                            <arg name="arg1" type="xs:string" emptyOk="yes"/>
                            <arg name="arg2" type="xs:string" emptyOk="yes"/>
                            <arg name="collation" type="xs:string"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the substring of the value of <code>$arg1</code> that
                        follows in the value of <code>$arg1</code> the first occurrence of a
                        sequence of collation units that provides a minimal match to the collation
                        units of <code>$arg2</code> according to the collation that is used. </p>
                    <note>
                        <p>"Minimal match" is defined in <bibref ref="Unicode-Collations"/>. </p>
                    </note>
                    <p> If the value of <code>$arg1</code> or <code>$arg2</code> is the empty
                        sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.</p>
                    <p>If the value of <code>$arg2</code> is the zero-length string, then the
                        function returns the value of <code>$arg1</code>.</p>
                    <p>If the value of <code>$arg1</code> does not contain a string that is equal to
                        the value of <code>$arg2</code>, then the function returns the zero-length
                        string. </p>
                    <p>The collation used by the invocation of this function is determined according
                        to the rules in <specref ref="collations"/> If the specified collation does
                        not support collation units an error <termref def="may"/> be raised
                            <errorref class="CH" code="0004"/>.</p>
                    <div4 id="func-substring-after-examples">
                        <head>Examples</head>
                        <p>CollationA used in these examples is a collation in which both "-" and
                            "*" are ignorable collation units.</p>
                        <note>
                            <p>"Ignorable collation unit" is equivalent to "ignorable collation
                                element" in <bibref ref="Unicode-Collations"/>.</p>
                        </note>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:substring-after("tattoo", "tat")</code> returns <quote><code>too</code></quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring-after ( "tattoo", "tattoo")</code> returns <quote><code/></quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring-after ((), ())</code> returns <quote><code/></quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code> fn:substring-after ( "abcdefghi", "--d-e-",
                                    "CollationA")</code> returns <quote><code>fghi</code></quote>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring-after ( "abc--d-e-fghi", "--d-e-",
                                    "CollationA")</code> returns <quote><code>-fghi</code>
                                    </quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring-after ( "a*b*c*d*e*f*g*h*i*", "***cde***",
                                    "CollationA")</code> returns <quote><code>*f*g*h*i*</code></quote>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:substring-after ( "Eureka!", "--***-*---",
                                    "CollationA")</code> returns <quote><code>Eureka!</code></quote>. The second argument contains only ignorable collation
                                    units and is equivalent to the zero-length string.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id="string.match">
                <head>String Functions that Use Pattern Matching</head>
                <p>The three functions described in this section make use of a regular expression
                    syntax for pattern matching. This is described below.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:matches</code>
                            </td>
                            <td>Returns an <code>xs:boolean</code> value that indicates whether the
                                value of the first argument is matched by the regular expression
                                that is the value of the second argument. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:replace</code>
                            </td>
                            <td>Returns the value of the first argument with every substring matched
                                by the regular expression that is the value of the second argument
                                replaced by the replacement string that is the value of the third
                                argument. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:tokenize</code>
                            </td>
                            <td>Returns a sequence of one or more <code>xs:string</code>s whose
                                values are substrings of the value of the first argument separated
                                by substrings that match the regular expression that is the value of
                                the second argument.</td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="regex-syntax">
                    <head>Regular Expression Syntax</head>
                    <p>The regular expression syntax used by these functions is defined in terms of
                        the regular expression syntax specified in XML Schema (see <bibref
                        ref="xmlschema-2"/>), which in turn is based on the established conventions of
                        languages such as Perl. However, because XML Schema uses regular expressions
                        only for validity checking, it omits some facilities that are widely-used
                        with languages such as Perl. This section, therefore, describes extensions
                        to the XML Schema regular expressions syntax that reinstate these capabilities.</p>
<note><p>
It is recommended that implementers consult <bibref ref='Unicode-Regex'/> for information on using regular expression processing on Unicode characters.</p></note>
                  
                        <p>The regular expression syntax and semantics are identical to those
                            defined in <bibref ref="xmlschema-2"/> with the following additions:</p>
                        <ulist>
                            <item>
                                <p> Two meta-characters, <code>^</code> and <code>$</code> are
                                    added. By default, the meta-character <code>^</code> matches the
                                    start of the entire string, while <code>$</code> matches the end
                                    of the entire string. In multi-line mode, <code>^</code> matches
                                    the start of any line (that is, the start of the entire string,
                                    and the position immediately after a newline character), while
                                    <code>$</code> matches the end of any line (that is, the end of
                                    the entire string, and the position immediately before a newline
                                    character). Newline here means the character <code>#x0A</code> only.</p>
                                <p>This means that the production in <bibref ref="xmlschema-2"/>:</p>
                                <p>
                                    <code>[10] Char ::= [^.\?*+()|#x5B#x5D]</code>
                                </p>
                                <p>is modified to read:</p>
                                <p>
                                    <code>[10] Char ::= [^.\?*+{}()|^$#x5B#x5D]</code>
                                </p>
                                <p>The characters <code>#x5B</code> and <code>#x5D</code> correspond
                                    to "<code>[</code>" and "<code>]</code>" respectively.</p>
<note><p>The definition of Char (production [10]) in <bibref ref="xmlschema-2"/> has a known error in which it omits the left brace ("{") and right brace ("}").  That error is corrected here.</p></note>

                                <p>The following production:</p>
                                <p>
                                    <code>[11] charClass ::= charClassEsc | charClassExpr | WildCardEsc</code>
                                </p>
                                <p>is modified to read:</p>
                                <p>
                                    <code>[11] charClass ::= charClassEsc | charClassExpr |
                                        WildCardEsc | "^" | "$"</code>
                                </p>
                            </item>
                                                <item>
                                <p>
                                    <emph>Reluctant quantifiers</emph> are supported. They are
                                    indicated by a <quote>
                                        <code>?</code>
                                    </quote> following a quantifier. Specifically:</p>
                                <ulist>
                                    <item>
                                        <p>
                                            <code>X??</code> matches X, once or not at all</p>
                                    </item>
                                    <item>
                                        <p>
                                            <code>X*?</code> matches X, zero or more times</p>
                                    </item>
                                    <item>
                                        <p>
                                            <code>X+?</code> matches X, one or more times</p>
                                    </item>
                                    <item>
                                        <p>
                                            <code>X{n}?</code> matches X, exactly n times</p>
                                    </item>
                                    <item>
                                        <p>
                                            <code>X{n,}?</code> matches X, at least n times</p>
                                    </item>
                                    <item>
                                        <p>
                                            <code>X{n,m}?</code> matches X, at least n times, but
                                            not more than m times</p>
                                    </item>
                                </ulist>
                                <p>The effect of these quantifiers is that the regular expression
                                    matches the <emph>shortest</emph> possible substring consistent
                                    with the match as a whole succeeding. Without the <quote>
                                        <code>?</code>
                                    </quote>, the regular expression matches the
                                    <emph>longest</emph> possible substring.</p>
                                <p>To achieve this, the production in <bibref ref="xmlschema-2"/>:</p>
                                <p>
                                    <code>[4] quantifier ::= [?*+] | ( '{' quantity '}' )</code>
                                </p>
                                <p>is changed to:</p>
                                <p>
                                    <code>[4] quantifier ::= ( [?*+] | ( '{' quantity '}' ) ) '?'?</code>
                                </p>
                                <note>
                                    <p>Reluctant quantifiers have no effect on the results of the
                                        boolean <code>fn:matches</code> function, since this
                                        function is only interested in discovering whether a match
                                        exists, and not where it exists.</p>
                                </note>
                            </item>
                            <item>
                                <p>Sub-expressions (groups) within the regular expression are
                                    recognized. The regular expression syntax defined by <bibref
                                    ref="xmlschema-2"/> allows a regular expression to contain
                                    parenthesized sub-expressions, but attaches no special
                                    significance to them. The <code>fn:replace()</code> function
                                    described below allows access to the parts of the input string
                                    that matched a sub-expression (called captured substrings). The
                                    sub-expressions are numbered according to the position of the
                                    opening parenthesis in left-to-right order within the top-level
                                    regular expression: the first opening parenthesis identifies
                                    captured substring 1, the second identifies captured substring
                                    2, and so on. 0 identifies the substring captured by the entire
                                    regular expression. If a sub-expression matches more than one
                                    substring (because it is within a construct that allows
                                    repetition), then only the <emph>last</emph> substring that it
                                    matched will be captured.</p>
                            </item>
                            <item>
                                <p> Back-references are allowed. The construct <code>\n</code> where
                                    <code>n</code> is a single digit is always recognized as a
                                    back-reference; if this is followed by further digits, these
                                    digits are taken to be part of the back-reference if and only if
                                    the back-reference is preceded by sufficiently many capturing
                                    subexpressions. A back-reference matches the string that was
                                    matched by the <code>n</code>th capturing subexpression within the regular
                                    expression, that is, the parenthesized subexpression whose
                                    opening left parenthesis is the <code>n</code>th unescaped left
                                    parenthesis within the regular expression. The closing right
                                    parenthesis of this subexpression must occur before the
                                    back-reference. For example, the regular expression
                                    <code>('|").*\1</code> matches a sequence of characters
                                    delimited either by an apostrophe at the start and end, or by a
                                    quotation mark at the start and end. </p>
                                   <p>If no string is matched by the <code>n</code>th capturing 
                                   subexpression, the back-reference is interpreted as matching 
                                   a zero-length string.</p>
                                <p>Back-references change the following production:</p>
                                <p>
                                    <code>[23] charClassEsc ::= ( SingleCharEsc | MultiCharEsc |
                                        catEsc | complEsc )</code>
                                </p>
                                <p>to</p>
                                <p>
                                    <code>[23] charClassEsc ::= ( SingleCharEsc | MultiCharEsc |
                                        catEsc | complEsc | backReference )</code>
                                </p>
                                <p>
                                    <code>[23a] backReference ::= "\" [1-9][0-9]*</code>
                                </p>
                            </item>
                            <item>
                                <p> Single character escapes are extended to allow the
                                    <code>$</code> character to be escaped. The following production
                                    is changed:</p>
                                <p>
                                    <code>[24]SingleCharEsc ::= '\' [nrt\|.?*+(){}#x2D#x5B#x5D#x5E]</code>
                                </p>
                                <p>to</p>
                                <p>
                                    <code>[24]SingleCharEsc ::= '\' [nrt\|.?*+(){}$#x2D#x5B#x5D#x5E]</code>
                                </p>
                            </item>
                        </ulist>
                       <div4 id="flags">
                        <head>Flags</head>
                        <p>All these functions provide an optional parameter, <code>$flags</code>,
                            to set options for the interpretation of the regular expression. The
                            parameter accepts a <code>xs:string</code>, in which individual letters
                            are used to set options. The presence of a letter within the string
                            indicates that the option is on; its absence indicates that the option
                            is off. Letters may appear in any order and may be repeated. If there
                            are characters present that are not defined here as flags, then an error
                            is raised <errorref class="RX" code="0001"/>.</p>
                        <p>The following options are defined:</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>s</code>: If present, the match operates in "dot-all"
                                    mode. (Perl calls this the single-line mode.) If the
                                    <code>s</code> flag is not specified, the meta-character
                                    <code>.</code> matches any character except a newline
                                    (<code>#x0A</code>) character. In dot-all mode, the
                                    meta-character <code>.</code> matches any character whatsoever.
                                    Suppose the input contains "hello" and "world" on two lines.
                                    This will not be matched by the regular expression
                                    "hello.*world" unless dot-all mode is enabled.</p>
                            </item>
                            <item>
                                <p>
                                    <code>m</code>: If present, the match operates in multi-line
                                    mode. By default, the meta-character <code>^</code> matches the
                                    start of the entire string, while $ matches the end of the
                                    entire string. In multi-line mode, <code>^</code> matches the
                                    start of any line (that is, the start of the entire string, and
                                    the position immediately after a newline character), while
                                    <code>$</code> matches the end of any line (that is, the end of
                                    the entire string, and the position immediately before a newline
                                    character). Newline here means the character <code>#x0A</code> only.</p>
                            </item>
 <item>
                                <p>
                                    <code>i</code>: If present, the match operates in
                                    case-insensitive mode. The detailed rules are as follows. 
                                    In these
                                    rules, a character C2 is considered to be a <emph>case-variant</emph> of 
                                    another character C1 if the following XPath expression returns 
                                    <code>true</code> when the two characters
                                    are considered as strings of length one, and the Unicode codepoint
                                    collation is used:</p>

                                    <p><code>fn:lower-case(C1) eq fn:lower-case(C2)</code></p> 
                                    <p>  or </p>
                                    <p><code>fn:upper-case(C1) eq fn:upper-case(C2)</code></p>
                                    <p>
                                     Note that the case-variants of a character under this definition 
                                     are always single characters.</p>
                                    <olist><item><p>
                                    When a normal character (<code>Char</code>) is used as an atom, 
                                    it represents 
                                    the set containing that character and all its case-variants. 
                                    For example, the regular expression "z" will match both "z" and 
                                    "Z".</p></item>
                                    <item><p>
                                    A character range (<code>charRange</code>) represents the set 
                                    containing all the characters that it would match in the absence 
                                    of the "<code>i</code>" flag, together with their case-variants. 
                                    For example, 
                                    the regular expression "[A-Z]" will match all
                                    the letters A-Z and all the letters a-z. It will also match 
                                    certain other characters such as <code>#x212A</code> (KELVIN SIGN), since 
                                    <code>fn:lower-case("#x212A")</code> is "k".</p>
                                    <p>
                                    This rule applies also to a character range used in a character 
                                    class subtraction (<code>charClassSub</code>): thus [A-Z-[IO]] will match 
                                    characters such as "A", "B", "a", and "b", but will not match 
                                    "I", "O", "i", or "o".</p> 
                                    <p>
                                    The rule also applies to a character range used as part of a 
                                    negative character group: thus [^Q] will match every character 
                                    except "Q" and "q" (these being the only case-variants of "Q" in 
                                    Unicode).</p></item>
                                    <item><p>
                                    A back-reference is compared using case-blind comparison: 
                                    that is, each character must either be the same as the 
                                    corresponding character of the previously matched string, or must 
                                    be a case-variant of that character. For example, the strings 
                                    "Mum", "mom", "Dad", and "DUD" all match the regular
                                    expression "([md])[aeiou]\1" when the "<code>i</code>" flag is used.</p></item>
                                    <item><p>
                                    All other constructs are unaffected by the "<code>i</code>" flag. 
                                    For example, 
                                    "\p{Lu}" continues to match upper-case letters only.</p></item>
                                    </olist>
                            </item>
  <item>
                                <p>
                                    <code>x</code>: If present, whitespace characters 
                                    (#x9, #xA, #xD and #x20) in the regular 
                                    expression are removed prior to matching with one exception:  
                                    whitespace characters within character class expressions 
                                    (<code>charClassExpr</code>) are not removed. This flag can be used, 
                                    for example, to break up long regular expressions into readable lines.</p>

                                    <p> Examples:</p>
                                    <p> <code>fn:matches("helloworld", "hello world", "x")</code> returns <code>true</code></p> 
                                    <p> <code>fn:matches("helloworld", "hello[ ]world", "x")</code> returns <code>false</code></p> 
                                    <p> <code>fn:matches("hello world", "hello\ sworld", "x")</code> returns <code>true</code></p> 
                                    <p> <code>fn:matches("hello world", "hello world", "x")</code> returns <code>false</code></p>
                            </item>
                         </ulist>
                    </div4>
                </div3>
                <div3 id="func-matches">
                    <head>fn:matches</head>
                    <example role="signature">
                        <proto name="matches" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="input" type="xs:string" emptyOk="yes"/>
                            <arg name="pattern" type="xs:string" emptyOk="no"/>
                        </proto>
                        <proto name="matches" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="input" type="xs:string" emptyOk="yes"/>
                            <arg name="pattern" type="xs:string" emptyOk="no"/>
                            <arg name="flags" type="xs:string" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: The function returns <code>true</code> if <code>$input</code>
                        matches the regular expression supplied as <code>$pattern</code> as
                        influenced by the value of <code>$flags</code>, if present; otherwise, it
                        returns <code>false</code>. </p>
                    <p>The effect of calling the first version of this function (omitting the
                        argument <code>$flags</code>) is the same as the effect of calling the
                        second version with the <code>$flags</code> argument set to a zero-length
                        string. Flags are defined in <specref ref="flags"/>.</p>
                    <p>If <code>$input</code> is the empty sequence, it is interpreted as the
                        zero-length string.</p>
                    <p>Unless the metacharacters <code>^</code> and <code>$</code> are used as
                        anchors, the string is considered to match the pattern if any substring
                        matches the pattern. But if anchors are used, the anchors must match the
                        start/end of the string (in string mode), or the start/end of a line (in
                        multiline mode). </p>
                    <note>
                        <p>This is different from the behavior of patterns in <bibref
                            ref="xmlschema-2"/>, where regular expressions are <emph>implicitly</emph> anchored.</p>
                    </note>
                    <p>An error is raised <errorref class="RX" code="0002"/> if the value of
                        <code>$pattern</code> is invalid according to the rules described in section
                            <specref ref="regex-syntax"/>. </p>
                    <p>An error is raised <errorref class="RX" code="0001"/> if the value of
                        <code>$flags</code> is invalid according to the rules described in section
                            <specref ref="regex-syntax"/>. </p>
                    <div4 id="func-matches-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:matches("abracadabra", "bra")</code> returns true</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:matches("abracadabra", "^a.*a$")</code> returns true</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:matches("abracadabra", "^bra")</code> returns false</p>
                            </item>
                        </ulist>
                        <p>Given the source document:</p>
                        <eg><![CDATA[<poem author="Wilhelm Busch"> 
Kaum hat dies der Hahn gesehen,
Fngt er auch schon an zu krhen:
Kikeriki! Kikikerikih!!
Tak, tak, tak! - da kommen sie.
</poem>]]></eg>
                        <p>the following function calls produce the following results, with the
                            <code>poem</code> element as the context node:</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:matches(., "Kaum.*krhen")</code> returns <code>false</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:matches(., "Kaum.*krhen", "s")</code> returns <code>true</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:matches(., "^Kaum.*gesehen,$", "m")</code> returns <code>true</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:matches(., "^Kaum.*gesehen,$")</code> returns <code>false</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:matches(., "kiki", "i")</code> returns <code>true</code>
                                </p>
                            </item>
                        </ulist>
                        <note>
                            <p>Regular expression matching is defined on the basis of Unicode code
                                points; it takes no account of collations.</p>
                        </note>
                    </div4>
                </div3>
                <!-- Mike Kay's regular expression proposal 2002-06-14 -->
                <div3 id="func-replace">
                    <head>fn:replace</head>
                    <example role="signature">
                        <proto name="replace" return-type="xs:string" returnEmptyOk="no">
                            <arg name="input" type="xs:string" emptyOk="yes"/>
                            <arg name="pattern" type="xs:string" emptyOk="no"/>
                            <arg name="replacement" type="xs:string" emptyOk="no"/>
                        </proto>
                        <proto name="replace" return-type="xs:string" returnEmptyOk="no">
                            <arg name="input" type="xs:string" emptyOk="yes"/>
                            <arg name="pattern" type="xs:string" emptyOk="no"/>
                            <arg name="replacement" type="xs:string" emptyOk="no"/>
                            <arg name="flags" type="xs:string" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: The function returns the <code>xs:string</code> that is obtained by
                        replacing each non-overlapping substring of <code>$input</code> that matches
                        the given <code>$pattern</code> with an occurrence of the
                        <code>$replacement</code> string.</p>
                    <p>The effect of calling the first version of this function (omitting the
                        argument <code>$flags</code>) is the same as the effect of calling the
                        second version with the <code>$flags</code> argument set to a zero-length
                        string. Flags are defined in <specref ref="flags"/>.</p>
                    <p>The <code>$flags</code> argument is interpreted in the same manner as for the
                        <code>fn:matches()</code> function. </p>
                    <p>If <code>$input</code> is the empty sequence, it is interpreted as the
                        zero-length string.</p>
                    <p>If two overlapping substrings of <code>$input</code> both match the
                        <code>$pattern</code>, then only the first one (that is, the one whose first
                        character comes first in the <code>$input</code> string) is replaced.</p> 
<p>
Within the <code>$replacement</code> string, a variable <code>$N</code> may be used to refer to the substring captured by the Nth parenthesized sub-expression in the regular expression. For each match of the pattern, these variables are assigned the value of the content matched by the relevant sub-expression, and the modified replacement string is then substituted for the characters in <code>$input</code> that matched the pattern.  <code>$0</code> refers to the substring captured by the regular expression as a whole.</p> 
<p>
More specifically, the rules are as follows, where <code>S</code> is the number of parenthesized sub-expressions in the regular expression, and <code>N</code> is the decimal number formed by taking all the digits that consecutively follow the <code>$</code> character:</p>
<p>
<olist>
<item><p>
If <code>N</code>=<code>0</code>, then the variable is replaced by the substring matched by the regular expression as a whole.</p></item>
<item><p>
If <code>1</code>&lt;=<code>N</code>&lt;=<code>S</code>, then the variable is replaced by the substring captured by the Nth parenthesized sub-expression. If the <code>Nth</code> parenthesized sub-expression was not matched, then the variable is replaced by the zero-length string.
</p></item>
<item><p>
If <code>S</code>&lt;<code>N</code>&lt;=<code>9</code>, then the variable is replaced by the zero-length string.
</p></item>
<item><p>
Otherwise (if <code>N</code>&gt;<code>S</code> and <code>N</code>&gt;<code>9</code>), the last digit of <code>N</code> is taken to be a literal character to be included "as is" in the replacement string, and the rules are reapplied using the number <code>N</code> formed by stripping off this last digit.
</p></item>
</olist></p>
<p>
For example, if the replacement string is <quote><code>$23</code></quote> and there are 5 substrings, the result contains the value of the substring that matches the second sub-expression, followed by the digit <quote><code>3</code></quote>.</p>
<p>A literal <quote><code>$</code></quote> symbol must be written as <quote><code>\$</code></quote>.</p> 
<p>A literal <quote><code>\</code></quote> symbol must be written as <quote><code>\\</code></quote>.</p>
                    <p> If two alternatives within the pattern both match at the same position in
                        the <code>$input</code>, then the match that is chosen is the one matched by
                        the first alternative. For example:</p>
                    <eg> fn:replace("abcd", "(ab)|(a)", "[1=$1][2=$2]") returns "[1=ab][2=]cd"</eg>
                    <p>An error is raised <errorref class="RX" code="0002"/> if the value of
                        <code>$pattern</code> is invalid according to the rules described in section
                            <specref ref="regex-syntax"/>. </p>
                    <p>An error is raised <errorref class="RX" code="0001"/> if the value of
                        <code>$flags</code> is invalid according to the rules described in section
                            <specref ref="regex-syntax"/>. </p>
                    <p>An error is raised <errorref class="RX" code="0003"/> if the pattern matches
                        a zero-length string, that is, if the expression <code>fn:matches("",
                            $pattern, $flags)</code> returns <code>true</code>. It is not an error,
                        however, if a captured substring is zero-length.</p>
                    <p>An error is raised <errorref class="RX" code="0004"/> if the value of
                        <code>$replacement</code> contains a "<code>$</code>" character that is not
                        immediately followed by a digit <code>0-9</code> and not immediately
                        preceded by a "\".</p>
                    <p>An error is raised <errorref class="RX" code="0004"/> if the value of
                        <code>$replacement</code> contains a "<code>\</code>" character that is not
                        part of a "<code>\\</code>" pair, unless it is immediately followed by a
                        "<code>$</code>" character.</p>
                    <div4 id="func-replace-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>replace("abracadabra", "bra", "*")</code> returns <code>"a*cada*"</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>replace("abracadabra", "a.*a", "*")</code> returns <code>"*"</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>replace("abracadabra", "a.*?a", "*")</code> returns <code>"*c*bra"</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>replace("abracadabra", "a", "")</code> returns <code>"brcdbr"</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>replace("abracadabra", "a(.)", "a$1$1")</code> returns <code>"abbraccaddabbra"</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>replace("abracadabra", ".*?", "$1")</code> raises an
                                    error, because the pattern matches the zero-length string </p>
                            </item>
                            <item>
                                <p>
                                    <code>replace("AAAA", "A+", "b")</code> returns <quote>
                                        <code>b</code>
                                    </quote>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>replace("AAAA", "A+?", "b")</code> returns <quote>
                                        <code>bbbb</code>
                                    </quote>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>replace("darted", "^(.*?)d(.*)$", "$1c$2")</code> returns <quote>
                                        <code>carted</code>
                                    </quote>. The first <quote>
                                        <code>d</code>
                                    </quote> is replaced.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <!-- Mike Kay's regular expression proposal 2002-06-14 -->
                <div3 id="func-tokenize">
                    <head>fn:tokenize</head>
                    <example role="signature">
                        <proto name="tokenize" return-type="xs:string*" returnEmptyOk="no">
                            <arg name="input" type="xs:string" emptyOk="yes"/>
                            <arg name="pattern" type="xs:string" emptyOk="no"/>
                        </proto>
                        <proto name="tokenize" return-type="xs:string*" returnEmptyOk="no">
                            <arg name="input" type="xs:string" emptyOk="yes"/>
                            <arg name="pattern" type="xs:string" emptyOk="no"/>
                            <arg name="flags" type="xs:string" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: This function breaks the <code>$input</code> string into a sequence
                        of strings, treating any substring that matches <code>$pattern</code> as a
                        separator. The separators themselves are not returned.</p>
                    <p>The effect of calling the first version of this function (omitting the
                        argument <code>$flags</code>) is the same as the effect of calling the
                        second version with the <code>$flags</code> argument set to a zero-length
                        string. Flags are defined in <specref ref="flags"/>.</p>
                    <p> The <code>$flags</code> argument is interpreted in the same way as for the
                        <code>fn:matches()</code> function.</p>
                    <p>If <code>$input</code> is the empty sequence, or if <code>$input</code> is the zero-length string, the result is the empty sequence.</p>
                    <p>If the supplied <code>$pattern</code> matches a zero-length string, that is,
                        if <code>fn:matches("", $pattern, $flags)</code> returns <code>true</code>,
                        then an error is raised: <errorref class="RX" code="0003"/>. </p>
                    <p>If a separator occurs at the start of the <code>$input</code> string, the
                        result sequence will start with a zero-length string. Zero-length strings
                        will also occur in the result sequence if a separator occurs at the end of
                        the <code>$input</code> string, or if two adjacent substrings match the
                        supplied <code>$pattern</code>.</p>
                    <p> If two alternatives within the supplied <code>$pattern</code> both match at
                        the same position in the <code>$input</code> string, then the match that is
                        chosen is the first. For example:</p>
                    <eg> fn:tokenize("abracadabra", "(ab)|(a)") returns ("", "r", "c", "d", "r", "")</eg>
                    <p> An error is raised <errorref class="RX" code="0002"/> if the value of
                        <code>$pattern</code> is invalid according to the rules described in section
                            <specref ref="regex-syntax"/>.</p>
                    <p> An error is raised <errorref class="RX" code="0001"/> if the value of
                        <code>$flags</code> is invalid according to the rules described in section
                            <specref ref="regex-syntax"/>.</p>
                    <div4 id="func-tokenize-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:tokenize("The cat sat on the mat", "\s+")</code>
                                    returns <code>("The", "cat", "sat", "on", "the", "mat")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:tokenize("1, 15, 24, 50", ",\s*")</code> returns
                                        <code>("1", "15", "24", "50")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:tokenize("1,15,,24,50,", ",")</code> returns
                                        <code>("1", "15", "", "24", "50", "")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:tokenize("abba", ".?")</code> raises the error
                                        <errorref class="RX" code="0003"/>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:tokenize("Some unparsed &lt;br&gt; HTML
                                        &lt;BR&gt; text", "\s*&lt;br&gt;\s*", "i")</code>
                                    returns <code>("Some unparsed", "HTML", "text")</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
        </div1>
        <div1 id='anyURI-functions'>
            <head>Functions on anyURI</head>
            <p>This section specifies functions that take anyURI as arguments.</p>
            <table border="1" summary="Function/operator summary">
                <thead>
                    <tr>
                        <th>Function</th>
                        <th>Meaning</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <code>fn:resolve-uri</code>
                        </td>
                        <td>Returns an <code>xs:anyURI</code> representing an absolute
                            <code>xs:anyURI</code> given a base URI and a relative URI. </td>
                    </tr>
                    <!--	<tr>
							<td>
								<code>op:anyURI-equal</code>
							</td>
							<td>Returns <code>true</code> if the two arguments are equal. </td>
							<td/>
						</tr> -->
                </tbody>
            </table>
            <div2 id="func-resolve-uri">
                <head>fn:resolve-uri</head>
                <example role="signature">
                    <proto name="resolve-uri" return-type="xs:anyURI" returnEmptyOk="yes">
                        <arg name="relative" type="xs:string" emptyOk="yes"/>
                    </proto>
                </example>
                <example role="signature">
                    <proto name="resolve-uri" return-type="xs:anyURI" returnEmptyOk="yes">
                        <arg name="relative" type="xs:string" emptyOk="yes"/>
                        <arg name="base" type="xs:string"/>
                    </proto>
                </example>
<p>Summary: The purpose of this function is to enable a relative URI to be resolved against an absolute URI.</p> 
<p>The first form of
                    this function resolves <code>$relative</code> against the value of the base-uri property from the
                    static context. If the base-uri property is not initialized in the static
                    context an error is raised <errorref class="NS" code="0005"/>. </p>
<p>If <code>$relative</code> is a relative URI
                    reference, it is resolved against <code>$base</code>, or the base-uri property from the
                    static context, using an algorithm such as the ones described in <bibref ref="rfc2396"/> or <bibref ref="rfc3986"/>, and the
                    resulting absolute URI reference is returned. An error may be raised <errorref class="RG" code="0009"/> in the resolution process.</p>
<p>If <code>$relative</code> is an
                    absolute URI reference, it is returned unchanged.</p> 

                
                <p>If <code>$relative</code> or <code>$base</code> is not a valid
                    <code>xs:anyURI</code> an error is raised <errorref class="RG" code="0002"/>.</p>
                <p>If <code>$relative</code> is the empty sequence, the empty sequence is returned.</p>
                <note>
<!--
                    <p>If <code>$relative</code> is the zero-length string, returns the value of the
                        base-uri property from the static context in the first form (if the base-uri
                        property is not initialized in the static context an error is raised
                            <errorref class="NS" code="0005"/>) and <code>$base</code> in the second form.</p> -->
                
               
                    <p>Resolving a URI does not dereference it. This is merely a syntactic operation
                        on two character strings.</p>
                </note>
            </div2>

<!-- THIS FUNCTION REMOVED.  URI's can now be compared using fn:compare 							
<div2 id="func-anyURI-equal">
					<head>op:anyURI-equal</head>
					<example role="signature">
						<proto name="anyURI-equal" return-type="xs:boolean" isOp="yes">
							<arg name="arg1" type="xs:anyURI"/>
							<arg name="arg2" type="xs:anyURI"/>
						</proto>
					</example>
					<p>Summary: Returns <code>true</code> if <code>$arg1</code> and <code>$arg2</code> compare equal based on the default collation in the static context.  Otherwise, returns <code>false</code>. This function backs up the "eq" and "ne" operators on anyURI. </p>
<p>For more details on comparing URIs see <bibref ref='RFC3986'/>.</p>
					<div3 id="func-anyURI-equals-examples">>
						<head>Examples</head>
						<ulist>
							<item>
								<p>
									<code>op:anyURI-equal(xs:anyURI("http://www.example.com/spinaltap.micro.umn.edu/00/Weather/California/Los%20Angeles"), xs:anyURI("http://www.example.com/spinaltap.micro.umn.edu"))</code> returns <code>false</code>
								</p>
							</item>
						</ulist>
					</div3>
			</div2> -->
        </div1>
        <div1 id='boolean-functions'>
            <head>Functions and Operators on Boolean Values</head>
            <p>This section defines functions and operators on the <bibref ref="xmlschema-2"/> boolean datatype.</p>
            <div2 id='boolean-constructors'>
                <head>Additional Boolean Constructor Functions</head>
                <p>The following additional constructor functions are defined on the boolean type. </p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:true</code>
                            </td>
                            <td>Constructs the xs:boolean value 'true'.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:false</code>
                            </td>
                            <td>Constructs the xs:boolean value 'false'.</td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-true">
                    <head>fn:true</head>
                    <example role="signature">
                        <proto name="true" return-type="xs:boolean"/>
                    </example>
                    <p>Summary: Returns the <code>xs:boolean</code> value <code>true</code>.
                        Equivalent to <code>xs:boolean("1")</code>.</p>
                    <div4 id='func-true-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:true()</code> returns <code>true</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-false">
                    <head>fn:false</head>
                    <example role="signature">
                        <proto name="false" return-type="xs:boolean"/>
                    </example>
                    <p>Summary: Returns the <code>xs:boolean</code> value <code>false</code>.
                        Equivalent to <code>xs:boolean("0")</code>.</p>
                    <div4 id="func-false-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:false()</code> returns <code>false</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id='op.boolean'>
                <head>Operators on Boolean Values</head>
                <p>The following functions define the semantics of operators on boolean values in
                        <bibref ref="xquery"/> and <bibref ref="xpath20"/>:</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Operator</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>op:boolean-equal</code>
                            </td>
                            <td>Equality of <code>xs:boolean</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:boolean-less-than</code>
                            </td>
                            <td>A less-than operator on <code>xs:boolean</code> values:
                                <code>false</code> is less than <code>true</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:boolean-greater-than</code>
                            </td>
                            <td>A greater-than operator on <code>xs:boolean</code> values:
                                <code>true</code> is greater than <code>false</code>.</td>
                        </tr>
                    </tbody>
                </table>
                <p>The ordering operators <code>op:boolean-less-than</code>
                    and <code>op:boolean-greater-than</code> are provided for application purposes
                    and for compatibility with <bibref ref="xpath"/>. The <bibref ref="xmlschema-2"/>
                    datatype <code>xs:boolean</code> is not ordered.</p>
                <div3 id="func-boolean-equal">
                    <head>op:boolean-equal</head>
                    <example role="signature">
                        <proto name="boolean-equal" return-type="xs:boolean" isOp="yes" returnEmptyOk="no">
                            <arg name="value1" type="xs:boolean" emptyOk="no"/>
                            <arg name="value2" type="xs:boolean" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if both arguments are <code>true</code> or
                        if both arguments are <code>false</code>. Returns <code>false</code> if one
                        of the arguments is <code>true</code> and the other argument is
                        <code>false</code>. </p>
                    <p>This function backs up the "eq" operator on <code>xs:boolean</code> values. </p>
                </div3>
                <div3 id="func-boolean-less-than">
                    <head>op:boolean-less-than</head>
                    <example role="signature">
                        <proto name="boolean-less-than" return-type="xs:boolean" isOp="yes">
                            <arg name="arg1" type="xs:boolean" emptyOk="no"/>
                            <arg name="arg2" type="xs:boolean" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if <code>$arg1</code> is
                        <code>false</code> and <code>$arg2</code> is <code>true</code>. Otherwise,
                        returns <code>false</code>.</p>
                    <p>This function backs up the "lt" and "ge" operators on <code>xs:boolean</code>
                        values. </p>
                </div3>
                <div3 id="func-boolean-greater-than">
                    <head>op:boolean-greater-than</head>
                    <example role="signature">
                        <proto name="boolean-greater-than" return-type="xs:boolean" isOp="yes">
                            <arg name="arg1" type="xs:boolean" emptyOk="no"/>
                            <arg name="arg2" type="xs:boolean" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if <code>$arg1</code> is <code>true</code>
                        and <code>$arg2</code> is <code>false</code>. Otherwise, returns <code>false</code>.</p>
                    <p>This function backs up the "gt" and "le" operators on <code>xs:boolean</code>
                        values. </p>
                </div3>
            </div2>
            <div2 id='boolean-value-functions'>
                <head>Functions on Boolean Values</head>
                <p>The following functions are defined on boolean values:</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:not</code>
                            </td>
                            <td>Inverts the <code>xs:boolean</code> value of the argument.</td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-not">
                    <head>fn:not</head>
                    <example role="signature">
                        <proto name="not" return-type="xs:boolean">
                            <arg name="arg" type="item()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: <code>$arg</code> is first reduced to an effective boolean value by
                        applying the <code>fn:boolean()</code> function. Returns <code>true</code>
                        if the effective boolean value is <code>false</code>, and <code>false</code>
                        if the effective boolean value is <code>true</code>. </p>
                    <div4 id="func-not-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:not(fn:true())</code> returns <code>false</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:not("false")</code> returns <code>false</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
        </div1>
        <div1 id="durations-dates-times">
            <head>Functions and Operators on Durations, Dates and Times</head>
            <p>This section discusses operations on the <bibref ref="xmlschema-2"/> date and time types.
                It also discusses operations on two subtypes of <code>xs:duration</code> that are
                defined in <xspecref
                    spec="DM" ref="types"/>. See <specref ref="duration-subtypes"/>.</p>
<p>
See <bibref ref='Working-With-Timezones'/> for a disquisition on working with date and time values with and without timezones.
</p>
  <!--          <p>The functions described in this section follow the principle of locale-independent
                storage for these datatypes that originated with <bibref ref="xmlschema-2"/>. Thus, a
                single calendar (Gregorian) and a single timezone (UTC) is chosen to represent
                normalized date and time values. Since the value tuple (See <xspecref spec="DM"
                ref="dates-and-times"/>) also contains the timezone specified in the lexical
                representation, applications and other processing systems are free to present this
                information in locale-specific representations.</p> -->
           
            <div2 id="duration-date-time-types">
                <head>Duration, Date and Time Types</head>
                <p>The operators described in this section are defined on the following date and
                    time types: </p>
                <ulist>
                    <item>
                        <p>xs:dateTime</p>
                    </item>
                    <item>
                        <p>xs:date</p>
                    </item>
                    <item>
                        <p>xs:time</p>
                    </item>
                    <item>
                        <p>xs:gYearMonth</p>
                    </item>
                    <item>
                        <p>xs:gYear</p>
                    </item>
                    <item>
                        <p>xs:gMonthDay</p>
                    </item>
                    <item>
                        <p>xs:gMonth</p>
                    </item>
                    <item>
                        <p>xs:gDay</p>
                    </item>
                </ulist>
                <p>Note that only equality is defined on					
                    <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
                    <code>xs:gMonthDay</code>, <code>xs:gMonth</code> and <code>xs:gDay</code> values.</p>
                <p>In addition, operators are defined on:</p>
                    <ulist>
                    <item>
                        <p>xs:duration</p>
                    </item>
                    </ulist>
<p>and on the <specref ref="duration-subtypes"/>:</p>
                <ulist>
                    <item>
                        <p>xs:yearMonthDuration</p>
                    </item>
                    <item>
                        <p>xs:dayTimeDuration</p>
                    </item>
                </ulist>
<p>Note that no ordering relation is defined on <code>xs:duration</code> values.Two <code>xs:duration</code> values may however be compared for equality. Operations on durations (including equality comparison, casting to string, and extraction of components) all treat the duration as normalized. This means that the seconds and minutes components will always be less than 60, the hours component less than 24, and the months component less than 12.  Thus, for example, a duration of 120 seconds always gives the same result as a duration of two minutes.</p>
                <div3 id="date-time-duration-conformance">
                    <head>Limits and Precision</head>
                    <p>For a number of the above datatypes <bibref ref="xmlschema-2"/> extends the basic
                            <bibref ref="ISO8601"/> lexical representations, such as
                        YYYY-MM-DDThh:mm:ss.s for dateTime, by allowing a preceding minus sign, more
                        than four digits to represent the year field &mdash; no maximum is
                        specified &mdash; and an unlimited number of digits for fractional
                        seconds. Leap seconds are not supported.</p>
                    <p>All <emph>minimally conforming</emph> processors
                        <termref def='must'/>  support positive year values with a minimum of 4 digits (i.e.,
                        YYYY) and a minimum fractional second precision of 1 millisecond or three
                        digits (i.e., s.sss). However, <emph>conforming</emph> processors
                        <termref def='may'/>  set larger <termref def="implementation-defined"/> limits
                        on the maximum number of digits they support in these two situations.  Processors <termref def="may"/> also choose to support the year 0000 and 
                        years with negative values.  The results of operations on dates that cross the year 
                        0000 are <termref def="implementation-defined"/>.</p>
                    <p>A processor that limits the number of digits in date and time datatype
                        representations may encounter overflow and underflow conditions when it
                        tries to execute the functions in <specref ref="dateTime-arithmetic"/>. In
                        these situations, the processor <termref def="must"/> return P0M or PT0S in
                        case of duration underflow and 00:00:00 in case of time underflow.
                            It <termref def="must"/> raise an error <errorref class="DT"
                        code="0001"/> in case of overflow.</p>
                    <p>The value spaces of the two totally ordered subtypes of
                        <code>xs:duration</code> described in <specref ref="duration-subtypes"/> are
                        <code>xs:integer</code> months for <code>xs:yearMonthDuration</code>
                        and <code>xs:decimal</code> seconds for <code>xs:dayTimeDuration</code>. If
                        a processor limits the number of digits allowed in the representation of
                        <code>xs:integer</code> and <code>xs:decimal</code> then overflow and
                        underflow situations can arise when it tries to execute the functions in
                            <specref ref="duration-arithmetic"/>. In these situations the processor
                            <termref def="must"/> return zero in case of numeric underflow and P0M
                        or PT0S in case of duration underflow. It <termref def="must"/> raise an
                        error <errorref class="DT" code="0002"/> in case of overflow.</p>
                </div3>
            </div2>
 <div2 id="date-time-values">
                <head>Date/time datatype values</head>
<p>As defined in <xspecref spec="DM" ref="dates-and-times"/>, <code>xs:dateTime</code>, <code>xs:date</code>, <code>xs:time</code>,  <code>xs:gYearMonth</code>, <code>xs:gYear</code>, <code>xs:gMonthDay</code>, <code>xs:gMonth</code>, <code>xs:gDay</code> values, referred to collectively as date/time values, are represented as seven components or properties: <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code> and <code>timezone</code>.  The value of the first five components are <code>xs:integer</code>s.  The value of the <code>second</code> component is an <code>xs:decimal</code> and the value of the <code>timezone</code> component is an <code>xs:dayTimeDuration</code>.  For all the date/time datatypes, the <code>timezone</code> property is optional and may or may not be present. Depending on the datatype, some of the remaining six properties must be present and some must be absent.   Absent, or missing, properties are represented by the empty sequence.  This value is referred to as the <emph>local</emph> value in that the value is in the given timezone.  Before comparing or subtracting <code>xs:dateTime</code> values, this local value <termref def='must'/>  be translated or <emph>normalized</emph> to UTC.
</p>
<p>For <code>xs:time</code>, <code>"00:00:00"</code> and <code>"24:00:00"</code> are alternate lexical forms for the same value, whose canonical representation is <code>"00:00:00"</code>.  For <code>xs:dateTime</code>,
a time component <code>"24:00:00"</code> translates to <code>"00:00:00"</code> of the following day.</p>
                <div3 id='date-time-lexical-mapping'>
                    <head>Examples</head>
                    <ulist>
                        <item>
                            <p>An <code>xs:dateTime</code> with lexical
                                representation <code>1999-05-31T05:00:00</code>                                 is represented in the datamodel by <code>{1999, 5, 31, 5, 0, 0.0, ()}</code>.</p>
                        </item>
                        <item>
                            <p>An <code>xs:dateTime</code> with lexical
                                representation <code>1999-05-31T13:20:00-05:00</code> is represented by <code>{1999, 5, 31, 13, 20, 0.0, -PT5H}</code>.</p>
                        </item>
                        <item>
                            <p>An <code>xs:dateTime</code> with lexical
                                representation <code>1999-12-31T24:00:00</code> is represented by <code>{2000, 1, 1, 0, 0, 0.0, ()}</code>.</p>
                        </item>
 						<item>
                            <p>An <code>xs:date</code> with lexical
                                representation <code>2005-02-28+8:00</code> is represented by <code>{2005, 2, 28, (), (), (), PT8H}</code>.</p>
                        </item>
						<item>
                            <p>An <code>xs:time</code> with lexical
                                representation <code>24:00:00</code> is represented by <code>{(), (), (), 0, 0, 0, ()}</code>.</p>
                        </item>
                    </ulist>
                </div3>
            </div2>
            <div2 id="duration-subtypes">
                <head>Two Totally Ordered Subtypes of Duration</head>
                <p>Two totally ordered subtypes of <code>xs:duration</code> are defined in <xspecref
                    spec="DM" ref="types"/>
                    specification using the mechanisms described in <bibref ref="xmlschema-2"/> for
                    defining user-defined types. Additional details about these types is given below.</p>
              
                <div3 id="dt-yearMonthDuration">
                    <head>xs:yearMonthDuration</head>
                    <p> [Definition] <code>xs:yearMonthDuration</code> is derived from
                        <code>xs:duration</code> by restricting its lexical representation to
                        contain only the year and month components. The value space of
                        <code>xs:yearMonthDuration</code> is the set of <code>xs:integer</code>
                        month values. The year and month components of
                        <code>xs:yearMonthDuration</code> correspond to the Gregorian year and
                        month components defined in section 5.5.3.2 of <bibref ref="ISO8601"/>, respectively.</p>
                   <div4 id="lexical-yearMonthDuration">
                        <head>Lexical representation</head>
                        <p>The lexical representation for <code>xs:yearMonthDuration</code> is the
                                <bibref ref="ISO8601"/> reduced format PnYnM, where nY represents
                            the number of years and nM the number of months. The values of the years
                            and months components are not restricted but allow an arbitrary unsigned <code>xs:integer</code>.</p>
                        <p>An optional preceding minus sign ('-') is allowed to indicate a negative
                            duration. If the sign is omitted a positive duration is indicated. To
                            indicate a <code>xs:yearMonthDuration</code> of 1 year, 2 months, one
                            would write: P1Y2M. One could also indicate a
                            <code>xs:yearMonthDuration</code> of minus 13 months as: -P13M. </p>
                        <p>Reduced precision and truncated representations of this format are
                            allowed provided they conform to the following: </p>
                        <p>If the number of years or months in any expression equals zero (0), the
                            number and its corresponding designator <termref def="may"/> be omitted.
                            However, at least one number and its designator <termref def="must"/> be
                            present. For example, P1347Y and P1347M are allowed; P-1347M is not
                            allowed, although -P1347M is allowed. P1Y2MT is not allowed. Also, P24YM
                            is not allowed, nor is PY43M since Y must have at least one preceding
                            digit and M must have one preceding digit.</p>
                    </div4>
                    <div4 id="calculating-value-yearMonthDuration">
                        <head>Calculating the value from the lexical representation</head>
                        <p>The value of a <code>xs:yearMonthDuration</code> lexical form is
                            obtained by multiplying the value of the years component by 12 and
                            adding the value of the months component. The value is positive or
                            negative depending on the preceding sign.</p>
                    </div4>
                    <div4 id="canonical-yearMonthDuration">
                        <head>Canonical representation</head>
                        <p>The canonical representation of <code>xs:yearMonthDuration</code>
                            restricts the value of the months component to <code>xs:integer</code>
                            values between 0 and 11, both inclusive. To convert from a non-canonical
                            representation to the canonical representation, the lexical
                            representation is first converted to a value in <code>xs:integer</code>
                            months as defined above. This value is then divided by 12 to obtain the
                            value of the years component of the canonical representation. The
                            remaining number of months is the value of the months component of the
                            canonical representation. For negative durations, the canonical form is
                            calculated using the absolute value of the duration and a negative sign
                            is prepended to it. If a component has the value zero (0), then the
                            number and the designator for that component <termref def="must"/> be
                            omitted. However, if the value is zero (0) months, the canonical form is "P0M".</p>
                    </div4>
                    <div4 id="order-yearMonthDuration">
                        <head>Order relation on xs:yearMonthDuration</head>
                        <p>Let the function that calculates the value of an
                            <code>xs:yearMonthDuration</code> in the manner described above be
                            called V(d). Then for two <code>xs:yearMonthDuration</code> values x
                            and y, x &gt; y if and only if V(x) &gt; V(y). The order relation on
                            <code>yearMonthDuration</code> is a total order.</p>
                    </div4>
                </div3>
                <div3 id="dt-dayTimeDuration">
                    <head>xs:dayTimeDuration</head>
                    <p>[Definition] <code>xs:dayTimeDuration</code> is derived from
                        <code>xs:duration</code> by restricting its lexical representation to
                        contain only the days, hours, minutes and seconds components. The value
                        space of <code>xs:dayTimeDuration</code> is the set of fractional second
                        values. The components of <code>xs:dayTimeDuration</code> correspond to the
                        day, hour, minute and second components defined in Section 5.5.3.2 of
                            <bibref ref="ISO8601"/>, respectively.</p> 
                    <div4 id="lexical-dayTimeDuration">
                        <head>Lexical representation</head>
                        <p>The lexical representation for <code>xs:dayTimeDuration</code> is the
                                <bibref ref="ISO8601"/> truncated format PnDTnHnMnS, where nD
                            represents the number of days, T is the date/time separator, nH the
                            number of hours, nM the number of minutes and nS the number of seconds.</p>
                        <p>The values of the days, hours and minutes components are not restricted,
                            but allow an arbitrary unsigned <code>xs:integer</code>. Similarly, the
                            value of the seconds component allows an arbitrary unsigned
                            <code>xs:decimal</code>. An optional minus sign ('-') is allowed to
                            precede the 'P', indicating a negative duration. If the sign is omitted,
                            the duration is positive. See also <bibref ref="ISO8601"/> Date and Time Formats.</p>
                        <p>For example, to indicate a duration of 3 days, 10 hours and 30 minutes,
                            one would write: P3DT10H30M. One could also indicate a duration of minus
                            120 days as: -P120D. Reduced precision and truncated representations of
                            this format are allowed, provided they conform to the following:</p>
                        <ulist>
                            <item>
                                <p>If the number of days, hours, minutes, or seconds in any
                                    expression equals zero (0), the number and its corresponding
                                    designator <termref def="may"/> be omitted. However, at least
                                    one number and its designator <termref def="must"/> be present.</p>
                            </item>
                            <item>
                                <p>The seconds part <termref def="may"/> have a decimal fraction.</p>
                            </item>
                            <item>
                                <p>The designator 'T' <termref def="must"/> be absent if and only if
                                    all of the time items are absent. The designator 'P' <termref
                                    def="must"/> always be present.</p>
                            </item>
                        </ulist>
                        <p>For example, P13D, PT47H, P3DT2H, -PT35.89S and P4DT251M are all allowed.
                            P-134D is not allowed (invalid location of minus sign), although -P134D
                            is allowed. </p>
                    </div4>
                    <div4 id="calculating-value-dayTimeDuration">
                        <head>Calculating the value of a xs:dayTimeDuration from the lexical representation</head>
                        <p>The value of a <code>xs:dayTimeDuration</code> lexical form in
                            fractional seconds is obtained by converting the days, hours, minutes
                            and seconds value to fractional seconds using the conversion rules: 24
                            hours = 1 day, 60 minutes = 1 hour and 60 seconds = 1 minute.</p>
                    </div4>
                    <div4 id="canonical-dayTimeDuration">
                        <head>Canonical representation</head>
                        <p>The canonical representation of <code>xs:dayTimeDuration</code>
                            restricts the value of the hours component to <code>xs:integer</code>
                            values between 0 and 23, both inclusive; the value of the minutes
                            component to <code>xs:integer</code> values between 0 and 59; both
                            inclusive; and the value of the seconds component to
                            <code>xs:decimal</code> valued from 0.0 to 59.999... (see <bibref
                            ref="xmlschema-2"/>, Appendix D).</p>
                        <p>To convert from a non-canonical representation to the canonical
                            representation, the value of the lexical form in fractional seconds is
                            first calculated in the manner described above. The value of the days
                            component in the canonical form is then calculated by dividing the value
                            by 86,400 (24*60*60). The remainder is in fractional seconds. The value
                            of the hours component in the canonical form is calculated by dividing
                            this remainder by 3,600 (60*60). The remainder is again in fractional
                            seconds. The value of the minutes component in the canonical form is
                            calculated by dividing this remainder by 60. The remainder in fractional
                            seconds is the value of the seconds component in the canonical form. For
                            negative durations, the canonical form is calculated using the absolute
                            value of the duration and a negative sign is prepended to it. If a
                            component has the value zero (0) then the number and the designator for
                            that component must be omitted. However, if all the components of the
                            lexical form are zero (0), the canonical form is <quote>PT0S</quote>.</p>
                    </div4>
                    <div4 id="order-dayTimeDuration">
                        <head>Order relation on xs:dayTimeDuration</head>
                        <p>Let the function that calculates the value of a
                            <code>xs:dayTimeDuration</code> in the manner described above be called
                            <emph>V(d)</emph>. Then for two <code>xs:dayTimeDuration</code> values
                            <emph>x</emph> and <emph>y, x &gt; y</emph> if and only if <emph>V(x)
                                &gt; V(y)</emph>. The order relation on
                            <code>xs:dayTimeDuration</code> is a total order. </p>
                    </div4>
                </div3>
            </div2>
            <div2 id="comp.duration.datetime">
                <head>Comparison Operators on Duration, Date and Time Values</head>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Operator</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
              
                        <tr>
                            <td>
                                <code>op:yearMonthDuration-less-than</code>
                            </td>
                            <td>Less-than comparison on <code>xs:yearMonthDuration</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:yearMonthDuration-greater-than</code>
                            </td>
                            <td>Greater-than comparison on <code>xs:yearMonthDuration</code> values</td>
                        </tr>
                        
                        <tr>
                            <td>
                                <code>op:dayTimeDuration-less-than</code>
                            </td>
                            <td>Less-than comparison on <code>xs:dayTimeDuration</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:dayTimeDuration-greater-than</code>
                            </td>
                            <td>Greater-than comparison on <code>xs:dayTimeDuration</code> values</td>
                        </tr>
						<tr>
                            <td>
                                <code>op:duration-equal</code>
                            </td>
                            <td>Equality comparison on <code>xs:duration</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:dateTime-equal</code>
                            </td>
                            <td>Equality comparison on <code>xs:dateTime</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:dateTime-less-than</code>
                            </td>
                            <td>Less-than comparison on <code>xs:dateTime</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:dateTime-greater-than</code>
                            </td>
                            <td>Greater-than comparison on <code>xs:dateTime</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:date-equal</code>
                            </td>
                            <td>Equality comparison on <code>xs:date</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:date-less-than</code>
                            </td>
                            <td>Less-than comparison on <code>xs:date</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:date-greater-than</code>
                            </td>
                            <td>Greater-than comparison on <code>xs:date</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:time-equal</code>
                            </td>
                            <td>Equality comparison on <code>xs:time</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:time-less-than</code>
                            </td>
                            <td>Less-than comparison on <code>xs:time</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:time-greater-than</code>
                            </td>
                            <td>Greater-than comparison on <code>xs:time</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:gYearMonth-equal</code>
                            </td>
                            <td>Equality comparison on <code>xs:gYearMonth</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:gYear-equal</code>
                            </td>
                            <td>Equality comparison on <code>xs:gYear</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:gMonthDay-equal</code>
                            </td>
                            <td>Equality comparison on <code>xs:gMonthDay</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:gMonth-equal</code>
                            </td>
                            <td>Equality comparison on <code>xs:gMonth</code> values</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:gDay-equal</code>
                            </td>
                            <td>Equality comparison on <code>xs:gDay</code> values</td>
                        </tr>
                    </tbody>
                </table>
                <p>The following comparison operators are defined on the <bibref ref="xmlschema-2"/>
                    date, time and duration datatypes. Each operator takes two operands of the same
                    type and returns an <code>xs:boolean</code> result. As discussed in <bibref ref="xmlschema-2"/>, the
                    order relation on <code>xs:duration</code> is
                    not a total order but, rather, a partial order. For this reason, only equality is defined on <code>xs:duration</code>. A full complement of comparison and
                    arithmetic functions are defined on the two subtypes of duration described in
                        <specref ref="duration-subtypes"/> which do have a total order.</p>
                <p><bibref ref="xmlschema-2"/> also states that the
                    order relation on date and time datatypes is
                    not a total order but a partial order because these
datatypes may or may not have a timezone.  This is handled as follows.
If either operand to a comparison function on date or time values does not have
                    an (explicit) timezone then, for the purpose of the operation, an implicit
                    timezone, provided by the dynamic context <xspecref spec="XP"
                        ref="id-xp-evaluation-context-components"/>, is assumed to be present as part of
                    the value. This creates a total order for all date and time values.</p>
<!--                <p>Note that for <code>xs:dateTime</code>, <code>xs:date</code> and
                    <code>xs:time</code>, as discussed in <specref ref="date-time-values"/> the
                    value is defined as a tuple. Comparison operators on these three datatypes
                    operate on the first, or normalized value, part of the tuple and disregard the
                    second, or timezone, part of the tuple. If the timezone part is (), the implicit
                    timezone is used to adjust the normalized value as necessary.</p> -->

<p>An <code>xs:dateTime</code> can be considered to consist of seven components:
<code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code> and <code>timezone</code>.  For <code>xs:dateTime</code> six components: <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code> and <code>second</code> are required  and  <code>timezone</code> is optional.   For other date/time values, of the first six components, some are required and others must be absent or missing.  <code>Timezone</code> is always optional.  For example, for <code>xs:date</code>, the <code>year</code>, <code>month</code> and <code>day</code> components are required and <code>hour</code>, <code>minute</code> and <code>second</code> components must be absent;  for <code>xs:time</code> the <code>hour</code>, <code>minute</code> and <code>second</code> components are required and <code>year</code>, <code>month</code> and <code>day</code> are missing;  for <code>xs:gDay</code>, <code>day</code> is required and <code>year</code>, <code>month</code>, <code>hour</code>, <code>minute</code> and <code>second</code> are missing.</p>

<p>Values of the date/time datatypes <code>xs:time</code>, <code>xs:gMonthDay</code>, <code>xs:gMonth</code>, and <code>xs:gDay</code>, can be considered to represent a sequence of recurring time instants or time periods.  An <code>xs:time</code> occurs every day.  An <code>xs:gMonth</code> occurs every year.  Comparison operators on these datatypes compare the starting instants of equivalent occurrences in the recurring series.  These <code>xs:dateTime</code> values are calculated  as described below.</p>

<p>Comparison operators on <code>xs:date</code>, <code>xs:gYearMonth</code> and <code>xs:gYear</code> compare their starting instants. These <code>xs:dateTime</code> values are calculated  as described below.</p>

<p>The starting instant of an occurrence of a date/time value is an <code>xs:dateTime</code> calculated by filling in the missing components of the local value from a reference <code>xs:dateTime</code>.  If the value filled in for a missing day component exceeds the maximum day value for the month, the last day of the month is used. Suppose, for example, that the reference <code>xs:dateTime</code> is <code>1972-12-31T00:00:00</code> and the <code>xs:date</code> value to be compared is <code>1993-03-31</code>.  Filling in the time components from the reference <code>xs:dateTime</code> we get <code>1993-03-31T00:00:00</code> which is the starting instant of that day.  Similarly, if the <code>xs:time</code> value <code>12:30:00</code> is to be compared, we fill in the missing components from the reference <code>xs:dateTime</code> and we get <code>1972-12-31T12:30:00</code> which is the time on that day.  For an <code>xs:gYearMonth</code> value of <code>1976-02</code> we fill in the missing components, adjust for the last day in the month and get <code>1976-02-29T00:00:00</code>.</p>
<p>If the <code>xs:time</code> value written as
<code>24:00:00</code> is to be compared, filling in the missing components gives <code>1972-12-31T00:00:00</code>, because <code>24:00:00</code> is an alternative representation of <code>00:00:00</code> (the lexical value <code>"24:00:00"</code> is
converted to the time components {0,0,0} before the missing components are filled
in). This has the consequence that when ordering <code>xs:time</code> values, 
<code>24:00:00</code> is
considered to be earlier than <code>23:59:59</code>. However, when ordering 
<code>xs:dateTime</code>
values, a time component of <code>24:00:00</code> is considered equivalent to <code>00:00:00</code> on the
following day.</p>

<p>Note that the reference <code>xs:dateTime</code> does not have a timezone.  The <code>timezone</code> component is never filled in from the reference <code>xs:dateTime</code>.  In some cases, if the date/time value does not have a timezone, the implicit timezone from the dynamic context is used as the timezone.</p>

<note><p>This proposal uses the reference <code>xs:dateTime 1972-12-31T00:00:00</code> in the description of the comparison operators.  Implementations are allowed to use other reference <code>xs:dateTime</code> values as long as they yield the same results.  The reference <code>xs:dateTime</code> used must meet the following constraints:  when it is used to supply components into <code>xs:gMonthDay</code> values, the year must allow for February 29 and so must be a leap year; when it is used to supply  missing components into <code>xs:gDay</code> values, the month must allow for 31 days.  Different reference <code>xs:dateTime</code> values may be used for different operators.</p></note>

<!--              <div3 id="func-yearMonthDuration-equal">
                    <head>op:yearMonthDuration-equal</head>
                    <example role="signature">
                        <proto name="yearMonthDuration-equal" return-type="xs:boolean"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:yearMonthDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:yearMonthDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if <code>$arg1</code> is equal
                        to <code>$arg2</code>. Returns <code>false</code> otherwise.</p>
                    <p>This function backs up the "eq", "ne", "le" and "ge" operators on
                        <code>xs:yearMonthDuration</code> values.</p>
                </div3> -->
                <div3 id="func-yearMonthDuration-less-than">
                    <head>op:yearMonthDuration-less-than</head>
                    <example role="signature">
                        <proto name="yearMonthDuration-less-than" return-type="xs:boolean"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:yearMonthDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:yearMonthDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if <code>$arg1</code> is less
                        than <code>$arg2</code>. Returns <code>false</code> otherwise.</p>
                    <p>This function backs up the "lt" and "le" operators on
                        <code>xs:yearMonthDuration</code> values.</p>
                </div3>
                <div3 id="func-yearMonthDuration-greater-than">
                    <head>op:yearMonthDuration-greater-than</head>
                    <example role="signature">
                        <proto name="yearMonthDuration-greater-than" return-type="xs:boolean"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:yearMonthDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:yearMonthDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if <code>$arg1</code> is
                        greater than <code>$arg2</code>. Returns <code>false</code> otherwise.</p>
                    <p>This function backs up the "gt" and "ge" operators on
                        <code>xs:yearMonthDuration</code> values.</p>
                </div3>
 <!--               <div3 id="func-dayTimeDuration-equal">
                    <head>op:dayTimeDuration-equal</head>
                    <example role="signature">
                        <proto name="dayTimeDuration-equal" return-type="xs:boolean"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dayTimeDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if the value of
                        <code>$arg1</code> is equal to the value of <code>$arg2</code>. Returns
                        <code>false</code> otherwise.</p>
                    <p>This function backs up the "eq", "ne", "le" and "ge" operators on
                        <code>xs:dayTimeDuration</code> values.</p>
                </div3> -->
                <div3 id="func-dayTimeDuration-less-than">
                    <head>op:dayTimeDuration-less-than</head>
                    <example role="signature">
                        <proto name="dayTimeDuration-less-than" return-type="xs:boolean"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dayTimeDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if <code>$arg1</code> is less
                        than <code>$arg2</code>. Returns <code>false</code> otherwise.</p>
                    <p>This function backs up the "lt" and "le" operators on
                        <code>xs:dayTimeDuration</code> values.</p>
                </div3>
                <div3 id="func-dayTimeDuration-greater-than">
                    <head>op:dayTimeDuration-greater-than</head>
                    <example role="signature">
                        <proto name="dayTimeDuration-greater-than" return-type="xs:boolean"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dayTimeDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if <code>$arg1</code> is
                        greater than <code>$arg2</code>. Returns <code>false</code> otherwise.</p>
                    <p>This function backs up the "gt" and "ge" operators on
                        <code>xs:dayTimeDuration</code> values.</p>
                </div3>
                <div3 id="func-duration-equal">
                    <head>op:duration-equal</head>
                    <example role="signature">
                        <proto name="duration-equal" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:duration" emptyOk="no"/>
                            <arg name="arg2" type="xs:duration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: 
                        Returns <code>true</code> if and only if the
<code>xs:yearMonthDuration</code> and the <code>xs:dayTimeDuration</code> 
components of <code>$arg1</code> and <code>$arg2</code> compare equal respectively.
                        Returns <code>false</code> otherwise.
</p>
                    <p>This function backs up the "eq" and "ne" operators on
                        <code>xs:duration</code> values.</p>
<p>Note that this function, like any other, may be applied to arguments that are derived from the types given in the function signature, including the two subtypes <code>xs:dayTimeDuration</code> and <code>xs:yearMonthDuration</code>. With the exception of the zero-length duration, no instance of <code>xs:dayTimeDuration</code> can ever be equal to an instance of <code>xs:yearMonthDuration</code>.</p>

<p>The semantics of this function are:</p>
<eg>
<![CDATA[xs:yearMonthDuration($arg1) div xs:yearMonthDuration('P1M')  eq
xs:yearMonthDuration($arg2) div xs:yearMonthDuration('P1M')
    and
xs:dayTimeDuration($arg1) div xs:dayTimeDuration('PT1S')  eq
xs:dayTimeDuration($arg2) div xs:dayTimeDuration('PT1S')
]]></eg>
<p>that is, the function returns <code>true</code> if the months and seconds values of the two durations are equal.</p>
                    <div4 id="func-duration-equal-examples">
                        <head>Examples</head>
						<ulist>
	
							<item><p>
<code>op:duration-equal(xs:duration("P1Y"), xs:duration("P12M"))</code> returns <code>true</code>.
							</p></item>
							<item><p>
<code>op:duration-equal(xs:duration("PT24H"), xs:duration("P1D"))</code> returns <code>true</code>.
							</p></item>
							<item><p>
<code>op:duration-equal(xs:duration("P1Y"), xs:duration("P365D"))</code> returns <code>false</code>. 
						
							</p></item>
<item><p>
<code>op:duration-equal(xs:yearMonthDuration("P0Y"), xs:dayTimeDuration("PT0D"))</code> returns <code>true</code>.
							</p></item>
	<item><p>
<code>op:duration-equal(xs:yearMonthDuration("P1Y"), xs:dayTimeDuration("PT365D"))</code> returns <code>false</code>.
							</p></item>
<item><p>
<code>op:duration-equal(xs:yearMonthDuration("P2Y"), xs:yearMonthDuration("P24M"))</code> returns <code>true</code>.
							</p></item>
	<item><p>
<code>op:duration-equal(xs:dayTimeDuration("PT10D"), xs:dayTimeDuration("PT240H"))</code> returns <code>true</code>.
							</p></item>
<item><p>
<code>op:duration-equal(xs:duration("P2Y0M0DT0H0M0S"), xs:yearMonthDuration("P24M"))</code> returns <code>true</code>.
							</p></item>
	<item><p>
<code>op:duration-equal(xs:duration("P0Y0M10D"), xs:dayTimeDuration("PT240H"))</code> returns <code>true</code>.
							</p></item>
						</ulist>
                    </div4>
                </div3>
                <div3 id="func-dateTime-equal">
                    <head>op:dateTime-equal</head>
                    <example role="signature">
                        <proto name="dateTime-equal" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dateTime" emptyOk="no"/>
                            <arg name="arg2" type="xs:dateTime" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: 
<!-- Returns <code>true</code> if and only if the normalized value of
                        <code>$arg1</code> is equal to the normalized value of <code>$arg2</code>.
                        Returns <code>false</code> otherwise. -->
Returns <code>true</code> if and only if the value of
                        <code>$arg1</code> is equal to the value of <code>$arg2</code> according to the algorithm defined in section 3.2.7.4 of <bibref ref="xmlschema-2"/> <quote>Order relation on dateTime</quote> for <code>xs:dateTime</code> values with timezones.
                        Returns <code>false</code> otherwise.
</p>
                    <p>This function backs up the "eq", "ne", "le" and "ge" operators on
                        <code>xs:dateTime</code> values.</p>
                    <div4 id="func-dateTime-equal-examples">
                        <head>Examples</head>
                        <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.</p>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00-01:00"),
                                    xs:dateTime("2002-04-02T17:00:00+04:00"))</code> returns <code>true</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),
                                    xs:dateTime("2002-04-02T23:00:00+06:00"))</code> returns <code>true</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),
                                    xs:dateTime("2002-04-02T17:00:00"))</code> returns <code>false</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),
                                    xs:dateTime("2002-04-02T12:00:00"))</code> returns <code>true</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>op:dateTime-equal(xs:dateTime("2002-04-02T23:00:00-04:00"),
                                    xs:dateTime("2002-04-03T02:00:00-01:00"))</code> returns <code>true</code>.</p>
                            </item>
                            <item>
                                <p><code>op:dateTime-equal(xs:dateTime("1999-12-31T24:00:00"),
xs:dateTime("2000-01-01T00:00:00"))</code> returns <code>true</code>.
                                </p>
                            </item>
							<item>
                                <p><code>op:dateTime-equal(xs:dateTime("2005-04-04T24:00:00"),
xs:dateTime("2005-04-04T00:00:00"))</code> returns <code>false</code>.
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-dateTime-less-than">
                    <head>op:dateTime-less-than</head>
                    <example role="signature">
                        <proto name="dateTime-less-than" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dateTime" emptyOk="no"/>
                            <arg name="arg2" type="xs:dateTime" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if the value of
                        <code>$arg1</code> is less than the value of <code>$arg2</code> according to the algorithm defined in section 3.2.7.4 of <bibref ref="xmlschema-2"/> <quote>Order relation on dateTime</quote> for <code>xs:dateTime</code> values with timezones.
<!--
Returns <code>true</code> if and only if the normalized value of
                        <code>$arg1</code> is less than the normalized value of <code>$arg2</code>. -->
                        Returns <code>false</code> otherwise.</p>
                    <p>This function backs up the "lt" and "le" operators on
                        <code>xs:dateTime</code> values.</p>
                </div3>
                <div3 id="func-dateTime-greater-than">
                    <head>op:dateTime-greater-than</head>
                    <example role="signature">
                        <proto name="dateTime-greater-than" return-type="xs:boolean"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dateTime" emptyOk="no"/>
                            <arg name="arg2" type="xs:dateTime" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if the value of
                        <code>$arg1</code> is greater than the value of <code>$arg2</code> according to the algorithm defined in section 3.2.7.4 of <bibref ref="xmlschema-2"/> <quote>Order relation on dateTime</quote> for <code>xs:dateTime</code> values with timezones.
Returns <code>false</code> otherwise.</p>
                    <p>This function backs up the "gt" and "ge" operators on
                        <code>xs:dateTime</code> values.</p>
                </div3>
                <div3 id="func-date-equal">
                    <head>op:date-equal</head>
                    <example role="signature">
                        <proto name="date-equal" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:date" emptyOk="no"/>
                            <arg name="arg2" type="xs:date" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if the starting instant of
                        <code>$arg1</code> is equal to starting instant of <code>$arg2</code>.
                        Returns <code>false</code> otherwise.</p>
                   <p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at time <code>00:00:00</code> on that date.</p>
<p>
The two starting instants are compared using <code>op:dateTime-equal</code>.
</p>
<p>This function backs up the "eq", "ne", "le" and "ge" operators on <code>xs:date</code> values.</p>
      
 <div4 id="func-date-equal-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:date-equal(xs:date("2004-12-25Z"),
                                    xs:date("2004-12-25+07:00"))</code> returns <code>false</code>.  The starting instants are <code>xs:dateTime("2004-12-25T00:00:00Z")</code> and <code>xs:dateTime("2004-12-25T00:00:00+07:00")</code>. These are normalized to <code>xs:dateTime("2004-12-25T00:00:00Z")</code> and <code>xs:dateTime("2004-12-24T17:00:00Z")</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:date-equal(xs:date("2004-12-25-12:00"),
                                    xs:date("2004-12-26+12:00"))</code> returns <code>true</code>.</p>
                            </item>
                        </ulist>
                    </div4>
</div3>
                <div3 id="func-date-less-than">
                    <head>op:date-less-than</head>
                    <example role="signature">
                        <proto name="date-less-than" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:date" emptyOk="no"/>
                            <arg name="arg2" type="xs:date" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if the starting instant of 
                        <code>$arg1</code> is less than the starting instant of <code>$arg2</code>.
                        Returns <code>false</code> otherwise.</p>
  <p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at time <code>00:00:00</code> on that date.</p>
<p>
The two starting instants are compared using <code>op:dateTime-less-than</code>.</p>
                    <p>This function backs up the "lt" and "le" operators on <code>xs:date</code> values.</p>
				<div4 id="func-date-less-than-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:date-less-than(xs:date("2004-12-25Z"),
                                    xs:date("2004-12-25-05:00"))</code> returns <code>true</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:date-less-than(xs:date("2004-12-25-12:00"),
                                    xs:date("2004-12-26+12:00"))</code> returns <code>false</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-date-greater-than">
                    <head>op:date-greater-than</head>
                    <example role="signature">
                        <proto name="date-greater-than" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:date" emptyOk="no"/>
                            <arg name="arg2" type="xs:date" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if the starting instant of
                        <code>$arg1</code> is greater than the starting instant of                        <code>$arg2</code>. Returns <code>false</code> otherwise.</p>
  <p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at time <code>00:00:00</code> on that date.</p>
<p>
The two starting instants are compared using <code>op:dateTime-greater-than</code>.</p>
                    <p>This function backs up the "gt" and "ge" operators on <code>xs:date</code> values.</p>
					 <div4 id='date-greater-than-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:date-greater-than(xs:date("2004-12-25Z"),
                                    xs:date("2004-12-25+07:00"))</code> returns <code>true</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:date-greater-than(xs:date("2004-12-25-12:00"),
                                    xs:date("2004-12-26+12:00"))</code> returns <code>false</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-time-equal">
                    <head>op:time-equal</head>
                    <example role="signature">
                        <proto name="time-equal" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:time" emptyOk="no"/>
                            <arg name="arg2" type="xs:time" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if the value of
                        <code>$arg1</code> converted to an <code>xs:dateTime</code> using the date components from the reference <code>xs:dateTime</code> is equal to the value of <code>$arg2</code> converted to an <code>xs:dateTime</code> using the date components from the same reference <code>xs:dateTime</code>.
                        Returns <code>false</code> otherwise.</p>
<p>The two <code>xs:dateTime</code> values are compared using <code>op:dateTime-equal</code>.</p>
                    <p>This function backs up the "eq", "ne", "le" and "ge" operators on <code>xs:time</code> values.</p>
   					<div4 id='func-time-equals-examples'>
                        <head>Examples</head>
                        <p>Assume that the date components from the reference <code>xs:dateTime</code> correspond to <code>1972-12-31</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:time-equal(xs:time("08:00:00+09:00"),
                                    xs:time("17:00:00-06:00"))</code> returns <code>false</code>. The <code>xs:dateTime</code>s calculated using the reference date components are <code>1972-12-31T08:00:00+09:00</code> and <code>1972-12-31T17:00:00-06:00</code>. 
These normalize to <code>1972-12-30T23:00:00Z</code> and <code>1972-12-31T23:00:00</code>.
</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:time-equal(xs:time("21:30:00+10:30"),
                                    xs:time("06:00:00-05:00"))</code> returns <code>true</code>.</p>
                            </item>
 							<item>
                                <p>
                                    <code>op:time-equal(xs:time("24:00:00+01:00"), xs:time("00:00:00+01:00"))</code> returns <code>true</code>. 
This not the result one might expect. For <code>xs:dateTime</code> values, a time of <code>24:00:00</code> is equivalent to <code>00:00:00</code> on the following day. For <code>xs:time</code>, the normalization from <code>24:00:00</code> to <code>00:00:00</code> happens before the <code>xs:time</code> is converted into an <code>xs:dateTime</code> for the purpose of the equality comparison. For <code>xs:time</code>, any operation on <code>24:00:00</code> produces the same result as the same operation on <code>00:00:00</code> because these are two different lexical representations of the same value.
</p>
                            </item>
                          </ulist>
                    </div4>
                </div3>
                <div3 id="func-time-less-than">
                    <head>op:time-less-than</head>
                    <example role="signature">
                        <proto name="time-less-than" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:time" emptyOk="no"/>
                            <arg name="arg2" type="xs:time" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if the value of
                        <code>$arg1</code> converted to an <code>xs:dateTime</code> using the date components from the reference <code>xs:dateTime</code> is less than the normalized value of <code>$arg2</code> converted to an <code>xs:dateTime</code> using the date components from the same reference <code>xs:dateTime</code>.
                        Returns <code>false</code> otherwise.</p>
<p>The two <code>xs:dateTime</code> values are compared using <code>op:dateTime-less-than</code>.</p>
                    <p>This function backs up the "lt" and "le" operators on <code>xs:time</code> values.</p>
                    <div4 id='func-time-less-than-examples'>
                        <head>Examples</head>
                        <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:time-less-than(xs:time("12:00:00"),
                                    xs:time("23:00:00+06:00"))</code> returns <code>false</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>op:time-less-than(xs:time("11:00:00"),
                                    xs:time("17:00:00Z"))</code> returns <code>true</code>.</p>
                            </item>
 <item>
                                <p>
                                    <code>op:time-less-than(xs:time("23:59:59"), xs:time("24:00:00"))</code> returns <code>false</code>.</p>
                            </item>
                          </ulist>
                    </div4>
                </div3>
                <div3 id="func-time-greater-than">
                    <head>op:time-greater-than</head>
                    <example role="signature">
                        <proto name="time-greater-than" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:time" emptyOk="no"/>
                            <arg name="arg2" type="xs:time" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if the value of
                        <code>$arg1</code> converted to an <code>xs:dateTime</code> using the date components from the reference <code>xs:dateTime</code> is greater than the value of
                        <code>$arg2</code> converted to an <code>xs:dateTime</code> using the date components from the same reference <code>xs:dateTime</code>. Returns <code>false</code> otherwise.</p>
<p>The two <code>xs:dateTime</code> values are compared using <code>op:dateTime-greater-than</code>.</p>
                    <p>This function backs up the "gt" and "ge" operators on <code>xs:time</code> values.</p>
   					<div4 id='func-time-greater-than-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:time-greater-than(xs:time("08:00:00+09:00"),
                                    xs:time("17:00:00-06:00"))</code> returns <code>false</code>.</p>
                            </item>
                         </ulist>
                    </div4>
                </div3>
                <div3 id="func-gYearMonth-equal">
                    <head>op:gYearMonth-equal</head>
                    <example role="signature">
                        <proto name="gYearMonth-equal" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:gYearMonth" emptyOk="no"/>
                            <arg name="arg2" type="xs:gYearMonth" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if and only if the <code>xs:dateTime</code>s representing the starting instants of <code>$arg1</code> and <code>$arg2</code> compare equal.  The starting instants of <code>$arg1</code> and <code>$arg2</code> are calculated by adding the missing components of <code>$arg1</code> and <code>$arg2</code> from the <code>xs:dateTime</code> template <code>xxxx-xx-ddT00:00:00</code> where <code>dd</code> represents the last day of the <code>month</code> component in <code>$arg1</code> or <code>$arg2</code>. Returns <code>false</code> otherwise. </p>
    <p>The two <code>xs:dateTime</code> values representing the starting instants of <code>$arg1</code> and <code>$arg2</code> are compared using <code>op:dateTime-equal</code>.</p>
                    <p>This function backs up the "eq" and "ne" operators on
                        <code>xs:gYearMonth</code> values.</p>
                     <div4 id='func-gYearMonth-equal-examples'>
                        <head>Examples</head>
                        <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:gYearMonth-equal(xs:gYearMonth("1976-02"),
                                    xs:gYearMonth("1976-03Z"))</code> returns <code>false</code>.  The starting instants are <code>1972-02-29T00:00:00-05:00</code> and <code>1972-03-31T00:00:00Z</code>, respectively.</p>
                            </item>
  							<item>
                                <p>
                                    <code>op:gYearMonth-equal(xs:gYearMonth("1976-03"),
                                    xs:gYearMonth("1976-03Z"))</code> returns <code>false</code>.</p>
                            </item>
                         </ulist>
                    </div4>
                </div3>
                <div3 id="func-gYear-equal">
                    <head>op:gYear-equal</head>
                    <example role="signature">
                        <proto name="gYear-equal" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:gYear" emptyOk="no"/>
                            <arg name="arg2" type="xs:gYear" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary:  Returns <code>true</code> if and only if the <code>xs:dateTime</code>s representing the starting instants of <code>$arg1</code> and <code>$arg2</code> compare equal.  The starting instants of <code>$arg1</code> and <code>$arg2</code> are calculated by adding the missing components of <code>$arg1</code> and <code>$arg2</code> from a <code>xs:dateTime</code> template such as <code>xxxx-01-01T00:00:00</code>.  Returns <code>false</code> otherwise.</p>
                   <p>The two <code>xs:dateTime</code> values representing the starting instants of <code>$arg1</code> and <code>$arg2</code> are compared using <code>op:dateTime-equal</code>.</p>
                    <p>This function backs up the "eq" and "ne" operators on <code>xs:gYear</code> values.</p>
 					<div4 id='func-gYear-equal-examples'>
                        <head>Examples</head>
                        <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.  Assume, also, that the <code>xs:dateTime</code> template is <code>xxxx-01-01T00:00:00</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:gYear-equal(xs:gYear("2005-12:00"),
                                    xs:gYear("2005+12:00"))</code> returns <code>false</code>.  The starting instants are <code>2005-01-01T00:00:00-12:00</code> and <code>2005-01-01T00:00:00+12:00</code>, respectively, and normalize to <code>2005-01-015T12:00:00Z</code> and <code>2004-12-31T12:00:00Z</code>.</p>
                            </item>
  							<item>
                                <p>
                                    <code>op:gYear-equal(xs:gYear("1976-05:00"),
                                    xs:gYear("1976"))</code> returns <code>true</code>.</p>
                            </item>
                         </ulist>
                    </div4>
                </div3>
                <div3 id="func-gMonthDay-equal">
                    <head>op:gMonthDay-equal</head>
                    <example role="signature">
                        <proto name="gMonthDay-equal" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:gMonthDay" emptyOk="no"/>
                            <arg name="arg2" type="xs:gMonthDay" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Summary: Returns <code>true</code> if and only if the <code>xs:dateTime</code>s representing the starting instants of equivalent occurrences of <code>$arg1</code> and <code>$arg2</code> compare equal.  The starting instants of equivalent occurrences of <code>$arg1</code> and <code>$arg2</code> are calculated by adding the missing components of <code>$arg1</code> and <code>$arg2</code> from an <code>xs:dateTime</code> template such as <code>1972-xx-xxT00:00:00</code>.  Returns <code>false</code> otherwise.</p>
<p>The two <code>xs:dateTime</code> values representing the starting instants of equivalent occurrences of <code>$arg1</code> and <code>$arg2</code> are compared using <code>op:dateTime-equal</code>.</p>
                                        <p>This function backs up the "eq" and "ne" operators on
                        <code>xs:gMonthDay</code> values.</p>
 					<div4 id='func-gMonthDay-equal-examples'>
                        <head>Examples</head>
                        <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.  Assume, also, that the <code>xs:dateTime</code> template is <code>1976-xx-xxT00:00:00</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:gMonthDay-equal(xs:gMonthDay("--12-25-14:00"),
                                    xs:gMonthDay("--12-26+10:00"))</code> returns <code>true</code>.  The starting instants are <code>1976-12-25T00:00:00-14:00</code> and <code>1976-12-26T00:00:00+10:00</code>, respectively, and normalize to <code>1976-12-25T14:00:00Z</code> and <code>1976-12-25T14:00:00Z</code>.</p>
                            </item>
  							<item>
                                <p>
                                    <code>op:gMonthDay-equal(xs:gMonthDay("--12-25"),
                                    xs:gMonthDay("--12-26Z"))</code> returns <code>false</code>.</p>
                            </item>
                         </ulist>
                    </div4>
                </div3>
                <div3 id="func-gMonth-equal">
                    <head>op:gMonth-equal</head>
                    <example role="signature">
                        <proto name="gMonth-equal" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:gMonth" emptyOk="no"/>
                            <arg name="arg2" type="xs:gMonth" emptyOk="no"/>
                        </proto>
                    </example>
                   
                    <p>Summary: Returns <code>true</code> if and only if the <code>xs:dateTime</code>s representing the starting instants of equivalent occurrences of <code>$arg1</code> and <code>$arg2</code> compare equal.  The starting instants of equivalent occurrences of <code>$arg1</code> and <code>$arg2</code> are calculated by adding the missing components of <code>$arg1</code> and <code>$arg2</code> from an <code>xs:dateTime</code> template such as <code>1972-xx-ddT00:00:00</code> where <code>dd</code> represents the last day of the month component in <code>$arg1</code> or <code>$arg2</code>. Returns <code>false</code> otherwise.</p>

           <p>The two <code>xs:dateTime</code> values representing the starting instants of equivalent occurrences of <code>$arg1</code> and <code>$arg2</code> are compared using <code>op:dateTime-equal</code>.</p>
                    
                    <p>This function backs up the "eq" and "ne" operators on <code>xs:gMonth</code> values.</p>
					<div4 id='func-gMonth-equal-examples'>
                        <head>Examples</head>
                        <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.  Assume, also, that the <code>xs:dateTime</code> template is <code>1972-xx-29T00:00:00</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:gMonth-equal(xs:gMonth("--12-14:00"),
                                    xs:gMonth("--12+10:00")</code> returns <code>false</code>.  The starting instants are <code>1972-12-29T00:00:00-14:00</code> and <code>1972-12-29T00:00:00+10:00</code>, respectively, and normalize to <code>1972-12-29T14:00:00Z</code> and <code>1972-12-28T14:00:00Z</code>.</p>
                            </item>
  							<item>
                                <p>
                                    <code>op:gMonth-equal(xs:gMonth("--12"),
                                    xs:gMonth("--12Z"))</code> returns <code>false</code>.</p>
                            </item>
                         </ulist>
                    </div4>
                </div3>
                <div3 id="func-gDay-equal">
                    <head>op:gDay-equal</head>
                    <example role="signature">
                        <proto name="gDay-equal" return-type="xs:boolean" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:gDay" emptyOk="no"/>
                            <arg name="arg2" type="xs:gDay" emptyOk="no"/>
                        </proto>
                    </example>
<p>Summary: Returns <code>true</code> if and only if the <code>xs:dateTime</code>s representing the starting instants of equivalent occurrences of <code>$arg1</code> and <code>$arg2</code> compare equal.  The starting instants of equivalent occurrences of <code>$arg1</code> and <code>$arg2</code> are calculated by adding the missing components of <code>$arg1</code> and <code>$arg2</code> from an <code>xs:dateTime</code> template such as <code>1972-12-xxT00:00:00</code>.  Returns <code>false</code> otherwise.</p>
                    <p>The two <code>xs:dateTime</code> values representing the starting instants of equivalent occurrences of <code>$arg1</code> and <code>$arg2</code> are compared using <code>op:dateTime-equal</code>.</p>
                    <p>This function backs up the "eq" and "ne" operators on <code>xs:gDay</code> values.</p>
					<div4 id='func-gDay-equal-examples'>
                        <head>Examples</head>
                        <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.  Assume, also, that the <code>xs:dateTime</code> template is <code>1976-12-xxT00:00:00</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:gDay-equal(xs:gDay("---25-14:00"),
                                    xs:gDay("---25+10:00"))</code> returns <code>false</code>.  The starting instants are <code>1972-12-25T00:00:00-14:00</code> and <code>1972-12-25T00:00:00+10:00</code>, respectively, and normalize to <code>1972-12-25T14:00:00Z</code> and <code>1972-12-24T14:00:00Z</code>.</p>
                            </item>
  							<item>
                                <p>
                                    <code>op:gDay-equal(xs:gDay("---12"),
                                    xs:gDay("---12Z"))</code> returns <code>false</code>.</p>
                            </item>
                         </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id='component-extraction-functions'>
                <head>Component Extraction Functions on Durations, Dates and Times</head>
                <p>The duration, date and time datatypes may be considered to be composite datatypes
                    in that they contain distinct properties or components. The extraction functions specified
                    below extract a single component from a duration, date or time value. For
                    the date/time datatypes the local value is used. 
For <code>xs:duration</code> and its subtypes, including the two subtypes <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>, the components are normalized: this means that the seconds and minutes components will always be less than 60, the hours component less than 24, and the months component less than 12.
</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:years-from-duration</code>
                            </td>
                            <td>Returns the year component of an <code>xs:duration</code>
                                value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:months-from-duration</code>
                            </td>
                            <td>Returns the months component of an
                                <code>xs:duration</code> value.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:days-from-duration</code>
                            </td>
                            <td>Returns the days component of an <code>xs:duration</code>
                                value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:hours-from-duration</code>
                            </td>
                            <td>Returns the hours component of an <code>xs:duration</code>
                                value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:minutes-from-duration</code>
                            </td>
                            <td>Returns the minutes component of an <code>xs:duration</code>
                                value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:seconds-from-duration</code>
                            </td>
                            <td>Returns the seconds component of an <code>xs:duration</code>
                                value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:year-from-dateTime</code>
                            </td>
                            <td>Returns the year from an <code>xs:dateTime</code> value.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:month-from-dateTime</code>
                            </td>
                            <td>Returns the month from an <code>xs:dateTime</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:day-from-dateTime</code>
                            </td>
                            <td>Returns the day from an <code>xs:dateTime</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:hours-from-dateTime</code>
                            </td>
                            <td>Returns the hours from an <code>xs:dateTime</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:minutes-from-dateTime</code>
                            </td>
                            <td>Returns the minutes from an <code>xs:dateTime</code> value.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:seconds-from-dateTime</code>
                            </td>
                            <td>Returns the seconds from an <code>xs:dateTime</code> value.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:timezone-from-dateTime</code>
                            </td>
                            <td>Returns the timezone from an <code>xs:dateTime</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:year-from-date</code>
                            </td>
                            <td>Returns the year from an <code>xs:date</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:month-from-date</code>
                            </td>
                            <td>Returns the month from an <code>xs:date</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:day-from-date</code>
                            </td>
                            <td>Returns the day from an <code>xs:date</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:timezone-from-date</code>
                            </td>
                            <td>Returns the timezone from an <code>xs:date</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:hours-from-time</code>
                            </td>
                            <td>Returns the hours from an <code>xs:time</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:minutes-from-time</code>
                            </td>
                            <td>Returns the minutes from an <code>xs:time</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:seconds-from-time</code>
                            </td>
                            <td>Returns the seconds from an <code>xs:time</code> value. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:timezone-from-time</code>
                            </td>
                            <td>Returns the timezone from an <code>xs:time</code> value. </td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-years-from-duration">
                    <head>fn:years-from-duration</head>
                    <example role="signature">
                        <proto name="years-from-duration" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:duration" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> representing the years component
                        in the value of <code>$arg</code>.  The result is obtained by casting <code>$arg</code> to an <code>xs:yearMonthDuration</code> (see <specref ref="casting-to-durations"/>) and then computing the years component as described in <specref ref="canonical-yearMonthDuration"/>.</p>

                    <p>The result may be negative.</p>
<p>If <code>$arg</code> is an <code>xs:dayTimeDuration</code> returns 0.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-years-from-duration-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:years-from-duration(xs:yearMonthDuration("P20Y15M"))</code>
                                    returns <code>21</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:years-from-duration(xs:yearMonthDuration("-P15M"))</code>
                                    returns <code>-1</code>.</p>
                            </item>
 							<item>
                                <p>

                                    <code>fn:years-from-duration(xs:dayTimeDuration("-P2DT15H"))</code>
                                    returns <code>0</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-months-from-duration">
                    <head>fn:months-from-duration</head>
                    <example role="signature">
                        <proto name="months-from-duration" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:duration" emptyOk="yes"/>
                        </proto>
                    </example>
<p>Summary: Returns an <code>xs:integer</code> representing the months component
                        in the value of <code>$arg</code>.  The result is obtained by casting <code>$arg</code> to an <code>xs:yearMonthDuration</code> (see <specref ref="casting-to-durations"/>) and then computing the months component as described in <specref ref="canonical-yearMonthDuration"/>.</p>

                    <p>The result may be negative.</p>
                    
<p>If <code>$arg</code> is an <code>xs:dayTimeDuration</code> returns 0.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-months-from-duration-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:months-from-duration(xs:yearMonthDuration("P20Y15M"))</code>
                                    returns <code>3</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:months-from-duration(xs:yearMonthDuration("-P20Y18M"))</code>
                                    returns <code>-6</code>.</p>
                            </item>
	<item>
                                <p>

                                    <code>fn:months-from-duration(xs:dayTimeDuration("-P2DT15H0M0S"))</code>
                                    returns <code>0</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-days-from-duration">
                    <head>fn:days-from-duration</head>
                    <example role="signature">
                        <proto name="days-from-duration" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:duration" emptyOk="yes"/>
                        </proto>
                    </example>
<p>Summary: Returns an <code>xs:integer</code> representing the days component
                        in the value of <code>$arg</code>.  The result is obtained by casting <code>$arg</code> to an <code>xs:dayTimeDuration</code> (see <specref ref="casting-to-durations"/>) and then computing the days component as described in <specref ref="canonical-dayTimeDuration"/>.</p>

                    <p>The result may be negative.</p>
                    
<p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> returns 0.</p>
                    <p> If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-days-from-duration-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:days-from-duration(xs:dayTimeDuration("P3DT10H"))</code>
                                    returns <code>3</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:days-from-duration(xs:dayTimeDuration("P3DT55H"))</code>
                                    returns <code>5</code>.</p>
                            </item>
 							<item>
                                <p>

                                    <code>fn:days-from-duration(xs:yearMonthDuration("P3Y5M"))</code>
                                    returns <code>0</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-hours-from-duration">
                    <head>fn:hours-from-duration</head>
                    <example role="signature">
                        <proto name="hours-from-duration" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:duration" emptyOk="yes"/>
                        </proto>
                    </example>
<p>Summary: Returns an <code>xs:integer</code> representing the hours component
                        in the value of <code>$arg</code>.  The result is obtained by casting <code>$arg</code> to an <code>xs:dayTimeDuration</code> (see <specref ref="casting-to-durations"/>) and then computing the hours component as described in <specref ref="canonical-dayTimeDuration"/>.</p>

                    <p>The result may be negative.</p>
                    
<p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> returns 0.</p>
                    <p> If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-hours-from-duration-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:hours-from-duration(xs:dayTimeDuration("P3DT10H"))</code>
                                    returns <code>10</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:hours-from-duration(xs:dayTimeDuration("P3DT12H32M12S"))</code>
                                    returns <code>12</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:hours-from-duration(xs:dayTimeDuration("PT123H"))</code>
                                    returns <code>3</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:hours-from-duration(xs:dayTimeDuration("-P3DT10H"))</code>
                                    returns <code>-10</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-minutes-from-duration">
                    <head>fn:minutes-from-duration</head>
                    <example role="signature">
                        <proto name="minutes-from-duration" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:duration" emptyOk="yes"/>
                        </proto>
                    </example>
<p>Summary: Returns an <code>xs:integer</code> representing the minutes component
                        in the value of <code>$arg</code>.  The result is obtained by casting <code>$arg</code> to an <code>xs:dayTimeDuration</code> (see <specref ref="casting-to-durations"/>) and then computing the minutes component as described in <specref ref="canonical-dayTimeDuration"/>.</p>

                    <p>The result may be negative.</p>
                    <p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> returns 0.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-minutes-from-duration-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:minutes-from-duration(xs:dayTimeDuration("P3DT10H"))</code>
                                    returns <code>0</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:minutes-from-duration(xs:dayTimeDuration("-P5DT12H30M"))</code>
                                    returns <code>-30</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-seconds-from-duration">
                    <head>fn:seconds-from-duration</head>
                    <example role="signature">
                        <proto name="seconds-from-duration" return-type="xs:decimal" returnEmptyOk="yes">
                            <arg name="arg" type="xs:duration" emptyOk="yes"/>
                        </proto>
                    </example>
<p>Summary: Returns an <code>xs:decimal</code> representing the seconds component
                        in the value of <code>$arg</code>.  The result is obtained by casting <code>$arg</code> to an <code>xs:dayTimeDuration</code> (see <specref ref="casting-to-durations"/>) and then computing the seconds component as described in <specref ref="canonical-dayTimeDuration"/>.</p>

                    <p>The result may be negative.</p>
                    
<p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> returns 0.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-seconds-from-duration-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:seconds-from-duration(xs:dayTimeDuration("P3DT10H12.5S"))</code>
                                    returns <code>12.5</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:seconds-from-duration(xs:dayTimeDuration("-P256S"))</code>
                                    returns <code>-16.0</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-year-from-dateTime">
                    <head>fn:year-from-dateTime</head>
                    <example role="signature">
                        <proto name="year-from-dateTime" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:dateTime" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> representing the year component
                        in the localized value of <code>$arg</code>. The result may be negative.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-year-from-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:year-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
                                    returns <code>1999</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:year-from-dateTime(xs:dateTime("1999-05-31T21:30:00-05:00"))</code>
                                    returns <code>1999</code>.</p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:year-from-dateTime(xs:dateTime("1999-12-31T19:20:00"))</code>
                                    returns <code>1999</code>.</p>
                            </item>
 							<item>
                                <p>

                                    <code>fn:year-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))</code>
                                    returns <code>2000</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-month-from-dateTime">
                    <head>fn:month-from-dateTime</head>
                    <example role="signature">
                        <proto name="month-from-dateTime" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:dateTime" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> between 1 and 12, both inclusive,
                        representing the month component in the localized value of <code>$arg</code>.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-month-from-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:month-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
                                    returns <code>5</code>. </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:month-from-dateTime(xs:dateTime("1999-12-31T19:20:00-05:00"))</code>
                                    returns <code>12</code>. </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:month-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T19:20:00-05:00"),
                                    xs:dayTimeDuration("PT0S")))</code> returns <code>1</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-day-from-dateTime">
                    <head>fn:day-from-dateTime</head>
                    <example role="signature">
                        <proto name="day-from-dateTime" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:dateTime" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> between 1 and 31, both inclusive,
                        representing the day component in the localized value of <code>$arg</code>.</p>
                    <p> If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-day-from-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:day-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
                                    returns <code>31</code>. </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:day-from-dateTime(xs:dateTime("1999-12-31T20:00:00-05:00"))</code>
                                    returns <code>31</code>. </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:day-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T19:20:00-05:00"),
                                    xs:dayTimeDuration("PT0S")))</code> returns <code>1</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-hours-from-dateTime">
                    <head>fn:hours-from-dateTime</head>
                    <example role="signature">
                        <proto name="hours-from-dateTime" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:dateTime" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> between 0 and 23, both inclusive,
                        representing the hours component in the localized value of <code>$arg</code>.</p>
                    <p> If <code>$arg</code> is the empty sequence, returns the empty sequence. </p>
                    <div4 id='func-hours-from-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:hours-from-dateTime(xs:dateTime("1999-05-31T08:20:00-05:00"))</code>
                                    returns <code>8</code>. </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:hours-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))</code>
                                    returns <code>21</code>. </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:hours-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T21:20:00-05:00"),
                                        xs:dayTimeDuration("PT0S")))</code> returns
                                    <code>2</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:hours-from-dateTime(xs:dateTime("1999-12-31T12:00:00"))</code>
                                    returns <code>12</code>.
                                </p>
                            </item>
							<item>
                                <p>
                                    <code>fn:hours-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))</code>
                                    returns <code>0</code>.
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-minutes-from-dateTime">
                    <head>fn:minutes-from-dateTime</head>
                    <example role="signature">
                        <proto name="minutes-from-dateTime" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:dateTime" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> value between 0 and 59, both
                        inclusive, representing the minute component in the localized value of <code>$arg</code>.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence. </p>
                    <div4 id='func-minutes-from-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
                                    returns <code>20</code> . </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:30:00+05:30"))</code>
                                    returns <code>30</code> . </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-seconds-from-dateTime">
                    <head>fn:seconds-from-dateTime</head>
                    <example role="signature">
                        <proto name="seconds-from-dateTime" return-type="xs:decimal" returnEmptyOk="yes">
                            <arg name="arg" type="xs:dateTime" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:decimal</code> value greater than or equal to zero and less than 60,
                        representing the seconds and fractional seconds in the
                        localized value of <code>$arg</code>.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-seconds-from-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
                                    returns <code>0</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-timezone-from-dateTime">
                    <head>fn:timezone-from-dateTime</head>
                    <example role="signature">
                        <proto name="timezone-from-dateTime" return-type="xs:dayTimeDuration" returnEmptyOk="yes">
                            <arg name="arg" type="xs:dateTime" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the timezone component of <code>$arg</code> if any. If
                        <code>$arg</code> has a timezone component, then the result is
                        an <code>xs:dayTimeDuration</code> that indicates deviation from UTC; its
                        value may range from +14:00 to -14:00 hours, both inclusive. Otherwise, the
                        result is the empty sequence.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence. </p>
                    <div4 id='func-timezone-from-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:timezone-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
                                    returns the <code>xs:dayTimeDuration</code> whose value is
                                    <code>-PT5H</code>. </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:timezone-from-dateTime(xs:dateTime("2000-06-12T13:20:00Z"))</code>
                                    returns the <code>xs:dayTimeDuration</code> whose value is
                                    <code>PT0S</code>. </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:timezone-from-dateTime(xs:dateTime("2004-08-27T00:00:00"))</code>
                                    returns <code>()</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-year-from-date">
                    <head>fn:year-from-date</head>
                    <example role="signature">
                        <proto name="year-from-date" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:date" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> representing the year in the
                        localized value of <code>$arg</code>. The value may be negative. </p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-year-from-date-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:year-from-date(xs:date("1999-05-31"))</code> returns
                                    <code>1999</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:year-from-date(xs:date("2000-01-01+05:00"))</code>
                                    returns <code>2000</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-month-from-date">
                    <head>fn:month-from-date</head>
                    <example role="signature">
                        <proto name="month-from-date" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:date" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> between 1 and 12, both inclusive,
                        representing the month component in the localized value of
                        <code>$arg</code>. </p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-month-from-date-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:month-from-date(xs:date("1999-05-31-05:00"))</code>
                                    returns <code>5</code> . </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:month-from-date(xs:date("2000-01-01+05:00"))</code>
                                    returns <code>1</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-day-from-date">
                    <head>fn:day-from-date</head>
                    <example role="signature">
                        <proto name="day-from-date" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:date" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> between 1 and 31, both inclusive,
                        representing the day component in the localized value of <code>$arg</code>.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-day-from-date-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:day-from-date(xs:date("1999-05-31-05:00"))</code>
                                    returns <code>31</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:day-from-date(xs:date("2000-01-01+05:00"))</code>
                                    returns <code>1</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-timezone-from-date">
                    <head>fn:timezone-from-date</head>
                    <example role="signature">
                        <proto name="timezone-from-date" return-type="xs:dayTimeDuration" returnEmptyOk="yes">
                            <arg name="arg" type="xs:date" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the timezone component of <code>$arg</code> if any. If
                        <code>$arg</code> has a timezone component, then the result is
                        an <code>xs:dayTimeDuration</code> that indicates deviation from UTC; its
                        value may range from +14:00 to -14:00 hours, both inclusive. Otherwise, the
                        result is the empty sequence.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-timezone-from-date-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:timezone-from-date(xs:date("1999-05-31-05:00"))</code>
                                    returns the <code>xs:dayTimeDuration</code> whose value is
                                    <code>-PT5H</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:timezone-from-date(xs:date("2000-06-12Z"))</code>
                                    returns the <code>xs:dayTimeDuration</code> with value <code>PT0S</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-hours-from-time">
                    <head>fn:hours-from-time</head>
                    <example role="signature">
                        <proto name="hours-from-time" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:time" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> between 0 and 23, both inclusive,
                        representing the value of the hours component in the localized value of <code>$arg</code>.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence. </p>
                    <div4 id='func-hours-from-time-examples'>
                        <head>Examples</head>
                        <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:hours-from-time(xs:time("11:23:00"))</code> returns
                                    <code>11</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:hours-from-time(xs:time("21:23:00"))</code> returns
                                    <code>21</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:hours-from-time(xs:time("01:23:00+05:00"))</code>
                                    returns <code>1</code>. </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:hours-from-time(fn:adjust-time-to-timezone(xs:time("01:23:00+05:00"),
                                    xs:dayTimeDuration("PT0S")))</code> returns <code>20</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:hours-from-time(xs:time("24:00:00"))</code>
                                    returns <code>0</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-minutes-from-time">
                    <head>fn:minutes-from-time</head>
                    <example role="signature">
                        <proto name="minutes-from-time" return-type="xs:integer" returnEmptyOk="yes">
                            <arg name="arg" type="xs:time" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:integer</code> value between 0 and 59, both
                        inclusive, representing the value of the minutes component in the localized
                        value of <code>$arg</code>.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-minutes-from-time-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:minutes-from-time(xs:time("13:00:00Z"))</code> returns
                                    <code>0</code> . </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-seconds-from-time">
                    <head>fn:seconds-from-time</head>
                    <example role="signature">
                        <proto name="seconds-from-time" return-type="xs:decimal" returnEmptyOk="yes">
                            <arg name="arg" type="xs:time" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:decimal</code> value greater than or equal to zero and less than 60, representing the seconds and fractional seconds in the
                        localized value of <code>$arg</code>.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-seconds-from-time-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:seconds-from-time(xs:time("13:20:10.5"))</code> returns
                                    <code>10.5</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-timezone-from-time">
                    <head>fn:timezone-from-time</head>
                    <example role="signature">
                        <proto name="timezone-from-time" return-type="xs:dayTimeDuration" returnEmptyOk="yes">
                            <arg name="arg" type="xs:time" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the timezone component of <code>$arg</code> if any. If
                        <code>$arg</code> has a timezone component, then the result is
                        an <code>xs:dayTimeDuration</code> that indicates deviation from UTC; its
                        value may range from +14:00 to -14:00 hours, both inclusive. Otherwise, the
                        result is the empty sequence.</p>
                    <p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
                    <div4 id='func-timezone-from-time-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:timezone-from-time(xs:time("13:20:00-05:00"))</code>
                                    returns <code>xs:dayTimeDuration</code> whose value is <code>-PT5H</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:timezone-from-time(xs:time("13:20:00"))</code> returns <code>()</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id="duration-arithmetic">
                <head>Arithmetic Operators on Durations</head>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>op:add-yearMonthDurations</code>
                            </td>
                            <td>Adds two <code>xs:yearMonthDuration</code>s. Returns an <code>xs:yearMonthDuration</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:subtract-yearMonthDurations</code>
                            </td>
                            <td>Subtracts one <code>xs:yearMonthDuration</code> from another.
                                Returns an <code>xs:yearMonthDuration</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:multiply-yearMonthDuration</code>
                            </td>
                            <td>Multiplies a <code>xs:yearMonthDuration</code> by an
                                <code>xs:double</code>. Returns an <code>xs:yearMonthDuration</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:divide-yearMonthDuration</code>
                            </td>
                            <td>Divides an <code>xs:yearMonthDuration</code> by an
                                <code>xs:double</code>. Returns an <code>xs:yearMonthDuration</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:divide-yearMonthDuration-by-yearMonthDuration</code>
                            </td>
                            <td>Divides an <code>xs:yearMonthDuration</code> by an
                                <code>xs:yearMonthDuration</code>. Returns an <code>xs:decimal</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:add-dayTimeDurations</code>
                            </td>
                            <td>Adds two <code>xs:dayTimeDurations</code>. Returns an <code>xs:dayTimeDuration</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:subtract-dayTimeDurations</code>
                            </td>
                            <td>Subtracts one <code>xs:dayTimeDuration</code> from another. Returns
                                an <code>xs:dayTimeDuration</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:multiply-dayTimeDuration</code>
                            </td>
                            <td>Multiplies an <code>xs:dayTimeDuration</code> by a
                                <code>xs:double</code>. Returns an <code>xs:dayTimeDuration</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:divide-dayTimeDuration</code>
                            </td>
                            <td>Divides an <code>xs:dayTimeDuration</code> by an
                                <code>xs:double</code>. Returns an <code>xs:dayTimeDuration</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:divide-dayTimeDuration-by-dayTimeDuration</code>
                            </td>
                            <td>Divides an <code>xs:dayTimeDuration</code> by an
                                <code>xs:dayTimeDuration</code>. Returns an <code>xs:decimal</code>.</td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-add-yearMonthDurations">
                    <head>op:add-yearMonthDurations</head>
                    <example role="signature">
                        <proto name="add-yearMonthDurations" return-type="xs:yearMonthDuration"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:yearMonthDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:yearMonthDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the result of adding the value of <code>$arg1</code> to the
                        value of <code>$arg2</code>. Backs up the "+" operator on
                        <code>xs:yearMonthDuration</code> values.</p>
                    <div4 id='func-add-yearMonthDurations-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:add-yearMonthDurations(xs:yearMonthDuration("P2Y11M"),
                                    xs:yearMonthDuration("P3Y3M"))</code> returns a
                                    <code>xs:yearMonthDuration</code> value corresponding to 6
                                    years and 2 months. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-subtract-yearMonthDurations">
                    <head>op:subtract-yearMonthDurations</head>
                    <example role="signature">
                        <proto name="subtract-yearMonthDurations"
                            return-type="xs:yearMonthDuration" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:yearMonthDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:yearMonthDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the result of subtracting the value of <code>$arg2</code>
                        from the value of <code>$arg1</code>. Backs up the "-" operator on
                        <code>xs:yearMonthDuration</code> values.</p>
                    <div4 id='func-subtract-yearMonthDurations-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:subtract-yearMonthDurations(xs:yearMonthDuration("P2Y11M"),
                                    xs:yearMonthDuration("P3Y3M"))</code> returns a
                                    <code>xs:yearMonthDuration</code> value corresponding to
                                    negative 4 months. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-multiply-yearMonthDuration">
                    <head>op:multiply-yearMonthDuration</head>
                    <example role="signature">
                        <proto name="multiply-yearMonthDuration" return-type="xs:yearMonthDuration"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:yearMonthDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:double" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the result of multiplying the value of <code>$arg1</code> by
                        <code>$arg2</code>. The result is rounded to the nearest month. For a value
                        <emph>v</emph>, 0 &lt;= <emph>v</emph> &lt; 0.5 rounds to 0; 0.5
                        &lt;= <emph>v</emph> &lt; 1.0 rounds to 1.</p>
                    <p>If <code>$arg2</code> is positive or negative zero, the result is a
                        zero-length duration. If <code>$arg2</code> is positive or negative
                        infinity, the result overflows and is handled as discussed in <specref
                        ref="date-time-duration-conformance"/>. If <code>$arg2</code> is
                        <code>NaN</code> an error is raised <errorref class="CA" code="0005"/>
                    </p>
                    <p>Backs up the "*" operator on <code>xs:yearMonthDuration</code> values.</p>
                    <div4 id='func-multiply-yearMonthDurations-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:multiply-yearMonthDuration(xs:yearMonthDuration("P2Y11M"),
                                    2.3)</code> returns a <code>xs:yearMonthDuration</code> value
                                    corresponding to 6 years and 9 months. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-divide-yearMonthDuration">
                    <head>op:divide-yearMonthDuration</head>
                    <example role="signature">
                        <proto name="divide-yearMonthDuration" return-type="xs:yearMonthDuration"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:yearMonthDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:double" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the result of dividing the value of <code>$arg1</code> by
                        <code>$arg2</code>. The result is rounded to the nearest month. For a value
                        <emph>v</emph>, 0 &lt;= <emph>v</emph> &lt; 0.5 rounds to 0; 0.5
                        &lt;= <emph>v</emph> &lt; 1.0 rounds to 1.</p>
                    <p>If <code>$arg2</code> is positive or negative infinity, the result is a
                        zero-length duration. If <code>$arg2</code> is positive or negative zero,
                        the result overflows and is handled as discussed in <specref
                        ref="date-time-duration-conformance"/>. If <code>$arg2</code> is
                        <code>NaN</code> an error is raised <errorref class="CA" code="0005"/>
                    </p>
                    <p>Backs up the "div" operator on <code>xs:yearMonthDuration</code> and numeric values.</p>
                    <div4 id='func-divide-yearMonthDurations-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:divide-yearMonthDuration(xs:yearMonthDuration("P2Y11M"),
                                    1.5)</code> returns a <code>xs:yearMonthDuration</code> value
                                    corresponding to 1 year and 11 months. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-divide-yearMonthDuration-by-yearMonthDuration">
                    <head>op:divide-yearMonthDuration-by-yearMonthDuration</head>
                    <example role="signature">
                        <proto name="divide-yearMonthDuration-by-yearMonthDuration"
                            return-type="xs:decimal" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:yearMonthDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:yearMonthDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the result of dividing the value of <code>$arg1</code>
                        by <code>$arg2</code>. Since the values of both operands are integers, the
                        semantics of the division is identical to <code>op:numeric-divide</code> with
                        <code>xs:integer</code> operands.</p>
                    <p>Backs up the "div" operator on <code>xs:yearMonthDuration</code> values.</p>
                    <div4 id='func-divide-yearMonthDuration-by-yearMonthDuration-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:divide-yearMonthDuration-by-yearMonthDuration(xs:yearMonthDuration("P3Y4M"),
                                    xs:yearMonthDuration("-P1Y4M"))</code> returns
                                    <code>-2.5</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-add-dayTimeDurations">
                    <head>op:add-dayTimeDurations</head>
                    <example role="signature">
                        <proto name="add-dayTimeDurations" return-type="xs:dayTimeDuration"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dayTimeDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the result of adding the value of <code>$arg1</code> to the
                        value of <code>$arg2</code>. Backs up the "+" operator on
                        <code>xs:dayTimeDuration</code> values.</p>
                    <div4 id='func-add-dayTimeDurations-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:add-dayTimeDurations(xs:dayTimeDuration("P2DT12H5M"),
                                    xs:dayTimeDuration("P5DT12H"))</code> returns a
                                    <code>xs:dayTimeDuration</code> value corresponding to 8 days
                                    and 5 minutes. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-subtract-dayTimeDurations">
                    <head>op:subtract-dayTimeDurations</head>
                    <example role="signature">
                        <proto name="subtract-dayTimeDurations" return-type="xs:dayTimeDuration"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dayTimeDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the result of subtracting the value of <code>$arg2</code>
                        from the value of <code>$arg1</code>. Backs up the "-" operator on
                        <code>xs:dayTimeDuration</code> values.</p>
                    <div4 id='func-subtract-dayTimeDurations-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:subtract-dayTimeDurations(xs:dayTimeDuration("P2DT12H"),
                                    xs:dayTimeDuration("P1DT10H30M"))</code> returns a
                                    <code>xs:dayTimeDuration</code> value corresponding to 1 day, 1
                                    hour and 30 minutes. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-multiply-dayTimeDuration">
                    <head>op:multiply-dayTimeDuration</head>
                    <example role="signature">
                        <proto name="multiply-dayTimeDuration" return-type="xs:dayTimeDuration"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dayTimeDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:double" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the result of multiplying the value of <code>$arg1</code> by <code>$arg2</code>.</p>
                    <p>If <code>$arg2</code> is positive or negative zero, the result is a
                        zero-length duration. If <code>$arg2</code> is positive or negative
                        infinity, the result overflows and is handled as discussed in <specref
                        ref="date-time-duration-conformance"/>. If <code>$arg2</code> is
                        <code>NaN</code> an error is raised <errorref class="CA" code="0005"/>
                    </p>
                    <p>Backs up the "*" operator on <code>xs:dayTimeDuration</code> values.</p>
                    <div4 id='func-multiply-yearMonthDuration-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:multiply-dayTimeDuration(xs:dayTimeDuration("PT2H10M"),
                                    2.1)</code> returns a <code>xs:dayTimeDuration</code> value
                                    corresponding to 4 hours and 33 minutes. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-divide-dayTimeDuration">
                    <head>op:divide-dayTimeDuration</head>
                    <example role="signature">
                        <proto name="divide-dayTimeDuration" return-type="xs:dayTimeDuration"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dayTimeDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:double" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the result of dividing the value of <code>$arg1</code> by
                        <code>$arg2</code>. </p>
                    <p>If <code>$arg2</code> is positive or negative infinity, the result is a
                        zero-length duration. If <code>$arg2</code> is positive or negative zero,
                        the result overflows and is handled as discussed in <specref
                        ref="date-time-duration-conformance"/>. If <code>$arg2</code> is
                        <code>NaN</code> an error is raised <errorref class="CA" code="0005"/>
                    </p>
                    <p>Backs up the "div" operator on <code>xs:dayTimeDuration</code> values.</p>
                    <div4 id='func-divide-yearMonthDuration-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:divide-dayTimeDuration(xs:yearMonthDuration("P1DT2H30M10.5S"),
                                    1.5)</code> returns a <code>xs:dayTimeDuration</code> value
                                    corresponding to 17 hours, 40 minutes and 7 seconds. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-divide-dayTimeDuration-by-dayTimeDuration">
                    <head>op:divide-dayTimeDuration-by-dayTimeDuration</head>
                    <example role="signature">
                        <proto name="divide-dayTimeDuration-by-dayTimeDuration"
                            return-type="xs:decimal" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dayTimeDuration" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the result of dividing the value of <code>$arg1</code>
                        by <code>$arg2</code>. Since the values of both operands are decimals, the
                        semantics of the division is identical to <code>op:numeric-divide</code> with
                        <code>xs:decimal</code> operands.</p>
                    <p>Backs up the "div" operator on <code>xs:dayTimeDuration</code> values.</p>
                    <div4 id='func-divide-dayTimeDuration-by-dayTimeDuration-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:divide-dayTimeDuration-by-dayTimeDuration(xs:dayTimeDuration("P2DT53M11S"),
                                    xs:dayTimeDuration("P1DT10H))</code> returns <code>1.4378349...</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id="timezone.functions">
                <head>Timezone Adjustment Functions on Dates and Time Values</head>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:adjust-dateTime-to-timezone</code>
                            </td>
                            <td>Adjusts an <code>xs:dateTime</code> value to a specific timezone, or
                                to no timezone at all. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:adjust-date-to-timezone</code>
                            </td>
                            <td>Adjusts an <code>xs:date</code> value to a specific timezone, or to
                                no timezone at all.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:adjust-time-to-timezone</code>
                            </td>
                            <td>Adjusts an <code>xs:time</code> value to a specific timezone, or to
                                no timezone at all.</td>
                        </tr>
                    </tbody>
                </table>
                <p>These functions adjust the timezone component of an <code>xs:dateTime</code>, <code>xs:date</code> or
                    <code>xs:time</code> value.  The <code>$timezone</code> argument to these functions is defined as an <code>xs:dayTimeDuration</code> but must be a valid timezone value.</p>
                <div3 id="func-adjust-dateTime-to-timezone">
                    <head>fn:adjust-dateTime-to-timezone</head>
                    <example role="signature">
                        <proto name="adjust-dateTime-to-timezone" return-type="xs:dateTime" returnEmptyOk="yes">
                            <arg name="arg" type="xs:dateTime" emptyOk="yes"/>
                        </proto>
                    </example>
                    <example role="signature">
                        <proto name="adjust-dateTime-to-timezone" return-type="xs:dateTime" returnEmptyOk="yes">
                            <arg name="arg" type="xs:dateTime" emptyOk="yes"/>
                            <arg name="timezone" type="xs:dayTimeDuration" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Adjusts an <code>xs:dateTime</code> value to a specific timezone, or
                        to no timezone at all. If <code>$timezone</code> is the empty sequence,
                        returns an <code>xs:dateTime</code> without a timezone. Otherwise, returns
                        an <code>xs:dateTime</code> with a timezone.</p>
                    <p> If <code>$timezone</code> is not specified, then <code>$timezone</code> is
                        the value of the implicit timezone in the dynamic context.</p>
                    <p> If <code>$arg</code> is the empty sequence, then the result is the empty sequence.</p>
                    <p> A dynamic error is raised <errorref class="DT" code="0003"/> if
                        <code>$timezone</code> is less than <code>-PT14H</code> or greater than <code>PT14H</code> or if does not contain an integral number of minutes.</p>
                    <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is the empty sequence, then the result is <code>$arg</code>.</p>
                    <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is not the empty sequence, then the result is
                        <code>$arg</code> with <code>$timezone</code> as the timezone component.</p>
                    <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        the empty sequence, then the result is the localized value of
                        <code>$arg</code> without its timezone component.</p>
                    <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        not the empty sequence, then the result is an <code>xs:dateTime</code> value
                        with a timezone component of <code>$timezone</code> that is equal to <code>$arg</code>.</p>
                    <div4 id='func-adjust-dateTime-to-timezone-examples'>
                        <head>Examples</head>
                        <p> Assume the dynamic context provides an implicit timezone of <code>-05:00 (-PT5H0M)</code>.</p>
                        <p>
                            <code>let $tz := xs:dayTimeDuration("-PT10H")</code>
                        </p>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:adjust-dateTime-to-timezone(xs:dateTime("2002-03-07T10:00:00"))</code>
                                    returns <code>2002-03-07T10:00:00-05:00</code>
                                </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:adjust-dateTime-to-timezone(xs:dateTime("2002-03-07T10:00:00-07:00"))</code>
                                    returns <code>2002-03-07T12:00:00-05:00</code>
                                </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:adjust-dateTime-to-timezone(xs:dateTime("2002-03-07T10:00:00"),
                                    $tz)</code> returns <code>2002-03-07T10:00:00-10:00</code>
                                </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:adjust-dateTime-to-timezone(xs:dateTime("2002-03-07T10:00:00-07:00"),
                                    $tz)</code> returns <code>2002-03-07T07:00:00-10:00</code>
                                </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:adjust-dateTime-to-timezone(xs:dateTime("2002-03-07T10:00:00-07:00"),
                                    xs:dayTimeDuration("PT10H"))</code> returns <code>2002-03-08T03:00:00+10:00</code>
                                </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:adjust-dateTime-to-timezone(xs:dateTime("2002-03-07T00:00:00+01:00"),
                                    xs:dayTimeDuration("-PT8H"))</code> returns <code>2002-03-06T15:00:00-08:00</code>
                                </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:adjust-dateTime-to-timezone(xs:dateTime("2002-03-07T10:00:00"),
                                    ())</code> returns <code>2002-03-07T10:00:00</code>
                                </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:adjust-dateTime-to-timezone(xs:dateTime("2002-03-07T10:00:00-07:00"),
                                    ())</code> returns <code>2002-03-07T10:00:00</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-adjust-date-to-timezone">
                    <head>fn:adjust-date-to-timezone</head>
                    <example role="signature">
                        <proto name="adjust-date-to-timezone" return-type="xs:date" returnEmptyOk="yes">
                            <arg name="arg" type="xs:date" emptyOk="yes"/>
                        </proto>
                    </example>
                    <example role="signature">
                        <proto name="adjust-date-to-timezone" return-type="xs:date" returnEmptyOk="yes">
                            <arg name="arg" type="xs:date" emptyOk="yes"/>
                            <arg name="timezone" type="xs:dayTimeDuration" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Adjusts an <code>xs:date</code> value to a specific timezone, or to
                        no timezone at all. If <code>$timezone</code> is the empty sequence, returns
                        an <code>xs:date</code> without a timezone. Otherwise, returns an
                        <code>xs:date</code> with a timezone. For purposes of timezone adjustment,
                        an <code>xs:date</code> is treated as an <code>xs:dateTime</code> with time <code>00:00:00</code>.</p>
                    <p> If <code>$timezone</code> is not specified, then <code>$timezone</code> is
                        the value of the implicit timezone in the dynamic context.</p>
                    <p> If <code>$arg</code> is the empty sequence, then the result is the empty sequence.</p>
                    <p> A dynamic error is raised <errorref class="DT" code="0003"/> if
                        <code>$timezone</code> is less than <code>-PT14H</code> or greater than <code>PT14H</code> or if does not contain an integral number of minutes.</p>
                    <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is the empty sequence, then the result is the value
                        of <code>$arg</code>.</p>
                    <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is not the empty sequence, then the result is
                        <code>$arg</code> with <code>$timezone</code> as the timezone component.</p>
                    <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        the empty sequence, then the result is the localized value of
                        <code>$arg</code> without its timezone component.</p>
                    <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        not the empty sequence, then:</p>
                    <ulist>
                        <item>
                            <p>Let <code>$srcdt</code> be an <code>xs:dateTime</code> value, with
                                <code>00:00:00</code> for the time component and date and timezone
                                components that are the same as the date and timezone components of <code>$arg</code>.</p>
                        </item>
                        <item>
                            <p>Let <code>$r</code> be the result of evaluating
                                    <code>fn:adjust-dateTime-to-timezone($srcdt, $timezone)</code>
                            </p>
                        </item>
                        <item>
                            <p>The result of this function will be a date value that has date and
                                timezone components that are the same as the date and timezone
                                components of <code>$r</code>.</p>
                        </item>
                    </ulist>
                    <div4 id='func-adjust-date-to-timezone-examples'>
                        <head>Examples</head>
                        <p> Assume the dynamic context provides an implicit timezone of <code>-05:00 (-PT5H0M)</code>.</p>
                        <p>
                            <code>let $tz := xs:dayTimeDuration("-PT10H")</code>
                        </p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:adjust-date-to-timezone(xs:date("2002-03-07"))</code>
                                    returns <code>2002-03-07-05:00.</code>
                                </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"))</code>
                                    returns <code>2002-03-07-05:00</code>. <code>$arg</code> is
                                    converted to the <code>xs:dateTime
                                    "2002-03-07T00:00:00-07:00"</code>. This is adjusted to the
                                    implicit timezone, giving <code>"2002-03-07T02:00:00-05:00".</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:adjust-date-to-timezone(xs:date("2002-03-07"),
                                    $tz)</code> returns <code>2002-03-07-10:00</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"),
                                    $tz)</code> returns <code>2002-03-06-10:00</code>.
                                    <code>$arg</code> is converted to the <code>xs:dateTime
                                    "2002-03-07T00:00:00-07:00"</code>. This is adjusted to the
                                    given timezone, giving <code>"2002-03-06T21:00:00-10:00"</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:adjust-date-to-timezone(xs:date("2002-03-07"),
                                    ())</code> returns <code>2002-03-07.</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"),
                                    ())</code> returns <code>2002-03-07.</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-adjust-time-to-timezone">
                    <head>fn:adjust-time-to-timezone</head>
                    <example role="signature">
                        <proto name="adjust-time-to-timezone" return-type="xs:time" returnEmptyOk="yes">
                            <arg name="arg" type="xs:time" emptyOk="yes"/>
                        </proto>
                    </example>
                    <example role="signature">
                        <proto name="adjust-time-to-timezone" return-type="xs:time" returnEmptyOk="yes">
                            <arg name="arg" type="xs:time" emptyOk="yes"/>
                            <arg name="timezone" type="xs:dayTimeDuration" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p> Summary: Adjusts an <code>xs:time</code> value to a specific timezone, or to
                        no timezone at all. If <code>$timezone</code> is the empty sequence, returns
                        an <code>xs:time</code> without a timezone. Otherwise, returns an
                        <code>xs:time</code> with a timezone.</p>
                    <p> If <code>$timezone</code> is not specified, then <code>$timezone</code> is
                        the value of the implicit timezone in the dynamic context.</p>
                    <p> If <code>$arg</code> is the empty sequence, then the result is the empty sequence.</p>
                    <p> A dynamic error is raised <errorref class="DT" code="0003"/> if
                        <code>$timezone</code> is less than <code>-PT14H</code> or greater than <code>PT14H</code> or if does not contain an integral number of minutes.</p>
                    <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is the empty sequence, then the result is <code>$arg</code>.</p>
                    <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is not the empty sequence, then the result is
                        <code>$arg</code> with <code>$timezone</code> as the timezone component.</p>
                    <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        the empty sequence, then the result is the localized value of
                        <code>$arg</code> without its timezone component.</p>
                    <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        not the empty sequence, then:</p>
                    <ulist>
                        <item>
                            <p> Let <code>$srcdt</code> be an <code>xs:dateTime</code> value, with
                                an arbitrary date for the date component and time and timezone
                                components that are the same as the time and timezone components of <code>$arg</code>.</p>
                        </item>
                        <item>
                            <p> Let <code>$r</code> be the result of evaluating</p>
                            <p>
                                <code>fn:adjust-dateTime-to-timezone($srcdt, $timezone)</code>
                            </p>
                        </item>
                        <item>
                            <p> The result of this function will be a time value that has time and
                                timezone components that are the same as the time and timezone
                                components of <code>$r</code>.</p>
                        </item>
                    </ulist>
                    <div4 id='func-adjust-time-to-timezone-examples'>
                        <head>Examples</head>
                        <p> Assume the dynamic context provides an implicit timezone of <code>-05:00 (-PT5H0M)</code>.</p>
                        <p>
                            <code>let $tz := xs:dayTimeDuration("-PT10H")</code>
                        </p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:adjust-time-to-timezone(xs:time("10:00:00"))</code>
                                    returns <code>10:00:00-05:00</code>
                                </p>
                            </item>
                            <item>
                                <p>

                                    <code>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"))</code>
                                    returns <code>12:00:00-05:00</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:adjust-time-to-timezone(xs:time("10:00:00"),
                                    $tz)</code> returns <code>10:00:00-10:00</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
                                    $tz)</code> returns <code>07:00:00-10:00</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:adjust-time-to-timezone(xs:time("10:00:00"), ())</code>
                                    returns <code>10:00:00</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
                                    ())</code> returns <code>10:00:00</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
                                    xs:dayTimeDuration("PT10H"))</code> returns <code>03:00:00+10:00</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id="dateTime-arithmetic">
                <head>Arithmetic Operators on Durations, Dates and Times</head>
                <p>These functions support adding or subtracting a duration value to or from an
                    <code>xs:dateTime</code>, an <code>xs:date</code> or an <code>xs:time</code>
                    value. Appendix E of <bibref ref="xmlschema-2"/> describes an algorithm for
                    performing such operations.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        
                        <tr>
                            <td>
                                <code>op:subtract-dateTimes</code>
                            </td>
                            <td>Returns the difference between two <code>xs:dateTimes</code> as an <code>xs:dayTimeDuration</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:subtract-dates</code>
                            </td>
                            <td>Returns the difference between two <code>xs:dateTimes</code> as an <code>xs:dayTimeDuration</code>.</td>
                        </tr>
                       
                        <tr>
                            <td>
                                <code>op:subtract-times</code>
                            </td>
                            <td>Returns the difference between two <code>xs:time</code>s as an <code>xs:dayTimeDuration</code>.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:add-yearMonthDuration-to-dateTime</code>
                            </td>
                            <td>Returns the end of a time period by adding an
                                <code>xs:yearMonthDuration</code> to the <code>xs:dateTime</code>
                                that starts the period. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:add-dayTimeDuration-to-dateTime</code>
                            </td>
                            <td>Returns the end of a time period by adding an
                                <code>xs:dayTimeDuration</code> to the <code>xs:dateTime</code>
                                that starts the period. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:subtract-yearMonthDuration-from-dateTime</code>
                            </td>
                            <td>Returns the beginning of a time period by subtracting an
                                <code>xs:yearMonthDuration</code> from the <code>xs:dateTime</code>
                                that ends the period. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:subtract-dayTimeDuration-from-dateTime</code>
                            </td>
                            <td>Returns the beginning of a time period by subtracting an
                                <code>xs:dayTimeDuration</code> from the <code>xs:dateTime</code>
                                that ends the period. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:add-yearMonthDuration-to-date</code>
                            </td>
                            <td>Returns the end of a time period by adding an
                                <code>xs:yearMonthDuration</code> to the <code>xs:date</code> that
                                starts the period. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:add-dayTimeDuration-to-date</code>
                            </td>
                            <td>Returns the end of a time period by adding an
                                <code>xs:dayTimeDuration</code> to the <code>xs:date</code> that
                                starts the period. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:subtract-yearMonthDuration-from-date</code>
                            </td>
                            <td>Returns the beginning of a time period by subtracting an
                                <code>xs:yearMonthDuration</code> from the <code>xs:date</code>
                                that ends the period. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:subtract-dayTimeDuration-from-date</code>
                            </td>
                            <td>Returns the beginning of a time period by subtracting an
                                <code>xs:dayTimeDuration</code> from the <code>xs:date</code> that
                                ends the period. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:add-dayTimeDuration-to-time</code>
                            </td>
                            <td>Adds the value of the hours, minutes and seconds components of an
                                <code>xs:dayTimeDuration</code> to an <code>xs:time</code> value.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:subtract-dayTimeDuration-from-time</code>
                            </td>
                            <td>Subtracts the value of the hours, minutes and seconds components of
                                an <code>xs:dayTimeDuration</code> to an <code>xs:time</code> value.</td>
                        </tr>
                    </tbody>
                </table>
                <!--				<div3 id="func-subtract-dateTimes-yielding-yearMonthDuration">
					<head>fn:subtract-dateTimes-yielding-yearMonthDuration</head>
					<example role="signature">
						<proto name="subtract-dateTimes-yielding-yearMonthDuration" return-type="xs:yearMonthDuration" returnEmptyOk="yes" isOp="no">
							<arg name="arg1" type="xs:dateTime" emptyOk="yes"/>
							<arg name="arg2" type="xs:dateTime" emptyOk="yes"/>
						</proto>
					</example>
					<p>Summary: Returns the
					<code>xs:yearMonthDuration</code> that
					corresponds to the difference between the
					normalized value of <code>$arg1</code> and the
					normalized value of
<code>$arg2</code>. In general, the difference between two
<code>xs:dateTime</code> values will be a duration that contains years
and months as well as days, hours, etc.  This function returns the result
rounded to contain only years and months. The calculation is as
follows:  first the duration is calculated as the value of an
<code>xs:dayTimeDuration</code> in seconds.  Then, starting from
<code>$arg2</code> and counting towards <code>$arg1</code>, the
maximum number of actual whole months in the duration is calculated
rounding towards zero. If there are a remaining number of days, they
are discarded.</p>
<p>If the normalized value of <code>$arg1</code> precedes in time the normalized value of <code>$arg2</code>, the returned value is a negative duration.</p>
					
				<div4>
						<head>Examples</head>
						<ulist>
							<item>
								<p>
									<code>fn:subtract-dateTimes-yielding-yearMonthDuration(xs:dateTime("2000-10-30T11:12:00"), xs:dateTime("1999-11-28T09:00:00"))</code> returns a <code>xs:yearMonthDuration</code> value corresponding to 11 months. </p>
							</item>
			  <item>
								<p>
									<code>fn:subtract-dateTimes-yielding-yearMonthDuration(xs:dateTime("2004-04-30T00:00:00"), xs:dateTime("2004-03-31T09:00:00"))</code> returns a <code>xs:yearMonthDuration</code> value corresponding to 0 months. </p>
							</item>
	      <item>
								<p>
									<code>fn:subtract-dateTimes-yielding-yearMonthDuration(xs:dateTime("2004-04-30T00:00:00"), xs:dateTime("2004-03-28T09:00:00"))</code> returns a <code>xs:yearMonthDuration</code> value corresponding to -1 month. </p>
							</item>
	     
	     
						</ulist>
					</div4>
				</div3> -->
                <div3 id="func-subtract-dateTimes">
                    <head>op:subtract-dateTimes</head>
                    <example role="signature">
                        <proto name="subtract-dateTimes"
                            return-type="xs:dayTimeDuration" returnEmptyOk="yes" isOp="yes">
                            <arg name="arg1" type="xs:dateTime" emptyOk="no"/>
                            <arg name="arg2" type="xs:dateTime" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:dayTimeDuration</code> that corresponds to the
                        difference between the normalized value of <code>$arg1</code> and the
                        normalized value of <code>$arg2</code>. If either <code>$arg1</code>
                        or <code>$arg2</code> do not contain an explicit timezone then, for the
                        purpose of the operation, the implicit timezone provided by the dynamic
                        context (See <xspecref spec="XP"
                        ref="id-xp-evaluation-context-components"/>.) is assumed to be present as
                        part of the value.</p>
                    <p>If the normalized value of <code>$arg1</code> precedes in time the normalized
                        value of <code>$arg2</code>, then the returned value is a negative duration.</p>
                    <p>Backs up the subtract, "-", operator on <code>xs:dateTime</code> values.</p>
                    <div4 id='func-subtract-dateTimes-examples'>
                        <head>Examples</head>
                        <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.</p>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:subtract-dateTimes(xs:dateTime("2000-10-30T06:12:00"),
                                    xs:dateTime("1999-11-28T09:00:00Z"))</code> returns an
                                    <code>xs:dayTimeDuration</code> value corresponding to 337
                                    days, 2 hours and 12 minutes.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-subtract-dates">
                    <head>op:subtract-dates</head>
                    <example role="signature">
                        <proto name="subtract-dates"
                            return-type="xs:dayTimeDuration" returnEmptyOk="yes" isOp="yes">
                            <arg name="arg1" type="xs:date" emptyOk="no"/>
                            <arg name="arg2" type="xs:date" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:dayTimeDuration</code> that corresponds to the
                        difference between the starting instant of <code>$arg1</code> and the
                        the starting instant of <code>$arg2</code>. If either <code>$arg1</code>
                        or <code>$arg2</code> do not contain an explicit timezone then, for the
                        purpose of the operation, the implicit timezone provided by the dynamic
                        context (See <xspecref spec="XP"
                        ref="id-xp-evaluation-context-components"/>.) is assumed to be present as
                        part of the value.
                     </p>
  <p>
The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at <code>00:00:00</code> on that date.
</p>
<p>The result is the result of subtracting the two starting instants using
<code>op:subtract-dateTimes</code>.</p>
                  <p>If the starting instant of <code>$arg1</code> precedes in time the starting instant of <code>$arg2</code>, then the returned value is a negative duration.</p>
                    <p>Backs up the subtract, "-", operator on <code>xs:date</code> values.</p>
                    <div4 id='func-subtract-dates-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>Assume that the dynamic context provides an implicit timezone value of <code>Z</code>. <code>op:subtract-dates(xs:date("2000-10-30"), xs:date("1999-11-28"))</code> returns an
                                    <code>xs:dayTimeDuration</code> value corresponding to 337 days.  The normalized values of the two starting instants are <code>{2000, 10, 30, 0, 0, 0, PT0S}</code> and <code>{1999, 11, 28, 0, 0, 0, PT0S}</code>.</p>
                            </item>
                            <item>
                                <p>If the dynamic context provides an implicit timezone value
                                    of <code>+05:00</code>,
                                        <code>op:subtract-dates(xs:date("2000-10-30"),
                                    xs:date("1999-11-28Z"))</code> returns an
                                    <code>xs:dayTimeDuration</code> value corresponding to 336 days and 19 hours.  The normalized values of the two starting instants are <code>{2000, 10, 29, 19, 0, 0, PT0S}</code> and <code>{1999, 11, 28, 0, 0, 0, PT0S}</code>.</p>
                            </item>
							<item>
                                <p><code>op:subtract-dates(xs:date("2000-10-15-05:00"),
                                    xs:date("2000-10-10+02:00"))</code> returns an
                                    <code>xs:dayTimeDuration</code> value corresponding to lexical form "<code>P5DT7H</code>".</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-subtract-times">
                    <head>op:subtract-times</head>
                    <example role="signature">
                        <proto name="subtract-times" return-type="xs:dayTimeDuration"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:time" emptyOk="no"/>
                            <arg name="arg2" type="xs:time" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:dayTimeDuration</code> that corresponds to the
                        difference between the value of <code>$arg1</code> converted to an <code>xs:dateTime</code> using the date components from the reference <code>xs:dateTime</code> and the
                        value of <code>$arg2</code> converted to an <code>xs:dateTime</code> using the date components from the same reference <code>xs:dateTime</code> . If either <code>$arg1</code>
                        or <code>$arg2</code> do not contain an explicit timezone then, for the
                        purpose of the operation, the implicit timezone provided by the dynamic
                        context (See <xspecref spec="XP"
                        ref="id-xp-evaluation-context-components"/>.) is assumed to be present as
                        part of the value.</p>
<p>The result is the result of subtracting the two <code>xs:dateTime</code>s using
<code>op:subtract-dateTimes</code>.</p>
                    <p>If the value of <code>$arg1</code> converted to an <code>xs:dateTime</code> using the date components from the reference <code>xs:dateTime</code> precedes in time the 
                        value of <code>$arg2</code> converted to an <code>xs:dateTime</code> using the date components from the same reference <code>xs:dateTime</code> , then the returned value is a negative duration.</p>
                    <p>Backs up the subtract, "-", operator on <code>xs:time</code> values.</p>
                    <div4 id='func-subtract-times-examples'>
                        <head>Examples</head>
                        <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.  Assume, also, that the date components of the reference <code>xs:dateTime</code> correspond to <code>"1972-12-31"</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:subtract-times(xs:time("11:12:00Z"),
                                    xs:time("04:00:00"))</code> returns an
                                    <code>xs:dayTimeDuration</code> value corresponding to 2 hours
                                    and 12 minutes. This is obtained by subtracting from the <code>xs:dateTime</code> value <code>{1972, 12, 31, 11, 12, 0, PT0S}</code> the <code>xs:dateTime</code> value <code>{1972, 12, 31, 9, 0, 0, PT0S}</code>.</p>
                            </item>	
							<item>
                                <p>
                                    <code>op:subtract-times(xs:time("11:00:00-05:00"),
                                    xs:time("21:30:00+05:30"))</code> returns a zero
                                    <code>xs:dayTimeDuration</code> value corresponding to the lexical representation <code>"PT0S"</code>.  The two <code>xs:dateTime</code> values are <code>{1972, 12, 31, 11, 0, 0, -PT5H}</code> and <code>{1972, 12, 31, 21, 30, 0, PT5H30M}</code>.
These normalize to  <code>{1972, 12, 31, 16, 0, 0, PT0S}</code> and <code>{1972, 12, 31, 16, 0, 0, PT0S}</code>.
</p>
                            </item>
  							<item>
                                <p>
                                    <code>op:subtract-times(xs:time("17:00:00-06:00"),
                                    xs:time("08:00:00+09:00"))</code> returns an
                                    <code>xs:dayTimeDuration</code> value corresponding to one day or 24 hours. The two normalized <code>xs:dateTime</code> values are <code>{1972, 12, 31, 23, 0, 0, PT0S}</code> and <code>{1972, 12, 30, 23, 0, 0, PT0S}</code>.</p>
                            </item>
							<item>
                                <p>
                                    <code>op:subtract-times(xs:time("24:00:00"), xs:time("23:59:59"))</code> returns an
                                    <code>xs:dayTimeDuration</code> value corresponding to <code>"-PT23H59M59S"</code>. The two normalized <code>xs:dateTime</code> values are <code>{1972, 12, 31, 0, 0, 0, ()}</code> and <code>{1972, 12, 31, 23, 59, 59.0, ()}</code>.</p>
                            </item>
	                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-add-yearMonthDuration-to-dateTime">
                    <head>op:add-yearMonthDuration-to-dateTime</head>
                    <example role="signature">
                        <proto name="add-yearMonthDuration-to-dateTime" return-type="xs:dateTime"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dateTime" emptyOk="no"/>
                            <arg name="arg2" type="xs:yearMonthDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:dateTime</code> computed by adding
                        <code>$arg2</code> to the value of <code>$arg1</code> using the
                        algorithm described in Appendix E of <bibref ref="xmlschema-2"/> disregarding the rule about leap seconds. If
                        <code>$arg2</code> is negative, then the result <code>xs:dateTime</code>
                        precedes <code>$arg1</code>.</p>
                    <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone. </p>
                    <p>This functions backs up the "+" operator on <code>xs:dateTime</code> and
                        <code>xs:yearMonthDuration</code> values. </p>
                    <div4 id='func-add-yearMonthDuration-to-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:add-yearMonthDuration-to-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                                    xs:yearMonthDuration("P1Y2M"))</code> returns an
                                    <code>xs:dateTime</code> value corresponding to the lexical
                                    representation <code>"2001-12-30T11:12:00"</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-add-dayTimeDuration-to-dateTime">
                    <head>op:add-dayTimeDuration-to-dateTime</head>
                    <example role="signature">
                        <proto name="add-dayTimeDuration-to-dateTime" return-type="xs:dateTime"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dateTime" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:dateTime</code> computed by adding
                        <code>$arg2</code> to the value of <code>$arg1</code> using the
                        algorithm described in Appendix E of <bibref ref="xmlschema-2"/> disregarding the rule about leap seconds. If
                        <code>$arg2</code> is negative, then the result <code>xs:dateTime</code>
                        precedes <code>$arg1</code>.</p>
                    <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone.</p>
                    <p>This functions backs up the "+" operator on <code>xs:dateTime</code> and
                        <code>xs:dayTimeDuration</code> values. </p>
                    <div4 id='func-add-dayTimeDuration-to-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:add-dayTimeDuration-to-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                                    xs:dayTimeDuration("P3DT1H15M"))</code> returns an
                                    <code>xs:dateTime</code> value corresponding to the lexical
                                    representation <code>"2000-11-02T12:27:00"</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-subtract-yearMonthDuration-from-dateTime">
                    <head>op:subtract-yearMonthDuration-from-dateTime</head>
                    <example role="signature">
                        <proto name="subtract-yearMonthDuration-from-dateTime"
                            return-type="xs:dateTime" returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:dateTime" emptyOk="no"/>
                            <arg name="arg2" type="xs:yearMonthDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:dateTime</code> computed by negating
                        <code>$arg2</code> and adding the result to the value of
                        <code>$arg1</code> using the algorithm described in Appendix E of <bibref
                        ref="xmlschema-2"/> disregarding the rule about leap seconds. If <code>$arg2</code> is negative, then the
                        <code>xs:dateTime</code> returned follows <code>$arg1</code>.</p>
                    <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone.</p>
                    <p>This functions backs up the "-" operator on <code>xs:dateTime</code> and
                        <code>xs:yearMonthDuration</code> values. </p>
                    <div4 id='func-subtract-yearMonthDuration-from-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:subtract-yearMonthDuration-from-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                                    xs:yearMonthDuration("P1Y2M"))</code> returns an
                                    <code>xs:dateTime</code> value corresponding to the lexical
                                    representation <code>"1999-08-30T11:12:00"</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-subtract-dayTimeDuration-from-dateTime">
                    <head>op:subtract-dayTimeDuration-from-dateTime</head>
                    <example role="signature">
                        <proto name="subtract-dayTimeDuration-from-dateTime" returnEmptyOk="no"
                            isOp="yes" return-type="xs:dateTime">
                            <arg name="arg1" type="xs:dateTime" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:dateTime</code> computed by negating
                        <code>$arg2</code> and adding the result to the value of
                        <code>$arg1</code> using the algorithm described in Appendix E of <bibref
                        ref="xmlschema-2"/> disregarding the rule about leap seconds. If <code>$arg2</code> is negative, then the
                        <code>xs:dateTime</code> returned follows <code>$arg1</code>.</p>
                    <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone.</p>
                    <p>This functions backs up the "-" operator on <code>xs:dateTime</code> and
                        <code>xs:dayTimeDuration</code> values.</p>
                    <div4 id='func-subtract-dayTimeDuration-from-dateTime-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:subtract-dayTimeDuration-from-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                                    xs:dayTimeDuration("P3DT1H15M"))</code> returns an
                                    <code>xs:dateTime</code> value corresponding to the lexical
                                    representation <code>"2000-10-27T09:57:00"</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-add-yearMonthDuration-to-date">
                    <head>op:add-yearMonthDuration-to-date</head>
                    <example role="signature">
                        <proto name="add-yearMonthDuration-to-date" return-type="xs:date"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:date" emptyOk="no"/>
                            <arg name="arg2" type="xs:yearMonthDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:date</code> computed by adding
                        <code>$arg2</code> to the starting instant of <code>$arg1</code> using the
                        algorithm described in Appendix E of <bibref ref="xmlschema-2"/> and discarding the time components from the resulting <code>xs:dateTime</code>. If
                        <code>$arg2</code> is negative, then the <code>xs:date</code> returned
                        precedes <code>$arg1</code>.</p>
<p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at time <code>00:00:00</code> on that date.</p>
                    <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone.</p>
                    <p>This functions backs up the "+" operator on <code>xs:date</code> and
                        <code>xs:yearMonthDuration</code> values. </p>
                    <div4 id='func-add-yearMonthDuration-to-date-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:add-yearMonthDuration-to-date(xs:date("2000-10-30"),
                                    xs:yearMonthDuration("P1Y2M"))</code> returns
                                    the <code>xs:date</code> corresponding to December 30, 2001. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-add-dayTimeDuration-to-date">
                    <head>op:add-dayTimeDuration-to-date</head>
                    <example role="signature">
                        <proto name="add-dayTimeDuration-to-date" return-type="xs:date"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:date" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:date</code> computed by adding
                        <code>$arg2</code> to the starting instant of <code>$arg1</code> using the
                        algorithm described in Appendix E of <bibref ref="xmlschema-2"/> and discarding the time components from the resulting <code>xs:dateTime</code>.  If
                        <code>$arg2</code> is negative, then the <code>xs:date</code> returned
                        precedes <code>$arg1</code>.</p>
<p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at time <code>00:00:00</code> on that date.</p>
                    <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone.</p>
                    <p>This functions backs up the "+" operator on <code>xs:date</code> and
                        <code>xs:dayTimeDuration</code> values. </p>
                    <div4 id='func-subtract-dayTimeDuration-to-date-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:add-dayTimeDuration-to-date(xs:date("2004-10-30Z"),
                                    xs:dayTimeDuration("P2DT2H30M0S"))</code> returns the
                                    <code>xs:date</code> November 1, 2004. The starting instant of the first argument is the <code>xs:dateTime</code> value <code>{2004, 10, 30, 0, 0, 0, PT0S}</code>.  Adding the second argument to this, gives the <code>xs:dateTime</code> value <code>{2004, 11, 1, 2, 30, 0, PT0S}</code>.  The time components are then discarded.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-subtract-yearMonthDuration-from-date">
                    <head>op:subtract-yearMonthDuration-from-date</head>
                    <example role="signature">
                        <proto name="subtract-yearMonthDuration-from-date" return-type="xs:date"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:date" emptyOk="no"/>
                            <arg name="arg2" type="xs:yearMonthDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:date</code> computed by negating
                        <code>$arg2</code> and adding the result to the starting instant of
                        <code>$arg1</code> using the algorithm described in Appendix E of <bibref
                        ref="xmlschema-2"/> and discarding the time components from the resulting <code>xs:dateTime</code>. If <code>$arg2</code> is positive, then the
                        <code>xs:date</code> returned precedes <code>$arg1</code>.</p>
<p>
The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at <code>00:00:00</code> on that date.</p>
                    <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone.</p>
                    <p>This functions backs up the "-" operator on <code>xs:date</code> and
                        <code>xs:yearMonthDuration</code> values. </p>
                    <div4 id='func-subtract-yearMonthDuration-from-date-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:subtract-yearMonthDuration-from-date(xs:date("2000-10-30"),
                                    xs:yearMonthDuration("P1Y2M"))</code> returns the
                                    <code>xs:date</code> August 30, 1999. </p>
                            </item>
                            <item>
                                <p>

                                    <code>op:subtract-yearMonthDuration-from-date(xs:date("2000-02-29Z"),
                                    xs:yearMonthDuration("P1Y"))</code> returns the
                                    <code>xs:date</code> February 28,
                                    1999 in timezone <code>Z</code>. </p>
                            </item>
                            <item>
                                <p>

                                    <code>op:subtract-yearMonthDuration-from-date(xs:date("2000-10-31-05:00"),
                                    xs:yearMonthDuration("P1Y1M"))</code> returns the
                                    <code>xs:date</code> September 30,
                                    1999 in timezone <code>-05:00</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-subtract-dayTimeDuration-from-date">
                    <head>op:subtract-dayTimeDuration-from-date</head>
                    <example role="signature">
                        <proto name="subtract-dayTimeDuration-from-date" return-type="xs:date"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:date" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the <code>xs:date</code> computed by negating
                        <code>$arg2</code> and adding the result to the starting instant of
                        <code>$arg1</code> using the algorithm described in Appendix E of <bibref
                        ref="xmlschema-2"/> and discarding the time components from the resulting <code>xs:dateTime</code>. If <code>$arg2</code> is positive, then the
                        <code>xs:date</code> returned precedes <code>$arg1</code>.</p>
<p>
The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at <code>00:00:00</code> on that date.</p>
                    <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone.</p>
                    <p>This functions backs up the "-" operator on <code>xs:date</code> and
                        <code>xs:dayTimeDuration</code> values. </p>
                    <div4 id='func-subtract-dayTimeDuration-from-date-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>op:subtract-dayTimeDuration-from-date(xs:date("2000-10-30"),
                                    xs:dayTimeDuration("P3DT1H15M"))</code> returns the
                                    <code>xs:date</code> October 26, 2000. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-add-dayTimeDuration-to-time">
                    <head>op:add-dayTimeDuration-to-time</head>
                    <example role="signature">
                        <proto name="add-dayTimeDuration-to-time" return-type="xs:time"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:time" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: First, the days component in the canonical lexical representation of
                        <code>$arg2</code> is set to zero (0) and the value of the resulting
                        <code>xs:dayTimeDuration</code> is calculated. Alternatively, the value of <code>$arg2</code> 
                        modulus 86,400 is used as the second argument. This value is added to the value of
                        <code>$arg1</code> converted to an <code>xs:dateTime</code> using a reference date such as <code>1972-12-31</code> and the time components of the result returned. Note that the
                        <code>xs:time</code> returned may occur in a following or preceding day and
                        may be less than <code>$arg1</code>.</p>
                    <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone.</p>
                    <p>This functions backs up the "+" operator on <code>xs:time</code> and
                        <code>xs:dayTimeDuration</code> values. </p>
                    <div4 id='func-add-dayTimeDuration-to-time-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:add-dayTimeDuration-to-time(xs:time("11:12:00"),
                                    xs:dayTimeDuration("P3DT1H15M"))</code> returns the 
                                    <code>xs:time</code> value corresponding to the lexical
                                    representation "<code>12:27:00</code>". </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:add-dayTimeDuration-to-time(xs:time("23:12:00+03:00"),
                                    xs:dayTimeDuration("P1DT3H15M"))</code> returns the
                                    <code>xs:time</code> value corresponding to the lexical
                                    representation "<code>02:27:00+03:00</code>", i.e. <code>{0, 0, 0, 2, 27, 0, PT3H}</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-subtract-dayTimeDuration-from-time">
                    <head>op:subtract-dayTimeDuration-from-time</head>
                    <example role="signature">
                        <proto name="subtract-dayTimeDuration-from-time" return-type="xs:time"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="arg1" type="xs:time" emptyOk="no"/>
                            <arg name="arg2" type="xs:dayTimeDuration" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: The result is calculated by first setting the day component in the
                        canonical lexical representation of <code>$arg2</code> to zero (0) and
                        calculating the value of the resulting <code>xs:dayTimeDuration</code>.
                        Alternatively, the value of <code>$arg2</code> modulus 86,400 is used as the second argument. This
                        value is subtracted from the value of <code>$arg1</code> converted to an <code>xs:dateTime</code> using a reference date such as <code>1972-12-31</code> and the time components of the
                        result are returned. Note that the <code>xs:time</code> returned may occur in
                        a preceding or following day and may be greater than <code>$arg1</code>.</p>
                    <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone.</p>
                    <p>This functions backs up the "-" operator on <code>xs:time</code> and
                        <code>xs:dayTimeDuration</code> values. </p>
                    <div4 id='func-subtract-dayTimeDuration-from-time-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:subtract-dayTimeDuration-from-time(xs:time("11:12:00"),
                                    xs:dayTimeDuration("P3DT1H15M"))</code> returns an 
                                    <code>xs:time</code> value corresponding to the lexical
                                    representation <code>"09:57:00"</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:subtract-dayTimeDuration-from-time(xs:time("08:20:00-05:00"),
                                    xs:dayTimeDuration("P23DT10H10M"))</code> returns the
                                    <code>xs:time</code> value corresponding to the lexical
                                    representation <code>"22:10:00-05:00"</code> i.e. <code>{0, 0, 0, 22, 10, 0, -PT5H}</code> </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
        </div1>
        <div1 id="QName-funcs">
            <head>Functions Related to QNames</head>
            <div2 id="QName-constructors">
                <head>Additional Constructor Functions for QNames</head>
                <p>
                    <!-- Since the validity of a QName is situation dependent, there is no -->
                    <!-- constructor function for QName defined in <specref -->
                    <!-- ref='constructor-functions'/>. Neither is casting defined for -->
                    <!-- QName from any other type in <specref ref='casting'/>.  --> This section
                    defines additional constructor functions for QName as defined in <bibref
                    ref="xmlschema-2"/>. Leading and trailing whitespace, if present, is stripped from
                    string arguments before the result is constructed.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:resolve-QName</code>
                            </td>
                            <td>Returns an <code>xs:QName</code> with the lexical form given in the
                                first argument. The prefix is resolved using the in-scope namespaces
                                for a given element. </td>
                            <td/>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:QName</code>
                            </td>
                            <td>Returns an <code>xs:QName</code> with the namespace URI given in the
                                first argument and the local name and prefix in the second argument. </td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-resolve-QName">
                    <head>fn:resolve-QName</head>
                    <example role="signature">
                        <proto name="resolve-QName" return-type="xs:QName" returnEmptyOk="yes">
                            <arg name="qname" type="xs:string" emptyOk="yes"/>
                            <arg name="element" type="element()" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:QName</code> value (that is, an expanded-QName)
                        by taking an <code>xs:string</code> that has the lexical form of an
                        <code>xs:QName</code> (a string in the form "prefix:local-name" or
                        "local-name") and resolving it using the in-scope namespaces for a given element.</p>
                    <p>If <code>$qname</code> does not have the correct lexical form
                        for <code>xs:QName</code> an error is raised <errorref class="CA" code="0002"/>.</p>
                    <p>If <code>$qname</code> is the empty sequence, returns the empty sequence.</p>
                    <p> More specifically, the function searches the namespace bindings of
                        <code>$element</code> for a binding whose name matches the prefix of
                        <code>$qname</code>, or the zero-length string if it has no prefix, and
                        constructs an expanded-QName whose local name is taken from the supplied
                        <code>$qname</code>, and whose namespace URI is taken from the string value
                        of the namespace binding.</p>
                    <p> If the <code>$qname</code> has a prefix and if there is no namespace binding
                        for <code>$element</code> that matches this prefix, then an error is raised
                            <errorref class="NS" code="0004"/>.</p>
                    <p> If the <code>$qname</code> has no prefix, and there is no namespace binding for
                        <code>$element</code> corresponding to the default (unnamed) namespace, then
                        the resulting expanded-QName has no namespace part.</p>
                    <p>The prefix (or absence of a prefix) in the supplied <code>$qname</code>
                        argument is retained in the returned expanded-QName, as discussed in
                            <xspecref spec="DM" ref="terminology"/>.</p>
                    <div4 id='func-resolve-QName-uasge'>
                        <head>Usage Note</head>
                        <p> Sometimes the requirement is to construct an <code>xs:QName</code>
                            without using the default namespace. This can be achieved by writing:</p>
                        <eg> if (contains($qname, ":")) then fn:resolve-QName($qname, $element) else
                            fn:QName("", $qname)</eg>
                        <p>If the requirement is to construct an <code>xs:QName</code> using the
                            namespaces in the static context, then the <code>xs:QName</code>
                            constructor should be used.</p>
                    </div4>
                    <div4 id='func-resolve-QName-examples'>
                        <head>Examples</head>
                        <p>Assume that the element bound to <code>$element</code> has a single
                            namespace binding bound to the prefix <code>eg</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:resolve-QName("hello", $element)</code> returns a QName
                                    with local name "hello" that is in no namespace.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:resolve-QName("eg:myFunc", $element)</code> returns an
                                    <code>xs:QName</code> whose namespace URI is specified by the
                                    namespace binding corresponding to the prefix "eg" and whose local
                                    name is "myFunc".</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-QName">
                    <head>fn:QName</head>
                    <example role="signature">
                        <proto name="QName" return-type="xs:QName">
                            <arg name="paramURI" type="xs:string" emptyOk="yes"/>
                            <arg name="paramQName" type="xs:string"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:QName</code> with the namespace URI given in
                        <code>$paramURI</code>. If <code>$paramURI</code> is the zero-length string or the

                        empty sequence, it represents "no namespace"; in this case, if the value
                        
                        of <code>$paramQName</code> contains a colon (<code>:</code>),
                        
                        an error is raised <errorref class="CA" code="0002"/>. 
                        
                        The prefix (or absence of a

                        prefix) in <code>$paramQName</code> is retained in the returned

                        <code>xs:QName</code> value. The local name in the result is taken from the

                        local part of <code>$paramQName</code>.</p>
                    <p>If <code>$paramQName</code> does not have the correct lexical form
                        for 
<code>xs:QName</code> an error is raised <errorref class="CA" code="0002"/>.</p>
                    <p>Note that unlike <code>xs:QName</code> this function does not require
                        a <code>xs:string</code> literal as the argument.</p>
                    <div4 id='func-QName-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:QName("http://www.example.com/example",
                                    "person")</code> returns an <code>xs:QName</code> with namespace
                                    URI = "http://www.example.com/example", local name = "person"
                                    and prefix = "".</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:QName("http://www.example.com/example",
                                    "ht:person")</code> returns an <code>xs:QName</code> with
                                    namespace URI = "http://www.example.com/example", local name =
                                    "person" and prefix = "ht".</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id='QName-functions'>
                <head>Functions and Operators Related to QNames</head>
                <p>This section discusses functions on QNames as defined in <bibref ref="xmlschema-2"/>.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>op:QName-equal</code>
                            </td>
                            <td>Returns <code>true</code> if the local names and namespace URIs of
                                the two arguments are equal.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:prefix-from-QName</code>
                            </td>
                            <td>Returns an <code>xs:NCName</code> representing the prefix of the
                                <code>xs:QName</code> argument. </td>
                        </tr>
<tr>
                            <td>
                                <code>fn:local-name-from-QName</code>
                            </td>
                            <td>Returns an <code>xs:NCName</code> representing the local name of the
                                <code>xs:QName</code> argument. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:namespace-uri-from-QName</code>
                            </td>
                            <td>Returns the namespace URI for the <code>xs:QName</code> argument. If
                                the <code>xs:QName</code> is in no namespace, the zero-length string
                                is returned.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:namespace-uri-for-prefix</code>
                            </td>
                            <td>Returns the namespace URI of one of the in-scope namespaces for the
                                given element, identified by its namespace prefix. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:in-scope-prefixes</code>
                            </td>
                            <td>Returns the prefixes of the in-scope namespaces for the given
                                element. </td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-QName-equal">
                    <head>op:QName-equal</head>
                    <example role="signature">
                        <proto name="QName-equal" return-type="xs:boolean" isOp="yes">
                            <arg name="arg1" type="xs:QName"/>
                            <arg name="arg2" type="xs:QName"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if the namespace URIs of
                        <code>$arg1</code> and <code>$arg2</code> are equal and the local names of
                        <code>$arg1</code> and <code>$arg2</code> are identical based on the Unicode code point
                        collation (<code>&codepoint.collation;</code>). Otherwise, returns <code>false</code>. Two namespace URIs are
                        considered equal if they are either both absent or both present and
                        identical based on the Unicode code point
                        collation. The prefix parts of
                        <code>$arg1</code> and <code>$arg2</code>, if any, are ignored.</p>
                    <p>Backs up the "eq" and "ne" operators on values of type <code>xs:QName</code>. </p>
                </div3>
             <div3 id="func-prefix-from-QName">
                    <head>fn:prefix-from-QName</head>
                    <example role="signature">
                        <proto name="prefix-from-QName" return-type="xs:NCName" returnEmptyOk="yes">
                            <arg name="arg" type="xs:QName" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:NCName</code> representing the prefix of
                        <code>$arg</code>. The empty sequence is returned if <code>$arg</code> is the empty sequence or if the value of <code>$arg</code> contains no prefix. </p>
                </div3>
                <div3 id="func-local-name-from-QName">
                    <head>fn:local-name-from-QName</head>
                    <example role="signature">
                        <proto name="local-name-from-QName" return-type="xs:NCName" returnEmptyOk="yes">
                            <arg name="arg" type="xs:QName" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns an <code>xs:NCName</code> representing the local part of
                        <code>$arg</code>. If <code>$arg</code> is the empty sequence, returns the
                        empty sequence.</p>
                    <div4 id='func-local-name-from-QName-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:local-name-from-QName(fn:QName("http://www.example.com/example",
                                    "person"))</code> returns <code>"person"</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-namespace-uri-from-QName">
                    <head>fn:namespace-uri-from-QName</head>
                    <example role="signature">
                        <proto name="namespace-uri-from-QName" return-type="xs:anyURI" returnEmptyOk="yes">
                            <arg name="arg" type="xs:QName" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the namespace URI for <code>$arg</code> as an
                        <code>xs:string</code>. If <code>$arg</code> is the empty sequence, the
                        empty sequence is returned. If <code>$arg</code> is in no namespace, the
                        zero-length string is returned.</p>
                    <p/>
                    <div4 id='func-namespace-uri-from-QName-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>

                                    <code>fn:namespace-uri-from-QName(fn:QName("http://www.example.com/example",
                                    "person"))</code> returns the namespace URI corresponding to
                                    <code>"http://www.example.com/example"</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-namespace-uri-for-prefix">
                    <head>fn:namespace-uri-for-prefix</head>
                    <example role="signature">
                        <proto name="namespace-uri-for-prefix" return-type="xs:anyURI" returnEmptyOk="yes">
                            <arg name="prefix" type="xs:string" emptyOk="yes"/>
                            <arg name="element" type="element()" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the namespace URI of one of the in-scope namespaces for
                        <code>$element</code>, identified by its namespace prefix.</p>
                    <p> If <code>$element</code> has an in-scope namespace whose namespace prefix is
                        equal to <code>$prefix</code>, it returns the namespace URI of that
                        namespace. If <code>$prefix</code> is the zero-length string or the empty sequence, it returns the
                        namespace URI of the default (unnamed) namespace. Otherwise, it returns the
                        empty sequence.</p>
                    <p>Prefixes are equal only if their Unicode code points match exactly.</p>
                </div3>
                <div3 id="func-in-scope-prefixes">
                    <head>fn:in-scope-prefixes</head>
                    <example role="signature">
                        <proto name="in-scope-prefixes" return-type="xs:string*" returnEmptyOk="no">
                            <arg name="element" type="element()" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the prefixes of the in-scope namespaces for
                        <code>$element</code>. For namespaces that have a prefix, it returns the
                        prefix as an <code>xs:NCName</code>. For the default namespace, which has no
                        prefix, it returns the zero-length string. </p>
                </div3>
            </div2>
        </div1>
        <div1 id='binary-functions'>
            <head>Operators on base64Binary and hexBinary</head>
            <div2 id='binary-value-comparisons'>
                <head>Comparisons of base64Binary and hexBinary Values</head>
                <p>The following comparison operators on <code>xs:base64Binary</code> and
                    <code>xs:hexBinary</code> values are defined. Comparisons take two operands of
                    the same type; that is, both operands must be <code>xs:base64Binary</code> or
                    both operands may be <code>xs:hexBinary</code>. Each returns a boolean value.</p>
                <p>A value of type <code>xs:hexBinary</code> can be compared with a value of type
                    <code>xs:base64Binary</code> by casting one value to the other type. See
                        <specref ref="casting-to-binary"/>.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>op:hexBinary-equal</code>
                            </td>
                            <td>Returns <code>true</code> if the two arguments are equal. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:base64Binary-equal</code>
                            </td>
                            <td>Returns <code>true</code> if the two arguments are equal. </td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-hexBinary-equal">
                    <head>op:hexBinary-equal</head>
                    <example role="signature">
                        <proto name="hexBinary-equal" return-type="xs:boolean" isOp="yes">
                            <arg name="value1" type="xs:hexBinary" emptyOk="no"/>
                            <arg name="value2" type="xs:hexBinary" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if <code>$value1</code> and
                        <code>$value2</code> are of the same length, measured in binary octets, and
                        contain the same octets in the same order. Otherwise, returns
                        <code>false</code>. </p>
                    <p>This function backs up the "eq" and "ne" operators on
                        <code>xs:hexBinary</code> values.</p>
                </div3>
                <div3 id="func-base64Binary-equal">
                    <head>op:base64Binary-equal</head>
                    <example role="signature">
                        <proto name="base64Binary-equal" return-type="xs:boolean" isOp="yes">
                            <arg name="value1" type="xs:base64Binary" emptyOk="no"/>
                            <arg name="value2" type="xs:base64Binary" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>true</code> if <code>$value1</code> and
                        <code>$value2</code> are of the same length, measured in binary octets, and
                        contain the same octets in the same order. Otherwise, returns <code>false</code>.</p>
                    <p>This function backs up the "eq" and "ne" operators on
                        <code>xs:base64Binary</code> values.</p>
                </div3>
            </div2>
        </div1>
        <div1 id='NOTATION-functions'>
            <head>Operators on NOTATION</head>
            <div2 id='op.NOTATION'>
                <head>Operators on NOTATION</head>
                <p>This section discusses functions that take NOTATION as arguments.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>op:NOTATION-equal</code>
                            </td>
                            <td>Returns <code>true</code> if the two arguments are <code>op:QName-equal</code>. </td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-NOTATION-equal">
                    <head>op:NOTATION-equal</head>
                    <example role="signature">
                        <proto name="NOTATION-equal" return-type="xs:boolean" isOp="yes">
                            <arg name="arg1" type="xs:NOTATION"/>
                            <arg name="arg2" type="xs:NOTATION"/>
                        </proto>
                    </example>
                   
<p>
 Summary: Returns <code>true</code> if the namespace URIs of 
<code>$arg1</code> and <code>$arg2</code> are
    equal and the local names of <code>$arg1</code> and <code>$arg2</code>
    are identical based
    on the Unicode code point collation: <code>&codepoint.collation;</code>. Otherwise,
    returns false. Two namespace URIs are considered equal if they are
    either both absent or both present and identical based on the
    Unicode code point collation. The prefix parts of <code>$arg1</code> and 
    <code>$arg2</code>, if any, are ignored.
</p>
                    <p>Backs up the "eq" and "ne" operators on values of type <code>xs:NOTATION</code>. </p>
                </div3>
            </div2>
        </div1>
        <div1 id='node-functions'>
            <head>Functions and Operators on Nodes</head>
            <p>This section discusses functions and operators on nodes. Nodes are formally defined
                in <xspecref spec="DM" ref="Node"/>.</p>
            <!--	<div2>
				<head>Functions and Operators on Nodes</head> -->
            <table border="1" summary="Function/operator summary">
                <thead>
                    <tr>
                        <th>Function</th>
                        <th>Meaning</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <code>fn:name</code>
                        </td>
                        <td>Returns the name of the context node or the specified node as an
                            <code>xs:string</code>. </td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:local-name</code>
                        </td>
                        <td>Returns the local name of the context node or the specified node as an
                            <code>xs:NCName</code>. </td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:namespace-uri</code>
                        </td>
                        <td>Returns the namespace URI as an <code>xs:anyURI</code> for the
                            <code>xs:QName</code> of the argument node or the context node if the
                            argument is omitted. This may be the URI corresponding to the
                            zero-length string if the <code>xs:QName</code> is in no namespace. </td>
                        <td/>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:number</code>
                        </td>
                        <td>Returns the value of the context item after atomization or the specified
                            argument converted to an <code>xs:double</code>.</td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:lang</code>
                        </td>
                        <td>Returns <code>true</code> or <code>false</code>, depending on whether the
                            language of the given node or the context node, as defined using the
                            xml:lang attribute, is the same as, or a sublanguage of, the language
                            specified by the argument. </td>
                    </tr>
                    <tr>
                        <td>
                            <code>op:is-same-node</code>
                        </td>
                        <td>Returns <code>true</code> if the two arguments have the same identity. </td>
                    </tr>
                    <tr>
                        <td>
                            <code>op:node-before</code>
                        </td>
                        <td>Indicates whether one node appears before another node in document
                            order. </td>
                    </tr>
                    <tr>
                        <td>
                            <code>op:node-after</code>
                        </td>
                        <td>Indicates whether one node appears after another node in document order. </td>
                    </tr>
                    <!-- Decision at 2002-07 F2F to delete op:node-precedes and op:node-follows -->
                    <!--						<tr>
							<td>
								<code>fn:copy</code>
							</td>
							<td>Returns a deep copy of a node. Not supported in XSLT.</td>
							</tr> -->
                    <!-- Note 9/13/2002 with decision to remove fn:copy() -->
                    <!-- Don Chamberlin email, 2002-07-27 and F2F decision 2002-07-31 delete fn:shallow -->
                    <tr>
                        <td>
                            <code>fn:root</code>
                        </td>
                        <td>Returns the root of the tree to which the node argument belongs.</td>
                    </tr>
                </tbody>
            </table>
            <p>For the illustrative examples below assume an XQuery or transformation operating on a
                PurchaseOrder document containing a number of line-item elements. Each line-item has
                child elements called description, price, quantity, etc. whose content is different
                for each line-item. Quantity has simple content of type <code>xs:decimal</code>.
                Further assume that variables <code>$item1</code>, <code>$item2</code>, etc. are
                each bound to single line-item element nodes in the document in sequence and that
                the value of the quantity child of the first line-item is <code>5.0</code>.</p>
            <eg><![CDATA[<PurchaseOrder>
  <line-item>
    <description> ... </description>
    <price> ... </price>
    <quantity>5.0</quantity>
      ...
  </line-item>
  <line-item>
      ...
  </line-item>
      ...
</PurchaseOrder>]]></eg>
            <div2 id="func-name">
                <head>fn:name</head>
                <example role="signature">
                    <proto name="name" return-type="xs:string"/>
                    <proto name="name" return-type="xs:string">
                        <!-- Don Chamberlin email, 2002-07-27 -->
                        <arg name="arg" type="node()" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Summary: Returns the name of a node, as an <code>xs:string</code> that is either
                    the zero-length string, or has the lexical form of an <code>xs:QName</code>. </p>
<p>If the argument is omitted, it defaults to the context item (<code>.</code>).
The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.</p> 
<p>The following errors may be raised:  if the context item is undefined <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
                <p>If the argument is supplied and is the empty sequence, the function returns the
                    zero-length string.</p>
               <p>If the target node has no name (that is, if it is a document node, a comment, a
                    text node, or a namespace binding having no name), the function returns the
                    zero-length string.</p>
                <p>Otherwise, the value returned is <code>fn:string(fn:node-name($arg))</code>.</p>
                <!--
					<p>Otherwise, the value returned is an <code>xs:string</code> whose lexical form is an <code>xs:QName</code>. </p>

					<p>If <code>$arg</code> is a processing
					instruction or a namespace binding, or if it is an
					element or attribute node whose expanded-QName (as
					determined by the <code>dm:node-name</code>
					accessor in the <xspecref spec="DM" ref="dm-node-name"/>) is in
					no namespace, then the function returns the local
					part of the expanded-QName.</p>
<p>If <code>$arg</code> is an attribute node whose
					expanded-QName is in a namespace, then a prefix is
					determined using the following
rule: if the attribute has a parent, in the same way that a prefix
would be constructed for that element, otherwise a non-empty prefix is
chosen in an <termref def='implementation-dependent'/> manner, and no attempt is made to associate the prefix with the namespace URI.</p>
<p>If <code>$arg</code> is an element node whose
					expanded-QName is in a namespace, then a prefix is
					determined using the following rules: if the
					element has at least one namespace binding whose
					namespace URI is the same as the namespace name of
					the <code>xs:QName</code> returned by the
					<code>fn:node-name</code>, it returns the local part
					of the name of that namespace binding or the empty
					string if the namespace binding has no name. If there
					are several such namespace bindings, it chooses one
					of them in an <termref
def='implementation-dependent'/> manner. If there is no such namespace
					node, it generates an arbitrary prefix that is
					distinct from the <code>fn:node-name</code> of any of the
					element node's namespaces. The prefix is the empty
					string if the element has an empty namespace name
					i.e. if it is in the null namespace.
</p>
<p>This prefix is then combined with the local part of the node's expanded-QName to form a string which will take one of the forms "prefix:local-part" (if the prefix is a non-zero length string) or "local-part" (if the prefix is a zero-length string). 
</p> 
<note><p>Some host languages, such as <bibref ref='xquery'/>, will
never provide a namespace binding as an argument to this function.</p></note> -->
            </div2>
            <div2 id="func-local-name">
                <head>fn:local-name</head>
                <example role="signature">
                    <proto name="local-name" return-type="xs:string"/>
                    <proto name="local-name" return-type="xs:string">
                        <!-- Don Chamberlin email, 2002-07-27 -->
                        <arg name="arg" type="node()" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Summary: Returns the local part of the name of <code>$arg</code> as an
                    <code>xs:string</code> that will either be the zero-length string or will have
                    the lexical form of an <code>xs:NCName</code>.</p>
                <p>If the argument is omitted, it defaults to the context item (<code>.</code>).
The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.</p> 
<p>The following errors may be raised:  if the context item is undefined <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node 
<xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
                <p>If the argument is supplied and is the empty sequence, the function returns the zero-length string.</p>
                <p>If the target node has no name (that is, if it is a document node, a comment, or
                    a text node), the function returns the zero-length string.</p>
                <p>Otherwise, the value returned will be the local part of the expanded-QName of the
                  target node (as determined by the <code>dm:node-name</code> accessor in <xspecref
                        spec="DM" ref="dm-node-name"/>. This will be an <code>xs:string</code> whose
                    lexical form is an <code>xs:NCName</code>.</p>
            </div2>
            <div2 id="func-namespace-uri">
                <head>fn:namespace-uri</head>
                <example role="signature">
                    <proto name="namespace-uri" return-type="xs:anyURI" returnEmptyOk="no"/>
                    <proto name="namespace-uri" return-type="xs:anyURI" returnEmptyOk="no">
                        <arg name="arg" type="node()" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Summary: Returns the namespace URI of the <code>xs:QName</code> of <code>$arg</code>.</p>
                <p>If the argument is omitted, it defaults to the context node (<code>.</code>). The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.</p> 
<p>The following errors may be raised:  if the context item is undefined <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
                <p>If <code>$arg</code> is neither an element nor an attribute node, or if it is an
                    element or attribute node whose expanded-QName (as determined by the
                    <code>dm:node-name</code> accessor in the <xspecref spec="DM"
                    ref="dm-node-name"/>) is in no namespace, then the function returns the
                    <code>xs:anyURI</code> corresponding to the zero-length string.</p>
                <!-- Don Chamberlin email, 2002-07-27 deleted type exception/fallback conversion text -->
            </div2>
            <div2 id="func-number">
                <head>fn:number</head>
                <example role="signature">
                    <proto name="number" return-type="xs:double"/>
                    <proto name="number" return-type="xs:double">
                        <arg name="arg" type="xs:anyAtomicType" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Summary: Returns the value indicated by <code>$arg</code> or, if
                    <code>$arg</code> is not specified, the context item after atomization,
                    converted to an <code>xs:double</code></p>
<p>Calling the zero-argument version of the function is defined to give the same
                    result as calling the single-argument version with the context item (<code>.</code>). That is,
                    <code>fn:number()</code> is equivalent to <code>fn:number(.)</code>.</p> 
<p>If <code>$arg</code> is the empty
                    sequence or if <code>$arg</code> or the context item cannot be converted to an
                    <code>xs:double</code>, the <code>xs:double</code> value <code>NaN</code> is
                    returned. If the context item is undefined an error is raised: <xerrorref spec="XP" class="DY" code="0002" type="type"/>.</p>
                
                <p>If <code>$arg</code> is the empty sequence, <code>NaN</code> is returned.
                    Otherwise, <code>$arg</code>, or the context item after atomization, is
                    converted to an <code>xs:double</code> following the rules of <specref
                    ref="casting-to-double"/>. If the conversion to <code>xs:double</code> fails,
                    the <code>xs:double</code> value <code>NaN</code> is returned.</p>
                <div3 id='func-number-examples'>
                    <head>Examples</head>
                    <ulist>
                        <item>
                            <p>
                                <code>fn:number($item1/quantity)</code> returns <code>5.0</code>. </p>
                        </item>
                        <item>
                            <p>
                                <code>fn:number($item2)</code> returns <code>NaN</code>.</p>
                        </item>
                        <item>
                            <p>Assume that the context item is the <code>xs:string</code>
                                "<code>15</code>". <code>fn:number()</code> returns <code>1.5E1</code>.</p>
                        </item>
                    </ulist>
                </div3>
            </div2>
            <div2 id="func-lang">
                <head>fn:lang</head>
                <example role="signature">
                    <proto name="lang" return-type="xs:boolean">
                        <arg name="testlang" type="xs:string" emptyOk="yes"/>
                    </proto>
                </example>
                <example role="signature">
                    <proto name="lang" return-type="xs:boolean">
                        <arg name="testlang" type="xs:string" emptyOk="yes"/>
                        <arg name="node" type="node()" emptyOk="no"/>
                    </proto>
                </example>
                <p>Summary: This function tests whether the language of <code>$node</code>, or the
                    context item if the second argument is omitted, as specified by
                    <code>xml:lang</code> attributes is the same as, or is a sublanguage of, the
                    language specified by <code>$testlang</code>. The behavior of the function if the second argument is omitted is exactly the same as if the context item  (<code>.</code>) had been passed as the second argument.  The language of the argument node,
                    or the context item if the second argument is omitted, is determined by the
                    value of the <code>xml:lang</code> attribute on the node, or, if the node has no
                    such attribute, by the value of the <code>xml:lang</code> attribute on the
                    nearest ancestor of the node that has an <code>xml:lang</code> attribute. If
                    there is no such ancestor, then the function returns <code>false</code>
                </p>
<p>The following errors may be raised:  if the context item is undefined <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node 
<xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
                <p>If <code>$testlang</code> is the empty sequence it is interpreted as the
                    zero-length string.</p>
                <p>The relevant <code>xml:lang</code> attribute is determined by the value of the
                    XPath expression:</p>
                <p>
                    <eg><![CDATA[(ancestor-or-self::*/@xml:lang)[last()]]]></eg>
                </p>
                <p>If this expression returns an empty sequence, the function returns
                    <code>false</code>. </p>
<p>
Otherwise, the function returns <code>true</code> if and only if, based on a caseless default match as specified in section 3.13 of <bibref ref="Unicode4"/>, either:
<olist>
<item><p>
(1) <code>$testlang</code> is equal to the string-value of the relevant <code>xml:lang</code> attribute, or</p></item>
<item><p> (2) <code>$testlang</code> is equal to some substring of the string-value of the relevant <code>xml:lang</code> attribute that starts at the start of the string-value and ends immediately before a hyphen, "-" (The character "-" is
                    HYPHEN-MINUS, #x002D).
</p></item></olist>
</p>
                <div3 id='func-lang-examples'>
                    <head>Examples</head>
                    <ulist>
                        <item>
                            <p>The expression <code>fn:lang("en")</code> would return
                                <code>true</code> if the context node were any of the following four elements:</p>
                            <ulist>
                                <item>
                                    <p>
                                        <code>&lt;para xml:lang="en"/&gt;</code>
                                    </p>
                                </item>
                                <item>
                                    <p>
                                        <code>&lt;div xml:lang="en"&gt;&lt;para&gt;And now,
                                            and forever!&lt;/para&gt;&lt;/div&gt;</code>
                                    </p>
                                </item>
                                <item>
                                    <p>
                                        <code>&lt;para xml:lang="EN"/&gt;</code>
                                    </p>
                                </item>
                                <item>
                                    <p>
                                        <code>&lt;para xml:lang="en-us"/&gt;</code>
                                    </p>
                                </item>
                            </ulist>
                        </item>
                        <item>
                            <p>The expression <code>fn:lang("fr")</code> would return
                                <code>false</code> if the context node were <code>&lt;para xml:lang="EN"/&gt;</code>
                            </p>
                        </item>
                    </ulist>
                </div3>
            </div2>
            <div2 id="func-is-same-node">
                <head>op:is-same-node</head>
                <example role="signature">
                    <proto name="is-same-node" return-type="xs:boolean" isOp="yes">
                        <arg name="parameter1" type="node()"/>
                        <arg name="parameter2" type="node()"/>
                    </proto>
                </example>
                <p>Summary: If the node identified by the value of <code>$parameter1</code> is the
                    same node as the node identified by the value of <code>$parameter2</code> (that
                    is, the two nodes have the same identity), then the function returns
                    <code>true</code>; otherwise, the function returns <code>false</code>. This
                    function backs up the "is" operator on nodes.</p>
                <div3 id="func-is-same-node-examples">
                    <head>Examples</head>
                    <ulist>
                        <item>
                            <p>
                                <code>op:is-same-node($item1, $item1)</code> returns
                                <code>true</code>. </p>
                        </item>
                        <item>
                            <p>
                                <code>op:is-same-node($item1, $item2)</code> returns
                                <code>false</code>. </p>
                        </item>
                    </ulist>
                </div3>
            </div2>
            <div2 id="func-node-before">
                <head>op:node-before</head>
                <example role="signature">
                    <proto name="node-before" return-type="xs:boolean" isOp="yes">
                        <arg name="parameter1" type="node()"/>
                        <arg name="parameter2" type="node()"/>
                    </proto>
                </example>
                <p>Summary: If the node identified by the value of <code>$parameter1</code> occurs
                    in document order before the node identified by the value of
                    <code>$parameter2</code>, this function returns <code>true</code>; otherwise, it
                    returns <code>false</code>. The rules determining the order of nodes within a
                    single document and in different documents can be found in <xspecref spec="DM"
                    ref="document-order"/>. This function backs up the "&lt;&lt;" operator.</p>
                <div3 id="func-node-before-examples">
                    <head>Examples</head>
                    <ulist>
                        <item>
                            <p>
                                <code>op:node-before($item1, $item2)</code> returns
                                <code>true</code>. </p>
                        </item>
                        <item>
                            <p>
                                <code>op:node-before($item1, $item1)</code> returns
                                <code>false</code>. </p>
                        </item>
                    </ulist>
                </div3>
            </div2>
            <div2 id="func-node-after">
                <head>op:node-after</head>
                <example role="signature">
                    <proto name="node-after" return-type="xs:boolean" isOp="yes">
                        <arg name="parameter1" type="node()"/>
                        <arg name="parameter2" type="node()"/>
                    </proto>
                </example>
                <p>Summary: If the node identified by the value of <code>$parameter1</code> occurs
                    in document order after the node identified by the value of
                    <code>$parameter2</code>, this function returns <code>true</code>; otherwise, it
                    returns <code>false</code>. The rules determining the order of nodes within a
                    single document and in different documents can be found in <xspecref spec="DM"
                    ref="document-order"/>. This function backs up the "&gt;&gt;" operator.</p>
                <div3 id="func-node-after-examples">
                    <head>Examples</head>
                    <ulist>
                        <item>
                            <p>
                                <code>op:node-after($item1, $item2)</code> returns
                                <code>false</code>. </p>
                        </item>
                        <item>
                            <p>
                                <code>op:node-after($item1, $item1)</code> returns
                                <code>false</code>. </p>
                        </item>
                        <item>
                            <p>
                                <code>op:node-after($item2, $item1)</code> returns
                                <code>true</code>. </p>
                        </item>
                    </ulist>
                </div3>
            </div2>
            <!-- Decision at 2002-07 F2F to delete op:node-precedes and op:node-follows -->
            <!--				<div2 id="func-copy">
					<head>fn:copy</head>
					<example role="signature">
						<proto name="copy" return-type="node()" returnEmptyOk="yes">
							<arg name="arg" type="node()" emptyOk="yes"/>
						</proto>
					</example>
					<p>Returns a copy of the node that is the value of <code>$arg</code> including all its attributes and descendants; the copy has a different identity than the node indicated by the value of <code>$arg</code>. </p>
					<note>
						<p>XSLT will not support this function.</p>
					</note>
					
					<div3>
						<head>Examples</head>
						<p>
							<code>$var = fn:copy($item1)</code> creates a node that is a copy of the value of $item1, including its attributes and descendants, gives it a different identity, and sets the value of $var equal to it. Assume that the value of <code>$item1</code> was the element node:</p>
						<eg>
   &lt;family name='green'&gt;
      &lt;father&gt;peter&lt;/father&gt;
      &lt;mother&gt;mary&lt;mother&gt;
      &lt;child&gt;joseph&lt;/child&gt;
   &lt;/family&gt;
</eg>
						<p>The value of <code>$var</code> would be</p>
						<eg>
   &lt;family name='green'&gt;
      &lt;father&gt;peter&lt;/father&gt;
      &lt;mother&gt;mary&lt;mother&gt;
      &lt;child&gt;joseph&lt;/child&gt;
   &lt;/family&gt;
</eg>
					</div3>
				</div2>  -->
            <!-- Don Chamberlin email, 2002-07-27 and F2F decision 2002-07-31 deleted fn:shallow -->
            <div2 id="func-root">
                <head>fn:root</head>
                <example role="signature">
                    <proto name="root" return-type="node()" returnEmptyOk="no"/>
                </example>
                <example role="signature">
                    <proto name="root" return-type="node()" returnEmptyOk="yes">
                        <arg name="arg" type="node()" emptyOk="yes"/>
                    </proto>
                </example>
                <p>Summary: Returns the root of the tree to which <code>$arg</code> belongs. This
                    will usually, but not necessarily, be a document node.</p>
                <p> If <code>$arg</code> is the empty sequence, the empty sequence is returned.</p>
                <p>If <code>$arg</code> is a document node, <code>$arg</code> is returned.</p>
                <p>If the function is called without an argument, the context item (<code>.</code>) is used as the
                    default argument. The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.</p> 
<p>The following errors may be raised:  if the context item is undefined <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
                <div3 id="func-root-examples">
                    <head>Examples</head>
                    <p>These examples use some variables which could be defined in <bibref
                        ref="xquery"/> as:</p>
                    <p>
                        <eg><![CDATA[let $i := <tool>wrench</tool>
let $o := <order> {$i} <quantity>5</quantity> </order>
let $odoc := document {$o}
let $newi := $o/tool]]></eg>
                    </p>
                    <p>Or they could be defined in <bibref ref="xslt20"/> as:</p>
                    <p>
                        <eg><![CDATA[<xsl:variable name="i" as="element()">
  <tool>wrench</tool>
</xsl:variable>

<xsl:variable name="o" as="element()">
  <order>
    <xsl:copy-of select="$i"/>
    <quantity>5</quantity>
  </order>
</xsl:variable>

<xsl:variable name="odoc">
  <xsl:copy-of select="$o"/>
</xsl:variable>

<xsl:variable name="newi" select="$o/tool"/>]]></eg>
                    </p>
                    <ulist>
                        <item>
                            <p>
                                <code>fn:root($i)</code> returns <code>$i</code>
                            </p>
                        </item>
                        <item>
                            <p>
                                <code>fn:root($o/quantity)</code> returns <code>$o</code>
                            </p>
                        </item>
                        <item>
                            <p>
                                <code>fn:root($odoc//quantity)</code> returns <code>$odoc</code>
                            </p>
                        </item>
                        <item>
                            <p>
                                <code>fn:root($newi)</code> returns <code>$o</code>
                            </p>
                        </item>
                    </ulist>
                    <note>
                        <p>The final three examples could be made type-safe by wrapping their operands with fn:exactly-one().</p>
                    </note>
                </div3>
            </div2>
            <!--		</div2> -->
        </div1>
        <div1 id='sequence-functions'>
            <head>Functions and Operators on Sequences</head>
            <p>A <code>sequence</code> is an ordered collection of zero or more <code>items</code>.
                An <code>item</code> is either a node or an atomic value. The terms
                <code>sequence</code> and <code>item</code> are defined formally in <bibref
                ref="xquery"/> and <bibref ref="xpath20"/>. </p>
            <div2 id="general-seq-funcs">
                <head>General Functions and Operators on Sequences</head>
                <p>The following functions are defined on sequences.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:boolean</code>
                            </td>
                            <td>Computes the effective boolean value of the argument sequence.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:concatenate</code>
                            </td>
                            <td>Concatenates two sequences. </td>
                        </tr>
                        <!--			<tr>
							<td>
								<code>fn:item-at</code>
							</td>
							<td>Returns the item at the given index. </td>
						</tr> -->
                        <tr>
                            <td>
                                <code>fn:index-of</code>
                            </td>
                            <td>Returns a sequence of <code>xs:integer</code>s, each of which is the
                                index of a member of the sequence specified as the first argument
                                that is equal to the value of the second argument. If no members of
                                the specified sequence are equal to the value of the second
                                argument, the empty sequence is returned. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:empty</code>
                            </td>
                            <td>Indicates whether or not the provided sequence is empty. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:exists</code>
                            </td>
                            <td>Indicates whether or not the provided sequence is not empty. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:distinct-values</code>
                            </td>
                            <td>Returns a sequence in which all but one of a set of duplicate
                                values, based on value equality, have been deleted. The order in
                                which the distinct values are returned is <termref
                                def="implementation-dependent"/>. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:insert-before</code>
                            </td>
                            <td>Inserts an item or sequence of items at a specified position in a
                                sequence. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:remove</code>
                            </td>
                            <td>Removes an item from a specified position in a sequence. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:reverse</code>
                            </td>
                            <td>Reverses the order of items in a sequence.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:subsequence</code>
                            </td>
                            <td>Returns the subsequence of a given sequence, identified by location. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:unordered</code>
                            </td>
                            <td>Returns the items in the given sequence in a non-deterministic
                                order. </td>
                        </tr>
                    </tbody>
                </table>
                <p>As in the previous section, for the illustrative examples below, assume an XQuery
                    or transformation operating on a non-empty Purchase Order document containing a
                    number of line-item elements. The variable <code>$seq</code> is bound to the
                    sequence of line-item nodes in document order. The variables
                    <code>$item1</code>, <code>$item2</code>, etc. are bound to separate, individual
                    line-item nodes in the sequence.</p>
                <div3 id="func-boolean">
                    <head>fn:boolean</head>
                    <example role="signature">
                        <proto name="boolean" return-type="xs:boolean">
                            <arg name="arg" type="item()*"/>
                        </proto>
                    </example>
                    <p>Summary: Computes the effective boolean value of the sequence
                        <code>$arg</code>. See <xspecref spec="XP" ref="id-ebv"/>
                    </p>
<ulist>
<item><p>If <code>$arg</code> is the empty sequence, <code>fn:boolean</code> returns <code>false</code>.</p></item>
<item><p>If <code>$arg</code> is a sequence whose first item is a node, <code>fn:boolean</code> returns <code>true</code>.</p></item>
<item><p>If <code>$arg</code> is a singleton value of type <code>xs:boolean</code> or a derived from <code>xs:boolean</code>, <code>fn:boolean</code> returns <code>$arg</code>.</p></item>
<item><p>If <code>$arg</code> is a singleton value of type <code>xs:string</code> or a type derived from <code>xs:string</code>, <code>xs:anyURI</code> or a type derived from <code>xs:anyURI</code> or <code>xs:untypedAtomic</code>, <code>fn:boolean</code> returns <code>false</code> if the operand value has zero length; otherwise it returns <code>true</code>.</p></item>
<item><p>If <code>$arg</code> is a singleton value of any numeric type or a type derived from a numeric type, <code>fn:boolean</code> returns <code>false</code> if the operand value is <code>NaN</code> or is numerically equal to zero; otherwise it returns <code>true</code>.</p></item>
<item><p>In all other cases, <code>fn:boolean</code> raises a type error <errorref
                            class="RG" code="0006"/>.</p></item>
</ulist>
 <p>The static semantics of this function are described in <xspecref spec="FS" ref="sec_fn_boolean"/>.</p>
                    <note>
                        <p>The result of this function is not necessarily the same as <quote>
                                <code>$arg cast as xs:boolean</code>
                            </quote>. For example, <code>fn:boolean("false")</code> returns the
                            value <code>"true"</code> whereas "<code>false</code>" <code>cast as
                            xs:boolean</code> returns <code>false</code>.</p>
                    </note>
                    <div4 id='func-boolean-examples'>
                        <head>Examples</head>
                        <p>let <code>$x := ("a", "b", "c")</code>
                        </p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:boolean($x)</code> raises a type error <errorref class="RG" code="0006"/>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:boolean($x[1])</code> returns <code>true</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:boolean($x[0])</code> returns <code>false</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-concatenate">
                    <head>op:concatenate</head>
                    <example role="signature">
                        <proto name="concatenate" return-type="item()*" isOp="yes" returnVaries="yes">
                            <arg name="seq1" type="item()*" emptyOk="no"/>
                            <arg name="seq2" type="item()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns a sequence consisting of the items in <code>$seq1</code>
                        followed by the items in <code>$seq2</code>. This function backs up the
                        infix operator ",". If either sequence is the empty sequence, the other
                        operand is returned.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_constructing_sequences"/>
                    </p>
                    <div4 id="func-concatenate-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:concatenate((1, 2, 3), (4, 5))</code> returns <code>(1,
                                        2, 3, 4, 5)</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:concatenate((1, 2, 3), ())</code> returns <code>(1, 2,
                                    3)</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:concatenate((), ())</code> returns <code>()</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <!--		<div3 id="func-item-at">
					<head>fn:item-at</head>
					<example role="signature">
						<proto name="item-at" return-type="item()" returnVaries='yes' returnEmptyOk="yes">
							<arg name="seqParam" type="item()*" emptyOk="no"/>
							<arg name="posParam" type="xs:integer"/>
						</proto>
					</example>
					<p>Returns the item in <code>$seqParam</code> that is located at the index that is the value of <code>$posParam</code>. The return type is the type of the item returned.</p>
					<p>If  <code>$seqParam</code> is the empty
					sequence, returns the empty sequence.</p>
<p>The first item in a sequence is at position 1, not position 0.</p>
					<p>If the value of <code>$posParam</code> is
					greater than the number of items in the sequence,
					or is less than or equal to zero (0), then an
					error is raised <errorref class="RG"
					code="0006"/>. </p>
					<p>This function is used in the definition of the formal semantics of filter expressions; that is, expressions of the form <code>expression-1[expression-2]</code>.  See <bibref ref='xquery-semantics'/>
					</p>
					<div4>
						<head>Examples</head>
<p>Assume <code>$seq1 = ($item1, $item2, $item3)</code></p>
						<ulist>
							<item>
								<p>
									<code>fn:item-at((10, 20, 30), 2)</code> returns <code>20</code>. </p>
							</item>
						</ulist>
					</div4>
				</div3> -->
                <div3 id="func-index-of">
                    <head>fn:index-of</head>
                    <example role="signature">
                        <proto name="index-of" return-type="xs:integer*" returnEmptyOk="no">
                            <arg name="seqParam" type="xs:anyAtomicType*" emptyOk="no"/>
                            <arg name="srchParam" type="xs:anyAtomicType"/>
                        </proto>
                        <proto name="index-of" return-type="xs:integer*" returnEmptyOk="no">
                            <arg name="seqParam" type="xs:anyAtomicType*" emptyOk="no"/>
                            <arg name="srchParam" type="xs:anyAtomicType"/>
                            <arg name="collation" type="xs:string"/>
                        </proto>
                    </example>
                    <p>Summary: Returns a sequence of positive integers giving the positions within
                        the sequence <code>$seqParam</code> of items that are equal to <code>$srchParam</code>.</p>
                    <p>The collation used by the invocation of this function is determined according
                        to the rules in <specref ref="collations"/>. The collation is used when
                        string comparison is required.</p>
                    <p>The items in the sequence <code>$seqParam</code> are compared with
                        <code>$srchParam</code> under the rules for the <code>eq</code> operator.  Values of type <code>xs:untypedAtomic</code> are
compared as if they were of type <code>xs:string</code>.
                        Values that cannot be compared, i.e. the <code>eq</code> operator is not
                        defined for their types, are considered to be distinct. If an item compares
                        equal, then the position of that item in the sequence
                        <code>$seqParam</code> is included in the result.
                    </p>
                    <p> If the value of <code>$seqParam</code> is the empty sequence, or if no item
                        in <code>$seqParam</code> matches <code>$srchParam</code>, then the empty
                        sequence is returned.</p>
                    <p> The first item in a sequence is at position 1, not position 0.</p>
                    <p>The result sequence is in ascending numeric order.</p>
                    <div4 id="func-index-of-examples">
                        <head>Examples</head>
                        <ulist>
                            <!--	<item>
								<p>
									<code>fn:index-of (("Love", "for", 3, "oranges"), 3)</code> returns <code>3.</code></p></item> -->
                            <item>
                                <p>
                                    <code>fn:index-of ((10, 20, 30, 40), 35)</code> returns <code>().</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:index-of ((10, 20, 30, 30, 20, 10), 20)</code> returns
                                        <code>(2, 5).</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:index-of (("a", "sport", "and", "a", "pastime"),
                                    "a")</code> returns <code>(1, 4).</code>
                                </p>
                            </item>
                            <item>
                                <p> If @a is an attribute of type <code>xs:NMTOKENS</code> whose
                                    typed value is <quote>
                                        <code>red green blue</code>
                                    </quote>, then: <code>fn:index-of (@a, "blue")</code> returns <code>3</code>.</p>
                                <p> This is because the function calling mechanism atomizes the
                                    attribute node to produce a sequence of three <code>xs:NMTOKEN</code>s.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-empty">
                    <head>fn:empty</head>
                    <example role="signature">
                        <proto name="empty" return-type="xs:boolean">
                            <arg name="arg" type="item()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: If the value of <code>$arg</code> is the empty sequence, the
                        function returns <code>true</code>; otherwise, the function returns
                        <code>false</code>. </p>
                    <div4 id="func-empty-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:empty(fn:remove(("hello", "world"), 1))</code> returns
                                    <code>false</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-exists">
                    <head>fn:exists</head>
                    <example role="signature">
                        <proto name="exists" return-type="xs:boolean">
                            <arg name="arg" type="item()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: If the value of <code>$arg</code> is not the empty sequence, the
                        function returns <code>true</code>; otherwise, the function returns
                        <code>false</code>.</p>
                    <div4 id="func-exists-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <!-- Email from Winter Marco, 2002-08-21 -->
                                    <code>fn:exists(fn:remove(("hello"), 1))</code> returns
                                    <code>false</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-distinct-values">
                    <head>fn:distinct-values</head>
                    <example role="signature">
                        <proto name="distinct-values" return-type="xs:anyAtomicType*"
                            returnVaries="yes" returnEmptyOk="no">
                            <arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/>
                        </proto>
                        <proto name="distinct-values" return-type="xs:anyAtomicType*"
                            returnVaries="yes" returnEmptyOk="no">
                            <arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/>
                            <arg name="collation" type="xs:string"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the sequence that results from removing
                        from <code>$arg</code> all but one of a set of values that are <code>eq</code>
                        to one other.  Values of type <code>xs:untypedAtomic</code> are compared as if they were of
                        type <code>xs:string</code>.  Values that cannot be compared, i.e. the <code>eq</code>
                        operator is not defined for their types, are considered to be distinct.
                        The order in which the sequence of values is
                        returned is <termref def="implementation-dependent"/>.</p>
                    <p>The static type of the result is a sequence of prime types as defined in
                            <xspecref spec="FS" ref="sec_fn_distinct_node_vals"/>.</p>
                    <p>The collation used by the invocation of this function is determined according
                        to the rules in <specref ref="collations"/>. The collation is used when
                        string comparison is required.</p>
                    <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned. </p>
                    <p>For <code>xs:float</code> and <code>xs:double</code> values, positive zero
                        is equal to negative zero and, although <code>NaN</code> does not equal
                        itself, if <code>$arg</code> contains multiple <code>NaN</code> values a
                        single <code>NaN</code> is returned.</p>
                    <p> If <code>xs:dateTime</code>, <code>xs:date</code> or <code>xs:time</code>
                        values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for the purpose of comparison.  Note that
                        <code>xs:dateTime</code>, <code>xs:date</code> or <code>xs:time</code> values
                        can compare equal even if their timezones are different.</p>
                    <p>Which value of a set of values that compare equal is returned is <termref
                        def="implementation-dependent"/>. </p>
                    <div4 id="func-distinct-values-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:distinct-values((1, 2.0, 3, 2))</code> might return
                                        <code>(1, 3, 2.0)</code>. </p>
                            </item>
                            <item>
                                <p>The following query:<eg><![CDATA[
let $x as xs:untypedAtomic*
    := (xs:untypedAtomic("cherry"),
        xs:untypedAtomic("bar"),
        xs:untypedAtomic("bar"))
return fn:distinct-values ($x)
                                    ]]></eg> returns a sequence containing two items of type
                                    <code>xs:untypedAtomic</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-insert-before">
                    <head>fn:insert-before</head>
                    <example role="signature">
                        <proto name="insert-before" return-type="item()*" returnVaries="yes" returnEmptyOk="no">
                            <arg name="target" type="item()*" emptyOk="no"/>
                            <arg name="position" type="xs:integer"/>
                            <arg name="inserts" type="item()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns a new sequence constructed from the value of
                        <code>$target</code> with the value of <code>$inserts</code> inserted at the
                        position specified by the value of <code>$position</code>. (The value of
                        <code>$target</code> is not affected by the sequence construction.) </p>
                    <p>If <code>$target</code> is the empty sequence, <code>$inserts</code> is
                        returned. If <code>$inserts</code> is the empty sequence,
                        <code>$target</code> is returned.</p>
                    <p>The value returned by the function consists of all items of
                        <code>$target</code> whose index is less than <code>$position</code>,
                        followed by all items of <code>$inserts</code>, followed by the remaining
                        elements of <code>$target</code>, in that sequence. </p>                   
<p>If <code>$position</code> is less than one (1), the first position, the
                        effective value of <code>$position</code> is one (1). If
                        <code>$position</code> is greater than the number of items in
                        <code>$target</code>, then the effective value of <code>$position</code> is
                        equal to the number of items in <code>$target</code> plus 1. </p>
<p>For detailed semantics see, <xspecref spec="FS" ref="sec_fn_insert_before"/>.</p>
                    <div4 id="func-insert-before-examples">
                        <head>Examples</head>
                        <p>let <code>$x</code> := <code>("a", "b", "c")</code>
                        </p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:insert-before($x, 0, "z")</code> returns <code>("z",
                                        "a", "b", "c")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:insert-before($x, 1, "z")</code> returns <code>("z",
                                        "a", "b", "c")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:insert-before($x, 2, "z")</code> returns <code>("a",
                                        "z", "b", "c")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:insert-before($x, 3, "z")</code> returns <code>("a",
                                        "b", "z", "c")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:insert-before($x, 4, "z")</code> returns <code>("a",
                                        "b", "c", "z")</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-remove">
                    <head>fn:remove</head>
                    <example role="signature">
                        <proto name="remove" return-type="item()*" returnVaries="yes" returnEmptyOk="no">
                            <arg name="target" type="item()*" emptyOk="no"/>
                            <arg name="position" type="xs:integer"/>
                        </proto>
                    </example>
                    <p>Summary: Returns a new sequence constructed from the value of
                        <code>$target</code> with the item at the position specified by the value of
                        <code>$position</code> removed.</p>
                    <p>If <code>$position</code> is less than 1 or greater than the number of items
                        in <code>$target</code>, <code>$target</code> is returned. Otherwise, the
                        value returned by the function consists of all items of <code>$target</code>
                        whose index is less than <code>$position</code>, followed by all items of
                        <code>$target</code> whose index is greater than <code>$position</code>. If
                        <code>$target</code> is the empty sequence, the empty sequence is returned.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_remove"/>
                    </p>
                    <div4 id="func-remove-examples">
                        <head>Examples</head>
                        <p>let <code>$x</code> := <code>("a", "b", "c")</code>
                        </p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:remove($x, 0)</code> returns <code>("a", "b", "c")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:remove($x, 1)</code> returns <code>("b", "c")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:remove($x, 6)</code> returns <code>("a", "b", "c")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:remove((), 3)</code> returns <code>()</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-reverse">
                    <head>fn:reverse</head>
                    <example role="signature">
                        <proto name="reverse" return-type="item()*" returnVaries="yes" returnEmptyOk="no">
                            <arg name="arg" type="item()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Reverses the order of items in a sequence. If <code>$arg</code> is
                        the empty sequence, the empty sequence is returned. </p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_reverse"/>
                    </p>
                    <div4 id="func-reverse-examples">
                        <head>Examples</head>
                        <p>let <code>$x</code> := <code>("a", "b", "c")</code>
                        </p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:reverse($x)</code> returns <code>("c", "b", "a")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:reverse(("hello"))</code> returns <code>("hello")</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:reverse(())</code> returns <code>()</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-subsequence">
                    <head>fn:subsequence</head>
                    <example role="signature">
                        <proto name="subsequence" return-type="item()*" returnVaries="yes" returnEmptyOk="no">
                            <arg name="sourceSeq" type="item()*" emptyOk="no"/>
                            <arg name="startingLoc" type="xs:double"/>
                        </proto>
                        <proto name="subsequence" return-type="item()*" returnVaries="yes" returnEmptyOk="no">
                            <arg name="sourceSeq" type="item()*" emptyOk="no"/>
                            <arg name="startingLoc" type="xs:double"/>
                            <arg name="length" type="xs:double"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the contiguous sequence of items in the value of
                        <code>$sourceSeq</code> beginning at the position indicated by the value of
                        <code>$startingLoc</code> and continuing for the number of items indicated
                        by the value of <code>$length</code>. </p>
 <p>In the two-argument case, returns:</p><eg>$sourceSeq[fn:round($startingLoc) le $p]</eg><p>In the three-argument case, returns:</p><eg>$sourceSeq[fn:round($startingLoc) le $p 
     and $p lt fn:round($startingLoc) + fn:round($length)]</eg>
<notes>
<p>If <code>$sourceSeq</code> is the empty sequence, the empty sequence is returned.</p>
<p>
If <code>$startingLoc</code> is zero or negative, the subsequence includes items from the
beginning of the <code>$sourceSeq</code>.</p>
<p>
If <code>$length</code> is not specified, the subsequence includes items to the end of <code>$sourceSeq</code>.</p>
<p>
If <code>$length</code> is greater than the number of items in the value of <code>$sourceSeq</code>
following <code>$startingLoc</code>, the subsequence includes items to the end of <code>$sourceSeq</code>.</p>
<p>The first item of a sequence is located at position 1, not position 0.</p>
<p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_subsequence"/>.</p>
<p>The reason the function accepts arguments of type <code>xs:double</code> is that many computations on untyped data return an <code>xs:double</code> result; and the reason for the rounding rules is to compensate for any imprecision in these floating-point computations.</p>
</notes>
                    <div4 id="func-subsequence-examples">
                        <head>Examples</head>
                        <p>Assume <code>$seq = ($item1, $item2, $item3, $item4, ...)</code>
                        </p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:subsequence($seq, 4)</code> returns <code>($item4, ...)</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:subsequence($seq, 3, 2)</code> returns <code>($item3, $item4)</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-unordered">
                    <head>fn:unordered</head>
                    <example role="signature">
                        <proto name="unordered" return-type="item()*" returnVaries="yes" returnEmptyOk="no">
                            <arg name="sourceSeq" type="item()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the items of <code>$sourceSeq</code> in an <termref
                        def="implementation-dependent"/> order.</p>
                    <note>
                        <p>Query optimizers may be able to do a better job if the order of the
                            output sequence is not specified. For example, when retrieving prices
                            from a purchase order, if an index exists on prices, it may be more
                            efficient to return the prices in index order rather than in document order.</p>
                    </note>
                </div3>
            </div2>
            <div2 id="cardinality-functions">
                <head>Functions That Test the Cardinality of Sequences</head>
                <p>The following functions test the cardinality of their sequence arguments.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:zero-or-one</code>
                            </td>
                            <td>Returns the input sequence if it contains zero or one items. Raises
                                an error otherwise.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:one-or-more</code>
                            </td>
                            <td>Returns the input sequence if it contains one or more items. Raises
                                an error otherwise.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:exactly-one</code>
                            </td>
                            <td>Returns the input sequence if it contains exactly one item. Raises
                                an error otherwise.</td>
                        </tr>
                    </tbody>
                </table>
                <p>The functions <code>fn:zero-or-one</code>, <code>fn:one-or-more</code>, and
                    <code>fn:exactly-one</code> defined in this section, check that the cardinality
                    of a sequence is in the expected range. They are particularly useful with regard
                    to static typing. For example, the XML Schema <bibref ref="xmlschema-1"/> describing
                    the output of a query may require a sequence of length one-or-more in some
                    position, but the static type system may not be able to infer this; inserting a
                    call to <code>fn:one-or-more</code> at the appropriate place will provide a
                    suitable static type at query analysis time, and confirm that the length is
                    correct with a dynamic check at query execution time.</p>
                <div3 id="func-zero-or-one">
                    <head>fn:zero-or-one</head>
                    <example role="signature">
                        <proto name="zero-or-one" return-type="item()" returnEmptyOk="yes" returnVaries="yes">
                            <arg name="arg" type="item()*"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>$arg</code> if it contains zero or one items.
                        Otherwise, raises an error <errorref class="RG" code="0003"/>.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_cardinality_funcs"/>
                    </p>
                </div3>
                <div3 id="func-one-or-more">
                    <head>fn:one-or-more</head>
                    <example role="signature">
                        <proto name="one-or-more" return-type="item()+" returnVaries="yes">
                            <arg name="arg" type="item()*"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>$arg</code> if it contains one or more items.
                        Otherwise, raises an error <errorref class="RG" code="0004"/>. </p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_cardinality_funcs"/>
                    </p>
                </div3>
                <div3 id="func-exactly-one">
                    <head>fn:exactly-one</head>
                    <example role="signature">
                        <proto name="exactly-one" return-type="item()" returnVaries="yes">
                            <arg name="arg" type="item()*"/>
                        </proto>
                    </example>
                    <p>Summary: Returns <code>$arg</code> if it contains exactly one item. Otherwise,
                        raises an error <errorref class="RG" code="0005"/>. </p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_cardinality_funcs"/>
                    </p>
                </div3>
            </div2>
            <div2 id='union-intersection-except'>
                <head>Equals, Union, Intersection and Except</head>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:deep-equal</code>
                            </td>
                            <td>Returns <code>true</code> if the two arguments have items that
                                compare equal in corresponding positions. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:union</code>
                            </td>
                            <td>Returns the union of the two sequence arguments, eliminating
                                duplicates. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:intersect</code>
                            </td>
                            <td>Returns the intersection of the two sequence arguments, eliminating
                                duplicates. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>op:except</code>
                            </td>
                            <td>Returns the difference of the two sequence arguments, eliminating
                                duplicates. </td>
                        </tr>
                    </tbody>
                </table>
                <p>As in the previous sections, for the illustrative examples below, assume an
                    XQuery or transformation operating on a Purchase Order document containing a
                    number of line-item elements. The variables <code>$item1</code>,
                    <code>$item2</code>, etc. are bound to individual line-item nodes in the
                    sequence. We use sequences of these nodes in some of the examples below.</p>
                <div3 id="func-deep-equal">
                    <head>fn:deep-equal</head>
                    <example role="signature">
                        <proto name="deep-equal" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="parameter1" type="item()*" emptyOk="no"/>
                            <arg name="parameter2" type="item()*" emptyOk="no"/>
                        </proto>
                        <proto name="deep-equal" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="parameter1" type="item()*" emptyOk="no"/>
                            <arg name="parameter2" type="item()*" emptyOk="no"/>
                            <arg name="collation" type="string"/>
                        </proto>
                    </example>
                    <p> Summary: This function assesses whether two sequences are deep-equal to each
                        other. To be deep-equal, they must contain items that are pairwise
                        deep-equal; and for two items to be deep-equal, they must either be atomic
                        values that compare equal, or nodes of the same kind, with the same name,
                        whose children are deep-equal. This is defined in more detail below. The
                        <code>$collation</code> argument identifies a collation which is used at all
                        levels of recursion when strings are compared (but not when names are
                        compared), according to the rules in <specref ref="collations"/>.</p>
                    <p>If the two sequences are both empty, the function returns <code>true</code>.</p>
                    <p>If the two sequences are of different lengths, the function returns <code>false</code>.</p>
                    <p>If the two sequences are of the same length, the function returns
                        <code>true</code> if and only if every item in the sequence
                        <code>$parameter1</code> is deep-equal to the item at the same position in
                        the sequence <code>$parameter2</code>. The rules for deciding whether two
                        items are deep-equal follow.</p>
                    <p>Call the two items <code>$i1</code> and <code>$i2</code> respectively.</p>
                    <p> If <code>$i1</code> and <code>$i2</code> are both atomic values, they are
                        deep-equal if and only if <code>($i1 eq $i2)</code> is <code>true</code>, or if both values are <code>NaN</code>.

                      If the <code>eq</code> operator is not defined for <code>$i1</code> and
                        <code>$i2</code>, the function returns <code>false</code>.</p>
                    <p> If one of the pair <code>$i1</code> or <code>$i2</code> is an atomic value
                        and the other is a node, the function returns <code>false</code>.</p>
                    <p>If <code>$i1</code> and <code>$i2</code> are both nodes, they are compared as
                        described below:</p>
                    <p>If the two nodes are of different kinds, the result is <code>false</code>.</p>
                    <p>If the two nodes are both document nodes then they are deep-equal if and only
                        if the sequence <code>$i1/(*|text())</code> is deep-equal to the sequence <code>$i2/(*|text())</code>.</p>
                    <p> If the two nodes are both element nodes then they are deep-equal if and only
                        if all of the following conditions are satisfied:</p>
                    <olist>
                        <item>
                            <p>the two nodes have the same name, that is <code>(node-name($i1) eq node-name($i2))</code>.</p>
                        </item>
						<item>
                            <p>the two nodes are both annotated as having simple content or both nodes are annotated as having complex content.</p>
                        </item>
                        <item>
                            <p> the two nodes have the same number of attributes, and for every
                                attribute <code>$a1</code> in <code>$i1/@*</code> there exists an
                                attribute <code>$a2</code> in <code>$i2/@*</code> such that
                                <code>$a1</code> and <code>$a2</code> are deep-equal.</p>
                        </item>
                        <item>
                            <p> One of the following conditions holds:</p>
                            <ulist>
                                <item>
                                    <p>Both element nodes have a type annotation that is simple content, and the
                                        typed value of <code>$i1</code> is deep-equal to the typed
                                        value of <code>$i2</code>.</p>
                                </item>
								<item>
                                    <p>Both element nodes have a type annotation that
                                        is complex content with elementOnly content, and each child element of <code>$i1</code> is deep-equal to the corresponding child element of <code>$i2</code>.</p>
                                </item>
                                <item>
                                    <p>Both element nodes have a type annotation that
                                        is complex content with mixed content, and the sequence <code>$i1/(*|text())</code> is
                                        deep-equal to the sequence <code>$i2/(*|text())</code>.</p>
                                </item>
								<item>
                                    <p>Both element nodes have a type annotation that
                                        is complex content with empty content.</p>
                                </item>
                            </ulist>
                        </item>
                    </olist>
                    <p> If the two nodes are both attribute nodes then they are deep-equal if and
                        only if both the following conditions are satisfied:</p>
                    <olist>
                        <item>
                            <p> the two nodes have the same name, that is <code>(node-name($i1) eq node-name($i2))</code>.</p>
                        </item>
                        <item>
                            <p> the typed value of <code>$i1</code> is deep-equal to the typed value of <code>$i2</code>.</p>
                        </item>
                    </olist>
                    <p> If the two nodes are both processing instruction nodes or namespace bindings,
                        then they are deep-equal if and only if both the following conditions are satisfied:</p>
                    <olist>
                        <item>
                            <p> the two nodes have the same name, that is <code>(node-name($i1) eq node-name($i2))</code>.</p>
                        </item>
                        <item>
                            <p> the string value of <code>$i1</code> is equal to the string value of <code>$i2</code>.</p>
                        </item>
                    </olist>
                    <p> If the two nodes are both text nodes or comment nodes, then they are
                        deep-equal if and only if their string-values are equal.</p>
                    <notes>
                        <p> The two nodes are not required to have the same type annotation, and
                            they are not required to have the same in-scope namespaces. They may
                            also differ in their parent, their base URI, and the values returned by the <code>is-id</code> and <code>is-idrefs</code> accessors (see <xspecref spec="DM" ref="dm-is-id"/> and <xspecref spec="DM" ref="dm-is-idrefs"/>). The order of
                            children is significant, but the order of attributes is insignificant. </p>
                        <p> The contents of comments and processing instructions are significant
                            only if these nodes appear directly as items in the two sequences being
                            compared. The content of a comment or processing instruction that
                            appears as a descendant of an item in one of the sequences being
                            compared does not affect the result. However, the presence of a comment
                            or processing instruction, if it causes a text node to be split into two
                            text nodes, may affect the result.</p>
                        <p> The result of <code>fn:deep-equal(1, current-dateTime())</code> is
                            <code>false</code>; it does not raise an error.</p>
                    </notes>
                    <!--
					<p>Summary: If the sequences that are the values of <code>$parameter1</code> and <code>$parameter2</code> have the same values (that is, they have the same number of items and items in corresponding positions in the two sequences compare equal), the function returns <code>true</code>; otherwise, the function returns <code>false</code>. Equality of corresponding items is determined based on the <code>eq</code> operator if they are atomic values and based on deep equality of nodes, as defined below, if they are nodes.</p>
<p>
Returns <code>true</code> if both of its arguments are the empty sequence.
Returns <code>false</code> if one, but not both, of its arguments is the empty sequence.</p>
<p>If equality is not defined for the types of two corresponding values the function returns <code>false</code>.</p> 
				<p>String values are compared using a collation. If the type of the items in <code>$parameter1</code> and <code>$parameter2</code> is not <code>xs:string</code> and <code>$collation</code> is specified, the collation is ignored.</p>
<p>The collation used by the invocation of this function is determined according to the rules in <specref ref="collations"/>.</p>
<div4 id = 'deep-equality-of-nodes'>
<head>Deep Equality of Nodes</head>
					<p>The following (recursive) tests are applied in
					order to determine whether two nodes are deep
					equal. This uses a function called
					<code>is-namespace-node()</code> which checks, by elimination,
					whether a node is a namespace node.  Note that
					some host languages may not support namespace nodes.
					</p>
					<p>If the two nodes are of different kinds,
					the result is <code>false</code>. </p>
					<eg>
if ($parameter1 instance of element() and not ($parameter2 instance of
element())) then fn:false() else

if ($parameter1 instance of attribute() and not ($parameter2 instance of
attribute())) then fn:false() else

if ($parameter1 instance of text() and not ($parameter2 instance of
text())) then fn:false() else

if ($parameter1 instance of comment() and not ($parameter2 instance of
comment())) then fn:false() else

(: if ($parameter1 instance of document-node() and not ($parameter2
instance of document-node())) then fn:false() else :)

if ($parameter1 instance of processing-instruction() and
 not ($parameter2 instance of processing-instruction())) then fn:false() else 

if (is-namespace-node($parameter1) and not is-namespace-node($parameter2)) 
   then fn:false()
   else 
                    </eg>
					<p>Return <code>false</code> if the two nodes
					have different names.</p>
					<eg>
if (not(fn:deep-equal(fn:node-name($parameter1), fn:node-name($parameter2)))) 
then fn:false()
else

                    </eg>
					<p>Now perform specific tests based on the kind of
					nodes in hand.  First, test element nodes:</p>
<eg>
if ($parameter1 instance of element()) then      (: element nodes :)  
  if (some $a1 in $parameter1/@* satisfies       (: have attributes :)
      not (some $a2 in $parameter2/@* 
           satisfies fn:deep-equal($a1, $a2, $collation))
      or (some $a2 in $parameter2/@* satisfies
      not (some $a1 in $parameter1/@* 
           satisfies fn:deep-equal($a1, $a2, $collation))))
then fn:false() else
</eg>
<p>Check if both element nodes have simple types.  if so, compare
their typed values, else compare their children recursively.
The result is <code>true</code> if
					and only if the children of both nodes are all
					pairwise deep-equal, ignoring comment and
					processing instruction node children nodes in both cases. 
Note that whitespace text nodes are considered significant in element nodes with element-only content.  Thus, two nodes that have identical element children and differ only in text whitespace nodes will not compare equal.</p>
<eg>
  if ($parameter1 instance of element(*, xs:anySimpleType) and 
     ($parameter2 instance of element(*, xs:anySimpleType))
       return fn:deep-equal(fn:data($parameter1), fn:data($parameter2))
     else 
     if (not ($parameter1 instance of element(*, xs:anySimpleType)) and 
      not ($parameter2 instance of element(*, xs:anySimpleType))) then
                               (:compare children recursively :)
        return fn:deep-equal( $parameter1/(* | text()),  
                       $parameter2/(* | text()), $collation )
     else return fn:false()
else   
</eg>
<p>Test attribute nodes by comparing their typed values:</p>
<eg>
if ($parameter1 instance of attribute()) then    (: attribute nodes :)
   fn:deep-equal( fn:data($parameter1), fn:data($parameter2), $collation
)
else
</eg>
<p>Test text nodes by comparing their string values:</p>
<eg>
if ($parameter1 instance of text()) then
   fn:compare
     (fn:string($parameter1), fn:string($parameter2), $collation) ne 0
else
</eg>
<p>Test comment nodes by comparing their string values:</p>
<eg>
if ($parameter1 instance of comment()) then
   fn:compare
     (fn:string($parameter1), fn:string($parameter2), $collation) ne 0
else
</eg>
<p>Test processing instruction nodes by comparing their string values:</p>
<eg>
if ($parameter1 instance of processing-instruction()) then
   fn:compare
        (fn:string($parameter1), fn:string($parameter2), $collation) ne 0
</eg>
<p>Finally, test namespace nodes by comparing their string values:</p>
<eg>
else  (: Must be a namespace node by elimination :)
   fn:compare (fn:string($parameter1), fn:string($parameter2)) ne 0
 </eg>
					<note>
						<p>The two nodes are not required to have the same type annotation, and they are not required to have the same in-scope namespaces. They may also differ in their parent, their base URI and the values returned by the <code>is-id</code> and <code>is-idref</code> accessors.  The order of children is significant, but the order of attributes is insignificant. The contents of comments and processing instructions are significant only if these nodes are used directly as arguments to the function, not if they appear as children of the nodes supplied as arguments. </p>
					</note>
					<note>
						<p>The result of <code>fn:deep-equal(1, current-dateTime())</code> is <code>false</code>; it does not raise an error. </p>
					</note>
<p>Here is the complete algorithm:</p>
<eg>
if ($parameter1 instance of element() and not ($parameter2 instance of
element())) then fn:false() else

if ($parameter1 instance of attribute() and not ($parameter2 instance of
attribute())) then fn:false() else

if ($parameter1 instance of text() and not ($parameter2 instance of
text())) then fn:false() else

if ($parameter1 instance of comment() and not ($parameter2 instance of
comment())) then fn:false() else

(: if ($parameter1 instance of document-node() and not ($parameter2
instance of document-node())) then fn:false() else :)

if ($parameter1 instance of processing-instruction() and
 not ($parameter2 instance of processing-instruction())) then fn:false() else 

if (is-namespace-node($parameter1) and not is-namespace-node($parameter2)) 
   then fn:false()
   else 
if (not(fn:deep-equal(fn:node-name($parameter1), fn:node-name($parameter2)))) 
then fn:false()
else

if ($parameter1 instance of element()) then      (: element nodes :)  
  if (some $a1 in $parameter1/@* satisfies       (: have attributes :)
      not (some $a2 in $parameter2/@* 
           satisfies fn:deep-equal($a1, $a2, $collation))
      or (some $a2 in $parameter2/@* satisfies
      not (some $a1 in $parameter1/@* 
           satisfies fn:deep-equal($a1, $a2, $collation))))
then fn:false() else

if ($parameter1 instance of element(*, xs:anySimpleType) and 
     ($parameter2 instance of element(*, xs:anySimpleType))
       return fn:deep-equal(fn:data($parameter1), fn:data($parameter2))
     else 
     if (not ($parameter1 instance of element(*, xs:anySimpleType)) and 
      not ($parameter2 instance of element(*, xs:anySimpleType))) then
                               (:compare children recursively :)
        return fn:deep-equal( $parameter1/(* | text()),  
                       $parameter2/(* | text()), $collation )
     else return fn:false()
else 
    
if ($parameter1 instance of attribute()) then    (: attribute nodes :)
   fn:deep-equal( fn:data($parameter1), fn:data($parameter2), $collation
)
else

if ($parameter1 instance of text()) then
   fn:compare
     (fn:string($parameter1), fn:string($parameter2), $collation) ne 0
else

if ($parameter1 instance of comment()) then
   fn:compare
     (fn:string($parameter1), fn:string($parameter2), $collation) ne 0
else

if ($parameter1 instance of processing-instruction()) then
   fn:compare
        (fn:string($parameter1), fn:string($parameter2), $collation) ne 0
else  (: Must be a namespace node by elimination :)
   fn:compare (fn:string($parameter1), fn:string($parameter2)) ne 0
</eg>    

					</div4> -->
                    <div4 id="func-deep-equal-examples">
                        <head>Examples</head>
                        <p>
                            <eg>let $at := &lt;attendees&gt; &lt;name last='Parker'
                                first='Peter'/&gt; &lt;name last='Barker' first='Bob'/&gt;
                                &lt;name last='Parker' first='Peter'/&gt; &lt;/attendees&gt;</eg>
                        </p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:deep-equal($at, $at/*)</code> returns <code>false</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:deep-equal($at/name[1], $at/name[2])</code> returns <code>false</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:deep-equal($at/name[1], $at/name[3])</code> returns <code>true</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:deep-equal($at/name[1], 'Peter Parker')</code> returns <code>false</code>.</p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <!--		<div3 id="func-sequence-node-identical">
					<head>fn:sequence-node-identical</head>
					<example role="signature">
						<proto name="sequence-node-identical" return-type="xs:boolean" returnEmptyOk="no">
							<arg name="parameter1" type="node()*" emptyOk="no"/>
							<arg name="parameter2" type="node()*" emptyOk="no"/>
						</proto>
					</example>
					<p>
Returns <code>true</code> if both of its arguments are the empty sequence.
Returns <code>false</code> if one, but not both, of its arguments is the empty sequence.</p>
					<p>If the sequences that are the values of
<code>$parameter1</code> and <code>$parameter2</code> are identical,
that is, they contain the same number of nodes and the nodes in
corresponding positions in the two sequences are identical as tested by <code>op:is-same-node</code>, then the function returns <code>true</code>; otherwise, the function returns <code>false</code>. </p>
					<div4 id='sequence-node-identical-examples'>
						<head>Examples</head>
						<p>Assume <code>$seq1 = ($item1, $item2), $seq2 = ($item1, $item2)</code> and <code>$seq3 = ($item2, $item3)</code>.</p>
						<ulist>
							<item>
								<p>
									<code>fn:sequence-node-identical($seq1, $seq2)</code> returns <code>true</code>. </p>
							</item>
							<item>
								<p>
									<code>fn:sequence-node-identical($seq2, $seq3)</code> returns <code>false</code>. </p>
							</item>
						</ulist>
					</div4>
				</div3> -->
                <div3 id="func-union">
                    <head>op:union</head>
                    <example role="signature">
                        <proto name="union" return-type="node()*" returnVaries="yes"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="parameter1" type="node()*" emptyOk="no"/>
                            <arg name="parameter2" type="node()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Constructs a sequence containing every node that occurs in the
                        values of either <code>$parameter1</code> or <code>$parameter2</code>,
                        eliminating duplicate nodes. Nodes are returned in document order. Two nodes
                        are duplicates if they are <code>op:is-same-node()</code>.</p>
                    <p> If either operand is the empty sequence, a sequence is returned containing
                        the nodes in the other operand in document order after eliminating duplicates.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_op_union_intersect_except"/>
                    </p>
                    <p>This function backs up the "union" or "|" operator.</p>
                    <div4 id='func-union-examples'>
                        <head>Examples</head>
                        <p>Assume <code>$seq1 = ($item1, $item2), $seq2 = ($item1, $item2)</code>
                            and <code>$seq3 = ($item2, $item3)</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:union($seq1, $seq1)</code> returns the sequence
                                        <code>($item1, $item2)</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:union($seq2, $seq3)</code> returns the sequence
                                    consisting of <code>($item1, $item2, $item3)</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-intersect">
                    <head>op:intersect</head>
                    <example role="signature">
                        <proto name="intersect" return-type="node()*" returnVaries="yes"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="parameter1" type="node()*" emptyOk="no"/>
                            <arg name="parameter2" type="node()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Constructs a sequence containing every node that occurs in the
                        values of both <code>$parameter1</code> and <code>$parameter2</code>,
                        eliminating duplicate nodes. Nodes are returned in document order. </p>
                    <p>If either operand is the empty sequence, the empty sequence is returned.</p>
                    <p>Two nodes are duplicates if they are <code>op:is-same-node()</code>.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_op_union_intersect_except"/>.</p>
                    <!--
For detailed type semantics, see section 6.2.4 of <bibref
					ref='xquery-semantics'/>.</p> -->
                    <p>This function backs up the "intersect" operator.</p>
                    <div4 id='func-intersect-examples'>
                        <head>Examples</head>
                        <p>Assume <code>$seq1 = ($item1, $item2), $seq2 = ($item1, $item2)</code>
                            and <code>$seq3 = ($item2, $item3)</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:intersect($seq1, $seq1)</code> returns the sequence
                                        <code>($item1, $item2)</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:intersect($seq2, $seq3)</code> returns the sequence
                                    <code>($item2)</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-except">
                    <head>op:except</head>
                    <example role="signature">
                        <proto name="except" return-type="node()*" returnVaries="yes"
                            returnEmptyOk="no" isOp="yes">
                            <arg name="parameter1" type="node()*" emptyOk="no"/>
                            <arg name="parameter2" type="node()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Constructs a sequence containing every node that occurs in the value
                        of <code>$parameter1</code>, but not in the value of
                        <code>$parameter2</code>, eliminating duplicate nodes. Nodes are returned in
                        document order.</p>
                    <p>If <code>$parameter1</code> is the empty sequence, the empty sequence is
                        returned. If <code>$parameter2</code> is the empty sequence, a sequence is
                        returned containing the nodes in <code>$parameter1</code> in document order
                        after eliminating duplicates.</p>
                    <p>Two nodes are duplicates if they are <code>op:is-same-node()</code>.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_op_union_intersect_except"/>.</p>
                    <p>This function backs up the "except" operator.</p>
                    <div4 id='func-except-examples'>
                        <head>Examples</head>
                        <p>Assume <code>$seq1 = ($item1, $item2), $seq2 = ($item1, $item2)</code>
                            and <code>$seq3 = ($item2, $item3)</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>op:except($seq1, $seq2)</code> returns the empty sequence. </p>
                            </item>
                            <item>
                                <p>
                                    <code>op:except($seq2, $seq3)</code> returns the sequence
                                    <code>($item1)</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id="aggregate-functions">
                <head>Aggregate Functions</head>
                <p>Aggregate functions take a sequence as argument and return a single value
                    computed from values in the sequence. Except for <code>fn:count</code>, the
                    sequence must consist of values of a single type or one if its subtypes, or they
                    must be numeric. <code>xs:untypedAtomic</code> values are permitted in the
                    input sequence and handled by special conversion rules. The type of the items in
                    the sequence must also support certain operations.</p>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>fn:count</code>
                            </td>
                            <td>Returns the number of items in a sequence. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:avg</code>
                            </td>
                            <td>Returns the average of a sequence of values. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:max</code>
                            </td>
                            <td>Returns the maximum value from a sequence of comparable values. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:min</code>
                            </td>
                            <td>Returns the minimum value from a sequence of comparable values. </td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:sum</code>
                            </td>
                            <td>Returns the sum of a sequence of values.</td>
                        </tr>
                    </tbody>
                </table>
                <div3 id="func-count">
                    <head>fn:count</head>
                    <example role="signature">
                        <proto name="count" return-type="xs:integer">
                            <arg name="arg" type="item()*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the number of items in the value of <code>$arg</code>.</p>
                    <p>Returns 0 if <code>$arg</code> is the empty sequence.</p>
                    <div4 id="func-count-examples">
                        <head>Examples</head>
                        <p>Assume <code>$seq1 = ($item1, $item2)</code> and <code>$seq3 = ()</code>,
                            the empty sequence.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:count($seq1)</code> returns <code>2</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:count($seq3)</code> returns <code>0</code>. </p>
                            </item>
                        </ulist>
                        <p>Assume <code>$seq2 = (98.5, 98.3, 98.9)</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:count($seq2)</code> returns <code>3</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:count($seq2[. &gt; 100])</code> returns <code>0</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-avg">
                    <head>fn:avg</head>
                    <example role="signature">
                        <proto name="avg" return-type="xs:anyAtomicType" returnVaries="yes" returnEmptyOk="yes">
                            <arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/>
                        </proto>
                    </example>
                    <p> Summary: Returns the average of the values in the input
                        sequence <code>$arg</code>, that is, the sum of the values divided by the
                        number of values.</p>
                    <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned.</p>
                    <p>If <code>$arg</code> contains values of type <code>xs:untypedAtomic</code>
                        they are cast to <code>xs:double</code>. </p>
                    <p>Duration values must either all be <code>xs:yearMonthDuration</code> values
                        or must all be <code>xs:dayTimeDuration</code> values. For numeric values,
                        the numeric promotion rules defined in <specref ref="op.numeric"/> are used
                        to promote all values to a single common type. After these operations,
                        <code>$arg</code> must contain items of a single type, which must be one of
                        the four numeric types, <code>xs:yearMonthDuration</code> or
                        <code>xs:dayTimeDuration</code> or one if its subtypes.</p>
                    <p>If the above conditions are not met, then a type error is raised <errorref
                            class="RG" code="0006"/>.</p>
                    
<p>Otherwise, returns the average of the values as <code>sum($arg) div count($arg)</code>; but the implementation may use an otherwise equivalent algorithm that avoids arithmetic overflow.</p>

                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_aggregates"/>.</p>
                    <div4 id="func-avg-examples">
                        <head>Examples</head>
                        <p>Assume <code>$d1 = xs:yearMonthDuration("P20Y")</code> and <code>$d2 =
                            xs:yearMonthDuration("P10M")</code> and <code>$seq3 = (3, 4, 5)</code>.</p>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:avg($seq3)</code> returns <code>4.0</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:avg(($d1, $d2))</code> returns a
                                    <code>yearMonthDuration</code> with value <code>125</code>
                                    months. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:avg(($d1, $seq3))</code> raises a type error <errorref
                                        class="RG" code="0006"/>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:avg(())</code> returns <code>()</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:avg((xs:float('INF'), xs:float('-INF')))</code> returns
                                    <code>NaN</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:avg(($seq3, xs:float('NaN')))</code> returns
                                    <code>NaN</code>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-max">
                    <head>fn:max</head>
                    <example role="signature">
                        <proto name="max" return-type="xs:anyAtomicType" returnVaries="yes" returnEmptyOk="yes">
                            <arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/>
                        </proto>
                        <proto name="max" return-type="xs:anyAtomicType" returnVaries="yes" returnEmptyOk="yes">
                            <arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/>
                            <arg name="collation" type="string"/>
                        </proto>
                    </example>
                    <p>Summary: Selects an item from the input sequence <code>$arg</code> whose
                        value is greater than or equal to the value of every other item in the input
                        sequence. If there are two or more such items, then the specific item whose
                        value is returned is <termref def="implementation-dependent"/>. </p>
                    <p>The following rules are applied to the input sequence:</p>
<ulist>
<item><p>Values of type <code>xs:untypedAtomic</code> in                         <code>$arg</code> are cast to <code>xs:double</code>.</p></item>
<item><p>Numeric and <code>xs:anyURI</code> values are converted to the least common type that supports the <code>ge</code> operator by a combination of type promotion and subtype substitution. See <xspecref
                        spec="XP" ref="promotion"/> and <xspecref
                        spec="XP" ref="mapping"/>.</p></item> 
</ulist>

<p>
The items in the
                        resulting sequence may be reordered in an arbitrary order. The resulting
                        sequence is referred to below as the converted sequence. This function returns an item from the converted 
sequence rather than the input sequence. </p>
                    <p>If the converted sequence is empty, the empty sequence is returned.</p>
                    <p>All items in <code>$arg</code> must be numeric or derived from a single base
                        type for which the <code>ge</code> operator is defined. In addition, the values in
                        the sequence must have a total order. If date/time values do not have a
                        timezone, they are considered to have the  implicit timezone provided by the dynamic context for purposes of comparison. Duration values
                        must either all be <code>xs:yearMonthDuration</code> values or must all be
                        <code>xs:dayTimeDuration</code> values.</p>
                    <p>If any of these conditions is not met, then a type error is raised <errorref
                            class="RG" code="0006"/>.</p>
                    <p>If the converted sequence contains the value <code>NaN</code>, the value
                        <code>NaN</code> is returned.</p>
                    <p>If the items in the value of <code>$arg</code> are of type
                        <code>xs:string</code> or types derived by restriction from
                        <code>xs:string</code>, then the determination of the item with the largest
                        value is made according to the collation that is used. If the type of the
                        items in <code>$arg</code> is not <code>xs:string</code> and
                        <code>$collation</code> is specified, the collation is ignored.</p>
                    <p>The collation used by the invocation of this function is determined according
                        to the rules in <specref ref="collations"/>.</p>
                    <p>Otherwise, the result of the function is the result of the expression:</p>
                    <eg><![CDATA[
   if (every $v in $c satisfies $c[1] ge $v)
   then $c[1] 
   else fn:max(fn:subsequence($c, 2))]]></eg>
                    <p>evaluated with <code>$collation</code> as the default collation if specified, and with <code>$c</code>
                        as the converted sequence.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_aggregates"/>.</p>
                    <notes>
                        <p> If the converted sequence contains exactly one value then that value is returned.</p>
                        <p>The default type when the <code>fn:max</code> function is applied
                            to <code>xs:untypedAtomic</code> values is <code>xs:double</code>. This
                            differs from the default type for operators such as <code>gt</code>, and
                            for sorting in XQuery and XSLT, which is <code>xs:string</code>.</p>
                    </notes>
                    <div4 id="func-max-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:max((3,4,5))</code> returns <code>5</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:max((5, 5.0e0))</code> returns <code>5.0e0</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:max((3,4,"Zero"))</code> raises a type error <errorref
                                        class="RG" code="0006"/>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:max((fn:current-date(), xs:date("2001-01-01")))</code>
                                    typically returns the current date. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:max(("a", "b", "c"))</code> returns "c" under a typical
                                    default collation. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-min">
                    <head>fn:min</head>
                    <example role="signature">
                        <proto name="min" return-type="xs:anyAtomicType" returnVaries="yes" returnEmptyOk="yes">
                            <arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/>
                        </proto>
                        <proto name="min" return-type="xs:anyAtomicType" returnVaries="yes" returnEmptyOk="yes">
                            <arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/>
                            <arg name="collation" type="string"/>
                        </proto>
                    </example>
                    <p>Summary: selects an item from the input sequence <code>$arg</code> whose
                        value is less than or equal to the value of every other item in the input
                        sequence. If there are two or more such items, then the specific item whose
                        value is returned is <termref def="implementation-dependent"/>. </p>
 <p>The following rules are applied to the input sequence:</p>
<ulist>
<item><p>Values of type <code>xs:untypedAtomic</code> in                         <code>$arg</code> are cast to <code>xs:double</code>.</p></item>
<item><p>Numeric and <code>xs:anyURI</code> values are converted to the least common type that supports the <code>le</code> operator by a combination of type promotion and subtype substitution. See <xspecref
                        spec="XP" ref="promotion"/> and <xspecref
                        spec="XP" ref="mapping"/>.</p></item> 
</ulist>

<p>
The items in the
                        resulting sequence may be reordered in an arbitrary order. The resulting
                        sequence is referred to below as the converted sequence. This function returns an item from the converted 
sequence rather than the input sequence. </p>                   <p>If the converted sequence is empty, the empty sequence is returned.</p>
                    <p>All items in <code>$arg</code> must be numeric or derived from a single base
                        type for which the <code>le</code> operator is defined. In addition, the values in
                        the sequence must have a total order. If date/time values do not have a
                        timezone, they are considered to have the implicit timezone provided by the dynamic context for the purpose of comparison. Duration values
                        must either all be <code>xs:yearMonthDuration</code> values or must all be
                        <code>xs:dayTimeDuration</code> values.</p>
                    <p>If any of these conditions is not met, a type error is raised <errorref
                            class="RG" code="0006"/>.</p>
                    <p>If the converted sequence contains the value <code>NaN</code>, the value
                        <code>NaN</code> is returned.</p>
                    <p>If the items in the value of <code>$arg</code> are of type
                        <code>xs:string</code> or types derived by restriction from
                        <code>xs:string</code>, then the determination of the item with the smallest
                        value is made according to the collation that is used. If the type of the
                        items in <code>$arg</code> is not <code>xs:string</code> and
                        <code>$collation</code> is specified, the collation is ignored.</p>
                    <p>The collation used by the invocation of this function is determined according
                        to the rules in <specref ref="collations"/>.</p>
                    <p>Otherwise, the result of the function is the result of the expression:</p>
                    <eg><![CDATA[
   if (every $v in $c satisfies $c[1] le $v) 
   then $c[1] 
   else fn:min(fn:subsequence($c, 2))]]></eg>
                    <p>evaluated with <code>$collation</code> as the default collation if specified, and with <code>$c</code>
                        as the converted sequence.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_aggregates"/>.</p>
                    <notes>
                        <p> If the converted sequence contains exactly one value then that value is returned.</p>
                        <p>The default type when the <code>fn:min</code> function is applied
                            to <code>xs:untypedAtomic</code> values is <code>xs:double</code>. This
                            differs from the default type for operators such as <code>lt</code>, and
                            for sorting in XQuery and XSLT, which is <code>xs:string</code>.</p>
                    </notes>
                    <div4 id="func-min-examples">
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:min((3,4,5))</code> returns <code>3</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:min((5, 5.0e0))</code> returns <code>5.0e0</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:min((3,4,"Zero"))</code> raises a type error <errorref
                                        class="RG" code="0006"/>. </p>
                            </item>
 							<item>
                                <p>
                                    <code>fn:min((xs:float(0.0E0), xs:float(-0.0E0)))</code> can return either positive or negative zero. <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero. The result is <termref def="implementation-dependent"/>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:min((fn:current-date(), xs:date("2001-01-01")))</code>
                                    typically returns <code>xs:date("2001-01-01")</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:min(("a", "b", "c"))</code> returns "a" under a typical
                                    default collation. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-sum">
                    <head>fn:sum</head>
                    <example role="signature">
                        <proto name="sum" return-type="xs:anyAtomicType" returnVaries="yes" returnEmptyOk="no">
                            <arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/>
                        </proto>
                    </example>
                    <example role="signature">
                        <proto name="sum" return-type="xs:anyAtomicType" returnVaries="yes" returnEmptyOk="yes">
                            <arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/>
                            <arg name="zero" type="xs:anyAtomicType" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Returns a value obtained by adding together the values
                        in <code>$arg</code>. If <code>$zero</code> is not specified, then the value
                        returned for an empty sequence is the <code>xs:integer</code> value 0. If
                        <code>$zero</code> is specified, then the value returned for an empty
                        sequence is <code>$zero</code>.</p>
                    <p>Any values of type <code>xs:untypedAtomic</code> in <code>$arg</code> are
                        cast to <code>xs:double</code>. The items in the resulting sequence may be
                        reordered in an arbitrary order. The resulting sequence is referred to below
                        as the converted sequence.</p>
                    <p>If the converted sequence is empty, then the single-argument form of the
                        function returns the <code>xs:integer</code> value <code>0</code>; the
                        two-argument form returns the value of the argument <code>$zero</code>.</p>
                    <p>If the converted sequence contains the value <code>NaN</code>,
                        <code>NaN</code> is returned.</p>
                    <p>All items in <code>$arg</code> must be numeric or derived from a single base
                        type. In addition, the type must support addition. Duration values must
                        either all be <code>xs:yearMonthDuration</code> values or must all be
                        <code>xs:dayTimeDuration</code> values. For numeric values, the numeric
                        promotion rules defined in <specref ref="op.numeric"/> are used to promote
                        all values to a single common type. The sum of a sequence of integers will
                        therefore be an integer, while the sum of a numeric sequence that includes
                        at least one xs:double will be an xs:double. </p>
                    <p>If the above conditions are not met, a type error is raised <errorref
                            class="RG" code="0006"/>. </p>
                    <p>Otherwise, the result of the function, using the second signature, is the
                        result of the expression:</p>
                    <eg><![CDATA[
if (fn:count($c) eq 0) then
    $zero
else if (fn:count($c) eq 1) then
    $c[1]
else
    $c[1] + fn:sum(subsequence($c, 2))]]></eg>
                    <p>where <code>$c</code> is the converted sequence.</p>
                    <p>The result of the function, using the first signature, is the result of the
                            expression: <code>fn:sum($arg, 0)</code>.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_aggregates"/>.</p>
                    <notes>
                        <p>The second argument allows an appropriate value to be defined to
                            represent the sum of an empty sequence. For example, when summing a
                            sequence of durations it would be appropriate to return a zero-length
                            duration of the appropriate type. This argument is necessary because a
                            system that does dynamic typing cannot distinguish "an empty sequence of
                            integers", for example, from "an empty sequence of durations".</p>
                        <p> If the converted sequence contains exactly one value then that value is returned.</p>
                    </notes>
                    <div4 id="func-sum-examples">
                        <head>Examples</head>
                        <p>Assume:</p>
                        <eg><![CDATA[
$d1 = xs:yearMonthDuration("P20Y")
$d2 = xs:yearMonthDuration("P10M")
$seq1 = ($d1, $d2)
$seq3 = (3, 4, 5)]]></eg>
                        <ulist>
                            <item>
                                <p>
                                    <code>fn:sum(($d1, $d2))</code> returns an
                                    <code>xs:yearMonthDuration</code> with a value of
                                    <code>250</code> months.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:sum($seq1[. &lt; xs:yearMonthDuration('P3M')],
                                    xs:yearMonthDuration('P0M'))</code> returns an
                                    <code>xs:yearMonthDuration</code> with a value of
                                    <code>0</code> months. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:sum($seq3)</code> returns <code>12</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:sum(())</code> returns <code>0</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:sum((),())</code> returns <code>()</code>. </p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:sum((1 to 100)[.&lt;0], 0) </code> returns <code>0</code>.</p>
                            </item>
                            <item>
                                <p>
                                    <code>fn:sum(($d1, 9E1))</code> raises an error <errorref
                                        class="RG" code="0006"/>. </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
            </div2>
            <div2 id="fns-that-generate-sequences">
                <head>Functions and Operators that Generate Sequences</head>
                <table border="1" summary="Function/operator summary">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <code>op:to</code>
                            </td>
                            <td>Returns the sequence containing every <code>xs:integer</code>
                                between the values of the operands.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:id</code>
                            </td>
                            <td>Returns the sequence of element nodes having an ID value matching
                                the one or more of the supplied IDREF values.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:idref</code>
                            </td>
                            <td>Returns the sequence of element or attribute nodes with an IDREF
                                value matching one or more of the supplied ID values.</td>
                        </tr>
                        <!-- Don Chamberlin email, 2002-07-27 -->
                        <tr>
                            <td>
                                <code>fn:doc</code>
                            </td>
                            <td>Returns a document node retrieved using the specified URI.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:doc-available</code>
                            </td>
                            <td>Returns <code>true</code> if a document node can be retrieved using
                                the specified URI.</td>
                        </tr>
                        <tr>
                            <td>
                                <code>fn:collection</code>
                            </td>
                            <td>Returns a sequence of nodes retrieved using the specified URI or the
                                nodes in the default collection.</td>
                        </tr>
                        <!--						<tr>
							<td>
								<code>fn:input</code>
							</td>
							<td>Returns the input sequence.</td>
							</tr> -->
                    </tbody>
                </table>
                <div3 id="func-to">
                    <head>op:to</head>
                    <example role="signature">
                        <!-- Don Chamberlin email, 2002-07-27 -->
                        <proto name="to" return-type="xs:integer*" isOp="yes">
                            <arg name="firstval" type="xs:integer"/>
                            <arg name="lastval" type="xs:integer"/>
                        </proto>
                    </example>
                    <p>Summary: Returns the sequence containing every <code>xs:integer</code> whose
                        value is between the value of <code>$firstval</code> (inclusive) and the
                        value of <code>$lastval</code> (inclusive), in monotonic order. If the value
                        of the first operand is greater than the value of the second, the empty
                        sequence is returned. If the values of the two operands are equal, a
                        sequence containing a single <code>xs:integer</code> equal to the value is returned.</p>
                    <p>This function backs up the "to" operator.</p>
                    <div4 id='func-to-examples'>
                        <head>Examples</head>
                        <ulist>
                            <item>
                                <p>
                                    <code>1 to 3</code> returns <code>(1, 2, 3)</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>3 to 1</code> returns <code>()</code>
                                </p>
                            </item>
                            <item>
                                <p>
                                    <code>5 to 5</code> returns <code>5</code>
                                </p>
                            </item>
                        </ulist>
                    </div4>
                </div3>
                <div3 id="func-id">
                    <head>fn:id</head>
                    <example role="signature">
                        <proto name="id" return-type="element()*" returnEmptyOk="no">
                            <arg name="arg" type="xs:string*" emptyOk="no"/>
                        </proto>
                    </example>
                    <example role="signature">
                        <proto name="id" return-type="element()*" returnEmptyOk="no">
                            <arg name="arg" type="xs:string*" emptyOk="no"/>
                            <arg name="node" type="node()" emptyOk="no"/>
                        </proto>
                    </example>
                    <p> Summary: Returns the sequence of element nodes that have an <code>ID</code>
                        value matching the value of one or more of the <code>IDREF</code> values
                        supplied in <code>$arg </code>.</p>
                    <p> The function returns a sequence, in document order with duplicates
                        eliminated, containing every element node <code>E</code> that satisfies all
                        the following conditions:</p>
                    <olist>
                        <item>
                            <p>
                                <code>E</code> is in the target document. The target document is the
                                document containing <code>$node</code>, or the document containing
                                the context item (<code>.</code>) if the second argument is omitted. The behavior of the function if <code>$node</code> is omitted is exactly the same as if the context item had been passed as <code>$node</code>.  If
                                <code>$node</code>, or the context item if the second argument is
                                omitted, is a node in a tree whose root is not a document node <errorref class="DC" code="0001" type="dynamic"/> is raised.  
If the second argument is the context item, or is omitted, the following errors may be raised: if there is no context item,
                                    <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node 
<xerrorref spec="XP" class="TY" code="0004" type="type"/>.
</p>
                        </item>
                        <item>
                            <p>
                                <code>E</code> has an <code>ID</code> value equal to one of the
                                candidate <code>IDREF</code> values, where:</p>
                            <ulist>
                                <item>
                                    <p> An element has an <code>ID</code> value equal to
                                        <code>V</code> if either or both of the following conditions
                                        are true:</p>
                                    <ulist>
                                        <item>
                                            <p> The <code>is-id</code> property (See <xspecref
                                                  spec="DM" ref="dm-is-id"/>.) of the element node
                                                is true, and the typed value of the element node is
                                                equal to V under the rules of the <code>eq</code>
                                                operator using the Unicode code point collation (<code>&codepoint.collation;</code>).</p>
                                        </item>
                                        <item>
                                            <p> The element has an attribute node whose
                                                <code>is-id</code> property (See <xspecref spec="DM"
                                                ref="dm-is-id"/>.) is true and whose typed value is
                                                equal to <code>V</code> under the rules of the
                                                <code>eq</code> operator using the Unicode code
                                                point collation (<code>&codepoint.collation;</code>).</p>
                                        </item>
                                    </ulist>
                                </item>
                                <item>
                                    <p> Each <code>xs:string</code> in <code>$arg</code> is parsed
                                        as if it were of type <code>IDREFS</code>, that is, each
                                        <code>xs:string</code> in <code>$arg</code> is treated as a
                                        whitespace-separated sequence of tokens, each acting as an
                                        <code>IDREF</code>. These tokens are then included in the
                                        list of candidate <code>IDREF</code>s. If any of the tokens
                                        is not a lexically valid <code>IDREF</code> (that is, if it
                                        is not lexically an <code>xs:NCName</code>), it is ignored.
                                        Formally, the candidate <code>IDREF</code> values are the
                                        strings in the sequence given by the expression:
<eg>for $s in $arg return fn:tokenize(fn:normalize-space($s), ' ')
                 [. castable as xs:IDREF]</eg>
                                    </p>
                                </item>
                            </ulist>
                        </item>
                        <item>
                            <p> If several elements have the same <code>ID</code> value, then
                                <code>E</code> is the one that is first in document order.</p>
                        </item>
                    </olist>
                    <notes>
                        <p> If the data model is constructed from an Infoset, an attribute will have
                            the <code>is-id</code> property if the corresponding attribute in the
                            Infoset had an attribute type of <code>ID</code>: typically this means
                            the attribute was declared as an <code>ID</code> in a DTD.</p>
                        <p> If the data model is constructed from a PSVI, an element or attribute
                            will have the <code>is-id</code> property if its schema-defined type
                            is <code>xs:ID</code> or a type derived by restriction from <code>xs:ID</code>.</p>
                        <p> No error is raised in respect of a candidate <code>IDREF</code> value
                            that does not match the <code>ID</code> of any element in the document.
                            If no candidate <code>IDREF</code> value matches the <code>ID</code>
                            value of any element, the function returns the empty sequence.</p>
                        <p> It is not necessary that the supplied argument should have type <code>xs:IDREF</code> or <code>xs:IDREFS</code>, or that it should be
                            derived from a node with the <code>is-idrefs</code> property.</p>
                        <p> An element may have more than one <code>ID</code> value. This can occur
                            with synthetic data models or with data models constructed from a PSVI
                            where the element and one of its attributes are both typed as <code>xs:ID</code>.</p>
                        <p> If the source document is well-formed but not valid, it is possible for
                            two or more elements to have the same <code>ID</code> value. In this
                            situation, the function will select the first such element.</p>
                        <p> It is also possible in a well-formed but invalid document to have an
                            element or attribute that has the is-id property but whose value does
                            not conform to the lexical rules for the <code>xs:ID</code> type. Such a
                            node will never be selected by this function.</p>
                    </notes>
                </div3>
                <div3 id="func-idref">
                    <head>fn:idref</head>
                    <example role="signature">
                        <proto name="idref" return-type="node()*" returnEmptyOk="no">
                            <arg name="arg" type="xs:string*" emptyOk="no"/>
                        </proto>
                    </example>
                    <example role="signature">
                        <proto name="idref" return-type="node()*" returnEmptyOk="no">
                            <arg name="arg" type="xs:string*" emptyOk="no"/>
                            <arg name="node" type="node()" emptyOk="no"/>
                        </proto>
                    </example>
                    <p> Summary: Returns the sequence of element or attribute nodes with an
                        <code>IDREF</code> value matching the value of one or more of
                        the <code>ID</code> values supplied in <code>$arg</code>.</p>
                    <p> The function returns a sequence, in document order with duplicates
                        eliminated, containing every element or attribute node <code>$N</code> that
                        satisfies all the following conditions:</p>
                    <olist>
                        <item>
                            <p>
                                <code>$N</code> is in the target document. 
The target document is the document containing <code>$node</code> or the document containing the context item (<code>.</code>) if the second argument is omitted. The behavior of the function if <code>$node</code> is omitted is exactly the same as if the context item had been passed as <code>$node</code>.  If
                                <code>$node</code>, or the context item if the second argument is
                                omitted, is a node in a tree whose root is not a document node <errorref class="DC" code="0001" type="dynamic"/> is raised.  
If the second argument is the context item, or is omitted, the following errors may be raised: if there is no context item <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node 
<xerrorref spec="XP" class="TY" code="0004" type="type"/>.
                                   </p>
                        </item>
                        <item>
                            <p>
                                <code>$N</code> has an <code>IDREF</code> value equal to one of the
                                candidate <code>ID</code> values, where:</p>
                            <ulist>
                                <item>
                                    <p> A node <code>$N</code> has an <code>IDREF</code> value equal
                                        to <code>V</code> if both of the following conditions are true:</p>
                                    <ulist>
                                        <item>
                                            <p>The <code>is-idrefs</code> property (See <xspecref
                                                  spec="DM" ref="dm-is-idrefs"/>.)of
                                                <code>$N</code> is <code>true</code>
                                            </p>
                                        </item>
                                        <item>
                                            <p> The sequence <eg>fn:tokenize(fn:normalize-space($N),
                                                  ' ')</eg> contains a string that is equal to
                                                <code>V</code> under the rules of the
                                                <code>eq</code> operator using the Unicode code
                                                point collation (<code>&codepoint.collation;</code>).</p>
                                        </item>
                                    </ulist>
                                </item>
                                <item>
                                    <p> Each <code>xs:string</code> in <code>$arg</code> is parsed
                                        as if it were of lexically of type <code>xs:ID</code>. These
                                        <code>xs:string</code>s are then included in the list of
                                        candidate <code>xs:ID</code>s. If any of the strings in
                                        <code>$arg</code> is not a lexically valid
                                        <code>xs:ID</code> (that is, if it is not lexically an
                                        <code>xs:NCName</code>), it is ignored. More formally, the
                                        candidate <code>ID</code> values are the strings in the
                                            sequence <eg>$arg[. castable as xs:NCName]</eg>
                                    </p>
                                </item>
                            </ulist>
                        </item>
                    </olist>
                    <notes>
                        <p> An element or attribute typically acquires the <code>is-idrefs</code>
                            property by being validated against the schema type
                            <code>xs:IDREF</code> or <code>xs:IDREFS</code>, or (for attributes only)
                            by being described as of type <code>IDREF</code> or <code>IDREFS</code>
                            in a DTD.</p>
                        <p> No error is raised in respect of a candidate <code>ID</code> value that
                            does not match the <code>IDREF</code> value of any element or attribute
                            in the document. If no candidate <code>ID</code> value matches the
                            <code>IDREF</code> value of any element or attribute, the function
                            returns the empty sequence.</p>
                        <p> It is possible for two or more nodes to have an <code>IDREF</code> value
                            that matches a given candidate <code>ID</code> value. In this situation,
                            the function will return all such nodes. However, each matching node
                            will be returned at most once, regardless how many candidate
                            <code>ID</code> values it matches.</p>
                        <p> It is possible in a well-formed but invalid document to have a node
                            whose <code>is-idrefs</code> property is true but that does not conform
                            to the lexical rules for the <code>xs:IDREF</code> type. The effect of
                            the above rules is that ill-formed candidate <code>ID</code> values and
                            ill-formed <code>IDREF</code> values are ignored.</p>
                    </notes>
                </div3>
                <div3 id="func-doc">
                    <head>fn:doc</head>
                    <example role="signature">
                        <proto name="doc" return-type="document-node()" returnEmptyOk="yes">
                            <arg name="uri" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: Retrieves a document using an <code>xs:anyURI</code>, which may
                        include a fragment identifier, supplied as an <code>xs:string</code>. If
                        <code>$uri</code> is not a valid <code>xs:anyURI</code>, an error is raised
                            <errorref class="DC" code="0005"/>. If it is a relative URI Reference,
                        it is resolved relative to the value of the base URI property from the
                        static context. The resulting absolute URI Reference is promoted to
                        an <code>xs:string</code>. If the <term>Available documents</term> discussed
                        in <xspecref spec="XP" ref="eval_context"/> provides a mapping from this
                        string to a document node, the function returns that document node. 
<!-- If the
                            <term>Available documents</term> maps the string to an empty sequence,
                        then the function returns an empty sequence. -->
If the <term>Available
                        documents</term> provides no mapping for the string, an error is raised
                            <errorref class="DC" code="0005"/>.</p>
                    <!-- <p><code>$uri</code> must not contain a fragment identifier.</p> -->
                    <p>If <code>$uri</code> is the empty sequence, the result is an empty sequence.</p>
                    <p>By default, this function is <termref def="stable"/>. Two calls on this function return
                        the same document node if the same URI Reference (after resolution to an
                        absolute URI Reference) is supplied to both calls. Thus, the following
                        expression (if it does not raise an error) will always be true:</p>
                    <eg>doc("foo.xml") is doc("foo.xml")</eg>
<p>However, for performance reasons, implementations may provide a user option to
evaluate the function without a guarantee of stability. The manner in which any
such option is provided is implementation-defined. If the user has not selected
such an option, a call of the function must either return a stable result or
must raise an error: <errorref class="DC" code="0003"/>.</p>
                    <p>For detailed type semantics, see <xspecref spec="FS" ref="sec_fn_doc_collection"/>.</p>
                    <note>
                        <p>If <code>$uri</code> is read from a source document, it is generally
                            appropriate to resolve it relative to the base URI property of the
                            relevant node in the source document. This can be achieved by calling
                            the <code>fn:resolve-uri</code> function, and passing the resulting
                            absolute URI as an argument to the <code>fn:doc</code> function.</p>
                    </note>
                    <p>If two calls to this function supply different absolute URI References as
                        arguments, the same document node may be returned if the implementation can
                        determine that the two arguments refer to the same resource.</p>
                    <p> By defining the semantics of this function in terms of a
                        string-to-document-node mapping in the dynamic context, the specification is
                        acknowledging that the results of this function are outside the purview of
                        the language specification itself, and depend entirely on the run-time
                        environment in which the expression is evaluated. This run-time environment
                        includes not only an unpredictable collection of resources ("the web"), but
                        configurable machinery for locating resources and turning their contents
                        into document nodes within the XPath data model. Both the set of resources
                        that are reachable, and the mechanisms by which those resources are parsed
                        and validated, are <termref def="implementation-dependent"/>.</p>
                    <p> One possible processing model for this function is as follows. The resource
                        identified by the URI Reference is retrieved. If the resource cannot be
                        retrieved, an error is raised <errorref class="DC" code="0002"/>. The data
                        resulting from the retrieval action is then parsed as an XML document and a
                        tree is constructed in accordance with the <bibref ref="xpath-datamodel"/>. If the
                        top-level media type is known and is "text", the content is parsed in the
                        same way as if the media type were text/xml; otherwise, it is parsed in the
                        same way as if the media type were application/xml. If the contents cannot
                        be parsed successfully, an error is raised <errorref class="DC" code="0002"/>. Otherwise, the result of the
                        function is the document node at the root of the resulting tree. This tree
                        is then optionally validated against a schema.</p>
                    <p>Various aspects of this processing are <termref
                        def="implementation-defined"/>. Implementations may provide external
                        configuration options that allow any aspect of the processing to be
                        controlled by the user. In particular:</p>
                    <ulist>
                        <item>
                            <p>The set of URI schemes that the implementation recognizes is
                                implementation-defined. Implementations may allow the mapping of
                                URIs to resources to be configured by the user, using mechanisms
                                such as catalogs or user-written URI handlers.</p>
                        </item>
                        <item>
                            <p>The handling of non-XML media types is implementation-defined.
                                Implementations may allow instances of the data model to be
                                constructed from non-XML resources, under user control.</p>
                        </item>
                        <item>
                            <p>It is <termref def="implementation-defined"/> whether DTD validation
                                and/or schema validation is applied to the source document.</p>
                        </item>
                        <item>
                            <p>Implementations may provide user-defined error handling options that
                                allow processing to continue following an error in retrieving a
                                resource, or in parsing and validating its content. When errors have
                                been handled in this way, the function may return either an empty
                                sequence, or a fallback document provided by the error handler.</p>
                        </item>
                        <item><p>Implementations may provide user options that relax the requirement for the
function to return stable results.</p></item>
                    </ulist>
                </div3>
                <div3 id="func-doc-available">
                    <head>fn:doc-available</head>
                    <example role="signature">
                        <proto name="doc-available" return-type="xs:boolean" returnEmptyOk="no">
                            <arg name="uri" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: If <code>fn:doc($uri)</code> returns a document node, this function
                        returns <code>true</code>. If <code>$uri</code> is not a valid
                        <code>xs:anyURI</code>, an error is raised <errorref class="DC"
                        code="0005"/>. Otherwise, this function returns <code>false</code>.</p>
                    <p>If this function returns <code>true</code>, then
                        calling <code>fn:doc($uri)</code> within the same <termref
                        def="execution-scope"/> must return a document node. However, if
non-stable processing has been selected for the <code>fn:doc</code> function, this guarantee is lost.</p>
                </div3>
                <div3 id="func-collection">
                    <head>fn:collection</head>
                    <example role="signature">
                        <proto name="collection" return-type="node()*" returnEmptyOk="no"/>
                    </example>
                    <example role="signature">
                        <proto name="collection" return-type="node()*" returnEmptyOk="no">
                            <arg name="arg" type="xs:string" emptyOk="yes"/>
                        </proto>
                    </example>
                    <p>Summary: This function takes an <code>xs:string</code> as argument and
                        returns a sequence of nodes obtained by interpreting <code>$arg</code> as an
                        <code>xs:anyURI</code> and resolving it according to the mapping specified
                        in <term>Available collections</term> described in <xspecref spec="XP"
                        ref="id-xp-evaluation-context-components"/>. If <term>Available
                        collections</term> provides a mapping from this string to a sequence of
                        nodes, the function returns that sequence. If <term>Available
                        collections</term> maps the string to an empty sequence, then the function
                        returns an empty sequence. If <term>Available collections</term> provides no
                        mapping for the string, an error is raised <errorref class="DC"
                        code="0004"/>. If <code>$arg</code> is not specified, the function returns
                        the sequence of the nodes in the default collection in the dynamic context.
                        See <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>. If the
                        value of the default collection is undefined an error is raised <errorref
                            class="DC" code="0002"/>.</p>
                    <p>If the <code>$arg</code> is a relative <code>xs:anyURI</code>, it is resolved against the value of the base-URI property from the static context. If <code>$arg</code> is not a valid <code>xs:anyURI</code>, an error is raised  <errorref class="DC" code="0004"/>.</p>
                    <p>If <code>$arg</code> is the empty sequence, the function behaves as if it had
                        been called without an argument. See above.</p>
                    <p>By default, this function is <termref def='stable'/>. This means that repeated calls on the function with the same argument will return the same result. However,
for performance reasons, implementations may provide a user option to evaluate
the function without a guarantee of stability. The manner in which any such
option is provided is <termref def='implementation-defined'/>. If the user has not selected such
an option, a call to this function must either return a stable result or must
raise an error: <errorref class="DC" code="0003"/>.</p> 
<p>For detailed type semantics, see
                            <xspecref spec="FS" ref="sec_fn_doc_collection"/>.</p>
                    <note>
                        <p> This function provides a facility for users to work with a collection of
                            documents which may be contained in a directory or rows of a Relational
                            table or other implementation-specific construct. An implementation may
                            also use external variables to identify external resources, but
                            <code>fn:collection()</code> provides functionality not provided by
                            external variables. Specifying resources using URIs is useful because
                            URIs are dynamic, can be parameterized, and do not rely on an external environment.</p>
                    </note>
                   
                </div3>
                <!--				<div3 id="func-input">
					<head>fn:input</head>
					<example role="signature">
						<proto name="input" return-type="node()*"  returnVaries='yes' returnEmptyOk="no"/>
					</example>
					<p>Returns the input sequence. If no input sequence has been assigned, then an error is raised ("No input sequence"). The means by which an input sequence is assigned depends on the environment. This function is <termref def='stable'/>. </p>
				</div3> -->
            </div2>
        </div1>
        <div1 id="context">
            <head>Context Functions</head>
            <p>The following functions are defined to obtain information from the dynamic context.</p>
            <table border="1" summary="Function/operator summary">
                <thead>
                    <tr>
                        <th>Function</th>
                        <th>Meaning</th>
                    </tr>
                </thead>
                <tbody>
                    <!--	<tr>
						<td>
							<code>fn:context-item</code>
						</td>
						<td>Returns the context item.</td>
					</tr> -->
                    <tr>
                        <td>
                            <code>fn:position</code>
                        </td>
                        <td>Returns the position of the context item within the sequence of items
                            currently being processed.</td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:last</code>
                        </td>
                        <td>Returns the number of items in the sequence of items currently being processed.</td>
                    </tr>
                    <!--				<tr>
						<td>
							<code>op:context-document</code>
						</td>
						<td>Returns the source document currently being processed.</td>
					</tr>  -->
                    <tr>
                        <td>
                            <code>fn:current-dateTime</code>
                        </td>
                        <td>Returns the current <code>xs:dateTime</code>.</td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:current-date</code>
                        </td>
                        <td>Returns the current <code>xs:date</code>.</td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:current-time</code>
                        </td>
                        <td>Returns the current <code>xs:time</code>.</td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:implicit-timezone</code>
                        </td>
                        <td>Returns the value of the implicit timezone property from the dynamic context.</td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:default-collation</code>
                        </td>
                        <td>Returns the value of the default collation property from the static context.</td>
                    </tr>
                    <tr>
                        <td>
                            <code>fn:static-base-uri</code>
                        </td>
                        <td>Returns the value of the Base URI property from the static context.</td>
                    </tr>
                </tbody>
            </table>
            <!--	<div2 id="func-context-item">
				<head>fn:context-item</head>
				<example role="signature">
					<proto name="context-item" return-type="item()" isOp="no" returnEmptyOk="yes"/>
				</example>
				<p>Returns the context item i.e. the item currently being processed.  Returns the empty sequence if the context is the empty sequence.</p>
			</div2> -->
            <div2 id="func-position">
                <head>fn:position</head>
                <example role="signature">
                    <proto name="position" return-type="xs:integer" returnEmptyOk="no"/>
                </example>
                <p>Summary:  Returns the context position from the dynamic context.
                        (See <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.) If the
                    context item is undefined, an error is raised: <xerrorref spec="XP" class="DY" code="0002" type="type"/>.</p>
            </div2>
            <div2 id="func-last">
                <head>fn:last</head>
                <example role="signature">
                    <proto name="last" return-type="xs:integer" returnEmptyOk="no"/>
                </example>
                <p>Summary:  Returns the context size from the dynamic context.
                        (See <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.) If the context item is undefined, an error is raised:
                    <xerrorref spec="XP" class="DY" code="0002" type="type"/>.</p>
            </div2>
            <!--		<div2 id="func-context-document">
				<head>op:context-document</head>
				<example role="signature">
					<proto name="context-document" return-type="document" isOp="yes" returnEmptyOk="yes"/>
				</example>
				<p>Returns a document node indicating the source document being processed.  If the context document is not specified, then an error is raised <errorref class="DC" code="0001"/>. If the context document is the empty sequence, returns the empty sequence.  This function backs up the "/" operator.</p>
			</div2> -->
            <div2 id="func-current-dateTime">
                <head>fn:current-dateTime</head>
                <example role="signature">
                    <proto name="current-dateTime" return-type="xs:dateTime" returnEmptyOk="no"/>
                </example>
                <p>Summary: Returns the current dateTime (with timezone) from the dynamic context.
                        (See <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.) This
                    is an <code>xs:dateTime</code> that is current at some time during the
                    evaluation of a query or transformation in
                    which <code>fn:current-dateTime()</code> is executed. This function is <termref
                    def="stable"/>. The precise instant during the query or transformation
                    represented by the value of <code>fn:current-dateTime()</code> is <termref def="implementation-dependent"/>.</p>
                <div3 id='func-current-dateTime-examples'>
                    <head>Examples</head>
                    <ulist>
                        <item>
                            <p>
                                <code>fn:current-dateTime()</code> returns an
                                <code>xs:dateTime</code> corresponding to the current date and time.
                                For example, an invocation of <code>fn:current-dateTime()</code>
                                might return <code>2004-05-12T18:17:15.125Z</code> corresponding to
                                the current time on May 12, 2004 in timezone <code>Z</code>. </p>
                        </item>
                    </ulist>
                </div3>
            </div2>
            <div2 id="func-current-date">
                <head>fn:current-date</head>
                <example role="signature">
                    <proto name="current-date" return-type="xs:date" returnEmptyOk="no"/>
                </example>
                <p>Summary: Returns <code>xs:date(fn:current-dateTime())</code>. This is an
                    <code>xs:date</code> (with timezone) that is current at some time during the
                    evaluation of a query or transformation in which <code>fn:current-date()</code>
                    is executed. This function is <termref def="stable"/>. The precise instant
                    during the query or transformation represented by the value of
                    <code>fn:current-date()</code> is <termref def="implementation-dependent"/>.</p>
                <div3 id='func-current-date-examples'>
                    <head>Examples</head>
                    <ulist>
                        <item>
                            <p>
                                <code>fn:current-date()</code> returns an <code>xs:date</code>
                                corresponding to the current date and time. For example, an
                                invocation of <code>fn:current-date()</code> might return
                                <code>2004-05-12+01:00</code>. </p>
                        </item>
                    </ulist>
                </div3>
            </div2>
            <div2 id="func-current-time">
                <head>fn:current-time</head>
                <example role="signature">
                    <proto name="current-time" return-type="xs:time" returnEmptyOk="no"/>
                </example>
                <p>Summary: Returns <code>xs:time(fn:current-dateTime())</code>. This is an
                    <code>xs:time</code> (with timezone) that is current at some time during the
                    evaluation of a query or transformation in which <code>fn:current-time()</code>
                    is executed. This function is <termref def="stable"/>. The precise instant
                    during the query or transformation represented by the value of
                    <code>fn:current-time()</code> is <termref def="implementation-dependent"/>.</p>
                <div3 id='func-current-time-examples'>
                    <head>Examples</head>
                    <ulist>
                        <item>
                            <p>
                                <code>fn:current-time()</code> returns an <code>xs:time</code>
                                corresponding to the current date and time. For example, an
                                invocation of <code>fn:current-time()</code> might return
                                <code>23:17:00.000-05:00</code>. </p>
                        </item>
                    </ulist>
                </div3>
            </div2>
            <div2 id="func-implicit-timezone">
                <head>fn:implicit-timezone</head>
                <example role="signature">
                    <proto name="implicit-timezone" return-type="xs:dayTimeDuration" returnEmptyOk="no"/>
                </example>
                <p>Summary: Returns the value of the implicit timezone property from the dynamic
                    context. Components of the dynamic context are discussed in <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.
                    <!--  Returns the empty sequence if the implicit timezone is undefined. -->
                </p>
            </div2>
            <div2 id="func-default-collation">
                <head>fn:default-collation</head>
                <example role="signature">
                    <proto name="default-collation" return-type="xs:string" returnEmptyOk="no"/>
                </example>
                <p>Summary: Returns the value of the default collation property from the static
                    context. Components of the static context are discussed in <xspecref spec="XP" ref="id-xp-static-context-components"/>.</p>
                <note>
                    <p> The default collation property can never be undefined. If it is not
                        explicitly defined, a system defined default can be invoked. If this is not
                        provided, the Unicode code point collation
                        (<code>&codepoint.collation;</code>)
                        is used. </p>
                </note>
            </div2>
            <div2 id="func-static-base-uri">
                <head>fn:static-base-uri</head>
                <example role="signature">
                    <proto name="static-base-uri" return-type="xs:anyURI" returnEmptyOk="yes"/>
                </example>
                <p>Summary: Returns the value of the Base URI property from the static context. If
                    the Base URI property is undefined, the empty sequence is returned. Components
                    of the static context are discussed in <xspecref spec="XP"
                    ref="id-xp-static-context-components"/> .</p>
            </div2>
        </div1>
        <div1 id="casting">
            <head>Casting</head>
            <p> Constructor functions and cast expressions accept an expression and return a value
                of a given type. They both convert a source value, <emph>SV</emph>, of a source type,
                <emph>ST</emph>, to a target value, <emph>TV</emph>, of the given target type,
                <emph>TT</emph>, with identical semantics and different syntax. The name of the
                constructor function is the same as the name of the built-in <bibref ref="xmlschema-2"/> 
                datatype or the datatype defined in <xspecref spec="DM" ref="types"/>
                   of <bibref ref="xpath-datamodel"/> (see <specref ref="constructor-functions-for-xsd-types"/>) or the user-derived datatype
                (see <specref ref="constructor-functions-for-user-defined-types"/>) that is the
                target for the conversion, and the semantics are exactly the same as for a cast
                expression; for example,<quote>
                    <code>xs:date("2003-01-01")</code>
                </quote> means exactly the same as <quote>
                    <code>"2003-01-01"</code> cast as 
<code>xs:date?</code>
                </quote>.</p>
            <p>The cast expression takes a type name to indicate the target type of the conversion.
                See <xspecref spec="XP" ref="id-cast"/>. If the type name allows the empty sequence
                and the expression to be cast is the empty sequence, the empty sequence is returned.
                If the type name does not allow the empty sequence and the expression to be cast is
                the empty sequence, a type error is raised <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
            <p>Where the argument to a cast is a literal, the result of the function may be
                evaluated statically; if an error is encountered during such evaluation, it may be
                reported as a static error. </p>
<p>Casting from primitive type to primitive type is discussed in
<specref ref="casting-from-primitive-to-primitive"/>.  Casting to derived types is discussed in <specref ref="casting-to-derived-types"/>.  Casting from derived types is discussed in <specref ref="casting-from-derived-to-parent"/>, <specref ref="casting-within-branch"/> and <specref ref="casting-across-hierarchy"/>.</p>
<p>When casting from <code>xs:string</code> the semantics in <specref ref="casting-from-strings"/> apply, regardless of target type.</p>
            <div2 id="casting-from-primitive-to-primitive">
                <head>Casting from primitive types to primitive types</head>
                <p>This section defines casting between the 19 primitive types defined in <bibref
                    ref="xmlschema-2"/> as well as <code>xs:untypedAtomic</code>,
                    <code>xs:integer</code> and the two derived types of
                    <code>xs:duration</code> (<code>xs:yearMonthDuration</code>
                    and <code>xs:dayTimeDuration</code>). These four types are not primitive types
                    but they are treated as primitive types in this section. The type conversions
                    that are supported are indicated in the table below. In this table, there is a
                    row for each primitive type with that type as the source of the conversion and
                    there is a column for each primitive type as the target of the conversion. The
                    intersections of rows and columns contain one of three characters:
                    <quote>Y</quote> indicates that a conversion from values of the type to which
                    the row applies to the type to which the column applies is supported;
                    <quote>N</quote> indicates that there are no supported conversions from values
                    of the type to which the row applies to the type to which the column applies;
                    and <quote>M</quote> indicates that a conversion from values of the type to
                    which the row applies to the type to which the column applies may succeed for
                    some values in the value space and fails for others.</p>
<p><bibref ref="xmlschema-2"/> defines <code>xs:NOTATION</code> as an abstract type. Thus, casting to <code>xs:NOTATION</code> from any other type including <code>xs:NOTATION</code> is not permitted and raises <xerrorref spec="XP" class="ST" code="0080" type="type"/>.  However, casting from one subtype of <code>xs:NOTATION</code> to another subtype of <code>xs:NOTATION</code> is permitted.</p>
<p>
Casting is not supported to or from <code>xs:anySimpleType</code>. Thus, there is no row or column for this type in the table below. For any node that has not been validated or has been validated as <code>xs:anySimpleType</code>, the typed value of the node is an atomic value of type <code>xs:untypedAtomic</code>. There are no atomic values with the type annotation <code>xs:anySimpleType</code> at runtime. Casting to a type that is not atomic raises <xerrorref spec="XP" class="ST" code="0051" type="type"/>.</p>
<p>
Similarly, casting is not supported to or from <code>xs:anyAtomicType</code> and will raise error <xerrorref spec="XP" class="ST" code="0080" type="type"/>. There are no atomic values with the type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type.
</p>
          <!--      <p>
                    <bibref ref="xmlschema-2"/> defines <code>xs:NOTATION</code> as an abstract type.
                    Thus, casting to <code>xs:NOTATION</code> from any other type including <code>xs:NOTATION</code> is not permitted.  However, casting from one subtype of <code>xs:NOTATION</code> to another subtype of <code>xs:NOTATION</code> is permitted.
</p>
                <p>Casting is not supported to or from <code>xs:anySimpleType</code>. Thus, there is
                    no row or column for this type in the table below. For any node that has not
                    been validated or has been validated as <code>xs:anySimpleType</code>, the typed
                    value of the node is an atomic value of type <code>xs:untypedAtomic</code>.
                    There are no atomic values with the type annotation <code>xs:anySimpleType</code> at runtime.</p>
<p>Similarly, casting is not supported to or from <code>xs:anyAtomicType</code>.  There are no atomic values with the type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type.</p>
<p>An attempt to cast to any of the above three type raises a static error
<xerrorref spec="XP" class="ST" code="0080" type="type"/></p> -->
                <p>If casting is attempted from an <emph>ST</emph> to a <emph>TT</emph> for which
                    casting is not supported, as defined in the table below, a type error is raised <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
                <p>In the following table, the columns and rows are identified by short codes that
                    identify simple types as follows:</p>
                <slist>
                    <sitem>uA = xs:untypedAtomic</sitem>
                    <sitem>aURI = xs:anyURI</sitem>
                    <sitem>b64 = xs:base64Binary</sitem>
                    <sitem>bool = xs:boolean</sitem>
                    <sitem>dat = xs:date</sitem>
                    <sitem>gDay = xs:gDay</sitem>
                    <sitem>dbl = xs:double</sitem>
                    <sitem>dec = xs:decimal</sitem>
                    <sitem>dT = xs:dateTime</sitem>
                    <sitem>dTD = xs:dayTimeDuration</sitem>
                    <sitem>dur = xs:duration</sitem>
                    <sitem>flt = xs:float</sitem>
                    <sitem>hxB = xs:hexBinary</sitem>
                    <sitem>gMD = xs:gMonthDay</sitem>
                    <sitem>gMon = xs:gMonth</sitem>
                    <sitem>int = xs:integer</sitem>
                    <sitem>NOT = xs:NOTATION</sitem>
                    <sitem>QN = xs:QName</sitem>
                    <sitem>str = xs:string</sitem>
                    <sitem>tim = xs:time</sitem>
                    <sitem>gYM = xs:gYearMonth</sitem>
                    <sitem>yMD = xs:yearMonthDuration</sitem>
                    <sitem>gYr = xs:gYear</sitem>
                </slist>
                <p>In the following table, the notation <quote>S\T</quote> indicates that the source
                    (<quote>S</quote>) of the conversion is indicated in the column below the
                    notation and that the target (<quote>T</quote>) is indicated in the row to the
                    right of the notation.</p>
                <!-- The markup in the following table is perhaps a bit surprising, but it serves an important purpose: to allow the resulting HTML to display "tool tips" and cell colors that make it much easier to interpret the contents of the table.  The "special" aspects of the markup include: setting the column widths so that all columns are the same width and marking up the first column in each row as "th" instead of "td".  Editors should be careful not to change these conventions without changing the associated stylesheets. -->
                <table border="1" cellpadding="1" role="casting" summary="Casting table" id='casting-to-primitives-table'>
                    <col width="5%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <col width="3%"/>
                    <thead>
                        <tr>
                            <th>S\T</th>
                            <th>uA</th>
                            <th>str</th>
                            <th>flt</th>
                            <th>dbl</th>
                            <th>dec</th>
                            <th>int</th>
                            <th>dur</th>
                            <th>yMD</th>
                            <th>dTD</th>
                            <th>dT</th>
                            <th>tim</th>
                            <th>dat</th>
                            <th>gYM</th>
                            <th>gYr</th>
                            <th>gMD</th>
                            <th>gDay</th>
                            <th>gMon</th>
                            <th>bool</th>
                            <th>b64</th>
                            <th>hxB</th>
                            <th>aURI</th>
                            <th>QN</th>
                            <th>NOT</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th>uA</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>str</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                            <td>M</td>
                        </tr>
                        <tr>
                            <th>flt</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>M</td>
                            <td>M</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>dbl</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>M</td>
                            <td>M</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>dec</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>int</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>dur</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>yMD</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>dTD</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>dT</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>tim</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>dat</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>gYM</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>gYr</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>gMD</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>gDay</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>gMon</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>bool</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>b64</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>hxB</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>aURI</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>QN</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>Y</td>
                            <td>N</td>
                        </tr>
                        <tr>
                            <th>NOT</th>
                            <td>Y</td>
                            <td>Y</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>N</td>
                            <td>M</td>
                        </tr>
                    </tbody>
                </table>
                <p>The following sub-sections define the semantics of casting from a primitive type
                    to a primitive type. Semantics of casting to and from a derived type are defined
                    in sections <specref ref="casting-to-derived-types"/>, <specref
                    ref="casting-from-derived-to-parent"/>, <specref ref="casting-within-branch"/>
                        and <specref ref="casting-across-hierarchy"/>.</p>
   <div3 id="casting-from-strings">
                    <head>Casting from xs:string and xs:untypedAtomic</head>
                    <p>When the supplied value is an instance of <code>xs:string</code> or an
                        instance of <code>xs:untypedAtomic</code>, it is treated as being a string
                        value and mapped to a typed value of the target type as defined in <bibref ref="xmlschema-2"/>. Whitespace normalization is applied as indicated by the
                        whiteSpace facet for the datatype. The resulting whitespace-normalized string must be a valid lexical form for the datatype.  The semantics of casting are identical to
                        XML Schema validation.  For example, <code>"13" cast as xs:unsignedInt</code> returns the <code>xs:unsignedInt</code> typed 
value <code>13</code>. This could also be written <code>xs:unsignedInt("13")</code>.</p>
<p>When casting from <code>xs:string</code> or <code>xs:untypedAtomic</code> to a derived type where the derived type is restricted by a pattern facet, the
lexical form is first checked against the pattern before further casting is attempted (See <specref ref="casting-to-derived-types"/>).  If the lexical form does not conform to the pattern, error <errorref class="RG" code="0001" type="dynamic"/> is raised. 
</p>
<p>Consider a user-defined Schema whose target namespace is bound to the prefix <code>mySchema</code> which defines a restriction of <code>xs:boolean</code> called <code>trueBool</code> which allows only the lexical forms <quote><code>1</code></quote> and <quote><code>0</code></quote>.  <code>"true" cast as mySchema:trueBool</code> would fail with <errorref class="RG" code="0001" type="dynamic"/>.  If the Schema also defines a datatype called <code>height</code> as a restriction of <code>xs:integer</code> with a maximum value of <code>84</code> then <code>"100" cast as mySchema:height</code> would also fail with <errorref class="RG" code="0001" type="dynamic"/>.</p>
<p>Casting is permitted from <code>xs:string</code> and
                        <code>xs:untypedAtomic</code> to any primitive atomic type or any atomic
                        type derived by restriction, except <code>xs:QName</code> or <code>xs:NOTATION</code>. Casting to <code>xs:NOTATION</code> is not permitted because it is an abstract type.
</p>
                    <p>Casting is permitted from <code>xs:string</code> literals to <code>xs:QName</code> and types derived from <code>xs:NOTATION</code>.  If the argument to such a cast is
computed dynamically, <xerrorref spec="XP" class="TY" code="0004" type="type"/>  is raised if the value is of any type other
than <code>xs:QName</code> or <code>xs:NOTATION</code> respectively (including the case where it is an
<code>xs:string</code>).
 </p>
            
<p>In casting to numerics, if the value is too large or too small to be accurately represented by the implementation, it is handled as an overflow or underflow as defined in <specref ref="op.numeric"/>.</p>

<p>
In casting to <code>xs:decimal</code> or to a type derived from <code>xs:decimal</code>, if the value is not too large or too small but nevertheless cannot be represented accurately with the number of decimal digits available to the implementation, the implementation may round to the nearest representable value or may raise a dynamic error <errorref class="CA" code="0006" type="dynamic"/>. The choice of rounding algorithm and the choice between rounding and error behavior and is implementation-defined.
</p>

<p>In casting to a date or time value, if the value is too large or too small to be represented by the implementation, error <errorref class="DT" code="0001" type="dynamic"/> is raised.</p>

<p>In casting to a duration value, if the value is too large or too small to be represented by the implementation, error <errorref class="DT" code="0002" type="dynamic"/> is raised.</p>

<p> For <code>xs:anyURI</code>, the extent to which an implementation validates the
                                lexical form of <code>xs:anyURI</code> is <termref def="implementation-dependent"/>.</p>

<p>If the cast fails for any other reason, error <errorref class="RG" code="0001" type="dynamic"/> is raised.</p>
                </div3>
              
                <div3 id="casting-to-string">
                    <head>Casting to xs:string and xs:untypedAtomic</head>
                    <p>Casting is permitted from any primitive type to the primitive types
                        <code>xs:string</code> and <code>xs:untypedAtomic</code>.</p>
                    <p>When a value of any simple type is cast as <code>xs:string</code>, the
                        derivation of the <code>xs:string</code> value <emph>TV</emph> depends on
                        the <emph>ST</emph> and on the <emph>SV</emph>, as follows.</p>
                    <ulist>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:string</code> or a type derived from
                                <code>xs:string</code>, <emph>TV</emph> is <emph>SV</emph>.</p>
                        </item>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:anyURI</code>, the type conversion is
                                performed without escaping any characters.</p>
                        </item>
<item>
                            <p>If <emph>ST</emph> is <code>xs:QName</code> or <code>xs:NOTATION</code>:</p>
<ulist> 
<item><p>
if the qualified name has a prefix <emph>TV</emph> is <code>(</code><code>fn:concat(fn:prefix-from-QName(</code><emph><code>SV</code></emph><code>)</code>, <code>":"</code>,
<code>fn:local-name-from-QName(</code><emph><code>SV</code></emph><code>))</code>.</p></item>
<item><p>otherwise <emph>TV</emph> is the local-name.</p>
</item>
</ulist>
                        </item>
                        <item>
                            <p>If <emph>ST</emph> is a numeric type, the following rules apply:</p>
                            <ulist>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:integer</code>,
                                        <emph>TV</emph> is the canonical lexical representation of
                                        <emph>SV</emph> as defined in <bibref ref="xmlschema-2"/>. There
                                        is no decimal point.</p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:decimal</code>, then:</p>
                                    <ulist>
                                        <item>
                                            <p>If <emph>SV</emph> is in the value space of
                                                <code>xs:integer</code>, that is, if there are no
                                                significant digits after the decimal point, then the
                                                value is converted from an <code>xs:decimal</code>
                                                to an <code>xs:integer</code> and the resulting
                                                <code>xs:integer</code> is converted to an
                                                <code>xs:string</code> using the rule above.</p>
                                        </item>
                                        <item>
                                            <p> Otherwise, the canonical lexical representation of
                                                <emph>SV</emph> is returned, as defined in <bibref ref="xmlschema-2"/>.</p>
                                        </item>
                                    </ulist>
                                </item>
                                <item>
                                    <p> If <emph>ST</emph> is <code>xs:float</code> or
                                        <code>xs:double</code>, then:</p>
                                    <ulist>
                                        <item>
                                            <p><emph>TV</emph> will be an <code>xs:string</code> in the lexical space of <code>xs:double</code> or <code>xs:float</code> that when
converted to an <code>xs:double</code> or <code>xs:float</code> under the rules of <specref ref='casting-from-strings'/> produces
a value that is equal to <emph>SV</emph>, or is <quote>NaN</quote> if <emph>SV</emph> is <code>NaN</code>.
In addition, <emph>TV</emph> must satisfy the constraints in the
following sub-bullets.
											</p>
                                   <ulist> 
                                      <item>
                                            <p>If <emph>SV</emph> has an absolute value that is
                                                greater than or equal to 0.000001 (one millionth)
                                                and less than 1000000 (one million), then the value
                                                is converted to an <code>xs:decimal</code> and the
                                                resulting <code>xs:decimal</code> is converted to an
                                                <code>xs:string</code> according to the rules above, as though using an 
implementation of <code>xs:decimal</code> that imposes no limits on the
<code>totalDigits</code> or
<code>fractionDigits</code> facets.</p>
                                        </item> 
  										<item>
                                            <p>If <emph>SV</emph> has the value positive or negative zero, <emph>TV</emph> is "0" or "-0"
respectively.
</p>
                                        </item>
                         				<item>
                                            <p>If <emph>SV</emph> is positive or negative infinity, <emph>TV</emph> is the string "<code>INF</code>" or "<code>-INF</code>" respectively.
</p>
                                        </item>
 										<item>
                                            <p>In other cases, the result consists of a mantissa, which has the lexical form
of an <code>xs:decimal</code>, followed by the letter "E", followed by an exponent which has
the lexical form of an <code>xs:integer</code>. Leading zeroes and "+" signs are prohibited
in the exponent. For the mantissa, there must be a decimal point, and there must
be exactly one digit before the decimal point, which must be non-zero. The  "+"
sign is prohibited. There must be at least one digit after the decimal point.
Apart from this mandatory digit, trailing zero digits are prohibited. 
</p></item>                                     
                       </ulist> </item>
                                  
                                   </ulist>
                              
                                              <note>  <p>The above rules allow more than one representation of the same value. For example, the <code>xs:float</code> value whose exact decimal representation is 1.26743223E15
might be represented by any of the strings "1.26743223E15", "1.26743222E15" or
"1.26743224E15" (inter alia). It is implementation-dependent which of these
representations is chosen.
</p></note>  </item>
                                            
                            </ulist>
                        </item>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:dateTime</code>, <code>xs:date</code>
                                or <code>xs:time</code>, <emph>TV</emph> is the local value. 
The components of <emph>TV</emph> are individually cast to <code>xs:string</code> using the functions described in <bibref ref="casting-to-datetimes"/> and the results are concatenated together.  The <code>year</code> component is cast to <code>xs:string</code> using <code>eg:convertYearToString</code>.  The <code>month</code>, <code>day</code>, <code>hour</code> and <code>minute</code> components are cast to <code>xs:string</code> using <code>eg:convertTo2CharString</code>.  The <code>second</code> component is cast to <code>xs:string</code> using <code>eg:convertSecondsToString</code>. The timezone component, if present, is cast to <code>xs:string</code> using <code>eg:convertTZtoString</code>.  
</p> 
<p> 
Note that the hours component of the resulting string
will never be <code>"24"</code>. Midnight is always represented as <code>"00:00:00"</code>.
</p>
                        </item>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code>, <emph>TV</emph> is the 
                                canonical representation of <emph>SV</emph> as defined in <specref ref='dt-yearMonthDuration'/> or <specref ref='dt-dayTimeDuration'/>, respectively.</p>
                        </item>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:duration</code>
 then let <emph>SYM</emph> be <emph><code>SV</code></emph> <code>cast as xs:yearMonthDuration</code>, and let <emph>SDT</emph> be <emph><code>SV</code></emph> <code>cast as xs:dayTimeDuration</code>;  Now, let the next intermediate value, <emph>TYM</emph>, 
be <emph><code>SYM</code></emph> <code>cast as</code> <emph><code>TT</code></emph>, and let <emph>TDT</emph> be <emph><code>SDT</code></emph> <code>cast as</code> <emph><code>TT</code></emph>.  If <emph>TYM</emph> is "P0M", then <emph>TV</emph> is 
<emph>TDT</emph>.  Otherwise, <emph>TYM</emph> and <emph>TDT</emph> are merged according to the following rules:</p>
<olist>
	<item><p>If <emph>TDT</emph> is "PT0S", then <emph>TV</emph> is <emph>TYM</emph>.</p></item>
	<item><p>Otherwise, <emph>TV</emph> is the concatenation of all the characters in <emph>TYM</emph> and all the
characters except the first "P" and the optional negative sign in <emph>TDT</emph>.</p></item>
</olist>
                         </item>
                        <item>
                            <p>In all other cases, <emph>TV</emph> is the <bibref ref="xmlschema-2"/>
                                canonical representation of <emph>SV</emph>. For datatypes that do
                                not have a canonical lexical representation defined an <termref
                                def="implementation-dependent"/> canonical representation may be used.</p>
                        </item>
                        <!--							<item>
								<p>If <emph>ST</emph> is <code>string</code>, </<emph>TV</emph> is <emph>SV</emph>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>float</code>, <code>double</code>, or <code>decimal</code> then <emph>TV</emph> is the canonical representation of <emph>SV</emph>, as defined by <bibref ref="xmlschema-2"/>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>duration</code> then <emph>TV</emph> is the lexical representation of <emph>SV</emph>, as defined in <bibref ref="xmlschema-2"/> in which each integer and decimal component is expressed in its canonical representation.</p>
							</item>
<item>
								<p>If <emph>ST</emph> is <code>yearMonthDuration</code> or <code>dayTimeDuration</code> then <emph>TV</emph> is the canonical representation of <emph>SV</emph>, in which each integer and decimal component is expressed in its canonical representation.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>dateTime</code> or <code>time</code>, then <emph>TV</emph> is the canonical representation of <emph>SV</emph>, as defined by <bibref ref="xmlschema-2"/>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>date</code>, <code>gYearMonth</code>, <code>gYear</code>, <code>gMonthDay</code>, <code>gDay</code>, or <code>gMonth</code>, then <emph>TV</emph> is the lexical representation of <emph>SV</emph>, as defined by <bibref ref="xmlschema-2"/>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>boolean</code>, then <emph>TV</emph> is <quote>true</quote> if <emph>SV</emph> is true and <quote>false</quote> if <emph>SV</emph> is false.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>hexBinary</code>, then <emph>TV</emph> is the canonical representation of <emph>SV</emph>, as defined by <bibref ref="xmlschema-2"/>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>anyURI</code>, then <emph>TV</emph> is the lexical representation of <emph>SV</emph>, as defined in <bibref ref="xmlschema-2"/>, with each space replaced by the sequence <quote>%20</quote>.</p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>NOTATION</code>, then <emph>TV</emph> is <emph>SV</emph>.</p>
							</item>  -->
                    </ulist>
                    <p>To cast as <code>xs:untypedAtomic</code> the value is cast as
                        <code>xs:string</code>, as described above, and the type annotation changed
                        to <code>xs:untypedAtomic</code>.</p>
                    <note>
                        <p>The string representations of numeric values are backwards compatible
                            with XPath 1.0 except for the special values positive and negative
                            infinity, negative zero and values outside the range <code>1.0e-6</code> to <code>1.0e+6</code>.</p>
                    </note>
                </div3>
                <div3 id="casting-to-numerics">
                    <head>Casting to numeric types</head>
                    <div4 id="casting-to-float">
                        <head>Casting to xs:float</head>
                        <p>When a value of any simple type is cast as <code>xs:float</code>, the <code>xs:float</code>
                            <emph>TV</emph> is derived from the <emph>ST</emph> and the
                            <emph>SV</emph> as follows:</p>
                        <ulist>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:float</code>, then <emph>TV</emph>
                                    is <emph>SV</emph> and the conversion is complete.</p>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:double</code>, then
                                    <emph>TV</emph> is obtained as follows: </p>
                                <ulist>
                                    <item>
                                        <p>if <emph>SV</emph> is the <code>xs:double</code> value
                                            <code>INF</code>, <code>-INF</code>, <code>NaN</code>,
                                            positive zero, or negative zero, then <emph>TV</emph> is
                                            the <code>xs:float</code> value <code>INF</code>,
                                            <code>-INF</code>, <code>NaN</code>, positive zero, or
                                            negative zero respectively.</p>
                                    </item>
                                    <item>
                                        <p>otherwise, <emph>SV</emph> can be expressed in the form
                                                <code>m &times; 2^e</code> where the mantissa
                                            <code>m</code> and exponent <code>e</code> are signed
                                            <code>xs:integer</code>s whose value range is defined in
                                                <bibref ref="xmlschema-2"/>, and the following rules apply:</p>
                                        <ulist>
                                            <item>
                                                <p>if <code>m</code> (the mantissa of
                                                  <emph>SV</emph>) is outside the permitted range
                                                  for the mantissa of an <code>xs:float</code>
                                                  value <code>(-2^24-1 to +2^24-1)</code>, then it
                                                  is divided by <code>2^N</code> where
                                                  <code>N</code> is the lowest positive
                                                  <code>xs:integer</code> that brings the result
                                                  of the division within the permitted range, and
                                                  the exponent <code>e</code> is increased by
                                                  <code>N</code>. This is integer division (in
                                                  effect, the binary value of the mantissa is
                                                  truncated on the right). Let <code>M</code> be
                                                  the mantissa and <code>E</code> the exponent
                                                  after this adjustment.</p>
                                            </item>
                                            <item>
                                                <p>if <code>E</code> exceeds <code>104</code> (the
                                                  maximum exponent value in the value space of
                                                  <code>xs:float</code>) then <emph>TV</emph> is
                                                  the <code>xs:float</code> value <code>INF</code>
                                                  or <code>-INF</code> depending on the sign of <code>M</code>.</p>
                                            </item>
                                            <item>
                                                <p>if <code>E</code> is less than <code>-149</code>
                                                  (the minimum exponent value in the value space
                                                  of <code>xs:float</code>) then <emph>TV</emph> is
                                                  the <code>xs:float</code> value positive or
                                                  negative zero depending on the sign of <code>M</code>
                                                </p>
                                            </item>
                                            <item>
                                                <p>otherwise, <emph>TV</emph> is the
                                                  <code>xs:float</code> value <code>M &times; 2^E</code>.</p>
                                            </item>
                                        </ulist>
                                    </item>
                                </ulist>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:decimal</code>, or
                                    <code>xs:integer</code>, then <emph>TV</emph> is <code>xs:float(</code>
                                    <emph>SV</emph>
                                    <code> cast as xs:string)</code> and the conversion is complete.</p>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:boolean</code>, <emph>SV</emph> is
                                    converted to <code>1.0E0</code> if <emph>SV</emph> is
                                    <code>true</code> and to <code>0.0E0</code> if <emph>SV</emph>
                                    is <code>false</code> and the conversion is complete.</p>
                            </item>
                            <item>
                                <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>. 
</p>
                            </item>
                        </ulist>
                        <note>
                            <p> Implementations <termref def="may"/> return negative zero for
                                    <code>"-0.0E0" cast as xs:float</code>.  <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.</p>
                        </note>
                    </div4>
                    <div4 id="casting-to-double">
                        <head>Casting to xs:double</head>
                        <p>When a value of any simple type is cast as <code>xs:double</code>, the
                            <code>xs:double</code> value <emph>TV</emph> is derived from the
                            <emph>ST</emph> and the <emph>SV</emph> as follows:</p>
                        <ulist>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:double</code>, then
                                    <emph>TV</emph> is <emph>SV</emph> and the conversion is complete.</p>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:float</code> or a type derived
                                    from <code>xs:float</code>, then <emph>TV</emph> is obtained as follows:</p>
                                <ulist>
                                    <item>
                                        <p>if <emph>SV</emph> is the <code>xs:float</code> value
                                            <code>INF</code>, <code>-INF</code>, <code>NaN</code>,
                                            positive zero, or negative zero, then <emph>TV</emph> is
                                            the <code>xs:double</code> value <code>INF</code>,
                                            <code>-INF</code>, <code>NaN</code>, positive zero, or
                                            negative zero respectively. </p>
                                    </item>
                                    <item>
                                        <p>otherwise, <emph>SV</emph> can be expressed in the form
                                                <code>m &times; 2^e</code> where the
                                            mantissa <code>m</code> and exponent <code>e</code> are
                                            signed <code>xs:integer</code> values whose value range
                                            is defined in <bibref ref="xmlschema-2"/>, and
                                            <emph>TV</emph> is the <code>xs:double</code> value
                                                <code>m &times; 2^e</code>. </p>
                                    </item>
                                </ulist>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:decimal</code> or
                                    <code>xs:integer</code>, then <emph>TV</emph> is <code>xs:double(</code>
                                    <emph>SV</emph>
                                    <code> cast as xs:string)</code> and the conversion is complete.</p>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:boolean</code>, <emph>SV</emph> is
                                    converted to <code>1.0E0</code> if <emph>SV</emph> is
                                    <code>true</code> and to <code>0.0E0</code> if <emph>SV</emph>
                                    is <code>false</code> and the conversion is complete.</p>
                            </item>
                            <item>
                                <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>.</p>
                            </item>
                        </ulist>
                        <note>
                            <p> Implementations <termref def="may"/> return negative zero for
                                    <code>"-0.0E0" cast as xs:double</code>.  <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.</p>
                        </note>
                    </div4>
                    <div4 id="casting-to-decimal">
                        <head>Casting to xs:decimal</head>
                        <p>When a value of any simple type is cast as <code>xs:decimal</code>, the
                            <code>xs:decimal</code> value <emph>TV</emph> is derived from
                            <emph>ST</emph> and <emph>SV</emph> as follows: </p>
                        <ulist>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:decimal</code>,
                                    <code>xs:integer</code> or a type derived from them, then
                                    <emph>TV</emph> is <emph>SV</emph>, converted to an
                                    <code>xs:decimal</code> value if need be, and the conversion is complete.</p>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:float</code> or
                                    <code>xs:double</code>, then <emph>TV</emph> is the
                                    <code>xs:decimal</code> value, within the set of
                                    <code>xs:decimal</code> values that the implementation is
                                    capable of representing, that is numerically closest to
                                    <emph>SV</emph>. If two values are equally close, then the one
                                    that is closest to zero is chosen. If <emph>SV</emph> is too
                                    large to be accommodated as an <code>xs:decimal</code>, (see
                                        <bibref ref="xmlschema-2"/> for <termref def='implementation-defined'/> limits on
                                    numeric values) an error is raised <errorref class="CA"
                                    code="0001"/>. If <emph>SV</emph> is one of the special
                                    <code>xs:float</code> or <code>xs:double</code> values
                                    <code>NaN</code>, <code>INF</code>, or <code>-INF</code>, an
                                    error is raised <errorref class="CA" code="0002"/>.</p>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:boolean</code>, <emph>SV</emph> is
                                    converted to <code>1.0</code> if <emph>SV</emph> is
                                    <code>1</code> or <code>true</code> and to <code>0.0</code> if
                                    <emph>SV</emph> is <code>0</code> or <code>false</code> and the
                                    conversion is complete.</p>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>.</p>
                            </item>
                        </ulist>
                    </div4>
                    <div4 id="casting-to-integer">
                        <head>Casting to xs:integer</head>
                        <p>When a value of any simple type is cast as <code>xs:integer</code>, the
                            <code>xs:integer</code> value <emph>TV</emph> is derived from
                            <emph>ST</emph> and <emph>SV</emph> as follows:</p>
                        <ulist>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:integer</code>, or a type derived
                                    from <code>xs:integer</code>, then <emph>TV</emph> is
                                    <emph>SV</emph>, converted to an <code>xs:integer</code> value
                                    if need be, and the conversion is complete.</p>
                            </item>
                            <item>
    
                            <p>If <emph>ST</emph> is
                                    <code>xs:decimal</code>, <code>xs:float</code> or
                                    <code>xs:double</code>, then <emph>TV</emph> is <emph>SV</emph>
                                    with the fractional part discarded and the value converted to
                                    <code>xs:integer</code>. Thus, casting <code>3.1456</code>
                                    returns <code>3</code> and <code>-17.89</code> returns
                                    <code>-17</code>. Casting <code>3.124E1</code>
                                    returns <code>31</code>. If <emph>SV</emph> is too large to be
                                    accommodated as an integer, (see <bibref ref="xmlschema-2"/> for
                                    <termref def='implementation-defined'/> limits on numeric values) an error is
                                    raised <errorref class="CA" code="0003"/>. If <emph>SV</emph> is
                                    one of the special <code>xs:float</code> or
                                    <code>xs:double</code> values <code>NaN</code>,
                                    <code>INF</code>, or <code>-INF</code>, an error is raised
                                        <errorref class="CA" code="0002"/>.</p>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:boolean</code>, <emph>SV</emph> is
                                    converted to <code>1</code> if <emph>SV</emph> is <code>1</code>
                                    or <code>true</code> and to <code>0</code> if <emph>SV</emph> is
                                    <code>0</code> or <code>false</code> and the conversion is complete.</p>
                            </item>
                            <item>
                                <p>If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>.</p>
                            </item>
                        <!--    <item>
                                <p>If <emph>TT</emph> is a subtype of <code>xs:integer</code>, then
                                    <emph>TV</emph> is calculated as described above, and is then
                                    cast to <emph>TT</emph> as described in <specref
                                    ref="casting-within-branch"/>. This involves checking the value
                                    against the facets of <emph>TT</emph>.</p>
                            </item>  -->
                        </ulist>
                    </div4>
                </div3>
                <div3 id="casting-to-durations">
                    <head>Casting to duration types</head>
                    <p>When a value of type <code>xs:untypedAtomic</code>, <code>xs:string</code>,
                        a type derived from <code>xs:string</code>,
                        <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code> is
                        cast as <code>xs:duration</code>, <code>xs:yearMonthDuration</code> or
                        <code>xs:dayTimeDuration</code>, <emph>TV</emph> is derived from
                        <emph>ST</emph> and <emph>SV</emph> as follows:</p>
                    <ulist>
                        <item>
                            <p>If <emph>ST</emph> is the same as <emph>TT</emph>, then
                                <emph>TV</emph> is <emph>SV</emph>. </p>
                        </item>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:duration</code>, or a type derived
                                from <code>xs:duration</code>, but not
                                <code>xs:dayTimeDuration</code> or a type derived from
                                <code>xs:dayTimeDuration</code>, and <emph>TT</emph> is
                                <code>xs:yearMonthDuration</code>, then <emph>TV</emph> is derived
                                from <emph>SV</emph> by removing the day, hour, minute and second
                                components from <emph>SV</emph>.</p>
                        </item>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:duration</code>, or a type derived
                                from <code>duration</code>, but not
                                <code>xs:yearMonthDuration</code> or a type derived from
                                <code>xs:yearMonthDuration</code>, and <emph>TT</emph> is
                                <code>xs:dayTimeDuration</code>, then <emph>TV</emph> is derived
                                from <emph>SV</emph> by removing the year and month components from <emph>SV</emph>.</p>
                        </item>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:yearMonthDuration</code>
                                or <code>xs:dayTimeDuration</code>, and <emph>TT</emph> is
                                <code>xs:duration</code>, then <emph>TV</emph> is derived from
                                <emph>SV</emph> as discussed in <specref ref="casting-from-derived-to-parent"/>.</p>
                        </item>
 						<item>
                            <p>If <emph>ST</emph> is <code>xs:yearMonthDuration</code>
                                and <emph>TT</emph> is
                                <code>xs:dayTimeDuration</code>, the cast is permitted and returns a <code>xs:dayTimeDuration</code> with value 0.0 seconds.</p>                      </item>
 						<item>
                            <p>If <emph>ST</emph> is <code>xs:dayTimeDuration</code>
                                and <emph>TT</emph> is
                                <code>xs:yearMonthDuration</code>, the cast is permitted and returns a <code>xs:yearMonthDuration</code> with value 0 months.</p>                      </item>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>.</p>
                        </item>
                    </ulist>
                    <p>Note that casting from <code>xs:duration</code> to
                        <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code> loses
                        information. To avoid this, users can cast the <code>xs:duration</code>
                        value to both an <code>xs:yearMonthDuration</code> and an
                        <code>xs:dayTimeDuration</code> and work with both values.</p>
                </div3>
                <div3 id="casting-to-datetimes">
                    <head>Casting to date and time types</head>
                    <p>In several situations, casting to date and time types requires the extraction
                        of a component from <emph>SV</emph> or from the result of
                        <code>fn:current-dateTime</code> and converting it to an
                        <code>xs:string</code>. These conversions must follow certain rules. For
                        example, converting an <code>xs:integer</code> year value requires
                        converting to an <code>xs:string</code> with four or more characters, preceded
                        by a minus sign if the value is negative.</p>
                    <p>This document defines four functions to perform these conversions. These
                        functions are for illustrative purposes only and make no recommendations as
                        to style or efficiency.  References to these functions from the following text are not normative.</p>
                    <p>The arguments to these functions come from functions defined in this
                        document. Thus, the functions below assume that they are correct and do no
                        range checking on them.</p>
                    <eg><![CDATA[
declare function eg:convertYearToString($year as xs:integer) as xs:string
{
   let $plusMinus := if ($year >= 0) then "" else "-"
   let $yearString := fn:abs($year) cast as xs:string
   let $length := fn:length($yearString)
   return
     if ($length = 1)  then fn:concat($plusMinus, "000", $yearString)
     else
     if ($length = 2)  then fn:concat($plusMinus, "00", $yearString)
       else
       if ($length = 3)  then fn:concat($plusMinus, "0", $yearString)
       else fn:concat($plusMinus, $yearString)
}
                    ]]></eg>
                    <eg><![CDATA[
declare function eg:convertTo2CharString($value as xs:integer) as xs:string
{
   let $string := $value cast as xs:string
   return 
     if (fn:length($string) = 1) then fn:concat("0", $string)
     else $string
}
                    ]]></eg>
                    <eg><![CDATA[
declare function eg:convertSecondsToString($seconds as xs:decimal) as xs:string
{
   let $string := $seconds cast as xs:string
   let $intLength := fn:length(($seconds cast as xs:integer) cast as xs:string)
   return 
     if ($intLength = 1) then fn:concat("0", $string)
     else $string
}
                    ]]></eg>
                    <eg><![CDATA[
declare function eg:convertTZtoString($tz as xs:dayTimeDuration?) as xs:string
{
   if (empty($tz)) then ""
   else 
     let $tzh := fn:hours-from-dayTimeDuration($tz)
     let $tzm := fn:minutes-from-dayTimeDuration($tz)
     let $plusMinus := if ($tzh >= 0) then "+" else "-"
     let $tzhString := eg:convertTo2CharString(fn:abs($tzh))
     let $tzmString := eg:convertTo2CharString(fn:abs($tzm))
     return fn:concat($plusMinus, $tzhString, ":", $tzmString)
}

                    ]]></eg>
                    <p>Conversion from primitive types to date and time types follows the rules below.</p>
                    <olist>
                    <!--    <item>
                            <p>When a value of any primitive type is cast as
                                <code>xs:dateTime</code>, <code>xs:time</code>,
                                <code>xs:date</code>, <code>xs:gYearMonth</code>,
                                <code>xs:gYear</code>, <code>xs:gMonthDay</code>,
                                <code>xs:gDay</code>, or <code>xs:gMonth</code>,</p>
                            <p> let <emph>CYR</emph> be <code>eg:convertYearToString(
                                    fn:year-from-dateTime( fn:current-dateTime() ))</code>,</p>
                            <p> let <emph>CMO</emph> be <code>eg:convertTo2CharString(
                                    fn:month-from-dateTime( fn:current-dateTime() ))</code>, </p>
                            <p> let <emph>CDA</emph> be <code>eg:convertTo2CharString(
                                    fn:day-from-dateTime( fn:current-dateTime() )) </code>.</p>
                            and </p>
<p>
let <emph>CTZ</emph> be <code>eg:convertTZtoString(
	    fn:timezone-from-dateTime( fn:current-dateTime()
	    )</code>. </p> 
                        </item> -->
                        <item>
                            <p>When a value of any primitive type is cast as
                                <code>xs:dateTime</code>, the <code>xs:dateTime</code> value
                                <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph>
                                as follows:</p>
                            <ulist>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:dateTime</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p>
                                </item>
                                <!--		<item>
								<p>If <emph>ST</emph> is <code>xs:time</code>, then let <emph>SHR</emph> be <code>eg:convertTo2CharString( fn:hours-from-time(</code>
									<emph>SV</emph>	<code>)) </code>, let <emph>SMI</emph> be <code>eg:convertTo2CharString( fn:minutes-from-time(</code>
									<emph>SV</emph><code>))</code>, let <emph>SSE</emph> be <code>eg:convertSecondsToString( fn:seconds-from-time(</code>
									<emph>SV</emph><code>))</code> and let <emph>STZ</emph> be <code>eg:convertTZtoString( fn:timezone-from-time(</code><emph>SV</emph><code>))</code>
; <emph>TV</emph> is <code>xs:dateTime( fn:concat(</code>
									<emph>CYR</emph>
									<code>, '-', </code>
									<emph>CMO</emph>
									<code>, '-', </code>
									<emph>CDA</emph>
									<code>, 'T', </code>
									<emph>SHR</emph>
									<code>, ':', </code>
									<emph>SMI</emph>
									<code>, ':', </code>
									<emph>SSE, STZ</emph> 
									<code>) )</code>. </p>
							</item> -->
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:date</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( fn:month-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( fn:day-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:dateTime( fn:concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>
                                        <code>, '-', </code>
                                        <emph>SDA</emph>
                                        <code>, 'T00:00:00 '</code>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                                </item>
                                <item>
                                    <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code> or
                                        <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>.</p>
                                </item>
                            </ulist>
                        </item>
                        <item>
                            <p>When a value of any primitive type is cast as <code>xs:time</code>,
                                the <code>xs:time</code> value <emph>TV</emph> is derived from
                                <emph>ST</emph> and <emph>SV</emph> as follows:</p>
                            <ulist>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:time</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:dateTime</code>, then
                                        <emph>TV</emph> is <code>xs:time( fn:concat(
                                            eg:convertTo2CharString( fn:hours-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>)), ':', eg:convertTo2CharString( fn:minutes-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>)), ':', eg:convertSecondsToString( fn:seconds-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>)), eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>)) ))</code>. </p>
                                </item>
                                <item>
                                    <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>. </p>
                                </item>
                            </ulist>
                        </item>
                        <item>
                            <p>When a value of any primitive type is cast as <code>xs:date</code>,
                                the <code>xs:date</code> value <emph>TV</emph> is derived from
                                <emph>ST</emph> and <emph>SV</emph> as follows:</p>
                            <ulist>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:date</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( fn:month-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( fn:day-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be <code>eg:convertTZtoString(fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:date( fn:concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>
                                        <code>, '-', </code>
                                        <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                                </item>
                                <item>
                                    <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>. </p>
                                </item>
                            </ulist>
                        </item>
                        <item>
                            <p>When a value of any primitive type is cast as
                                <code>xs:gYearMonth</code>, the <code>xs:gYearMonth</code> value
                                <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph>
                                as follows:</p>
                            <ulist>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:gYearMonth</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( fn:month-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:date</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( fn:month-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                                </item>
                                <item>
                                    <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>. </p>
                                </item>
                            </ulist>
                        </item>
                        <item>
                            <p>When a value of any primitive type is cast as <code>xs:gYear</code>,
                                the <code>xs:gYear</code> value <emph>TV</emph> is derived from
                                <emph>ST</emph> and <emph>SV</emph> as follows:</p>
                            <ulist>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:gYear</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:dateTime</code>, let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYear(fn:concat(</code>
                                        <emph>SYR</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:date</code>, let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( fn:year-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYear(fn:concat(</code>
                                        <emph>SYR</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                                </item>
                                <item>
                                    <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>. </p>
                                </item>
                            </ulist>
                        </item>
                        <item>
                            <p>When a value of any primitive type is cast as
                                <code>xs:gMonthDay</code>, the <code>xs:gMonthDay</code> value
                                <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph>
                                as follows:</p>
                            <ulist>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:gMonthDay</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( fn:month-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( fn:day-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
                                        <code> '--', </code>
                                        <emph>SMO</emph>
                                        <code> '-', </code>
                                        <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:date</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( fn:month-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( fn:day-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
                                        <code> '--', </code>
                                        <emph>SMO</emph>
                                        <code>, '-', </code>
                                        <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                                </item>
                                <item>
                                    <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>.</p>
                                </item>
                            </ulist>
                        </item>
                        <item>
                            <p>When a value of any primitive type is cast as <code>xs:gDay</code>,
                                the <code>xs:gDay</code> value <emph>TV</emph> is derived from
                                <emph>ST</emph> and <emph>SV</emph> as follows:</p>
                            <ulist>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:gDay</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let
                                        <emph>SDA</emph> be <code>eg:convertTo2CharString( fn:day-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gDay(
                                            fn:concat( '---'</code>, <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:date</code>, then let
                                        <emph>SDA</emph> be <code>eg:convertTo2CharString( fn:day-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gDay(
                                            fn:concat( '---'</code>, <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                                </item>
                                <item>
                                    <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>. </p>
                                </item>
                            </ulist>
                        </item>
                        <item>
                            <p>When a value of any primitive type is cast as <code>xs:gMonth</code>,
                                the <code>xs:gMonth</code> value <emph>TV</emph> is derived from
                                <emph>ST</emph> and <emph>SV</emph> as follows:</p>
                            <ulist>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:gMonth</code>, then
                                        <emph>TV</emph> is <emph>SV</emph>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( fn:month-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-dateTime(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gMonth(
                                            fn:concat( '--' </code>, <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                                </item>
                                <item>
                                    <p>If <emph>ST</emph> is <code>xs:date</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( fn:month-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( fn:timezone-from-date(</code>
                                        <emph>SV</emph>
                                        <code>))</code>; <emph>TV</emph> is <code>xs:gMonth(
                                            fn:concat( '--'</code>, <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                                </item>
                                <item>
                                    <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>.</p>
                                </item>
                            </ulist>
                        </item>
                    </olist>
                </div3>
                <!--					<head>Casting to date and time types</head>

				<p>Conversion from primitive types to date and time types follows the rules below.</p>
                 <olist> 
					<item>
						<p>When a value of any primitive type is cast as <code>xs:dateTime</code>, <code>xs:time</code>, <code>xs:date</code>, <code>xs:gYearMonth</code>, <code>xs:gYear</code>, 
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, or <code>xs:gMonth</code>, let <emph>CYR</emph> be <code>fn:year-from-dateTime( fn:current-dateTime() ) cast as xs:string</code>, let <emph>CMO</emph> be <code>fn:month-from-dateTime( fn:current-dateTime() ) cast as xs:string</code>, let <emph>CDA</emph> be <code>fn:day-from-dateTime( fn:current-dateTime() ) cast as xs:string</code> and let <emph>CTZ</emph> be <code>fn:timezone-from-dateTime( fn:current-dateTime() ) cast as xs:string</code>. </p>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:dateTime</code>, the <code>xs:dateTime</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
							<item>
								<p>If <emph>ST</emph> is <code>xs:dateTime</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>xs:time</code>, then let <emph>SHR</emph> be <code>fn:hours-from-time(</code>
									<emph>SV</emph>	<code>) cast as xs:string</code>, let <emph>SMI</emph> be <code>fn:minutes-from-time(</code>
									<emph>SV</emph><code>) cast as xs:string</code>, let <emph>SSE</emph> be <code>fn:seconds-from-time(</code>
									<emph>SV</emph><code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-time(</code><emph>SV</emph><code>) cast as xs:string</code>
; <emph>TV</emph> is <code>xs:dateTime( fn:concat(</code>
									<emph>CYR</emph>
									<code>, '-', </code>
									<emph>CMO</emph>
									<code>, '-', </code>
									<emph>CDA</emph>
									<code>, 'T', </code>
									<emph>SHR</emph>
									<code>, ':', </code>
									<emph>SMI</emph>
									<code>, ':', </code>
									<emph>SSE</emph>,
									<emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>xs:date</code>, then let <emph>SYR</emph> be <code>fn:year-from-date(</code>
									<emph>SV</emph><code>) cast as xs:string</code>, let <emph>SMO</emph> be <code>fn:month-from-date(</code><emph>SV</emph><code>) cast as xs:string</code>, let <emph>SDA</emph> be <code>fn:day-from-date(</code>
									<emph>SV</emph><code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code><emph>SV</emph><code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:dateTime( fn:concat(</code>
									<emph>SYR</emph>
									<code>, '-', </code>
									<emph>SMO</emph>
									<code>, '-', </code>
									<emph>SDA</emph>
									<code>, 'T00:00:00 '</code>,
									<emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
							<item>
								<p>
								If <emph>ST</emph> is 
												<code>xs:untypedAtomic</code> or <code>xs:string</code>, emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p>
							</item>
							<item>
								<p><emph>TV</emph> is <code>xs:dateTime(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:time</code>, the <code>xs:time</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
							<item>
								<p>If <emph>ST</emph> is <code>xs:time</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>xs:dateTime</code>, then <emph>TV</emph> is <code>xs:time( fn:concat( fn:hours-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string, ':', fn:minutes-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string, ':', fn:seconds-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string,  fn:timezone-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string ) )</code>. </p>
							</item>
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:time(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:date</code>, the <code>xs:date</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
							<item>
								<p>If <emph>ST</emph> is <code>xs:date</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
							<item>
								<p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let <emph>SYR</emph> be <code>fn:year-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string</code>, 
let <emph>SMO</emph> be <code>fn:month-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string</code>, 
let <emph>SDA</emph> be <code>fn:day-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code><emph>SV</emph><code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:date( fn:concat(</code>
									<emph>SYR</emph>
									<code>, '-', </code>
									<emph>SMO</emph>
									<code>, '-', </code>
									<emph>SDA</emph>, 
									<emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:date(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:gYearMonth</code>, the <code>xs:gYearMonth</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
						<item>
								<p>If <emph>ST</emph> is <code>xs:gYearMonth</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
						<item>
								<p>If <emph>ST</emph> is <code>dateTime</code>, then let <emph>SYR</emph> be <code>fn:year-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>, let <emph>SMO</emph> be <code>fn:month-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
									<emph>SYR</emph>
									<code>, '-', </code>
									<emph>SMO</emph>,
									<emph>STZ</emph>
									<code>) )</code>. </p>
							</item> 
<item>
								<p>If <emph>ST</emph> is <code>date</code>, then let <emph>SYR</emph> be <code>fn:year-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>, let <emph>SMO</emph> be <code>fn:month-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
									<emph>SYR</emph>
									<code>, '-', </code>
									<emph>SMO</emph>,
									<emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:gYearMonth(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:gYear</code>, the <code>xs:gYear</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
						<item> 
								<p>If <emph>ST</emph> is <code>xs:gYear</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
						<item>
								<p>If <emph>ST</emph> is <code>dateTime</code>, let <emph>SYR</emph> be <code>fn:year-from-dateTime(</code> <emph>SV</emph> <code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gYear(</code>
									<emph>SYR</emph>,
									<emph>STZ</emph>
									<code>)</code>. </p>
							</item> 
							<item>
<p>If <emph>ST</emph> is <code>date</code>, let <emph>SYR</emph> be <code>fn:year-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code> 
<emph>SV</emph> <code>) cast as xs:string</code>;
									<emph>TV</emph> is <code>xs:gYear(</code>
									<emph>SYR</emph>,
									<emph>STZ</emph>
									<code>)</code>. </p>
							</item> 
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:gYear(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:gMonthDay</code>, the <code>xs:gMonthDay</code> value <emph>TV</emph> is derived from <emph>ST</emph> <emph>SV</emph> as follows:</p>
						<ulist>
						<item>
								<p>If <emph>ST</emph> is <code>xs:gMonthDay</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
						<item>
								<p>If <emph>ST</emph> is <code>dateTime</code>, then let <emph>SMO</emph> be <code>fn:month-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>, let <emph>SDA</emph> be <code>fn:day-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
									<code> '&mdash;&mdash;', </code>
									<emph>SMO</emph>
									<code>, '-', </code>
									<emph>SDA</emph>, <emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
<item>
								<p>If <emph>ST</emph> is <code>date</code>, then let <emph>SMO</emph> be <code>fn:month-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>, let <emph>SDA</emph> be <code>fn:day-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gYearMonth( fn:concat(</code>
									<code>, '&mdash;&mdash;', </code>
									<emph>SMO</emph>
									<code>, '-', </code>
									<emph>SDA</emph>, <emph>STZ</emph>
									<code>) )</code>. </p>
							</item>
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:gMonthDay(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:gDay</code>, the <code>xs:gDay</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
						<item>
								<p>If <emph>ST</emph> is <code>xs:gDay</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
						<item>
								<p>If <emph>ST</emph> is <code>dateTime</code>, then let <emph>SDA</emph> be <code>fn:day-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gDay( fn:concat( '&mdash;&mdash;&mdash;'</code>,
									<emph>SDA</emph>, <emph>STZ</emph>
									<code>))</code>. </p>
							</item> 
							<item>
								<p>If <emph>ST</emph> is <code>date</code>, then let <emph>SDA</emph> be <code>fn:day-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gDay( fn:concat( '&mdash;&mdash;&mdash;'</code>,
									<emph>SDA</emph>, <emph>STZ</emph>
									<code>))</code>. </p>
							</item> 
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:gDay(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
					<item>
						<p>When a value of any primitive type is cast as <code>xs:gMonth</code>, the <code>xs:gMonth</code> value <emph>TV</emph> is derived from <emph>ST</emph> and <emph>SV</emph> as follows:</p>
						<ulist>
						<item>
								<p>If <emph>ST</emph> is <code>xs:gMonth</code>, then <emph>TV</emph> is <emph>SV</emph>. </p>
							</item>
						<item>
								<p>If <emph>ST</emph> is <code>xs:dateTime</code>, then let <emph>SMO</emph> be <code>fn:month-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-dateTime(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gMonth( fn:concat( '&mdash;&mdash' </code>,
									<emph>SMO</emph>, <emph>STZ</emph>
									<code>))</code>. </p>
							</item> 
<item>
								<p>If <emph>ST</emph> is <code>xs:date</code>, then let <emph>SMO</emph> be <code>fn:month-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code> and let <emph>STZ</emph> be <code>fn:timezone-from-date(</code>
									<emph>SV</emph>
									<code>) cast as xs:string</code>; <emph>TV</emph> is <code>xs:gMonth( fn:concat( '&mdash;&mdash'</code>,
									<emph>SMO</emph>, <emph>STZ</emph>
									<code>))</code>. </p>
							</item> 
							<item>
								<p>
						If <emph>ST</emph> is 
<code>xs:untypedAtomic</code> or 
<code>xs:string</code>, 
<emph>SV</emph> is converted to an intermediate value <emph>IV</emph> of type <code>xs:string</code>.</p></item>
							<item>
								<p><emph>TV</emph> is <code>xs:gMonth(</code>
									<emph>IV</emph>
									<code>)</code>. </p>
							</item>
						</ulist>
					</item>
				</olist> 
			</div2> -->
                <div3 id="casting-boolean">
                    <head>Casting to xs:boolean </head>
                    <p>When a value of any primitive type is cast as <code>xs:boolean</code>, the
                        <code>xs:boolean</code> value <emph>TV</emph> is derived from
                        <emph>ST</emph> and <emph>SV</emph> as follows:</p>
                    <ulist>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:boolean</code>, then <emph>TV</emph>
                                is <emph>SV</emph>.</p>
                        </item>
                        <!--					<item>
						<p>If <emph>ST</emph> is <code>string</code> and 
<code>fn:upper-case(</code>
							<emph>SV</emph>
							<code>)</code> is <quote>
								<code>TRUE</code>
							</quote> or <quote>
								<code>1</code>
							</quote>, then <emph>TV</emph> is <code>true</code>; if <emph>ST</emph> is <code>string</code> and <code>fn:upper-case(</code>
							<emph>SV</emph>
							<code>)</code> is <quote>
								<code>FALSE</code>
							</quote> or <quote>
								<code>0</code>
							</quote>, then <emph>TV</emph> is <code>false</code>. </p>
					</item> -->
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:float</code>, <code>xs:double</code>,
                                <code>xs:decimal</code> or <code>xs:integer</code> and
                                <emph>SV</emph> is <code>0</code>, <code>+0</code>, <code>-0</code>,
                                <code>0.0</code>, <code>0.0E0</code> or <code>NaN</code>, then
                                <emph>TV</emph> is <code>false</code>. </p>
                        </item>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:float</code>, <code>xs:double</code>,
                                <code>xs:decimal</code> or <code>xs:integer</code> and
                                <emph>SV</emph> is not one of the above values, then <emph>TV</emph>
                                is <code>true</code>. </p>
                        </item>
                        <!--					<item>
						<p>If <emph>ST</emph> is <code>xs:base64Binary</code> or <code>xs:hexBinary</code> and <emph>SV</emph> is <quote>
								<code>1</code>
							</quote>, then <emph>TV</emph> is <code>true</code>; if <emph>ST</emph> is <code>xs:base64Binary</code> or <code>xs:hexBinary</code> and <emph>SV</emph> is <quote>
								<code>0</code>
							</quote>, then <emph>TV</emph> is <code>false</code>. </p>
					</item> -->
                        <item>
                            <p> If <emph>ST</emph> is <code>xs:untypedAtomic</code>
                                or <code>xs:string</code>, see 
                                    <specref ref='casting-from-strings'/>. </p>
                        </item>
                    </ulist>
                </div3>
                <div3 id="casting-to-binary">
                    <head>Casting to xs:base64Binary and xs:hexBinary</head>
                    <p>Values of type <code>xs:base64Binary</code> can be cast as
                        <code>xs:hexBinary</code> and vice versa, since the two types have the same
                        value space. Casting to <code>xs:base64Binary</code> and
                        <code>xs:hexBinary</code> is also supported from the same type and from
                        <code>xs:untypedAtomic</code>, <code>xs:string</code> and subtypes of
                        <code>xs:string</code> using <bibref ref="xmlschema-2"/> semantics.</p>
                </div3>
                <div3 id="casting-to-anyuri">
                    <head>Casting to xs:anyURI</head>
                    <p>Casting to <code>xs:anyURI</code> is supported only from the same type,
                        <code>xs:untypedAtomic</code> or <code>xs:string</code>.</p>
                    <p>When a value of any primitive type is cast as <code>xs:anyURI</code>, the
                        <code>xs:anyURI</code> value <emph>TV</emph> is derived from the
                        <emph>ST</emph> and <emph>SV</emph> as follows:</p>
                    <ulist>
                        <item>
                            <p>If <emph>ST</emph> is <code>xs:untypedAtomic</code> or <code>xs:string</code> see 
                                    <specref ref='casting-from-strings'/>.
                             </p>
                        </item>
                    </ulist>
                </div3>
                <!--
<div3 id="casting-to-QName">
				<head>Casting to xs:QName</head>
				<p>It is possible to cast as <code>xs:QName</code> only from <code>xs:untypedAtomic</code>, <code>xs:string</code>.  In each case the <emph>SV</emph> is treated like an <code>xs:string</code>.</p>
<p>The lexical form of <emph>SV</emph> must conform to the QName production of <bibref ref='namespaces'/>.  If not, an error is raised <errorref class="RG" code="0001"/>.</p>
<p>The effect of casting to <code>xs:QName</code> is context dependent.  The local part of the resulting <code>xs:QName</code> is taken from the local part of <emph>SV</emph>. The namespace URI of the resulting <code>xs:QName</code> is determined as follows:</p>
<ulist>
<item><p>
If <emph>SV</emph> has a prefix, then the prefix is mapped to a namespace URI using the statically-known namespaces from the static context. A dynamic error is raised <errorref class="NS" code="0003"/>
 if there is no statically-known namespace with the given prefix.
</p></item>
<item><p>
If <emph>SV</emph> has no prefix, then the resulting <code>xs:QName</code> has the namespace URI given by the default namespace for elements and types, as defined in the static context. If there is no default namespace for elements and types, then the resulting <code>xs:QName</code> has no namespace.</p></item>
</ulist>
<div3 id='Casting-QName-usage'>
<head>Usage Note</head>
<p>
Sometimes the user may want to cast as an <code>xs:QName</code> without using the default namespace. This can be achieved by writing:</p>
<eg>
   if (fn:contains(<emph>SV</emph>, ":")) then xs:QName(<emph>SV</emph>)
        else fn:QName("", <emph>SV</emph>)
</eg>
<p>
Note that the result of casting a string to an <code>xs:QName</code> depends on the static context in which the expression appears, in particular on the namespace declarations that are in scope. This means, for example, that it is not a
good idea to pass a string as an argument to a function and convert the
string to an <code>xs:QName</code> within the function; the conversion must be done in the place where the appropriate namespaces are declared.
</p>
								</div3>
								</div2>
<div2 id="casting-to-notation">
				<head>Casting to xs:NOTATION</head>
<p>Casting to <code>xs:NOTATION</code> and types derived from it is permitted only from values of the same type because the validity of values of these types is context dependent and cannot, in general, be determined. <emph>TV</emph> is derived from the <emph>SV</emph> as follows: <emph>TV</emph> = <emph>SV</emph>.
</p> -->
               
            </div2>
            <div2 id="casting-to-derived-types">
                <head>Casting to derived types</head>
                <p>Casting a value to a derived type can be separated into four cases. Note that
                    <code>xs:untypedAtomic</code>, <code>xs:integer</code> and the two derived
                    types of <code>xs:duration</code>:<code>xs:yearMonthDuration</code>
                    and <code>xs:dayTimeDuration</code> are treated as primitive types.</p>
                <olist>
                    <item>
                        <p>When <emph>SV</emph> is an instance of a type that is derived by
                            restriction from <emph>TT</emph>. This is described in section <specref
                            ref="casting-from-derived-to-parent"/>. </p>
                    </item>
                    <item>
                        <p>When <emph>SV</emph> is an instance of a type derived by restriction from
                            the same primitive type as <emph>TT</emph>. This is described in
                                <specref ref="casting-within-branch"/>. </p>
                    </item>
                    <item>
                        <p>When the derived type is derived, directly or indirectly, from a
                            different primitive type than the primitive type of <emph>ST</emph>.
                            This is described in <specref ref="casting-across-hierarchy"/>.</p>
                    </item>
                    <item>
                        <p>When <emph>SV</emph> is an instance of the <emph>TT</emph>, the cast
                            always succeeds (Identity cast).</p>
                    </item>
                </olist>
            </div2>
            <div2 id="casting-from-derived-to-parent">
                <head>Casting from derived types to parent types</head>
                <p>Except in the case of <code>xs:NOTATION</code>, it is always possible to cast a value of any atomic type to an atomic type from
                    which it is derived, directly or indirectly, by restriction. For example, it is
                    possible to cast an <code>xs:unsignedShort</code> to an
                    <code>xs:unsignedInt</code>, an <code>xs:integer</code>, or an
                    <code>xs:decimal</code>. Since the value space of the original type is a subset
                    of the value space of the target type, such a cast is always successful. The
                    result will have the same value as the original, but will have a new type annotation.</p>
            </div2>
            <div2 id="casting-within-branch">
                <head>Casting within a branch of the type hierarchy</head>
                <p>It is possible to cast an <emph>SV</emph> to a <emph>TT</emph> if the type of the
                    <emph>SV</emph> and the <emph>TT</emph> type are both derived by restriction
                    (directly or indirectly) from the same primitive type, provided that the
                    supplied value conforms to the constraints implied by the facets of the target
                    type.  This includes the case where the target type is derived from the type of the supplied value,
                    as well as the case where the type of the supplied value is derived from the target type.  For example, an instance of <code>xs:byte</code> can be cast as
                    <code>xs:unsignedShort</code>, provided the value is not negative.  </p>
                <p>If the value does not conform to the facets defined for the target type, then an
                    error is raised <errorref class="RG" code="0001"/>. See <bibref ref="xmlschema-2"/>.
                    In the case of the pattern facet (which applies to the lexical space rather than
                    the value space), the pattern is tested against the canonical lexical
                    representation of the value, as defined for the source type (or the result
                    of casting the value to an <code>xs:string</code>, in the case of types that have no canonical
                    lexical representation defined for them).</p>
                <p>Note that this will cause casts to fail if the pattern excludes the canonical
                    lexical representation of the source type. For example, if the type
                    <code>my:distance</code> is defined as a restriction of <code>xs:decimal</code>
                    with a pattern that requires two digits after the decimal point, casting of an
                    <code>xs:integer</code> to <code>my:distance</code> will always fail, because
                    the canonical representation of an <code>xs:integer</code> does not conform to
                    this pattern.</p>
                <p>In some cases, casting from a parent type to a derived type requires special
                    rules. See <specref ref="casting-to-durations"/> for rules regarding casting to
                    <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>.  See <specref ref="casting-to-ENTITY"/>, below, for casting to <code>xs:ENTITY</code> and types derived from it.</p>
			<div3 id="casting-to-ENTITY">
                <head>Casting to xs:ENTITY</head>
<p><bibref ref="xmlschema-2"/> says that <quote>The
value space of ENTITY is the set of all strings that match the 
NCName production ... and have been
declared as an unparsed entity in a document type definition.</quote>
However,
<bibref ref="xslt20"/> and <bibref ref='xquery'/> do not check that constructed values of type <code>xs:ENTITY</code> match declared unparsed entities.  Thus, this rule is relaxed in this specification and, in casting to <code>xs:ENTITY</code> and types derived from it, no check is made that the values correspond to declared unparsed entities.
</p>
			</div3>
            </div2>
            <div2 id="casting-across-hierarchy">
                <head>Casting across the type hierarchy</head>
                <p>When the <emph>ST</emph> and the <emph>TT</emph> are derived, directly or
                    indirectly, from different primitive types, this is called casting across the
                    type hierarchy. Casting across the type hierarchy is logically equivalent to
                    three separate steps performed in order. Errors can occur in either of the
                    latter two steps.</p>
                <olist>
                    <item>
                        <p>Cast the <emph>SV</emph>, up the hierarchy, to the primitive type of the
                            source, as described in <specref ref="casting-from-derived-to-parent"/>.</p>
                    
 <olist><item><p>
If <emph>SV</emph> is an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>, check its value against the pattern facet of <emph>TT</emph>, and raise an error <errorref class="RG" code="0001"/> if the check fails.</p></item>
                   </olist> </item>
                    <item>
                        <p>Cast the value to the primitive type of <emph>TT</emph>, as described in
                                <specref ref="casting-from-primitive-to-primitive"/>.</p>
<ulist><item><p>If <emph>TT</emph> is derived from <code>xs:NOTATION</code>, assume for the
purposes of this rule that casting to <code>xs:NOTATION</code> succeeds.
</p></item></ulist>
                    </item>
                    <item>
                        <p>Cast the value down to the <emph>TT</emph>, as described in <specref ref="casting-within-branch"/>
                        </p>
                    </item>
                </olist>
            </div2>
        </div1>
    </body>
    <back>
<div1 id="biblio">
<head>References</head>

<div2 id="normative-biblio">
<head>Normative References</head>
<blist>

<bibl id="ieee754" key="IEEE 754-1985">IEEE. <emph>IEEE Standard for
Binary Floating-Point Arithmetic.</emph>
</bibl>

<bibl id="LDML" key="Locale Data Markup Language">Unicode Technical
Standard #35, Locale Data Markup Language. Available at:
<loc href="http://www.unicode.org/unicode/reports/tr35/">http://www.unicode.org/unicode/reports/tr35/</loc>
</bibl>

<bibl id="rfc2396" key="RFC 2396">IETF. <emph>RFC 2396: Uniform
Resource Identifiers (URI): Generic Syntax. </emph> Available at:
<loc href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</loc>
</bibl>

<bibl id="rfc3986" key="RFC 3986">IETF. <emph>RFC 3986: Uniform
Resource Identifiers (URI): Generic Syntax. </emph> Available at:
<loc href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</loc>
</bibl>

<bibl id="rfc3987" key="RFC 3987">IETF. <emph>RFC 3987:
Internationalized Resource Identifiers (IRIs).</emph> Available at:
<loc href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</loc>
</bibl>

<bibl id="charmod" key="Character Model for the World Wide Web 1.0:
Fundamentals">Character Model for the World Wide Web 1.0:
Fundamentals. Available at:
<loc href="http://www.w3.org/TR/2005/REC-charmod-20050215/">http://www.w3.org/TR/2005/REC-charmod-20050215/</loc>
</bibl>

<bibl id="charmod-normalization" key="Character Model for the World
Wide Web 1.0: Normalization">Character Model for the World Wide Web
1.0: Normalization, Last Call Working Draft. Available at:
<loc href="http://www.w3.org/TR/2004/WD-charmod-norm-20040225/">http://www.w3.org/TR/2004/WD-charmod-norm-20040225/</loc>
</bibl>

<bibl id="ISO10967" key="ISO 10967">ISO (International Organization
for Standardization). <emph>ISO/IEC 10967-1:1994, Information
technologyLanguage Independent ArithmeticPart 1:
Integer and floating point arithmetic</emph> [Geneva]: International
Organization for Standardization, 1994. Available from: <loc
href="http://www.iso.ch/">http://www.iso.ch/</loc>
</bibl>

<bibl id="Unicode4" key="The Unicode Standard">
The Unicode Consortium, Reading, MA, Addison-Wesley, 2003. <emph>The Unicode Standard</emph>
as updated from time to time by the publication of new versions. See 
<loc href="http://www.unicode.org/unicode/standard/versions">http://www.unicode.org/unicode/standard/versions</loc>
for the latest version and additional information on versions of the standard and of the Unicode Character Database. The version of Unicode to be used is <termref def='implementation-defined'/>, but implementations are recommended to use the latest Unicode version; currently, Version 4.0.00, Addison-Wesley, 2003 ISBN 0-321-18578-1
</bibl>

<bibl id="Unicode-Collations" key="Unicode Collation
Algorithm">Unicode Technical Standard #10, Unicode Collation
Algorithm. Available at:
<loc href="http://www.unicode.org/unicode/reports/tr10/">http://www.unicode.org/unicode/reports/tr10/</loc>
</bibl>

<bibl id="Unicode-Regex" key="Unicode Regular Expressions">Unicode
Technical Standard #18, Unicode Regular Expressions. Available at:
<loc href="http://www.unicode.org/unicode/reports/tr18/">http://www.unicode.org/unicode/reports/tr18/</loc>
</bibl>

<bibl id="REC-xml" key="Extensible Markup Language (XML) 1.0 Recommendation (Third Edition)"> World Wide Web
                        Consortium. <emph>Extensible Markup Language (XML) 1.0 Third Edition.</emph>
                        Available at: <loc href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</loc>
                    </bibl>

<bibl id="xml11" key="Extensible Markup Language (XML) 1.1 Recommendation"> World Wide Web
                        Consortium. <emph>Extensible Markup Language (XML) 1.1.</emph>
                        Available at: <loc href="http://www.w3.org/TR/2004/REC-xml11-20040204/">http://www.w3.org/TR/2004/REC-xml11-20040204/</loc>
                    </bibl>

<bibl id="xpath20" key="XML Path Language (XPath) 2.0"> 
World Wide Web Consortium. XML Path Language
                        (XPath) Version 2.0. Available at: <loc href="http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</loc>
                    </bibl>

<bibl id="xslt20" key="XSL Transformations (XSLT) Version 2.0"> World Wide Web Consortium. XSL Transformations
                        Version 2.0. Available at: <loc href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</loc>
                    </bibl>

<bibl id="xpath-datamodel" key="XQuery 1.0 and XPath 2.0 Data Model"> World Wide Web
                        Consortium. XQuery 1.0 and XPath 2.0 Data Model (XDM). Available at: <loc href="http://www.w3.org/TR/query-datamodel/">http://www.w3.org/TR/query-datamodel/</loc>
                    </bibl>
<bibl id="xquery-semantics" key="XQuery 1.0 and XPath 2.0 Formal Semantics">
                        World Wide Web Consortium. XQuery 1.0 and XPath 2.0 Formal Semantics.
                        Available at: <loc href="http://www.w3.org/TR/query-semantics/">http://www.w3.org/TR/query-semantics/</loc></bibl>
<bibl id="xquery" key="XQuery 1.0: An XML Query Language"> World Wide Web
                        Consortium. XQuery 1.0: An XML Query Language. Available at: <loc href="http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</loc>                    </bibl>
<bibl id="xmlschema-1" key="XML Schema Part 1: Structures Second Edition"> XML
                        Schema Part 1: Structures Second Edition, Oct 28 2004. Available at: <loc href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</loc>
                    </bibl>
<bibl id="xmlschema-2" key="XML Schema Part 2: Datatypes Second Edition"> XML Schema
                        Part 2: Datatypes Second Edition, Oct. 28 2004. Available at: <loc href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</loc></bibl>
<bibl id="REC-xml-names" key="Namespaces in XML"> Namespaces in XML. Available at:
                            <loc href="http://www.w3.org/TR/1999/REC-xml-names-19990114/">http://www.w3.org/TR/1999/REC-xml-names-19990114/</loc>
                    </bibl>
</blist>
</div2>

<div2 id="non-normative-biblio">
<head>Non-normative References</head>
<blist>

<bibl id="HTML40" key="HTML 4.0">HTML 4.01 Recommendation, 24 December
1999. Available at:
<loc href="http://www.w3.org/TR/REC-html40/">http://www.w3.org/TR/REC-html40/</loc>
</bibl>

<bibl id="ISO8601" key="ISO 8601">ISO (International Organization for
Standardization). <emph>Representations of dates and times,
2000-08-03.</emph> Available from:
<loc href="http://www.iso.ch/">http://www.iso.ch/"</loc>
</bibl>

<bibl id="Working-With-Timezones" key="Working With Timezones">World Wide Web Consortium Working Group Note. <emph>Working With Timezones, October 13, 2005.</emph> Available at:
<loc href="http://www.w3.org/TR/2005/NOTE-timezone-20051013/">http://www.w3.org/TR/2005/NOTE-timezone-20051013/</loc>
</bibl>

<bibl id="xpath" key="XML Path Language (XPath) Version 1.0">
World Wide Web Consortium. XML Path Language (XPath) Version 1.0 Available at: 
<loc href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</loc></bibl>

</blist>
</div2>
</div1>

        <div1 id='changelog'>
           <head>Change Log for this Version of the Document</head>
<p>This draft includes corrections and changes based on
<!--
<loc href="http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;product=XPath+%2F+XQuery+%2F+XSLT&amp;component=Functions+and+Operators&amp;version=Candidate+Recommendation&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=&amp;bug_status=RESOLVED&amp;bug_status=VERIFIED&amp;bug_status=CLOSED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">public comments</loc> -->
<loc href="http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;product=XPath+%2F+XQuery+%2F+XSLT&amp;component=Functions+and+Operators&amp;version=Proposed+Recommendation&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=&amp;bug_status=RESOLVED&amp;bug_status=VERIFIED&amp;bug_status=CLOSED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">public comments</loc> 
<!-- in the above the & character has been replaced by &amp; -->
recorded in the W3C public Bugzilla repository (<loc
href="http://www.w3.org/Bugs/Public/">http://www.w3.org/Bugs/Public/</loc>)
used for issue tracking on the <loc href="http://www.w3.org/TR/2006/PR-xpath-functions-20061121/">Proposed Recommendation</loc> of 21 November 2006. A list of 
<!--* substantive  *-->
<!--* No changes since PR are substantive in the technical sense.
    * Word suppressed by MSM, 2007-01-16 *-->
changes since the publication of the <loc href="http://www.w3.org/TR/2006/PR-xpath-functions-20061121/">Proposed Recommendation</loc> appears below.</p>
<ulist>
<item>
<p><kw>Bug 1207: Is unsignedInt("+123") an error?</kw></p>
<p>
The rules for casting from <code>xs:string</code> to derived types were felt to be unclear.  This was resolved by adding a sentence at the end of 
<specref ref="casting"/> that says "When casting from <code>xs:string</code> the semantics in <specref ref="casting-from-strings"/> apply, regardless of target type."
</p>
</item>
<item>
<p><kw>Bug 4030:  Ambiguity re. normalization of the result of fn:concat</kw></p><p>
It was not clear whether the result of result of <code>fn:concat</code> may not be normalized or must not be normalized.  This was resolved by changing the first setence in the note in <code>fn:concat</code> to say "Unicode normalization is not automatically applied to the result of <code>fn:concat</code>".
</p>
</item>
<item>
<p><kw>Bug 4036:  Ambiguity re. matching of argument to fn:lang</kw></p>
<p>
The rules for matching the argument to <code>fn:lang</code> with the value of the <code>xml:lang</code> attribute were felt to be imprecise.  This was resolved by changing the final paragraph to read "Otherwise, the function returns true if and only if, based on a caseless default match as specified in [The Unicode Standard], either (1) <code>$testlang</code> is equal to the string-value of the relevant <code>xml:lang</code> attribute,
or (2) <code>$testlang</code> is equal to some substring of the string-value of the relevant <code>xml:lang</code> attribute that starts at the start of the string-value and ends immediately before a hyphen (x2D)."
</p>
</item>
<item>
<p><kw>fn:iri-to-uri</kw></p>
<p>
Added a note that says that if the argument contains a character that is prohibited in an IRI that character must be percent encoded.
</p>
</item>
</ulist>
<!--
<ulist>
<item>
<p><kw>Namespace prefixes for datatypes:</kw>
Previously, the datatypes that were defined in this document and the <bibref ref='xpath-datamodel'/> document were identified by the prefix <quote>xdt</quote>.  The prefix for all these documents has been changed to <quote>xs</quote> as these datatypes will all be defined in a forthcoming version of XML Schema 1.1 Part 2.
</p>
</item>

<item>
<p><kw>Bug 2448 fn:upper-case() and fn:lower-case():</kw> 
Changed the summary sections of <code>fn:upper-case</code> and <code>fn:lower-case</code> to make explicit the mapping rules for different versions of the <bibref ref='Unicode4'/>.</p>
</item>
<item>
<p><kw>Bug 2457 Rules for URI encoding don't match RFC 3986/3987:</kw>                                    Changed the semantics of <code>fn:encode-for-uri</code> to match <bibref ref='rfc3986'/> and <bibref ref='rfc3987'/>.</p></item>
<item><p><kw>Bug 2464  Regex production [10]:</kw> 
The definition of Char (production [10]) in <bibref ref='xmlschema-2'/> has a known error in which it omits the left brace ("{") and right brace ("}").  That error has been corrected here in section <specref ref='regex-syntax'/>. </p>
</item>
<item><p><kw>Bug 2492 op:notation-equal</kw> 
Since NOTATIONS are QNames, the semantics of <code>op:NOTATION-equal</code> have been changed to mirror the semantics on <code>op:QName-equal</code>.</p></item>

<item><p><kw>Bug 2539 Conformance does not specify what it means for XML:</kw>
Added a note to section 1.1 re. XML 1.1 support.</p></item>

<item><p><kw>Bug 2545 EBV (fn:boolean) and xs:anyURI:</kw> 
Extended bullet 4 that explains <code>fn:boolean</code> semantics to read:
<quote>If <code>$arg</code> is a singleton value of type <code>xs:string</code> or a type derived from <code>xs:string</code>, <code>xs:anyURI</code> or a type derived from <code>xs:anyURI</code> or <code>xs:untypedAtomic</code>, 
<code>fn:boolean</code> returns <code>false</code> if the operand value has zero-length; otherwise it returns <code>true</code>.</quote>
</p></item>

<item><p><kw>2553 Stability of fn:collection:</kw> 
In <specref ref='terminology'/>, added a note under the definition of the term "stable",  after the first paragraph: 
"Note: in the case of <code>fn:collection</code> and <code>fn:doc</code>, the requirement for stability may be relaxed: see the function definitions for details".</p>
<p>
In the definition of <code>fn:collection</code>, deleted the sentence "This function is <termref def='stable'/>. " and replaced it with the following paragraph: "By default, this function is <termref def='stable'/>. This means that repeated calls on the function specifying the same URI will return the same result each time. However, for performance reasons, implementations may provide a user option to evaluate the function without a guarantee of stability. The manner in which any such option is provided is <termref def="implementation-defined"/>. If the user has not selected such an option, a call of the function must either return a stable result or must raise an error."</p>
<p>
In the definition of <code>fn:doc</code>, changed "This function is <termref def='stable'/>" to "By default, this function is <termref def='stable'/>". After the example explaining what this means, added the paragraph: 
"However, for performance reasons, implementations may provide a user option to evaluate the function without a guarantee of stability. The manner in which any such option is provided is <termref def="implementation-defined"/>. If the user has not selected such an option, a call of the function must either return a stable result or must raise an error.</p>
<p>
At the end of this section, added a fifth bullet:</p>
<p>
* Implementations may provide user options that relax the requirement for the function to return stable results.</p>
<p>
In the definition of <code>fn:doc-available</code>, added a final sentence: "However, if non-stable processing has been selected for the <code>fn:doc</code> function, this guarantee is lost."
</p></item>
<item><p><kw>Bug 2559  Conflicting error codes: FORG0006 vs XPTY0004:</kw> 
Changed Section <specref ref='casting'/>, paragraph 2 to say that <quote>() cast as xs:int raises <xerrorref spec="XP" class="TY" code="0004" type="type"/></quote>.
</p></item>
<item><p><kw>Bug 2644 Conversion from float/double to string:</kw> 
Added following paragraph in section <specref ref='casting-from-strings'/> to cover case where the implementation does not support enough digits to accurately represent the value.
"In casting to <code>xs:decimal</code> or to a type derived from <code>xs:decimal</code>, if the value is not too large or too small but nevertheless cannot be represented accurately with the number of decimal digits available to the implementation, the implementation may round to the nearest representable value or may raise a dynamic error <errorref class="CA" code="0006"/>. The choice of rounding algorithm and the choice between rounding and error behavior and is implementation-defined."
</p></item>

<item><p><kw>Bug 2654 Wrong note for resolve-uri():</kw> 
Removed following non-normative note from <code>fn:resolve-uri</code>:
<quote>If <code>$relative</code> is the zero-length string, returns the value of the base-uri property from the static context in the first form (if the base-uri property is not initialized in the static context an error is raised <errorref class="NS" code="0005"/>) and <code>$base</code> in the second form.</quote>
</p></item>

<item><p><kw>Bug 2678  Can't cast xs:QName to xs:QName:</kw></p>
<p> 
In <specref ref='constructor-functions-for-xsd-types'/>, deleted the caveat: "except for constructors for <code>xs:QName</code> and types derived from <code>xs:NOTATION</code> which are identical to "<code>cast as xs:TYPE ". "</code>.</p>
<p>
In <specref ref='constructor-functions-for-xsd-types'/>, deleted the following two paragraphs:</p>
<p>
"Constructor functions for <code>xs:QName</code> and types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>, ..."</p>
<p>
"The prefix within the lexical <code>xs:QName</code> ..."</p>
<p>
replacing them with the paragraph:</p>
<p>
"Special rules apply to constructor functions for <code>xs:QName</code> and types derived from <code>xs:QName</code> and <code>xs:NOTATION:</code> see 
<specref ref='constructor-qname-notation'/>."</p>
<p>
In the list of constructors replaced the entry for <code>xs:QName</code> which read
"<code>xs:QName($arg as xs:string) as xs:QName</code>, <code>$arg</code> 
must be a <code>xs:string</code> literal" with "<code>xs:QName($arg as xdt:anyAtomicType?) as xs:QName?</code> (see <specref ref='constructor-functions-for-user-defined-types'/> for special rules)."</p>
<p>
In <specref ref='constructor-functions-for-user-defined-types'/>, added a new second paragraph: "Special rules apply to constructor functions for types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>: see <specref ref='constructor-qname-notation'/>."</p>
<p>
Added a new section <specref ref='constructor-qname-notation'/> with the following content:</p>
<p>
&lt;new></p><p>
Special rules apply to constructor functions for the types <code>xs:QName</code> and <code>xs:NOTATION</code>, for two reasons:</p>
<ulist>
<item><p>
The lexical representation of these types uses namespace prefixes, whose meaning is context-dependent</p></item>
<item><p>
Values cannot belong directly to the type <code>xs:NOTATION:</code>, only to its subtypes.
</p></item>
</ulist>
<p>These constraints result in the following restrictions:</p>
<ulist>
<item><p>
Conversion from a string to a value of type <code>xs:QName</code> or <code>xs:NOTATION:</code> (including types derived from these) is permitted only if the string is written as a
string literal. This applies whether the conversion is expressed using a constructor function or using the "cast as" syntax. Such a conversion can be regarded as a pseudo-function, which is always evaluated statically. It is also permitted for these constructors and casts to take a dynamically-supplied argument in the normal way, but as the casting table (see  <specref ref='casting'/>) indicates, the only arguments that are supported in this case are values of type <code>xs:QName</code> or <code>xs:NOTATION</code> respectively.</p></item>
<item><p>
There is no constructor function for <code>xs:NOTATION</code>. Constructors are defined, however, for <code>xs:QName</code>, for types derived from <code>xs:QName</code>, and for types derived from <code>xs:NOTATION</code>.</p></item>
</ulist>
<p>
When converting from a string, the prefix within the lexical <code>xs:QName</code> supplied as the argument is resolved to a namespace URI using the statically known namespaces from the static context. If the lexical <code>xs:QName</code> has no prefix, the namespace URI of the resulting expanded-QName is the default element/type namespace from the static context. Components of the static context are discussed in <xspecref spec="XP" ref="static_context"/>. A static error is raised  if the prefix is not bound in the static context. As described in
<xspecref spec="DM" ref="terminology"/>, the supplied prefix is retained as part of the expanded-QName value.</p>
<p>
&lt;/new></p>
<p>
In <specref ref='casting-from-strings'/>, deleted "A static error is raised <xerrorref spec="XP" class="ST" code="0083" type="type"/>if the argument to a cast for <code>xs:QName</code> or a type derived from <code>xs:QName</code> or <code>xs:NOTATION</code> is not an <code>xs:string</code> literal.", replacing it with "If the argument to such a cast is computed dynamically, <xerrorref spec="XP" class="TY" code="0004" type="type"/> is raised if the value is of any type other than <code>xs:QName</code> or <code>xs:NOTATION</code> respectively (including the case where it is an <code>xs:string</code>.)."
</p>
<p>
In <specref ref='casting-from-derived-to-parent'/>, changed "It is always possible..." to "Except in the case of
<code>xs:NOTATION</code>, it is always possible..."
</p>
<p>
In  <specref ref='casting-across-hierarchy'/>, added a bullet 2a: "If <emph>TT</emph> is derived from <code>xs:NOTATION</code>, assume for the purposes of this rule that casting to <code>xs:NOTATION</code> succeeds."
</p></item>

<item><p><kw>Bug 2681 Functions taking "." as default argument:</kw> 
Changed the semantics for all these functions to say that calling the function without an argument is synonymous with calling the function with the context node as argument, both in terms of semantics and error codes. </p></item> 

<item><p><kw>Bug 2722  Compatibility of fn:string-length():</kw> 
Appendix <specref ref='xpath1-compatibility'/> used to say:
"If you apply <code>fn:string-length(@a) == 0</code>; In 1.0 returns <code>true</code> if <code>@a</code> does not exist. In 2.0 returns <code>false</code>."</p>
<p>
This is no longer the case. <code>fn:string-length()</code> is now <code>0</code>, so this expression returns <code>true</code>.</p>
<p>Added: "If compatibility mode is off, numbers and booleans will give errors for first arg. Also, multiple nodes will give an error."
</p></item>
<item><p><kw>Bug 2735  Need for exact semantics in casting xs:string to xs:decimal</kw>
Added the following paragraph to <specref ref='casting-from-strings'/> along with the new error code and a new entry in Appendix G.</p>
<p>
In casting to <code>xs:decimal</code> or to a type derived from <code>xs:decimal</code>, if the value is not too large or too small but nevertheless cannot be represented accurately with the number of decimal digits available to the implementation, the implementation may round to the nearest representable value or may raise a dynamic error <errorref class="CA" code="0006" type="dynamic"/>. The choice of rounding algorithm and the choice between rounding and error behavior and is implementation-defined.
</p></item> 
<item><p><kw>Bug 2789 Substitutability of duration subtypes:</kw> 
Fixed <code>op:duration-equal</code> by adding following text:
<quote>Note that this function (like any other) may be applied to arguments that are derived from the types given in the function signature, including the two subtypes <code>xs:dayTimeDuration</code> and <code>xs:yearMonthDuration</code>. With the exception of the zero-length duration, no instance of <code>xs:dayTimeDuration</code> will ever be equal to an instance of <code>xs:yearMonthDuration</code>.</quote>
</p></item>
<item><p><kw>Bug 3055: How does fn:iri-to-uri() handle an invalid IRI?</kw>
Added the following to
the description of <code>fn:iri-to-uri</code>: If <code>$uri-part</code> contains an invalid character, such as a space character, the invalid character is 
replaced by its percent-encoded form as described in <bibref ref='rfc3986'/> before the conversion is performed.</p>
<p>Also added a note saying that this function does not
check whether <code>$uri-part</code> was a legal IRI; it merely operates on the characters in <code>$uri-part</code>. 
</p></item>
<item><p><kw>Bug 3173 A difficulty with fn:document-uri():</kw>
Changed the text in <code>fn:document-uri</code> from
"If <code>fn:document-uri($arg)</code> does not return the empty sequence, then the
following expression always holds: <code>fn:doc(fn:document-uri($arg))</code> is <code>$arg</code>".
</p>
<p>to:</p>
<p>
"In the case of a document node <code>$D</code> returned by the <code>fn:doc</code> function, or a document node at the root of a tree containing a node returned by the <code>fn:collection</code> function, it will always be true that either
<code>fn:document-uri($D)</code> returns the empty sequence, or that the following expression is true: <code>fn:document-uri($D)</code> is <code>$D</code>. It is implementation-defined whether this guarantee also holds for document nodes
obtained by other means, for example a document node passed as the initial
context node of a query or transformation".</p>
<p>Changes were also made to the definition of "Available Documents" and
"Available Collections" in the XPath and XQuery documents.
</p></item>
<item><p><kw>Bug 3358 Rules for fn:min() and fn:max() handling of non-primitive types:</kw>
Added wording that says that numeric values appearing in the
arguments to <code>fn:min()</code> and <code>fn:max()</code> will "be converted to their least common type by a combination of type promotion and subtype substitution." This is a phrase that is used in XPath, and although there is no formal definition of the terms, it appears to be clear what is meant. 
</p></item>
<item><p><kw>Bug 3369 Operations on xs:duration:</kw>
</p>
<p>
(a) In <specref ref='duration-date-time-types'/>, replaced "Note that only equality is defined on 
<code>xs:duration</code> values." by 
"Note that no ordering relation is defined on <code>xs:duration</code> values.
Two <code>xs:duration</code> values may however be compared for equality. Operations on durations (including equality comparison, casting to string, and extraction of components) all treat the duration as normalized: for example, a duration of 120 seconds always gives the same result as a duration of two minutes."</p>
<p>
(b) In <specref ref='component-extraction-functions'/>, added at the end of the introductory paragraph the sentence: 
"For <code>xs:duration</code> and its subtypes, including the
two subtypes <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>, the components are normalized: this means that the seconds and minutes components will always be less than 60, the hours component less than 24, and the months component less than 12.</p>
<p>
(c) In the description of the individual component extraction functions such as
<code>fn:years-from-duration</code>, deleted the reference to the canonical lexical representation because XML Schema does not define such a representation.
Instead, <code>fn:years-from-duration</code> now says:</p>
<p>
Summary: Returns an <code>xs:integer</code> representing the years component in the value of <code>$arg</code>.</p>
<p>
The result is given by casting <code>$arg</code> to an <code>xs:yearMonthDuration</code> (see <specref ref='casting-to-durations'/>) and then computing the years component as described in <specref ref='dt-yearMonthDuration'/>.</p>
<p>The result may be negative.</p>
<p>If <code>$arg</code> is an <code>xs:dayTimeDuration</code>, returns 0.</p>
<p>If <code>$arg</code> is the empty sequence, returns the empty sequence.</p>
<p>Added similar text for the other five component extraction functions. 
</p></item>
<item><p><kw>Bug 3472 namespace URI for functions:</kw> 
Froze the URL for functions as http://www.w3.org/2005/xpath-functions.
Froze the URL for the codepoint collation as http://www.w3.org/2005/xpath-functions/collation/codepoint. 
</p></item>
<item><p><kw>Bug 3759 fn:round-half-to-even and float precision:</kw> 
For <code>float</code> and <code>double</code> arguments, redefined the function to work by converting the argument to <code>xs:decimal</code>, and then converting the result back to the original type. The additional wording added is " ... the argument is cast to <code>xs:decimal</code>, the function is applied to this <code>xs:decimal</code> value, and the
resulting <code>xs:decimal</code> is cast back to <code>float</code> and <code>double</code> as appropriate to form the function result. 
</p></item>
</ulist>
-->
<!--   
<p>Some of the more significant changes that appear in this version of the document with respect to the last call version <loc xmlns:xlink="http://www.w3.org/1999/xlink"
href="http://www.w3.org/TR/2005/WD-xpath-functions-20050404/">http://www.w3.org/TR/2005/WD-xpath-functions-20050404/</loc>
are listed below.  A complete list of comments against the last call version of the document can be found in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bugzilla</loc> database for product "XPath/XQuery/XSLT" and component "Functions and Operators".  A list of bugs that have been resolved or closed can be found at: 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/buglist.cgi?action=wrap&amp;bug_file_loc_type=allwordssubstr&amp;bugidtype=include&amp;chfieldto=Now&amp;component=Functions%20and%20Operators&amp;emailtype1=substring&amp;emailtype2=substring&amp;field0-0-0=noop&amp;keywords_type=allwords&amp;long_desc_type=allwordssubstr&amp;product=XPath%20%2F%20XQuery%20%2F%20XSLT&amp;query_format=report-table&amp;short_desc_type=allwordssubstr&amp;status_whiteboard_type=allwordssubstr&amp;type0-0-0=noop&amp;resolution=FIXED&amp;bug_status=RESOLVED&amp;bug_status=CLOSED" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">resolved comments</loc>.

</p>
            <ulist>
 				<item>
                    <p>A reference has been added from the section entitled <specref ref = 'durations-dates-times'/> to
<bibref ref='Working-With-Timezones'/>, a W3C Note prepared by the I18N WG that discusses problems, pitfalls and solutions for writing applications that work with date and time values with and without timezones. 
                </p>
                </item>
				<item>
                    <p>The <code>fn:escape-uri</code> function has been removed and replaced with 2 functions called <code>fn:encode-for-uri</code> and
<code>fn:iri-to-uri</code> corresponding to the behaviour of <code>fn:escape-uri</code> with the parameter
<code>escape-reserved</code> set to <code>TRUE</code> and <code>FALSE</code> respectively. 
                    </p>
                </item>
				<item>
                    <p>Values of type <code>xs:duration</code> can now be compared for equality using the new function <code>op:duration-equal</code>.</p>
                </item>
                <item>
                    <p>Values of type <code>xs:duration</code> can now be cast to <code>xs:string</code>.</p>
                </item>
 				<item>
                    <p>The functions <code>fn:subtract-dateTimes-yielding-dayTimeDuration</code> and <code>fn:subtract-dates-yielding-dayTimeDuration</code> have been renamed <code>fn:subtract-dateTimes</code> and <code>fn:subtract-dates</code>, respectively.</p>
                </item>
                <item>
                    <p>The rules for functions returning positive zero or negative zero have been clarified.  Since <bibref ref='xmlschema-2'/> does not distinguish between these two values, functions that return positive zero or negative zero are free to return either value.</p>
                </item>
                <item>
                    <p>A new function <code>fn:escape-html-uri</code> has been added to mimic the html 4.0 URI escaping behavior on attributes.  The serialization specification escapes URIs in this manner and it was felt to be useful to make this functionality available as a function. 
                    </p>
                </item>
				<item>
                    <p>Casting from <code>xs:string</code> and <code>xs:untypedAtomic</code> to derived types has been clarified.  If the derived type is restricted by a pattern, the lexical form is first checked against the pattern.  See <specref ref="casting-from-strings"/>.</p>
                </item>
				<item><p>
Section <specref ref="casting-from-primitive-to-primitive"/> has been clarified to say that although casting is not permitted from <code>xs:NOTATION</code> to
<code>xs:NOTATION</code>, since it is an abstract type, casting is permitted from one subtype of <code>xs:NOTATION</code> to another.  The entry in the table at the intersection of <code>xs:NOTATION</code> and <code>xs:NOTATION</code> has consequently been changed to "M".</p>
				</item>
                <item>
                    <p>This document now does support leap seconds.  Wording has been changed in several places to reflect this decision.</p>
                </item>
			</ulist>  -->
<!--
            <p>We have been made aware of ongoing work to provide URI-based names for collations and
                collation algorithms and to create an IANA registry for such names. See member-only
                communication: <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Member/w3c-query-operators/2003Aug/0017.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Member/w3c-query-operators/2003Aug/0017.html</loc>.
                References to this work may also appear in future versions of this document.</p> -->
        </div1>
        <div1 id='error-summary'>
            <head>Error Summary</head>
            <p>The error text provided with these errors is non-normative.</p>
            <error-list>
                <error class="ER" code="0000" label="Unidentified error." type="dynamic">
                    <p>Unidentified error.</p>
                </error>
                <error class="AR" code="0001" label="Division by zero." type="dynamic">
                    <p>This error is raised whenever an attempt is made to divide by zero.</p>
                </error>
                <error class="AR" code="0002" label="Numeric operation overflow/underflow." type="dynamic">
                    <p>This error is raised whenever numeric operations result in an overflow or underflow.</p>
                </error>
                <error class="CA" code="0001" label="Input value too large for decimal." type="dynamic">  <p></p>
                </error>
                <error class="CA" code="0002" label="Invalid lexical value." type="dynamic">
                    <p></p>
                </error>
                <error class="CA" code="0003" label="Input value too large for integer." type="dynamic">
                    <p></p>
                </error>
                <error class="CA" code="0005" label="NaN supplied as float/double value." type="dynamic">
                    <p></p>
  				</error>
 <error class="CA" code="0006" label="String to be cast to decimal has too many digits of precision." type="dynamic">
                    <p></p>
                </error>
                <error class="CH" code="0001" label="Code point not valid." type="dynamic">
                    <p></p>
                </error>
                <error class="CH" code="0002" label="Unsupported collation." type="dynamic">
                    <p></p>
                </error>
                <error class="CH" code="0003" label="Unsupported normalization form." type="static">
                    <p></p>
                </error>
                <error class="CH" code="0004" label="Collation does not support collation units." type="dynamic">
                    <p></p>
                </error>
                <error class="DC" code="0001" label="No context document." type="dynamic">
                    <p></p>
                </error>
                <error class="DC" code="0002" label="Error retrieving resource." type="dynamic">
                    <p></p>
                </error>
				<error class="DC" code="0003" label="Function stability not defined." type="dynamic">
                    <p></p>
                </error>
                <error class="DC" code="0004" label="Invalid argument to fn:collection." type="dynamic">
                    <p></p>
                </error>
                <error class="DC" code="0005" label="Invalid argument to fn:doc or fn:doc-available." type="dynamic">
                    <p></p>
                </error>
                <error class="DT" code="0001" label="Overflow/underflow in date/time operation." type="dynamic">
                   <p></p>
                </error>
                <error class="DT" code="0002" label="Overflow/underflow in duration operation." type="dynamic">
                    <p></p>
                </error>
                <error class="DT" code="0003" label="Invalid timezone value." type="dynamic">
                    <p></p>
                </error>
<!--
                <error class="NC" code="0001" label="Undefined context item." type="dynamic">
                    <p></p>
                </error> -->
<!--
                <error class="NS" code="0003" label="No prefix defined for namespace." type="dynamic">
                    <p></p>
                </error> -->
                <error class="NS" code="0004" label="No namespace found for prefix." type="dynamic">
                    <p></p>
                </error>
                <error class="NS" code="0005" label="Base-uri not defined in the static context." type="dynamic">
                    <p></p>
                </error>
                <error class="RG" code="0001" label="Invalid value for cast/constructor." type="dynamic">
                    <p></p>
                </error>
                <error class="RG" code="0002" label="Invalid argument to fn:resolve-uri()." type="dynamic">
                    <p></p>
                </error>
                <error class="RG" code="0003"
                    label="fn:zero-or-one called with a sequence containing more than one item." type="dynamic">
                    <p></p>
                </error>
                <error class="RG" code="0004"
                    label="fn:one-or-more called with a sequence containing no items." type="dynamic">
                    <p></p>
                </error>
                <error class="RG" code="0005"
                    label="fn:exactly-one called with a sequence containing zero or more than one item." type="dynamic">
                    <p></p>
                </error>
                <error class="RG" code="0006" label="Invalid argument type." type="static">
                    <p></p>
                </error>
                <error class="RG" code="0008"
                    label="Both arguments to fn:dateTime have a specified timezone." type="dynamic">
                    <p></p>
                </error>
                <error class="RG" code="0009"
                    label="Error in resolving a relative URI against a base URI in fn:resolve-uri." type="dynamic">
                    <p></p>
                </error>
                <error class="RX" code="0001" label="Invalid regular expression. flags" type="static">
                    <p></p>
                </error>
                <error class="RX" code="0002" label="Invalid regular expression." type="dynamic">
                    <p></p>
                </error>
                <error class="RX" code="0003" label="Regular expression matches zero-length string." type="dynamic">
                    <p></p>
                </error>
                <error class="RX" code="0004" label="Invalid replacement string." type="dynamic">
                    <p></p>
                </error>
<!--               	<error class="TY" code="0011" label="Type error.  Context item is not a node." type="type"><p></p>
				   </error> -->
                <error class="TY" code="0012" label="Argument node does not have a typed value." type="dynamic"><p></p>
                   </error>
            </error-list>
        </div1>
        <inform-div1 id="xpath1-compatibility">
            <head>Compatibility with XPath 1.0</head>
            <p>This appendix summarizes the relationship between certain functions defined in
                    <bibref ref="xpath"/> and the corresponding functions defined in this document.
                The first column of the table provides the signature of functions defined in this
                document. The second column provides the signature of the corresponding function in
                    <bibref ref="xpath"/>. The third column discusses the differences in the
                semantics of the corresponding functions. The functions appear in the order they
                appear in <bibref ref="xpath"/>. </p>
            <p>The evaluation of the arguments to the functions defined in this document depends on
                whether the XPath 1.0 compatibility mode is on or off. See <bibref ref="xpath20"/>.
                If the mode is on, the following conversions are applied, in order, before the
                argument value is passed to the function:</p>
            <ulist>
                <item>
                    <p> If the expected type is a single item or an optional single item, (examples:
                            <code>xs:string, xs:string?, xs:untypedAtomic, xs:untypedAtomic?,
                            node(), node()?, item(), item()?</code>), then the given value
                        <code>V</code> is effectively replaced by <code>fn:subsequence(V, 1, 1)</code>.</p>
                </item>
                <item>
                    <p> If the expected type is <code>xs:string</code> or <code>xs:string?</code>,
                        then the given value <code>V</code> is effectively replaced by <code>fn:string(V)</code>.</p>
                </item>
                <item>
                    <p> If the expected type is numeric or optional numeric, then the given value
                        <code>V</code> is effectively replaced by <code>fn:number(V)</code>.</p>
                </item>
                <item>
                    <p>Otherwise, the given value is unchanged.</p>
                </item>
            </ulist>
            <table border="1" width="100%" summary="Issues list">
                <col width="33%"/>
                <col width="33%"/>
                <col width="33%"/>
                <tbody>
                    <tr>
                        <th>XQuery 1.0 and XPath 2.0</th>
                        <th>XPath 1.0</th>
                        <th>Notes</th>
                    </tr>
                    <tr>
                        <td>
                            <proto name="last" role="example" return-type="xs:integer" returnEmptyOk="no"/>
                        </td>
                        <td>
                            <code>last() =&gt; number</code>
                        </td>
                        <td>Precision of numeric results may be different.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="position" role="example" return-type="xs:integer" returnEmptyOk="no"/>
                        </td>
                        <td>
                            <code>position() =&gt; number</code>
                        </td>
                        <td>Precision of numeric results may be different.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="count" role="example" return-type="xs:integer" returnEmptyOk="no">
                                <arg name="arg" type="item*" emptyOk="no"/>
                            </proto>
                        </td>
                        <td>
                            <code>count(node-set) =&gt; number</code>
                        </td>
                        <td>Precision of numeric results may be different.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="id" role="example" return-type="element()*" returnEmptyOk="no">
                                <arg name="arg" type="xs:string*" emptyOk="no"/>
                            </proto>
                        </td>
                        <td>
                            <code>id(object) =&gt; node-set</code>
                        </td>
                        <td>XPath 2.0 behavior is different for boolean and numeric arguments. The
                            recognition of a node as an id value is sensitive to the manner in which
                            the datamodel is constructed. In XPath 1.0 the whole string is treated
                            as a unit. In XPath 2.0 each string is treated as a list.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="local-name" role="example" return-type="xs:string" returnEmptyOk="no"/>
                        </td>
                        <td rowspan="2">
                            <code>local-name(node-set?) =&gt; string</code>
                        </td>
                        <td rowspan="2">If compatibility mode is off, an error will occur if
                            argument has more than one node.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="local-name" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg" type="node()?"/>
                            </proto>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="namespace-uri" role="example" return-type="xs:string" returnEmptyOk="no"/>
                        </td>
                        <td rowspan="2">
                            <code>namespace-uri(node-set?) =&gt; string</code>
                        </td>
                        <td rowspan="2">If compatibility mode is off, an error will occur if
                            argument has more than one node.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="namespace-uri" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg" type="node" emptyOk="yes"/>
                            </proto>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="name" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg" type="node()" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td>
                            <code>name(node-set?) =&gt; string</code>
                        </td>
                        <td>If compatibility mode is off, an error will occur if argument has more
                            than one node. The rules for determining the prefix are more precisely
                            defined in <bibref ref="xpath20"/>. Function is not "well-defined" for
                            parentless attribute nodes.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="string" role="example" return-type="xs:string" returnEmptyOk="no"/>
                        </td>
                        <td rowspan="2">
                            <code>string(object) =&gt; string</code>
                        </td>
                        <td rowspan="2">If compatibility mode is off, an error will occur if
                            argument has more than one node. Representations of numeric values are
                            XPath 1.0 compatible except for the special values positive and negative
                            infinity, and for values outside the range 1.0e-6 to 1.0e+6.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="string" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg" type="item()" emptyOk="yes"/>
                            </proto>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="concat" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg1" type="xs:anyAtomicType" emptyOk="yes"/>
                                <arg name="arg2" type="xs:anyAtomicType" emptyOk="yes"/>
                                <arg name="..." type=""/>
                            </proto>
                        </td>
                        <td rowspan="1">
                            <code>concat(string, string, string*) =&gt; string</code>
                        </td>
<td rowspan="1">If compatibility mode is off, an error will occur if
                            an argument has more than one node.
                            If compatibility mode on, the first node in the sequence is used.</td>
              <!--          <td rowspan="1">If compatibility mode is off, an error will occur if
                            argument has more than one node or if argument is a number or a boolean.
                            If compatibility mode on, implicit conversion is performed.</td> -->
                    </tr>
                    <tr>
                        <td>
                            <proto name="starts-with" role="example" return-type="xs:boolean" returnEmptyOk="no">
                                <arg name="arg1" type="xs:string" emptyOk="yes"/>
                                <arg name="arg2" type="xs:string" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td rowspan="2">
                            <code>starts-with(string, string) =&gt; boolean</code>
                        </td>
                        <td rowspan="2"><!-- In 1.0, returns <code>false</code> if the first argument is
                            an empty node-set. In 2.0, returns <code>()</code>.
--> If compatibility
                            mode is off, an error will occur if either argument has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="starts-with" role="example" return-type="xs:boolean" returnEmptyOk="no">
                                <arg name="arg1" type="xs:string" emptyOk="yes"/>
                                <arg name="arg2" type="xs:string" emptyOk="yes"/>
                                <arg name="collation" type="xs:string"/>
                            </proto>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="contains" role="example" return-type="xs:boolean" returnEmptyOk="no">
                                <arg name="arg1" type="xs:string" emptyOk="yes"/>
                                <arg name="arg2" type="xs:string" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td rowspan="2">
                            <code>contains(string, string) =&gt; boolean</code>
                        </td>
                        <td rowspan="2">
<!-- In 1.0, returns <code>false</code> if the first argument is
                            an empty node-set. In 2.0, returns <code>()</code>.
-->If compatibility
                            mode is off, an error will occur if either argument has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td>                    </tr>
                    <tr>
                        <td>
                            <proto name="contains" role="example" return-type="xs:boolean" returnEmptyOk="no">
                                <arg name="arg1" type="xs:string" emptyOk="yes"/>
                                <arg name="arg2" type="xs:string" emptyOk="yes"/>
                                <arg name="collation" type="xs:string"/>
                            </proto>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="substring-before" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg1" type="xs:string" emptyOk="yes"/>
                                <arg name="arg2" type="xs:string" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td rowspan="2">
                            <code>substring-before(string, string) =&gt; string </code>
                        </td>
                        <td rowspan="2">
<!-- In 1.0, returns <code>""</code> if the first argument is an
                            empty node-set. In 2.0, returns <code>()</code>. -->
If compatibility
                            mode is off, an error will occur if either argument has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="substring-before" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg1" type="xs:string" emptyOk="yes"/>
                                <arg name="arg2" type="xs:string" emptyOk="yes"/>
                                <arg name="collation" type="xs:string"/>
                            </proto>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="substring-after" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg1" type="xs:string" emptyOk="yes"/>
                                <arg name="arg2" type="xs:string" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td rowspan="2">
                            <code>substring-after(string, string) =&gt; string </code>
                        </td>
                        <td rowspan="2">
<!-- In 1.0, returns <code>""</code> if the first argument is an
                            empty node-set. In 2.0, returns <code>()</code>. -->
If compatibility
                            mode is off, an error will occur if either argument has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="substring-after" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg1" type="xs:string" emptyOk="yes"/>
                                <arg name="arg2" type="xs:string" emptyOk="yes"/>
                                <arg name="collation" type="xs:string"/>
                            </proto>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="substring" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="sourceString" type="xs:string" emptyOk="yes"/>
                                <arg name="startingLoc" type="xs:double" emptyOk="no"/>
                            </proto>
                        </td>
                        <td rowspan="2">
                            <code>substring(string, number, number?) =&gt; string </code>
                        </td>
                        <td rowspan="2">
<!-- In 1.0, returns <code>""</code> if the first argument is an
                            empty node-set. In 2.0, returns <code>()</code>. -->If compatibility
                            mode is off, an error will occur if <code>$sourceString</code> has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="substring" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="sourceString" type="xs:string" emptyOk="yes"/>
                                <arg name="startingLoc" type="xs:double" emptyOk="no"/>
                                <arg name="length" type="xs:double" emptyOk="no"/>
                            </proto>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="string-length" role="example" return-type="xs:integer" returnEmptyOk="yes">
                                <arg name="arg" type="xs:string" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td rowspan="2">
                            <code>string-length(string?) =&gt; number </code>
                        </td>
                        <td rowspan="2">If compatibility mode
                            is off, numbers and booleans will give errors for first arg. Also,
                            multiple nodes will give error.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="string-length" role="example" return-type="xs:integer" returnEmptyOk="yes"/>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="normalize-space" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg" type="xs:string" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td rowspan="2">
                            <code>normalize-space(string?) =&gt; string </code>
                        </td>
                        <td rowspan="2">
<!-- In 1.0, returns <code>""</code> if the first argument is an
                            empty node-set. In 2.0, returns <code>()</code>. 
--> If compatibility
                            mode is off, an error will occur if <code>$arg</code> has more than one node or
                            is a number or a boolean. If compatibility mode is on,
                            implicit conversion is performed.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="normalize-space" role="example" return-type="xs:string" returnEmptyOk="no"/>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="translate" role="example" return-type="xs:string" returnEmptyOk="no">
                                <arg name="arg" type="xs:string" emptyOk="yes"/>
                                <arg name="mapString" type="xs:string" emptyOk="yes"/>
                                <arg name="transString" type="xs:string" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td>
                            <code>translate(string, string, string)=&gt; string </code>
                        </td>
                        <td>.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="boolean" role="example" return-type="xs:boolean" returnEmptyOk="no">
                                <arg name="arg" type="item()*" emptyOk="no"/>
                            </proto>
                        </td>
                        <td>
                            <code>boolean(object) =&gt; boolean </code>
                        </td>
                        <td/>
                    </tr>
                    <tr>
                        <td>
                            <proto name="not" role="example" return-type="xs:boolean" returnEmptyOk="no">
                                <arg name="arg" type="item()*" emptyOk="no"/>
                            </proto>
                        </td>
                        <td>
                            <code>not(boolean) =&gt; boolean </code>
                        </td>
                        <td/>
                    </tr>
                    <tr>
                        <td>
                            <proto name="true" role="example" return-type="xs:boolean" returnEmptyOk="no"/>
                        </td>
                        <td>
                            <code>true() =&gt; boolean</code>
                        </td>
                        <td/>
                    </tr>
                    <tr>
                        <td>
                            <proto name="false" role="example" return-type="xs:boolean" returnEmptyOk="no"/>
                        </td>
                        <td>
                            <code>false() =&gt; boolean</code>
                        </td>
                        <td/>
                    </tr>
                    <tr>
                        <td>
                            <proto name="lang" role="example" return-type="xs:boolean" returnEmptyOk="no">
                                <arg name="testlang" type="xs:string"/>
                            </proto>
                        </td>
                        <td>
                            <code>lang(string) =&gt; boolean</code>
                        </td>
                        <td>If compatibility mode is off, numbers and booleans will give errors.
                            Also, multiple nodes will give error. If compatibility mode is on,
                            implicit conversion is performed.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="number" role="example" return-type="xs:double" returnEmptyOk="no"/>
                        </td>
                        <td rowspan="2">
                            <code>number(object?) =&gt; number</code>
                        </td>
                        <td rowspan="2">Error if argument has more than one node when not in
                            compatibility node.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="number" role="example" return-type="xs:double" returnEmptyOk="no">
                                <arg name="arg" type="xs:anyAtomicType?"/>
                            </proto>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="sum" role="example" return-type="xs:anyAtomicType"
                                returnEmptyOk="no" returnVaries="yes">
                                <arg name="arg" type="xs:anyAtomicType*" emptyOk="no"/>
                            </proto>
                        </td>
                        <td>
                            <code>sum(node-set) =&gt; number</code>
                        </td>
                        <td>2.0 raises an error if sequence contains values that cannot be added
                            together such as NMTOKENS and other subtypes of string. 1.0 returns <code>NaN</code>.
                            <!-- In 2.0 <code>NaN</code> values are removed from sequences of
<code>xs:float</code> or <code>xs:double</code> before addition is
performed. -->
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="floor" role="example" return-type="numeric"
                                returnEmptyOk="yes" returnVaries="yes">
                                <arg name="arg" type="numeric" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td>
                            <code>floor(number)=&gt; number</code>
                        </td>
                        <td>In 2.0, if argument is <code>()</code>, the result is <code>()</code>.
                            In 1.0, the result is <code>NaN</code>. If compatibility mode is off, an
                            error will occur with more than one node. If compatibility mode is on,
                            implicit conversion is performed.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="ceiling" role="example" return-type="numeric"
                                returnEmptyOk="yes" returnVaries="yes">
                                <arg name="arg" type="numeric" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td>
                            <code>ceiling(number)=&gt; number</code>
                        </td>
                        <td>In 2.0, if argument is <code>()</code>, the result is <code>()</code>.
                            In 1.0, the result is <code>NaN</code>. If compatibility mode is off, an
                            error will occur with more than one node. If compatibility mode is on,
                            implicit conversion is performed.</td>
                    </tr>
                    <tr>
                        <td>
                            <proto name="round" role="example" return-type="numeric"
                                returnEmptyOk="yes" returnVaries="yes">
                                <arg name="arg" type="numeric" emptyOk="yes"/>
                            </proto>
                        </td>
                        <td>
                            <code>round(number)=&gt; number</code>
                        </td>
                        <td>In 2.0, if argument is <code>()</code>, the result is <code>()</code>.
                            In 1.0, the result is <code>NaN</code>. If compatibility mode is off, an
                            error will occur with more than one node. If compatibility mode is on,
                            implicit conversion is performed.</td>
                    </tr>
                </tbody>
            </table>
        </inform-div1>
        <!--  THE PUTATIVE START OF AN APPENDIX OF FUNCTIONS IN FUTURE VERSION
<inform-div1 id="future-requirements">
			<head>Functions to be Considered for Future Versions</head>
<div1 id='second-order-distict-function'>
  <head>Second-order distinct Function <specref ref="second-order-distinct-function"/> </head>
<p>Was issue 154 
<specref ref="second-order-distinct-function"/></p>
</div1>
</inform-div1> END OF APPENDIX OF FUNCTIONS FOR FUTURE VERSIONS  -->
        <inform-div1 id="examples">
            <head>Illustrative User-written Functions</head>
            <p> Certain functions that were proposed for inclusion in this function library have
                been excluded on the basis that it is straightforward for users to implement these
                functions themselves using XSLT 2.0 or XQuery 1.0.</p>
            <p>This Appendix provides sample implementations of some of these functions.</p>
            <p> To emphasize that these functions are examples of functions that vendors may write,
                their names carry the prefix 'eg'. Vendors are free to define such functions in any
                namespace. A group of vendors may also choose to create a collection of such useful
                functions and put them in a common namespace.</p>
            <div2 id="if-empty-if-absent">
                <head>eg:if-empty and eg:if-absent</head>
                <p>In some situations, users may want to provide default values for missing
                    information that may be signaled by elements that are omitted, have no value or
                    have the empty sequence as their value. For example, a missing middle initial
                    may be indicated by omitting the element or a non-existent bonus signaled with
                    an empty sequence. This section includes examples of functions that provide such
                    defaults. These functions return <code>xs:anyAtomicType*</code>. Users may want
                    to write functions that return more specific types.</p>
                <div3 id="if-empty">
                    <head>eg:if-empty</head>
                    <example role="signature">
                        <proto role="example" name="eg:if-empty" return-type="xs:anyAtomicType*"
                            returnEmptyOk="no" isSpecial="yes">
                            <arg name="node" type="node()" emptyOk="yes"/>
                            <arg name="value" type="xs:anyAtomicType"/>
                        </proto>
                    </example>
                    <p> If the first argument is the empty sequence or an element without simple or
                        complex content, if-empty() returns the second argument; otherwise, it
                        returns the content of the first argument.</p>
                    <p>XSLT implementation</p>
                    <eg><![CDATA[
<xsl:function name="eg:if-empty" as="xs:anyAtomicType*">
  <xsl:param name="node" as="node()?"/>
  <xsl:param name="value" as="xs:anyAtomicType"/>
  <xsl:choose>
    <xsl:when test="$node and $node/child::node()">
      <xsl:sequence select="fn:data($node)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:sequence select="$value"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>]]></eg>
                    <p>XQuery implementation</p>
                    <eg><![CDATA[
declare function eg:if-empty (
  $node as node()?,
  $value as xs:anyAtomicType) as xs:anyAtomicType* 
{
  if ($node and $node/child::node())
            then fn:data($node)
            else $value
}
                    ]]></eg>
                </div3>
                <div3 id="if-absent">
                    <head>eg:if-absent</head>
                    <example role="signature">
                        <proto role="example" name="eg:if-absent" return-type="xs:anyAtomicType*"
                            returnEmptyOk="no" isSpecial="yes">
                            <arg name="node" type="node()" emptyOk="yes"/>
                            <arg name="value" type="xs:anyAtomicType"/>
                        </proto>
                    </example>
                    <p> If the first argument is the empty sequence, if-absent() returns the second
                        argument; otherwise, it returns the content of the first argument.</p>
                    <p>XSLT implementation</p>
                    <eg><![CDATA[
<xsl:function name="eg:if-absent">
  <xsl:param name="node" as="node()?"/>
  <xsl:param name="value" as="xs:anyAtomicType"/>
  <xsl:choose>
    <xsl:when test="$node">
      <xsl:sequence select="fn:data($node)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:sequence select="$value"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>]]></eg>
                    <p>XQuery implementation</p>
                    <eg><![CDATA[
declare function eg:if-absent (
  $node as node()?,
  $value as xs:anyAtomicType) as xs:anyAtomicType* 
{
  if ($node)
    then fn:data($node)
    else $value
}
                    ]]></eg>
                </div3>
            </div2>
            <div2 id="union-intersect-except-on-values">
                <head>union, intersect and except on sequences of values</head>
                <div3 id="value-union">
                    <head>eg:value-union</head>
                    <example role="signature">
                        <proto role="example" name="eg:value-union" return-type="xs:anyAtomicType*"
                            returnEmptyOk="no" isSpecial="yes">
                            <arg name="arg1" type="xs:anyAtomicType*"/>
                            <arg name="arg2" type="xs:anyAtomicType*"/>
                        </proto>
                    </example>
                    <p> This function returns a sequence containing all the distinct items in $arg1
                        and $arg2, in an undefined order.</p>
                    <p>XSLT implementation</p>
                    <eg><![CDATA[
xsl:function name="eg:value-union" as="xs:anyAtomicType*">
  <xsl:param name="arg1" as="xs:anyAtomicType*"/>
  <xsl:param name="arg2" as="xs:anyAtomicType*"/>
  <xsl:sequence
     select="fn:distinct-values(($arg1, $arg2))"/> 
</xsl:function>]]></eg>
                    <p>XQuery implementation</p>
                    <eg><![CDATA[
declare function eg:value-union (
  $arg1 as xs:anyAtomicType*,
  $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* 
{
  fn:distinct-values(($arg1, $arg2))
}
                    ]]></eg>
                </div3>
                <div3 id="value-intersect">
                    <head>eg:value-intersect</head>
                    <example role="signature">
                        <proto role="example" name="eg:value-intersect"
                            return-type="xs:anyAtomicType*" returnEmptyOk="no" isSpecial="yes">
                            <arg name="arg1" type="xs:anyAtomicType*"/>
                            <arg name="arg2" type="xs:anyAtomicType*"/>
                        </proto>
                    </example>
                    <p> This function returns a sequence containing all the distinct items that
                        appear in both $arg1 and $arg2, in an undefined order.</p>
                    <p>XSLT implementation&gt;</p>
                    <eg><![CDATA[
<xsl:function name="eg:value-intersect" as="xs:anyAtomicType*">
  <xsl:param name="arg1" as="xs:anyAtomicType*"/>
  <xsl:param name="arg2" as="xs:anyAtomicType*"/>
  <xsl:sequence 
     select="fn:distinct-values($arg1[.=$arg2])"/>
</xsl:function>]]></eg>
                    <p>XQuery implementation</p>
                    <eg><![CDATA[
declare function eg:value-intersect (
  $arg1 as xs:anyAtomicType*,
  $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* 
{
  fn:distinct-values($arg1[.=$arg2])
}
                    ]]></eg>
                </div3>
                <div3 id="value-except">
                    <head>eg:value-except</head>
                    <example role="signature">
                        <proto role="example" name="eg:value-except"
                            return-type="xs:anyAtomicType*" returnEmptyOk="no" isSpecial="yes">
                            <arg name="arg1" type="xs:anyAtomicType*"/>
                            <arg name="arg2" type="xs:anyAtomicType*"/>
                        </proto>
                    </example>
                    <p> This function returns a sequence containing all the distinct items that
                        appear in $arg1 but not in $arg2, in an undefined order.</p>
                    <p>XSLT implementation</p>
                    <eg><![CDATA[
<xsl:function name="eg:value-except" as="xs:anyAtomicType*">
  <xsl:param name="arg1" as="xs:anyAtomicType*"/>
  <xsl:param name="arg2" as="xs:anyAtomicType*"/>
  <xsl:sequence
     select="fn:distinct-values($arg1[not(.=$arg2)])"/>
</xsl:function>]]></eg>
                    <p>XQuery implementation</p>
                    <eg><![CDATA[
declare function eg:value-except (
  $arg1 as xs:anyAtomicType*,
  $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* 
{
  fn:distinct-values($arg1[not(.=$arg2)])
}]]></eg>
                </div3>
            </div2>
            <div2 id="index-of-node">
                <head>eg:index-of-node</head>
                <example role="signature">
                    <proto role="example" name="eg:index-of-node" return-type="xs:integer*"
                        returnEmptyOk="no" isSpecial="yes">
                        <arg name="seqParam" type="node()*"/>
                        <arg name="srchParam" type="node()"/>
                    </proto>
                </example>
                <p>This function returns a sequence of positive integers giving the positions within
                    the sequence <code>$seqParam</code> of nodes that are identical to <code>$srchParam</code>.</p>
                <p>The nodes in the sequence <code>$seqParam</code> are compared with
                    <code>$srchParam</code> under the rules for the <code>is</code> operator. If a
                    node compares identical, then the position of that node in the sequence
                    <code>$srchParam</code> is included in the result.</p>
                <p> If the value of <code>$seqParam</code> is the empty sequence, or if no node in
                    <code>$seqParam</code> matches $srchParam, then the empty sequence is returned.</p>
                <p> The index is 1-based, not 0-based.</p>
                <p>The result sequence is in ascending numeric order.</p>
                <p>XSLT implementation</p>
                <eg><![CDATA[
<xsl:function name="eg:index-of-node" as="xs:integer*">
  <xsl:param name="sequence" as="node()*"/>
  <xsl:param name="srch" as="node()"/>
  <xsl:for-each select="$sequence">
    <xsl:if test=". is $srch">
       <xsl:sequence select="position()"/>
    </xsl:if>
  </xsl:for-each>
</xsl:function>]]></eg>
                <p>XQuery implementation</p>
                <eg><![CDATA[
declare function eg:index-of-node($sequence as node()*, $srch as node()) as xs:integer* 
{
  for $n at $i in $sequence where ($n is $srch) return $i
}]]></eg>
            </div2>
            <div2 id="string-pad">
                <head>eg:string-pad</head>
                <example role="signature">
                    <proto role="example" name="eg:string-pad" return-type="xs:string"
                        returnEmptyOk="no" isSpecial="yes">
                        <arg name="padString" type="xs:string" emptyOk="yes"/>
                        <arg name="padCount" type="xs:integer"/>
                    </proto>
                </example>
                <p>Returns a <code>xs:string</code> consisting of a given number of copies of an
                    <code>xs:string</code> argument concatenated together.</p>
                <p>XSLT implementation</p>
                <eg><![CDATA[
<xsl:function name="eg:string-pad" as="xs:string">
  <xsl:param name="padString" as="xs:string?"/>
  <xsl:param name="padCount" as="xs:integer"/>
  <xsl:sequence select="fn:string-join((for $i in 1 to $padCount 
                                    return $padString), '')"/>
 </xsl:function>
                ]]></eg>
                <p>XQuery implementation</p>
                <eg><![CDATA[
declare function eg:string-pad (
  $padString as xs:string?,
  $padCount as xs:integer) as xs:string 
{
   fn:string-join((for $i in 1 to $padCount return $padString), "")
}

                ]]></eg>
                <p>This returns the zero-length string if <code>$padString</code> is the empty
                    sequence, which is consistent with the general principle that if an
                    <code>xs:string</code> argument is the empty sequence it is treated as if it
                    were the zero-length string.</p>
            </div2>
            <!--
<div2 id = 'reverse'>
<head>eg:reverse</head>
<example role="signature">
						<proto role='example' name="eg:reverse" return-type="item()*" returnEmptyOk="no" isSpecial='yes'>
							<arg name="inSeq" type="item()*"/>
						</proto>
					</example>

<p>This illustrative function reverses a sequence.</p>

<p>XSLT implementation</p>
<eg><![CDATA[
<xsl:function name="eg:reverse as="item()*">
  <xsl:param name="inSeq" as="item()*" required="yes"/>

  <xsl:variable name="length" select="count($inSeq)"/>
  <xsl:if test="$length > 0">
    <xsl:sequence select="for $p in ($length to 1) return $inSeq[$p]"/>
  </xsl:if>
</xsl:function>]]></eg>

<p>XQuery implementation</p>
<eg><![CDATA[
declare eg:reverse($inSeq as item()*) as item()*
{
   let $length := fn:count($inSeq)
   for $i at $p in $inSeq
   return $inSeq[$length - $p + 1]
}
}]]></eg>

</div2> -->
            <div2 id="func-distinct-nodes-stable">
                <head>eg:distinct-nodes-stable</head>
                <example role="signature">
                    <proto role="example" name="eg:distinct-nodes-stable" return-type="node()*"
                        returnEmptyOk="no" isSpecial="no">
                        <arg name="arg" type="node()*"/>
                    </proto>
                </example>
                <p>This function illustrates one possible implementation of a distinct-nodes
                    function. It removes duplicate nodes by identity, preserving the first
                    occurrence of each node.</p>
                <p>XPath</p>
                <eg><![CDATA[$arg[empty(subsequence($arg, 1, position()-1) intersect .)]
                ]]></eg>
                <p>XSLT implementation</p>
                <eg><![CDATA[
<xsl:function name="eg:distinct-nodes-stable" as="node()*">
  <xsl:param name="arg" as="node()*"/>
  <xsl:sequence 
    select="$arg[empty(subsequence($arg, 1, position()-1) intersect .)]"/> </xsl:function>
                ]]></eg>
                <p>XQuery implementation</p>
                <eg><![CDATA[
declare function distinct-nodes-stable ($arg as node()*) as node()* 
{ 
   for $a at $apos in $arg 
   let $before_a := fn:subsequence($arg, 1, $apos - 1) 
   where every $ba in $before_a satisfies not($ba is $a) 
   return $a 
}]]></eg>
            </div2>
            
  
        </inform-div1>
<!--        <inform-div1 id="schema-for-duration-subtypes">
&xdt-schema-app;
		</inform-div1> -->
		<inform-div1 id="impl-def">
            <head>Checklist of Implementation-Defined Features</head>
<p>This appendix provides a summary of features defined in this specification whose effect is explicitly <termref def='implementation-defined'/>. The conformance rules require vendors to provide documentation that explains how these choices have been exercised.
</p>
<olist>
<item><p>The destination of the trace output is <termref def='implementation-defined'/>.  See <specref ref='func-trace'/>.</p></item>
<item><p>For <code>xs:integer</code> operations, implementations that support limited-precision integer operations <termref def='must'/> either raise an error 
<errorref class="AR" code="0002"/> or provide an <termref def='implementation-defined'/> mechanism that allows users to choose between raising an error and returning a result that is modulo the largest representable integer value.  See <specref ref='op.numeric'/>.</p></item>

<item><p> For <code>xs:decimal</code> values the number of digits of precision returned by the numeric operators is <termref def='implementation-defined'/>. See <specref ref='op.numeric'/>.  See also
<specref ref='casting-to-decimal'/> and <specref ref='casting-to-integer'/></p>
</item>
<item><p> If the number of digits in the result of a numeric operation exceeds the number of digits that the implementation supports, the result is truncated or rounded in an <termref def='implementation-defined'/> manner. See <specref ref='op.numeric'/>.  See also
<specref ref='casting-to-decimal'/> and <specref ref='casting-to-integer'/></p>
</item>
<item><p>It is <termref def='implementation-defined'/> which version of Unicode is supported by the features defined in this specification, but it is recommended that the most recent version of Unicode be used.  See <specref ref='string-types'/>.</p></item>
<item><p>For <specref ref='func-normalize-unicode'/>, conforming implementations <termref def='must'/> support normalization form "NFC" and <termref def='may'/> support normalization forms "NFD", "NFKC", "NFKD", "FULLY-NORMALIZED". They <termref def='may'/> also support other normalization forms with <termref def='implementation-defined'/> semantics.</p></item>
<item><p>The ability to decompose strings into collation units suitable for substring matching is an <termref def='implementation-defined'/> property of a collation. See <specref ref='substring.functions'/>.</p></item>
<item><p>All <emph>minimally conforming</emph> processors <termref def='must'/>  support year values with a minimum of 4 digits (i.e., YYYY) and a minimum fractional second precision of 1 millisecond or three digits (i.e., s.sss). However, <emph>conforming processors</emph> <termref def='may'/> set larger <termref def='implementation-defined'/> limits on the maximum number of digits they support in these two situations. See <specref ref='date-time-duration-conformance'/>.</p></item>
<item><p>The result of casting a string to <code>xs:decimal</code>, when the resulting value is not too large or too small but nevertheless has too many decimal digits to be accurately represented, is implementation-defined. See <specref ref="casting-from-strings"/>.
</p></item>
<item><p>Various aspects of the processing provided by <specref ref='func-doc'/> are <termref def='implementation-defined'/>. Implementations may provide external configuration options that allow any aspect of the processing to be controlled by the user.</p></item>
<item><p>The manner in which implementations provide options to weaken the 
<termref def='stable'/> characteristic of <specref ref='func-collection'/> and <specref ref='func-doc'/> are <termref def='implementation-defined'/>.</p></item>
</olist>
</inform-div1>
</back>
</spec>
