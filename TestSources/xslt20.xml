<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE spec SYSTEM "schema/xsltspec.dtd" [
	<!ENTITY XSLT.file "xslt20">


]>
<spec w3c-doctype="rec" role="recommendation" xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax">
	<header>
		<title>XSL Transformations (XSLT)</title>
		<version>Version 2.0</version>
		<w3c-designation>WD-****</w3c-designation>
		<w3c-doctype>W3C Recommendation</w3c-doctype>
		<pubdate>
			<day>23</day>
			<month>January</month>
			<year>2007</year>
		</pubdate>
		<publoc>
			
			<loc href="http://www.w3.org/TR/yyyy/WD-xslt20-yyyymmdd/">http://www.w3.org/TR/yyyy/WD-&XSLT.file;-yyyymmdd/</loc>
		</publoc>
		<!--<altlocs>
		    <loc href="Overview-diff.html">HTML with revision markings</loc>
		    <loc href="http://www.w3.org/2007/schema-for-xslt20.xsd">Schema for XSLT 2.0 stylesheets</loc>
		</altlocs>-->
		<latestloc>
			<loc href="http://www.w3.org/TR/xslt20/"/>
		</latestloc>
		<prevlocs>
		   <loc href="http://www.w3.org/TR/2006/PR-xslt20-20061121/"/>	
<!--
		   <loc href="http://www.w3.org/TR/2006/CR-xslt20-20060608/"/>	
                   <loc href="http://www.w3.org/TR/2005/CR-xslt20-20051103/"/>
	           <loc href="http://www.w3.org/TR/2005/WD-xslt20-20050915/"/>	
	           <loc href="http://www.w3.org/TR/2005/WD-xslt20-20050404/"/>	
                   <loc href="http://www.w3.org/TR/2005/WD-xslt20-20050211/"/>	
    	           <loc href="http://www.w3.org/TR/2004/WD-xslt20-20041105/"/>		
                   <loc href="http://www.w3.org/TR/2003/WD-xslt20-20031112/"/>
		   <loc href="http://www.w3.org/TR/2003/WD-xslt20-20030502/"/>		
		   <loc href="http://www.w3.org/TR/2002/WD-xslt20-20021115/"/>
		   <loc href="http://www.w3.org/TR/2002/WD-xslt20-20020816/"/>	
                   <loc href="http://www.w3.org/TR/2002/WD-xslt20-20020430/"/>
		   <loc href="http://www.w3.org/TR/2001/WD-xslt20-20011220/"/>
-->
		</prevlocs>
		
	
		<authlist>
			<author>
				<name>Michael Kay</name>
				<affiliation>Saxonica</affiliation>
				<email href="http://www.saxonica.com/">http://www.saxonica.com/</email>
			</author>
		</authlist>

		<errataloc href="http://www.w3.org/XML/2007/qt-errata/xslt-errata.html" xlink:type="simple"/>
		
		<translationloc href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xslt20"/>

	
		
		<status diff="chg" at="ZC">
		
<p><emph>This section describes the status of this document at the time of
its publication. Other documents may supersede this document. A list of
current W3C publications and the latest revision of this technical report
can be found in the <loc href="http://www.w3.org/TR/">W3C technical reports
index</loc> at http://www.w3.org/TR/.</emph></p>

<p>This <loc href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C">
Recommendation</loc> builds on the success of <bibref ref="xslt"/>, which was published on
16 November 1999. Many new features have been added to the language (see <specref ref="changes-since-1.0"/>)
while retaining a high level of backwards compatibility (see <specref ref="incompatibilities"/>).
The changes have been
designed to meet the requirements for XSLT 2.0 described in <bibref ref="xslt20req"/>.
The way in which each requirement has been addressed is outlined in <specref ref="requirements-checklist"/>.</p>

<p>XSLT 2.0 depends on a number of other specifications that have progressed to 
Recommendation status at the same time: see <bibref ref="xpath20"/>, <bibref ref="xpath-datamodel"/>,
<bibref ref="xpath-functions"/>, and <bibref ref="xslt-xquery-serialization"/>. These 
subsidiary documents are also referenced in the specification of XQuery 1.0.</p>

<p>This document has been produced by the 
<loc href="http://www.w3.org/Style/XSL/">XSL Working Group</loc>, which is part of the
<loc href="http://www.w3.org/XML/Activity">XML Activity</loc>.
The document has been reviewed by W3C Members and other interested parties, and is endorsed by the 
Director. It is a stable document and may be used as reference material 
or cited as a normative reference from another document. 
W3C's role in making the Recommendation is to draw attention 
to the specification and to promote its widespread deployment. 
This enhances the functionality and interoperability of the Web.</p> 

<p>A small number of editorial corrections and clarifications have been made to the document since
it <loc
href="http://www.w3.org/TR/2006/PR-xslt20-20061121/">was published</loc>
 as a <loc
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed
Recommendation</loc> on 21 November 2006. These changes are listed at <specref ref="changes-2007-01"/>.</p> 

<!--*
<p>An <loc href="http://www.w3.org/XML/Group/xslt20-test/Documentation/reportSummary.html">implementation report</loc> 
is available at <loc href="http://www.w3.org/XML/Group/xslt20-test/Documentation/reportSummary.html"
>http://www.w3.org/XML/Group/xslt20-test/Documentation/reportSummary.html</loc >
(member-only link).</p>
*-->


<p>
Please record any comments about this document in W3C's
<loc href="http://www.w3.org/Bugs/Public/">public Bugzilla system</loc> (instructions can be found at <loc href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
If access to that system is not feasible, you may send your comments to the W3C XSLT/XPath/XQuery public comments mailing list, <loc href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</loc>.
It is helpful to include the string [XSLT] in the subject line of your comment,
whether made in Bugzilla or in email.
Each Bugzilla entry and email message should contain only one comment.
Archives of the comments and responses are available 
at <loc href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</loc>.</p>

<p>General public discussion of XSLT takes place on the 
<loc href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</loc> forum.</p>

<p>This document was produced by a group operating under the <loc
xmlns:xlink="http://www.w3.org/1999/xlink"
href="http://www.w3.org/Consortium/Patent-Policy-20040205/"
xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5
February 2004 W3C Patent Policy</loc>. W3C maintains a <loc
xmlns:xlink="http://www.w3.org/1999/xlink" rel="disclosure"
href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures"
xlink:type="simple" xlink:show="replace"
xlink:actuate="onRequest">public list of any patent disclosures</loc>
made in connection with the deliverables of the group; that page also
includes instructions for disclosing a patent. An individual who has
actual knowledge of a patent which the individual believes contains
<loc xmlns:xlink="http://www.w3.org/1999/xlink"
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential"
xlink:type="simple" xlink:show="replace"
xlink:actuate="onRequest">Essential Claim(s)</loc> must disclose the
information in accordance with <loc
xmlns:xlink="http://www.w3.org/1999/xlink"
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure"
xlink:type="simple" xlink:show="replace"
xlink:actuate="onRequest">section 6 of the W3C Patent
Policy</loc>. </p>

</status>

		<abstract>
			<p>This specification defines the syntax and semantics of XSLT 2.0, 
      a language for transforming XML documents into other XML documents.</p>

			<p>XSLT 2.0 is a revised version of the XSLT 1.0 Recommendation
<bibref ref="xslt"/> published on 16 November 1999.<!-- The changes made in this document are
designed to meet the requirements for XSLT 2.0 described in <bibref ref="xslt20req"/>.
The way in which each requirement has been addressed is outlined in <specref ref="requirements-checklist"/>.
 A summary of the changes since XSLT 1.0
is included in <specref ref="changes"/>.--></p>

			<p>XSLT 2.0 is designed to be used in conjunction with XPath 2.0,
which is defined in <bibref ref="xpath20"/>. XSLT shares the same data model as XPath 2.0,
which is defined in <bibref ref="xpath-datamodel"/>, and it uses the library of functions and
operators defined in <bibref ref="xpath-functions"/>.</p>

<p>XSLT 2.0 also includes optional facilities to serialize the results of a transformation,
by means of an interface to the serialization component described in <bibref ref="xslt-xquery-serialization"/>.</p>

<p><emph>This document contains hyperlinks to specific sections or definitions within
other documents in this family of specifications. These links are indicated visually by a superscript
identifying the target specification: for example XP for XPath, DM for the XDM data model, FO for Functions
and Operators.</emph></p> 
		</abstract>
		<langusage>
			<language id="EN">English</language>
		</langusage>
		<revisiondesc>
			<slist>
				<sitem>((not used)).</sitem>
			</slist>
		</revisiondesc>
	</header>
	<body>
		<div1 id="introduction">
			<head>Introduction</head>
			<div2 id="what-is-xslt">
				<head>What is XSLT?</head>
				<p>This specification defines the syntax and semantics of the XSLT 2.0
language.</p>

<p><termdef id="dt-stylesheet" term="stylesheet">A 
transformation in the XSLT language is expressed 
in the form of a <term>stylesheet</term>, whose syntax is 
well-formed XML <bibref ref="REC-xml"/> conforming to the
Namespaces in XML Recommendation <bibref ref="REC-xml-names"/>.</termdef></p>

<p>A stylesheet generally includes elements that are defined by XSLT
 as well as elements that are not defined by XSLT.  XSLT-defined elements are
 distinguished by use of the namespace <code>http://www.w3.org/1999/XSL/Transform</code> 
(see <specref ref="xslt-namespace"/>),
 which is referred to in this specification as the <termref def="dt-xslt-namespace">XSLT
namespace</termref>. Thus this specification is a definition of
the syntax and semantics of the XSLT namespace.</p>
				<p>The term <termref def="dt-stylesheet">stylesheet</termref> reflects
the fact that one of the important roles of XSLT is to add styling information
to an XML source document, by transforming it into a document consisting of XSL 
formatting objects (see <bibref ref="xsl"/>),
or into another presentation-oriented format such as HTML, XHTML, or SVG.
However, XSLT is used for a wide range of transformation tasks,
not exclusively for formatting and presentation applications.</p>
				<p>A transformation expressed in XSLT describes rules for transforming
zero or more source trees into 
one or more result trees. The structure of these trees
is described in <bibref ref="xpath-datamodel"/>.
 The transformation is achieved by
a set of <termref def="dt-template-rule">template rules</termref>. 
A template rule associates a <termref def="dt-pattern">pattern</termref>, which
matches nodes in the source document, with a <termref def="dt-sequence-constructor">sequence constructor</termref>.
In many cases, evaluating the sequence constructor will cause new
nodes to be constructed, which can be used to produce part of a result tree.
The structure of the result trees can be completely different
from the structure of the source trees.
 In constructing a result
tree, nodes from the source trees can be filtered and reordered, and
arbitrary structure can be added. This mechanism allows a <termref def="dt-stylesheet">stylesheet</termref> 
to be applicable to a wide class of
documents that have similar source tree structures.</p>



				<p><termdef id="dt-principal-stylesheet-module" term="principal stylesheet module">A 
<termref def="dt-stylesheet">stylesheet</termref> may consist of several 
<termref def="dt-stylesheet-module">stylesheet modules</termref>,
contained in different XML documents. 
For a given transformation, one of these functions as the
<term>principal stylesheet module</term>. The complete <termref def="dt-stylesheet">stylesheet</termref> is
assembled by finding the <termref def="dt-stylesheet-module">stylesheet modules</termref> referenced 
directly or indirectly from the
principal stylesheet module using <elcode>xsl:include</elcode> and
<elcode>xsl:import</elcode> elements: see <specref ref="include"/> and
<specref ref="import"/>.</termdef></p>
			</div2>
			<div2 id="whats-new-in-xslt2">
				<head>What's New in XSLT 2.0?</head>
				<p>XSLT 1.0 was published in November 1999, and version 2.0 represents a significant increase
in the capability of the language. A detailed list of changes is included in <specref ref="changes"/>.
XSLT 2.0 has been developed in parallel with XPath 2.0 (see <bibref ref="xpath20"/>), so the changes
to XPath must be considered alongside the changes to XSLT.</p>
			</div2>
		</div1>
		<div1 id="concepts">
			<head>Concepts</head>
			<div2 id="terminology">
				<head>Terminology</head>
				<p>For a full glossary of terms, see <specref ref="glossary"/>.</p>
				<p>
					<termdef id="dt-processor" term="processor">The software responsible
 for transforming source trees into
result trees using an XSLT stylesheet 
is referred to as the <term>processor</term>. This is sometimes expanded
to <emph>XSLT processor</emph> to avoid any confusion with
other processors, for example an XML processor.</termdef></p>
					<p><termdef id="dt-implementation" term="implementation">A specific product that performs the functions of
 an <termref def="dt-processor">XSLT processor</termref> is referred to as
 an <term>implementation</term>
					</termdef>.</p>

<p><termdef id="dt-result-tree" term="result tree">The term <term>result tree</term>
is used to refer to any tree constructed by <termref def="dt-instruction">instructions</termref>
 in the stylesheet. A result tree is either a <termref def="dt-final-result-tree">final result tree</termref>
 or a <termref def="dt-temporary-tree">temporary tree</termref>.</termdef></p>
 
<p><termdef id="dt-final-result-tree" term="final result tree">A <term>final result tree</term>
is a <termref def="dt-result-tree">result tree</termref> that forms part of the final output 
of a transformation. Once created, the contents of a final result tree are
not accessible within the stylesheet itself.</termdef> The <elcode>xsl:result-document</elcode>
instruction always creates a final result tree, and a final result tree may also be created
implicitly by the <termref def="dt-initial-template">initial template</termref>. 
The conditions under which
this happens are described in <specref ref="executing-a-transformation"/>.
A final result tree <rfc2119>may</rfc2119> be serialized
as described in <specref ref="serialization"/>.</p>

<p><termdef id="dt-source-tree" term="source tree">The term <term>source tree</term>
means any tree provided as input to the transformation. This includes the document containing
the <termref def="dt-initial-context-node">initial context node</termref> if any, documents containing
nodes supplied as the values of <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>,
documents obtained from the results of functions such as <function>document</function>, <xfunction>doc</xfunction>,
and <xfunction>collection</xfunction>, and documents returned by extension functions or extension 
instructions. In the context of a particular XSLT instruction, the term <term>source tree</term> means
any tree provided as input to that instruction; this may be a source tree of the transformation as a whole,
or it may be a <termref def="dt-temporary-tree">temporary tree</termref> produced during the course
of the transformation.</termdef></p>

<p><termdef id="dt-temporary-tree" term="temporary tree">The term <term>temporary tree</term>
means any tree that is neither a <termref def="dt-source-tree">source tree</termref>
nor a <termref def="dt-final-result-tree">final result tree</termref>.</termdef> Temporary trees
are used to hold intermediate results during the execution of the transformation.</p>
  

	
<p>In this specification the phrases <rfc2119>must</rfc2119>, 
<rfc2119>must not</rfc2119>, <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>, 
<rfc2119>may</rfc2119>, 
<rfc2119>required</rfc2119>, and <rfc2119>recommended</rfc2119> 
are to be interpreted as described in <bibref ref="RFC2119"/>.</p> 

<p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, 
or <rfc2119>required</rfc2119> relates to the behavior of the
XSLT processor, then an implementation is not conformant unless it behaves
as specified, subject to the more detailed rules in <specref ref="conformance"/>. </p>

<p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, 
or <rfc2119>required</rfc2119> relates to a stylesheet, then the
processor <rfc2119>must</rfc2119> enforce this constraint on stylesheets by reporting an error
if the constraint is not satisfied.</p>

<p>Where the phrase <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>, 
or <rfc2119>recommended</rfc2119> relates to a stylesheet,
then a processor <rfc2119>may</rfc2119> produce warning messages if the constraint is not
satisfied, but <rfc2119>must not</rfc2119> treat this as an error.</p>

				<p>
					<termdef id="dt-implementation-defined" term="implementation-defined">In this
specification, the term <term>implementation-defined</term> refers to a feature where the
implementation is allowed some flexibility, and where the choices made by the
implementation <rfc2119>must</rfc2119> be described in  
documentation that accompanies any conformance claim.</termdef>
				</p>
				<p>
					<termdef id="dt-implementation-dependent" term="implementation-dependent">The 
term <term>implementation-dependent</term> refers to a feature where the
behavior <rfc2119>may</rfc2119> vary from one implementation to another, and where the vendor is not expected to
provide a full specification of the behavior.</termdef> (This might apply, for example, to
limits on the size of source documents that can be transformed.)</p>
				<p>In all cases where this specification leaves the behavior implementation-defined
or implementation-dependent, the implementation has the option of providing mechanisms that allow
the user to influence the behavior.</p>
				<p>A paragraph labeled as a <term>Note</term> or described as an <term>example</term> is
non-normative.</p>

<p>Many terms used in this document are defined in the XPath specification 
<bibref ref="xpath20"/> or the XDM specification <bibref ref="xpath-datamodel"/>. Particular
attention is drawn to the following:</p>

<ulist>
<item><p><termdef id="dt-atomization" term="atomize">The term <term>atomization</term> is defined
in <!--<bibref ref="xpath20"/>--><xspecref spec="XP" ref="id-atomization"/>. It is a process that takes as input a sequence of nodes and atomic values, and
returns a sequence of atomic values, in which the nodes are replaced by their typed values as defined in
<bibref ref="xpath-datamodel"/>.</termdef> For some nodes (for example, elements with element-only content), 
atomization generates a <termref def="dt-dynamic-error">dynamic error</termref>.</p></item>

<item><p><termdef id="dt-typed-value" term="typed value">The term <term>typed value</term>
is defined in <xspecref spec="DM" ref="dm-typed-value"/>. 
Every node except an element defined in the schema with element-only content has a 
<termref def="dt-string-value">typed value</termref>. For example, the
 <termref def="dt-typed-value">typed value</termref>
of an attribute of type <code>xs:IDREFS</code> is a sequence of zero or more <code>xs:IDREF</code> values.</termdef></p>
</item>

<item><p><termdef id="dt-string-value" term="string value">The term <term>string value</term>
is defined in <!--<bibref ref="xpath-datamodel"/>--><xspecref spec="DM" ref="dm-string-value"/>. 
Every node has a <termref def="dt-string-value">string value</termref>. For example, the <termref def="dt-string-value">string value</termref>
of an element is the concatenation of the <termref def="dt-string-value">string values</termref> of all its descendant text nodes.</termdef></p></item>

<item><p><termdef id="dt-compatibility-mode" term="XPath 1.0 compatibility mode">The term
<term>XPath 1.0 compatibility mode</term> is defined in <xspecref spec="XP" ref="static_context"/>. This is a setting in the
static context of an XPath expression; it has two values, <code>true</code> and <code>false</code>. When the value
is set to true, the semantics of function calls and certain other operations are adjusted to give a greater degree
of backwards compatibility between XPath 2.0 and XPath 1.0.</termdef></p></item>

</ulist>

<p><termdef id="dt-core-function" term="core function">The
term <term>core function</term> means a function that is specified in
<bibref ref="xpath-functions"/> and that is in the
<termref def="dt-standard-function-namespace">standard function
namespace</termref>.</termdef></p>

			</div2>
			<div2 id="notation">
				<head>Notation</head>

<p><termdef id="dt-xslt-element" term="XSLT element">An <term>XSLT element</term> is an element
in the <termref def="dt-xslt-namespace">XSLT namespace</termref> whose syntax and semantics are
defined in this specification.</termdef> For a non-normative list of XSLT elements, see 
<specref ref="element-syntax-summary"/>.</p>

				<p>In this document the specification of each 
				<termref def="dt-xslt-element">XSLT element</termref> is preceded by
a summary of its syntax in the form of a model for elements of that
element type.  A full list of all these specifications can be found in
 <specref ref="element-syntax-summary"/>.
The meaning of syntax summary notation is as follows:</p>
				<ulist>
					<item>
						<p>An attribute that is <rfc2119>required</rfc2119> is shown with its
name in bold. An attribute that may be omitted is shown with a question mark following its name.</p>
					</item>
          <item><p>An attribute that is <termref def="dt-deprecated">deprecated</termref>
          is shown in a grayed font within square brackets.</p></item>
					<item>
						<p>The string that occurs in the place of an attribute value
specifies the allowed values of the attribute.  If this is surrounded
by curly brackets (<code>{...}</code>), then the attribute value is treated as an
 <termref def="dt-attribute-value-template">attribute value template</termref>,
and the string occurring within curly brackets specifies the allowed
values of the result of evaluating the attribute value template.
Alternative allowed values are separated by <code>|</code>.  A quoted
string indicates a value equal to that specific string. An unquoted,
italicized name specifies a particular type of value.</p>

<p>In all cases where this specification states
that the value of an attribute <rfc2119>must</rfc2119> be one of a limited set of values, 
leading and trailing whitespace in the attribute value is ignored.
In the case of an <termref def="dt-attribute-value-template">attribute value template</termref>,
this applies to the <termref def="dt-effective-value">effective value</termref> obtained
when the attribute value template is expanded.</p>

					</item>
					<item>
						<p>Unless the element is <rfc2119>required</rfc2119> to be empty, the model element
contains a comment specifying the allowed content.  The allowed
content is specified in a similar way to an element type declaration
in XML; <emph>sequence constructor</emph> means that any mixture of text nodes,
<termref def="dt-literal-result-element">literal result elements</termref>, 
<termref def="dt-extension-instruction">extension instructions</termref>, and 
<termref def="dt-xslt-element">XSLT elements</termref> from
the <termref def="dt-instruction">instruction</termref> category is allowed;
<emph>other-declarations</emph> means that any mixture of XSLT
elements from the <termref def="dt-declaration">declaration</termref> category, 
other than <elcode>xsl:import</elcode>, is
allowed, together with <termref def="dt-data-element">user-defined data elements</termref>.</p>
					</item>
					<item>
						<p>The element is prefaced by comments indicating if it belongs
to the <code>instruction</code> category or
<code>declaration</code> category or both.  The category of an
element only affects whether it is allowed in the content of elements
that allow a <termref def="dt-sequence-constructor">sequence constructor</termref> or
<emph>other-declarations</emph>.</p>
					</item>
				</ulist>
				<example><head>Syntax Notation</head>
					<p>This example illustrates the notation used to describe 
					<termref def="dt-xslt-element">XSLT elements</termref>.</p>
					<e:element-syntax name="example-element">
						<e:in-category name="instruction"/>
						<e:attribute name="select" required="yes">
							<e:data-type name="expression"/>
						</e:attribute>
						<e:attribute name="debug">
							<e:attribute-value-template>
								<e:constant value="yes"/>
								<e:constant value="no"/>
							</e:attribute-value-template>
						</e:attribute>
						<e:sequence>
							<e:choice repeat="zero-or-more">
								<e:element name="variable"/>
								<e:element name="param"/>
							</e:choice>
							<e:element name="sequence"/>
						</e:sequence>
						<e:allowed-parents>
							<e:parent-category name="sequence-constructor"/>
						</e:allowed-parents>
					</e:element-syntax>
					<p>This example defines a (non-existent) element <code>xsl:example-element</code>. The element is classified as
an instruction. It takes a mandatory <code>select</code> attribute, whose value is an XPath <termref def="dt-expression">expression</termref>, and
an optional <code>debug</code> attribute, whose value <rfc2119>must</rfc2119> be either <code>yes</code> or <code>no</code>; the curly 
brackets indicate that the value can be defined as an <termref def="dt-attribute-value-template">attribute value
template</termref>, allowing a value such as <code>debug="{$debug}"</code>, where the <termref def="dt-variable">variable</termref> <code>debug</code>
is evaluated to yield <code>"yes"</code> or <code>"no"</code> at run-time.</p>
					<p>The content of an <code>xsl:example-element</code> instruction is defined to be a sequence of zero or more
<elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> elements, followed by an <elcode>xsl:sequence</elcode>
element.</p>
				</example>
				<p><error spec="XT" type="static" class="SE" code="0010"><p>A <termref def="dt-static-error">static error</termref> is signaled
 if an XSLT-defined element is used in a context
  where it is not permitted, if a <rfc2119>required</rfc2119> attribute is omitted,
  or if the content of the element does not correspond to the
  content that is allowed for the element.</p></error></p>
  
  <p>Attributes are validated as follows. These rules apply to the value of the
  attribute after removing leading and trailing whitespace.</p>
  
  <ulist>
	<item><p><error spec="XT" type="static" class="SE" code="0020"><p>It is a <termref def="dt-static-error">static error</termref>
if an attribute (other than an attribute written using curly brackets in 
a position where an
 <termref def="dt-attribute-value-template">attribute value template</termref> is permitted) contains a value 
that is not one of the permitted values for that attribute.</p></error></p></item>
	<item><p><error spec="XT" type="dynamic" class="DE" code="0030"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if the <termref def="dt-effective-value">effective value</termref> of an attribute written
 using curly brackets, in 
a position where an <termref def="dt-attribute-value-template">attribute value template</termref> is
 permitted, is a value 
that is not one of the permitted values for that attribute.
If the processor is able to detect the error statically (for example, when
any XPath expressions within the curly brackets can be evaluated statically), then the processor may
optionally signal this as a static error.</p></error></p></item>
</ulist>


			
				<p>Special rules apply if the construct appears in part of
the <termref def="dt-stylesheet">stylesheet</termref> that is processed with
 <termref def="dt-forwards-compatible-behavior">forwards-compatible behavior</termref>: see <specref ref="forwards"/>.</p>

<p><termdef id="dt-deprecated" term="deprecated">Some constructs defined in this
specification are described as being <term>deprecated</term>. The use of this term implies that
stylesheet authors <rfc2119>should not</rfc2119> use the construct, and that the construct may
be removed in a later version of this specification.</termdef> All constructs that are 
<termref def="dt-deprecated">deprecated</termref> in this specification are also (as it happens)
optional features that <termref def="dt-implementation">implementations</termref> are 
<rfc2119>not required</rfc2119> to provide.</p> 
				
				<note><p>This working draft includes a non-normative XML Schema for XSLT 
				<termref def="dt-stylesheet-module">stylesheet modules</termref> 
(see <specref ref="schema-for-xslt"/>). The syntax summaries described in this section are normative.</p></note>

				<p>XSLT defines a set of standard functions which are additional to those defined
				in <bibref ref="xpath-functions"/>. The signatures of these functions are described using the
				same notation as used in <bibref ref="xpath-functions"/>. 
				The names of these functions are all in the
				<termref def="dt-standard-function-namespace">standard function namespace</termref>.</p>
			</div2>
			<div2 id="initiating">
				<head>Initiating a Transformation</head>
				<p>This document does not specify any application programming interfaces or other
interfaces for initiating a transformation. This section, however, describes the information that is 
supplied when a transformation is initiated. Except where otherwise indicated, the information
is <rfc2119>required</rfc2119>.</p>

<p>Implementations <rfc2119>may</rfc2119> allow a transformation to run as two or more phases, for example parsing, compilation and
execution. Such a distinction is outside the scope of this specification, which treats transformation as a single
process controlled using a set of <termref def="dt-stylesheet-module">stylesheet modules</termref>, supplied 
in the form of XML documents.</p>

<p>The following information is supplied to execute a transformation:</p>
<ulist>
<item>
    <p>The <termref def="dt-stylesheet-module">stylesheet module</termref> that is
    to act as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref> for the transformation.
    The complete <termref def="dt-stylesheet">stylesheet</termref> is assembled by recursively
    expanding the <elcode>xsl:import</elcode> and <elcode>xsl:include</elcode>
    declarations in the principal stylesheet module, as described in <specref ref="include"/> and <specref ref="import"/>.
    </p>
</item>
<item>
    <p>A set (possibly empty) of values for <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>
    (see <specref ref="global-variables"/>). These
    values are available for use within <termref def="dt-expression">expressions</termref> in the
     <termref def="dt-stylesheet">stylesheet</termref>.</p>
</item>
<item>
    <p>
    <termdef id="dt-initial-context-node" term="initial context node">A node that acts as
    the <term>initial context node</term> for the transformation. This node is accessible within the
    <termref def="dt-stylesheet">stylesheet</termref> as the initial value of the XPath 
    <termref def="dt-expression">expressions</termref> <code>.</code> (dot) and <code>self::node()</code>,
    as described in <specref ref="focus"/></termdef>. </p> 
    <p>If no initial context
    node is supplied, then the <termref def="dt-context-item">context item</termref>, 
    <termref def="dt-context-position">context position</termref>, and 
    <termref def="dt-context-size">context size</termref>
    will initially be undefined, and the evaluation of any expression that
    references these values will result in a dynamic error.
    (Note that the initial context size and
    context position will always be 1 (one) when an initial context node is supplied, and will be undefined if no
    initial context node is supplied).</p>
    
</item>
<item>
    <p>Optionally, the name of a <termref def="dt-named-template">named template</termref> which is to
    be executed as the entry point to the transformation. This template <rfc2119>must</rfc2119> 
    exist within the <termref def="dt-stylesheet">stylesheet</termref>. If no
    named template is supplied, then the transformation starts
    with the <termref def="dt-template-rule">template rule</termref>
     that best matches the <termref def="dt-initial-context-node">initial context node</termref>, 
    according to the rules defined in
    <specref ref="conflict"/>. Either a named template, or an initial context node,
    or both, <rfc2119>must</rfc2119> be supplied.</p>


</item>
<item>
    <p>Optionally, an initial <termref def="dt-mode">mode</termref>. 
	<phrase diff="add" at="ZB">This <rfc2119>must</rfc2119> either be the default mode,
	or a mode that is explicitly named in the <code>mode</code> attribute of an 
	<elcode>xsl:template</elcode> declaration within the stylesheet</phrase>.
	If an initial mode
    is supplied, then in searching for the <termref def="dt-template-rule">template rule</termref> that best matches
    the <termref def="dt-initial-context-node">initial context node</termref>, 
    the processor considers only those rules that apply to the initial mode. If no
    initial mode is supplied, the <termref def="dt-default-mode">default mode</termref> is used.</p>
</item>
<item>
    <p>A base output URI. <termdef id="dt-base-output-uri" term="base output URI">
    The <term>base output URI</term> is a URI to be used as the base URI when resolving a relative URI allocated to a 
    <termref def="dt-final-result-tree">final result tree</termref>. 
    If the transformation generates more than one final result
    tree, then typically each one will be allocated a URI relative to this base URI.
    </termdef> 
    <phrase diff="add" at="T">The way in which a base output URI is established 
    is <termref def="dt-implementation-defined">implementation-defined</termref>.</phrase>
    </p>
</item>
<item>
    <p>A mechanism for obtaining a document node and a media type, given an absolute URI. The total
	set of available documents (modeled as a mapping from URIs to document nodes) forms part of the
	context for evaluating XPath expressions, specifically the <xfunction>doc</xfunction> function.
	The XSLT <function>document</function> function additionally requires the media type of the
	resource representation, for use in interpreting any fragment identifier present within a URI
	Reference.</p>
	<note><p>The set of documents
that are available to the stylesheet is 
<termref def="dt-implementation-dependent">implementation-dependent</termref>, as is
the processing that is carried out to construct a tree representing
the resource retrieved using a given URI. Some possible ways of
constructing a document (specifically, rules for constructing a document
from an Infoset or from a PSVI) are described in <bibref ref="xpath-datamodel"/>.</p></note></item>  

</ulist>
					
					<p>
<error spec="XT" type="dynamic" class="DE" code="0040"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the invocation of the
<termref def="dt-stylesheet">stylesheet</termref> specifies a template name that does not match the
<termref def="dt-expanded-qname">expanded-QName</termref> of a named template defined in the <termref def="dt-stylesheet">stylesheet</termref>.</p></error>
					</p>

				<p diff="add" at="ZB">
<error spec="XT" type="dynamic" class="DE" code="0045"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the invocation of the
<termref def="dt-stylesheet">stylesheet</termref> specifies an initial <termref def="dt-mode">mode</termref>
 (other than the default mode)
that does not match the
<termref def="dt-expanded-qname">expanded-QName</termref> in the <code>mode</code> attribute of any
 template defined in the <termref def="dt-stylesheet">stylesheet</termref>.</p></error>
					</p>

			<p diff="add" at="ZB">
<error spec="XT" type="dynamic" class="DE" code="0047"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the invocation of the
<termref def="dt-stylesheet">stylesheet</termref> specifies both an initial <termref def="dt-mode">mode</termref> and an initial 
template.</p></error></p>
					
<p><error spec="XT" type="dynamic" class="DE" code="0050"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
 if the stylesheet that is invoked declares a visible 
 <termref def="dt-stylesheet-parameter">stylesheet parameter</termref> 
with <code>required="yes"</code> and no value for
this parameter is supplied during the invocation of the stylesheet. A stylesheet parameter
is visible if it is not masked by another global variable or parameter with the same name and higher
 <termref def="dt-import-precedence">import precedence</termref>.</p></error></p>					
					
<p><termdef id="dt-initial-template" term="initial template">The transformation
 is performed by evaluating an <term>initial template</term>. If a 
 <termref def="dt-named-template">named template</termref> is
 supplied when the transformation is initiated, then this is the initial template; 
 <phrase diff="chg" at="R">otherwise, the initial
 template is the <termref def="dt-template-rule">template rule</termref>
 selected according to the rules of the <elcode>xsl:apply-templates</elcode> instruction
  for processing the
 <termref def="dt-initial-context-node">initial context node</termref> in the 
 initial <termref def="dt-mode">mode</termref>.</phrase></termdef>
 
 </p> 				
					
					<p>Parameters passed to the transformation by the client application are matched against 
<termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see <specref ref="global-variables"/>), 
not against the <termref def="dt-template-parameter">template parameters</termref> declared within
the <termref def="dt-initial-template">initial template</termref>. 
All <termref def="dt-template-parameter">template parameters</termref>
 within the initial template to be executed will take their default values.</p>
 <p><error spec="XT" type="dynamic" class="DE" code="0060"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
 if the <termref def="dt-initial-template">initial template</termref> defines a <termref def="dt-template-parameter">template parameter</termref>
 that specifies <code>required="yes"</code>.</p></error></p>


				<imp-def-feature>The way in which an XSLT processor is invoked, 
				and the way in which values are supplied for
the source document, starting node, 
 <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, and 
 <termref def="dt-base-output-uri">base output URI</termref>,
 are implementation-defined.</imp-def-feature>
				<p>A <termref def="dt-stylesheet">stylesheet</termref> can process further source documents in
addition to those supplied when the transformation is invoked.
 These additional documents can be loaded using the functions
<function>document</function> (see <specref ref="document"/>) 
or <xfunction>doc</xfunction> or <xfunction>collection</xfunction> (see <bibref ref="xpath-functions"/>), or
they can be supplied as <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>
 (see <specref ref="global-variables"/>),
 or as the result of an <termref def="dt-extension-function">extension function</termref>
 (see <specref ref="extension-functions"/>).</p>

 			</div2>
			
<div2 diff="chg" at="R" id="executing-a-transformation"> 
<head>Executing a Transformation</head> 

<p><termdef id="dt-template-rule" term="template rule" diff="chg" at="ZA">A stylesheet contains a
set of <term>template rules</term> (see <specref ref="rules"/>). A template rule has three parts: a
<termref def="dt-pattern">pattern</termref> that is matched against nodes, 
a (possibly empty) set of <termref def="dt-template-parameter">template parameters</termref>, and a
 <termref def="dt-sequence-constructor">sequence
constructor</termref> that is evaluated to produce a
sequence of items.</termdef> In many cases these items are newly constructed
nodes, which are then written to a <termref def="dt-result-tree">result tree</termref>.</p>

<p diff="chg" at="Y">A transformation as a whole is
executed by evaluating the <termref def="dt-sequence-constructor">sequence
constructor</termref> of the 
<termref def="dt-initial-template">initial template</termref> as described
in <specref ref="sequence-constructors"/>. </p>

<p diff="chg" at="Y">If the initial template has an <code>as</code> attribute, then the result
sequence of the initial template is checked against the required type in the
same way as for any other template. If this result sequence is non-empty, then it is used to construct
an implicit 
<termref def="dt-final-result-tree">final result tree</termref>,
following the rules described in <specref ref="constructing-complex-content"/>: 
the effect is as if the initial template <var>T</var> were called by an
implicit template of the form:</p>

<eg><![CDATA[
<xsl:template name="IMPLICIT">
  <xsl:result-document href="">
    <xsl:call-template name="T"/>
  </xsl:result-document>
</xsl:template>]]></eg>

<p diff="chg" at="Y">An implicit result tree is also created when the result sequence is empty, provided
that no <elcode>xsl:result-document</elcode> instruction has been evaluated during the course of
the transformation. In this situation the implicit result tree will consist of a document node with no children.</p>

<note diff="add" at="Y"><p>This means that there is always at least one result tree. It also means that if the
content of the initial template is a single <elcode>xsl:result-document</elcode> instruction, as in the example
above, then only one result tree is produced, not two. It is useful to make the result document explicit as this
is the only way of invoking document-level validation.</p>

<p>If the result of the initial template is non-empty, and an explicit
<elcode>xsl:result-document</elcode>
instruction has been evaluated with the empty attribute <code>href=""</code>, then an error will occur
<errorref spec="XT" class="DE" code="1490"/>, since it is not possible to create two final result
trees with the same URI.</p></note>



<p diff="add" at="ZA">A <termref def="dt-sequence-constructor">sequence constructor</termref> is a
sequence of sibling nodes in the stylesheet, each of which is either an
<termref def="dt-xslt-instruction">XSLT instruction</termref>,
a <termref def="dt-literal-result-element">literal result element</termref>,
a text node, or
an <termref def="dt-extension-instruction">extension instruction</termref>.</p>

<p diff="add" at="ZA"><termdef id="dt-instruction" term="instruction">An
<term>instruction</term> is either an <termref def="dt-xslt-instruction">XSLT instruction</termref>
or an <termref def="dt-extension-instruction">extension instruction</termref>.</termdef></p>

<p diff="add" at="ZA"><termdef id="dt-xslt-instruction" term="XSLT instruction">An 
<term>XSLT instruction</term> is an <termref def="dt-xslt-element">XSLT element</termref>
whose syntax summary in this specification contains the annotation
<code>&lt;!-- category: instruction --&gt;</code>.</termdef></p>

<p diff="add" at="ZA"><termref def="dt-extension-instruction">Extension instructions</termref> are
described in <specref ref="extension-instruction"/>.</p>






<p>The main categories of <termref def="dt-xslt-instruction">XSLT instruction</termref> are as follows:</p>

<ulist>
<item><p>instructions that create new nodes: <phrase diff="add" at="T"><elcode>xsl:document</elcode></phrase>, <elcode>xsl:element</elcode>, 
<elcode>xsl:attribute</elcode>, <elcode>xsl:processing-instruction</elcode>,
<elcode>xsl:comment</elcode>, <elcode>xsl:value-of</elcode>, <elcode>xsl:text</elcode>, 
<elcode>xsl:namespace</elcode>;</p></item>

<item><p>an instruction that returns an arbitrary sequence by evaluating an XPath expression:
 <elcode>xsl:sequence</elcode>;</p></item>

<item><p>instructions that cause conditional or repeated evaluation of nested instructions: 
<elcode>xsl:if</elcode>,
<elcode>xsl:choose</elcode>, <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>;</p></item>

<item><p>instructions that invoke templates: <elcode>xsl:apply-templates</elcode>, 
<elcode>xsl:apply-imports</elcode>, <elcode>xsl:call-template</elcode>,
<elcode>xsl:next-match</elcode>;</p></item>

<item><p diff="chg" at="T">Instructions that declare variables: <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>;</p></item>

<item><p>other specialized instructions: <elcode>xsl:number</elcode>, <elcode>xsl:analyze-string</elcode>,
 <elcode>xsl:message</elcode>, <elcode>xsl:result-document</elcode>.</p></item>
 
 </ulist>

      
<p>Often, a <termref def="dt-sequence-constructor">sequence constructor</termref>
will include an <elcode>xsl:apply-templates</elcode> instruction, which selects a sequence
of nodes to be processed. Each of the selected nodes is
processed by searching the stylesheet for a matching
<termref def="dt-template-rule">template rule</termref>
and evaluating the <termref def="dt-sequence-constructor">sequence
constructor</termref> of that template rule.
The resulting sequences of items are concatenated, in order,
to give the result of the <elcode>xsl:apply-templates</elcode> instruction,
as described in <specref ref="applying-templates"/>;
this sequence is often added to a <termref def="dt-result-tree">result tree</termref>. Since the
<termref def="dt-sequence-constructor">sequence
constructors</termref> of the selected
<termref def="dt-template-rule">template rules</termref>
may themselves contain <elcode>xsl:apply-templates</elcode>
instructions, this results in a cycle of selecting nodes,
identifying <termref def="dt-template-rule">template rules</termref>,
constructing sequences, and constructing
<termref def="dt-result-tree">result trees</termref>, that recurses
through a <termref def="dt-source-tree">source tree</termref>.
</p>  






</div2>			
			
<div2 id="context" diff="chg" at="U">
<head>The Evaluation Context</head>

<p>The results of some expressions and instructions in a stylesheet may depend on information
provided contextually. This context information is divided into two categories: the static
context, which is known during static analysis of the stylesheet, and the dynamic context, which
is not known until the stylesheet is evaluated. Although information in the static context is
known at analysis time, it is sometimes used during stylesheet evaluation.</p>

<p>Some context information can be set by means of declarations within the stylesheet itself.
For example, the namespace bindings used for any XPath expression are determined by the namespace
declarations present in containing elements in the stylesheet. Other information may
be supplied externally or implicitly: an example is the current date and time.</p>

<p>The context information used in processing an XSLT stylesheet includes as a subset all the context
information required when evaluating XPath expressions. The XPath 2.0 specification defines a static
and dynamic context that the host language (in this case, XSLT) may initialize, which affects the
results of XPath expressions used in that context. XSLT augments the context with additional
information: this additional information is used firstly by XSLT constructs outside the scope of
XPath (for example, the <elcode>xsl:sort</elcode> element), and secondly, by functions that are
defined in the XSLT specification (such as <function>key</function> and <function>format-number</function>)
that are available for use in XPath expressions appearing within a stylesheet.</p>

<p>The static context for an expression or other construct in a stylesheet is determined by the place
in which it appears lexically. The details vary for different components of the static context, but in
general, elements within a stylesheet module affect the static context for their descendant elements 
within the same stylesheet module.</p>

<p>The dynamic context is maintained as a stack. When an instruction or expression is evaluated, it
may add dynamic context information to the stack; when evaluation is complete, the dynamic context
reverts to its previous state. An expression that accesses information from the dynamic context
always uses the value at the top of the stack.</p>

<p>The most commonly used component of the dynamic context is the 
<termref def="dt-context-item">context item</termref>. This is an implicit variable whose value
is the item (it may be a node or an atomic value) currently being processed. The value of the
context item can be referenced within an XPath expression using the expression <code>.</code> (dot).</p>

<p>Full details of the static and dynamic context are provided in <specref ref="static-and-dynamic-context"/>.</p>

</div2>


			<div2 id="parsing-and-serialization">
				<head>Parsing and Serialization</head>
				<p>An XSLT <termref def="dt-stylesheet">stylesheet</termref> describes a process that
constructs a set of <termref def="dt-final-result-tree">final result trees</termref> from a set of 
<termref def="dt-source-tree">source trees</termref>.</p>
				<p>The <termref def="dt-stylesheet">stylesheet</termref> does not describe how a
         <termref def="dt-source-tree">source tree</termref> is constructed. 
         <phrase diff="add" at="U">Some possible ways of constructing source trees
         are described in <bibref ref="xpath-datamodel"/>.</phrase>
         Frequently
an <termref def="dt-implementation">implementation</termref> will operate in conjunction
 with an XML parser (or more strictly, in the
terminology of <bibref ref="REC-xml"/>, an <emph>XML processor</emph>), to build a source
tree from an input XML document. An implementation <rfc2119>may</rfc2119> also provide an application programming
interface allowing the tree to be constructed directly, or allowing it to be supplied in the form of a
DOM Document object (see <bibref ref="DOM-Level-2-Core"/>). This is outside the scope of this specification.
Users should be aware, however, that since the input to the transformation is a tree conforming
to the <phrase diff="chg" at="Z">XDM</phrase> data model as described in <bibref ref="xpath-datamodel"/>, constructs that might exist in the
original XML document, or in the DOM, but which are not within the scope of the data model,
cannot be processed by the <termref def="dt-stylesheet">stylesheet</termref> and cannot be guaranteed to
remain unchanged in the transformation output. Such constructs include CDATA section boundaries,
the use of entity references, and the DOCTYPE declaration and internal DTD subset.</p>
				<p>
					<termdef id="dt-serialization" term="serialization">A frequent requirement is to
output a <termref def="dt-final-result-tree">final result tree</termref> as an XML document (or in other formats such as HTML). 
This process is referred to as <term>serialization</term>.</termdef></p>
 
 <p>Like parsing, serialization is not part of the transformation
 process, and it is not <rfc2119>required</rfc2119> that an XSLT processor <rfc2119>must</rfc2119> be able to perform
 serialization. However, for pragmatic reasons, this specification describes declarations
 (the <elcode>xsl:output</elcode> element and the <elcode>xsl:character-map</elcode> declarations, 
 see <specref ref="serialization"/>), and attributes on the
 <elcode>xsl:result-document</elcode> instruction, that allow a
 <termref def="dt-stylesheet">stylesheet</termref> to specify the desired properties of a 
 serialized output file. <phrase diff="chg" at="R">When serialization is not being performed,
 either because the implementation does not support the serialization option, or because
 the user is executing the transformation in a way that does not invoke serialization, then
 the content of the <elcode>xsl:output</elcode> and <elcode>xsl:character-map</elcode>
 declarations has no effect. Under these circumstances the processor
 <rfc2119>may</rfc2119> report any errors in an <elcode>xsl:output</elcode> or <elcode>xsl:character-map</elcode>
 declaration, or in the serialization attributes of
 <elcode>xsl:result-document</elcode>,</phrase> but is not <rfc2119>required</rfc2119> to do so.</p>
				
			</div2>
			<div2 id="extensibility" diff="chg" at="R">
				<head>Extensibility</head>
				
<p>XSLT defines a number of features that allow the language to be extended by
implementers, or, if implementers choose to provide the capability, by users. These features
have been designed, so far as possible, so that they can be used without sacrificing interoperability. 
Extensions other than those explicitly defined in this specification are not permitted.</p>

<p>These features are all based on XML namespaces; namespaces are used to ensure that the
extensions provided by one implementer do not clash with those of a different implementer.</p>

<p>The most common way of extending the language is by providing additional functions, which
can be invoked from XPath expressions. These are known as 
<termref def="dt-extension-function">extension functions</termref>, and are described in
<specref ref="extension-functions"/>.</p>

<p>It is also permissible to extend the language by providing new 
<termref def="dt-instruction">instructions</termref>. These
are referred to as <termref def="dt-extension-instruction">extension instructions</termref>,
and are described in <specref ref="extension-instruction"/>.
A stylesheet that uses extension instructions must declare that it is doing so by using
the <code>[xsl:]extension-element-prefixes</code> attribute.</p>

<p>Extension instructions and
extension functions defined according to these rules <rfc2119>may</rfc2119> be provided by
the implementer of the XSLT processor, and the implementer <rfc2119>may</rfc2119> also provide
facilities to allow users to create further extension instructions and
extension functions.</p>
 
<p>This specification defines how extension instructions and extension functions
are invoked, but the facilities for creating new extension instructions and extension
functions are <termref def="dt-implementation-defined">implementation-defined</termref>.
For further details, see <specref ref="extension"/>.</p>
				<imp-def-feature>The mechanisms for creating new extension instructions and extension
functions are implementation-defined.</imp-def-feature>

<p>The XSLT language can also be extended by the use of 
<termref def="dt-extension-attribute">extension attributes</termref> (see
<specref ref="extension-attributes"/>), and by means of 
<termref def="dt-data-element">user-defined data elements</termref>
(see <specref ref="user-defined-top-level"/>).</p>
			</div2>
			<div2 id="stylesheets-and-schemas">
				<head>Stylesheets and <phrase diff="add" at="T">XML</phrase> Schemas</head>
				
				

				
				<p>An XSLT <termref def="dt-stylesheet">stylesheet</termref> 
				can make use of information from a schema. An XSLT transformation can take place 
        in the absence of a
schema (and, indeed, in the absence of a DTD), but where the source document has
undergone schema validity assessment, the XSLT processor has access to the type
information associated with individual nodes, not merely to the untyped text.</p>

<p>Information from a schema can be used both statically (when the <termref def="dt-stylesheet">stylesheet</termref> is compiled),
and dynamically (during evaluation of the stylesheet to transform a source document).</p>

<p>There are places within a <termref def="dt-stylesheet">stylesheet</termref>, 
and within XPath <termref def="dt-expression">expressions</termref> and 
<termref def="dt-pattern">patterns</termref> in
a <termref def="dt-stylesheet">stylesheet</termref>, where it is possible
to refer to named type definitions in a schema, or to element and attribute declarations.
For example, it is
possible to declare the types expected for the parameters of a function. 
This is done using the <xnt spec="XP" ref="SequenceType">SequenceType</xnt> syntax defined
in <bibref ref="xpath20"/>.</p>

<p><termdef id="dt-schema-component" term="schema component">Type definitions
 and element and attribute declarations
are referred to collectively as <term>schema components</term>.</termdef></p>

<p><termdef id="dt-in-scope-schema-component" term="in-scope schema component">The
<termref def="dt-schema-component">schema components</termref> that may be referenced by name in 
a <termref def="dt-stylesheet">stylesheet</termref> are referred to as the
 <term>in-scope schema components</term>. This set is the same throughout all the modules of a stylesheet.</termdef></p>
  
<p>The conformance rules for XSLT 2.0, defined in <specref ref="conformance"/>, distinguish
between a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> and a
<termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>. As the names
suggest, a basic XSLT processor does not support the features of XSLT that require access to
schema information, either statically or dynamically. 
A <termref def="dt-stylesheet">stylesheet</termref> that works with a basic
XSLT processor will produce the same results with a schema-aware XSLT processor
 <phrase diff="chg" at="Y">provided
that the source documents are untyped (that is, they are not validated against a schema). However,
if source documents are validated against a schema then the results may be different from the
case where they are not validated. Some constructs that work on untyped data may fail with typed data (for example,
an attribute of type <code>xs:date</code> cannot be used as an argument of the 
<xfunction>substring</xfunction> function) and other constructs may produce different results depending
on the data type (for example, given the element <code>&lt;product price="10.00" discount="2.00"/&gt;</code>,
the expression <code>@price gt @discount</code> will return true if the attributes have type <code>xs:decimal</code>,
but will return false if they are untyped).</phrase></p>

<p>There is a standard set of type definitions that are always available
as <termref def="dt-in-scope-schema-component">in-scope schema components</termref> in every
stylesheet. These are defined in <specref ref="built-in-types"/>. The set of built-in types
varies between a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> and a
<termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>.</p>

<!--
<p>
The 
<phrase diff="chg" at="R">names of <termref def="dt-schema-component">schema components</termref></phrase> that
appear in such contexts <rfc2119>must</rfc2119> either be built-in schema types (for example <code>xs:string</code> or
<code>xs:integer</code>), or they <rfc2119>must</rfc2119> be user-defined <phrase diff="chg">schema components</phrase>
 that are made accessible to the
XSLT processor by means of an <elcode>xsl:import-schema</elcode> declaration  
(see <specref ref="import-schema"/>) <phrase diff="add" at="R">or by other
 <termref def="dt-implementation-defined">implementation-defined</termref> mechanisms.</phrase></p>-->


 
 <p>The remainder of this section describes facilities that are available only with a
<termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>.</p>

<p>Additional <termref def="dt-schema-component">schema components</termref> (type definitions,
element declarations, and attribute declarations) may be added to the 
<termref def="dt-in-scope-schema-component">in-scope schema components</termref>
by means of the <elcode>xsl:import-schema</elcode> declaration in a stylesheet.</p>

<p diff="add" at="V">The <elcode>xsl:import-schema</elcode> declaration may reference an external schema
document by means of a URI, or it may contain an inline <code>xs:schema</code> element.</p>
 
				<p>It is only necessary to import a schema explicitly
if <phrase diff="chg" at="R">one or more of its <termref def="dt-schema-component">schema components</termref>
are referenced explicitly by name</phrase> in the <termref def="dt-stylesheet">stylesheet</termref>; it is not
necessary to import a schema merely because the stylesheet is used to process a
source document that has been assessed against that schema. It is possible to make use of
the information resulting from schema assessment (for example, the fact that a particular
attribute holds a date) even if no schema has been imported by the stylesheet.</p>
				<p>Further, importing
a schema does not of itself say anything about the type of the source document that the
<termref def="dt-stylesheet">stylesheet</termref> is expected to process. The imported type definitions can be used for temporary nodes
or for nodes on a <termref def="dt-result-tree">result tree</termref> just as much as for nodes <phrase diff="chg" at="M"> in source documents.
It is possible to make assertions about the type of an input document by means of tests within the <termref def="dt-stylesheet">stylesheet</termref>. 
For example:</phrase></p>

<example>
<head>Asserting the Required Type of the Source Document</head>
<eg diff="chg" at="T"><![CDATA[<xsl:template match="document-node(schema-element(my:invoice))" priority="2">
. . .
</xsl:template>

<xsl:template match="document-node()" priority="1">
  <xsl:message terminate="yes">Source document is not an invoice</xsl:message>
</xsl:template>]]></eg>

<p>This example will cause the transformation to fail with an error 
message unless the document element of the source document is valid against
the top-level element declaration <code>my:invoice</code>, and has been annotated as such.</p>

</example>


<p>It is possible that a source document may contain nodes whose <termref def="dt-annotation">type annotation</termref>
is not one of the types imported by the stylesheet. This creates a potential problem because 
in the case of an expression such as <code>data(.) instance of xs:integer</code> the system
needs to know whether the type named in the type annotation of the context node is derived
by restriction from the type <code>xs:integer</code>. This information is not explicitly
available in an <phrase diff="chg" at="Z">XDM tree</phrase>, as defined in <bibref ref="xpath-datamodel"/>.
The implementation may choose one of several strategies for dealing with this situation:</p>

<olist diff="add" at="R">
<item><p>The processor may signal a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if a source document is found to contain a <termref def="dt-annotation">type annotation</termref> that is not known to the processor.</p></item>
<item><p>The processor may maintain additional metadata, beyond that described in <bibref ref="xpath-datamodel"/>,
that allows the source document to be processed as if all the necessary schema information had been imported
using <elcode>xsl:import-schema</elcode>. Such metadata might be held in the data structure representing the 
source document itself, or it might
be held in a system catalog or repository.</p></item>
<item><p>The processor may be configured to use a fixed set of schemas, which are automatically used
 to validate all source documents before they can be supplied as input to a transformation. In this case
 it is impossible for a source document to have a <termref def="dt-annotation">type annotation</termref> that the processor is not aware of.</p></item>
 <item><p>The processor may be configured to treat the source document as if no schema processing had
 been performed, that is, effectively to strip all type annotations from elements and attributes on input,
 marking them instead as having type <phrase diff="chg" at="ZA"><code>xs:untyped</code></phrase> and <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>
 respectively.</p></item>
 </olist> 

				

				<p>Where a stylesheet author chooses to make assertions about the types of nodes or of 
				<termref def="dt-variable">variables</termref> and <termref def="dt-parameter">parameters</termref>,
it is possible for an XSLT processor to perform static analysis of the <termref def="dt-stylesheet">stylesheet</termref> (that is, analysis in the absence of any
source document). Such analysis <rfc2119>may</rfc2119> reveal errors that would otherwise not be discovered until the 
transformation is actually executed. An XSLT processor is not <rfc2119>required</rfc2119> to perform such static type-checking.
<phrase diff="chg" at="R">Under some circumstances (see <specref ref="errors"/>) type errors that
are detected early <rfc2119>may</rfc2119> be reported as static errors. In addition an implementation <rfc2119>may</rfc2119> report any condition found during
static analysis as a warning, provided that this does not prevent the stylesheet being evaluated as described
by this specification.</phrase></p>

<p>A <termref def="dt-stylesheet">stylesheet</termref> can also control the <termref def="dt-annotation">type annotations</termref> 
of nodes that it constructs in a <termref def="dt-final-result-tree">final result tree</termref>, 
or in <termref def="dt-temporary-tree">temporary trees</termref>. This can be done
in a number of ways.</p>

<ulist>
<item><p>It is possible to request explicit validation of 
a complete document, that is, a tree rooted at a document node. This applies
both to temporary trees constructed using the <elcode>xsl:document</elcode> (or <elcode>xsl:copy</elcode>) instruction
and also to <termref def="dt-final-result-tree">final result trees</termref> 
constructed using <elcode>xsl:result-document</elcode>.
Validation is either strict or lax, as described in <bibref ref="xmlschema-1"/>.
If validation of a <termref def="dt-result-tree">result tree</termref> fails 
(strictly speaking, if the outcome of the validity assessment is
<code>invalid</code>), then the transformation fails, but in all other cases, 
the element and attribute nodes of the
tree will be annotated with the names of the types to which these nodes conform.
These <termref def="dt-annotation">type annotations</termref> will be discarded if the result tree is serialized as an XML document, but they
remain available when the result tree is passed to an application (perhaps another <termref def="dt-stylesheet">stylesheet</termref>) for
further processing.</p></item>

<item><p>It is also possible to validate individual element and attribute nodes
 as they are constructed. This is done
using the <code>type</code> and <code>validation</code> attributes of the <elcode>xsl:element</elcode>, 
<elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and <elcode>xsl:copy-of</elcode> instructions, 
or the <code>xsl:type</code> and <code>xsl:validation</code> attributes of a literal result element.</p></item>

<item><p>When elements, attributes, or document nodes
are copied, either explicitly using the <elcode>xsl:copy</elcode>
or <elcode>xsl:copy-of</elcode> instructions, or implicitly when nodes in a sequence are attached to a new
parent node, the options <code>validation="strip"</code> and <code>validation="preserve"</code> are
available, to control whether existing <termref def="dt-annotation">type annotations</termref> are to be retained or not.</p></item>
</ulist>

<p>When nodes in a <termref def="dt-temporary-tree">temporary tree</termref> are validated,
 type information is available
for use by operations carried out on the temporary tree,
in the same way as for a source document that has undergone schema assessment.</p>

<p>For details of how validation of element and attribute nodes works, 
see <specref ref="validation"/>.</p>
			</div2>
			<div2 id="errors">
				<head>Error Handling</head>
				<p>
					<termdef id="dt-static-error" term="static error">An error that is detected by examining
 a <termref def="dt-stylesheet">stylesheet</termref> before execution starts (that is, before the source document
 and values of stylesheet parameters
 are available) is referred to as a <term>static error</term>.</termdef></p>
 
 <p>Errors classified in this specification as static errors <rfc2119>must</rfc2119> be signaled by all
 implementations: that is, the <termref def="dt-processor">processor</termref> <rfc2119>must</rfc2119> indicate that the error is
 present. A static error <rfc2119>must</rfc2119> be signaled
 even if it occurs in a part of the <termref def="dt-stylesheet">stylesheet</termref> that is never evaluated. 
 Static errors are never recoverable. After signaling a static error, a processor
 <rfc2119>may</rfc2119> continue for the purpose of signaling additional errors, but it <rfc2119>must</rfc2119> eventually terminate abnormally
 without producing any <phrase diff="add" at="U"><termref def="dt-final-result-tree">final result tree</termref></phrase>.</p>
				<p>There is an exception to this rule when the stylesheet specifies
<termref def="dt-forwards-compatible-behavior">forwards-compatible behavior</termref>
 (see <specref ref="forwards"/>).</p>
				<p>Generally, errors in the structure of the <termref def="dt-stylesheet">stylesheet</termref>, or in the syntax
				 of XPath <termref def="dt-expression">expressions</termref>
contained in the stylesheet, are classified as
<termref def="dt-static-error">static errors</termref>.
Where this specification states that an element in the stylesheet <rfc2119>must</rfc2119> or <rfc2119>must not</rfc2119> appear in
 a certain position, or that it <rfc2119>must</rfc2119> or <rfc2119>must not</rfc2119> have a particular attribute, 
 or that an attribute <rfc2119>must</rfc2119> or <rfc2119>must not</rfc2119>
 have a value satisfying specified conditions,
  then any contravention of this rule is a static error unless otherwise specified.  </p>
				<p>
					<termdef id="dt-dynamic-error" term="dynamic error">An error that is not detected until
 a source document is being transformed is referred to as a
  <term>dynamic error</term>.</termdef></p>
   
  <p><termdef id="dt-recoverable-error" term="recoverable error" diff="chg" at="Q">Some dynamic errors are classed as 
  <term>recoverable errors</term>. When a recoverable error occurs, this specification allows
  the processor either to signal the error (by reporting
 the error condition and terminating execution) or to take a defined recovery action and continue
 processing.</termdef> 
 It is <termref def="dt-implementation-defined">implementation-defined</termref>
 whether the error is signaled or the recovery action is taken.</p>
 
 <p><termdef id="dt-optional-recovery-action" term="optional recovery action">If an implementation chooses to recover from
 a <termref def="dt-recoverable-error">recoverable dynamic error</termref>, it <rfc2119>must</rfc2119> take
 the <term>optional recovery action</term> defined for that error condition in this specification.</termdef></p>
				<imp-def-feature>Where the specification provides a choice between signaling a dynamic
 error or recovering, the decision that is made
 (but not the recovery action itself) is implementation-defined.</imp-def-feature>
				<p>When the implementation makes the choice
between signaling a dynamic error or recovering, it is not restricted in how it makes
the choice; for example, it <rfc2119>may</rfc2119> provide options that can be set by the user.
When an implementation chooses to recover from a dynamic error, it <phrase diff="chg" at="R"><rfc2119>may</rfc2119></phrase>
 also take other action, such as logging a warning message.</p>
 
 <p><termdef id="dt-nonrec-dynamic-error" term="non-recoverable dynamic error">A 
 <termref def="dt-dynamic-error">dynamic error</termref> that is not recoverable is referred to as a
 <term>non-recoverable dynamic error</term>. When a non-recoverable dynamic error occurs, the
 <termref def="dt-processor">processor</termref> <rfc2119>must</rfc2119> signal the error, and the transformation fails.</termdef></p>
 
				<p>Because different implementations may optimize execution of the <termref def="dt-stylesheet">stylesheet</termref> in
different ways, the detection of dynamic errors is to some degree
<termref def="dt-implementation-dependent">implementation-dependent</termref>. In 
cases where an implementation is able to produce the <termref def="dt-final-result-tree">final result trees</termref> without evaluating a 
particular construct, the implementation is never <rfc2119>required</rfc2119> to
evaluate that construct solely in order to determine whether doing so causes a dynamic error.
 For example, if a <termref def="dt-variable">variable</termref> is declared but never referenced,
 an implementation <rfc2119>may</rfc2119> choose whether or not to evaluate the variable declaration, which means that
 if evaluating the variable declaration causes a dynamic error, some implementations will signal
 this error and others will not.</p>
				<p>There are some cases where this specification requires that a construct <rfc2119>must not</rfc2119>
  be evaluated: for example, the content of an <elcode>xsl:if</elcode> instruction
 <rfc2119>must not</rfc2119> be evaluated if the test condition is false. This means that an implementation
 <rfc2119>must not</rfc2119> signal any dynamic errors that would arise if the construct were evaluated.</p>
				<p>An implementation <rfc2119>may</rfc2119> signal a <termref def="dt-dynamic-error">dynamic error</termref>
 before any source document is available, but only if it can determine that the error would
 be signaled for every possible source document and every possible set of parameter values.
 For example, some <termref def="circularity">circularity</termref> errors fall into this
 category: see <specref ref="circularity"/>.</p>
 
 <p diff="chg" at="T">The XPath specification states (see <xspecref spec="XP" ref="id-kinds-of-errors"/>)
 that if any expression (at any level) can be evaluated during the analysis phase 
 (because all its explicit operands are known and it has no dependencies on the dynamic context), 
 then any error in performing this evaluation <rfc2119>may</rfc2119> be reported as a static error.
  For XPath expressions used in an XSLT stylesheet, however, any
 such errors <rfc2119>must not</rfc2119> be reported as static errors in the stylesheet unless they
 would occur in every possible evaluation of that stylesheet; instead, they must be 
 signaled as dynamic errors, and signaled only if the XPath expression is actually evaluated.</p>
 
 <example>
 <head>Errors in Constant Subexpressions</head>
 <p>An XPath processor
 may report statically that the expression <code>1 div 0</code> fails with a "divide by zero" error.
 But suppose this XPath expression occurs in an XSLT construct such as:</p>
 
<eg><![CDATA[<xsl:choose>
  <xsl:when test="system-property('xsl:version') = '1.0'">
    <xsl:value-of select="1 div 0"/>
  </xsl:when>
  <xsl:otherwise>
    <xsl:value-of select="xs:double('INF')"/>
  </xsl:otherwise>
</xsl:choose>]]></eg>
 
 <p>Then the XSLT processor must not report an error, because the relevant XPath construct
 appears in a context where it will never be executed by an XSLT 2.0 processor. (An XSLT 1.0 processor
 will execute this code successfully, returning positive infinity, because it uses double arithmetic
 rather than decimal arithmetic.)</p></example>
 
				<p>
					<termdef id="dt-type-error" term="type errors">Certain errors are classified as <term>type errors</term>.
 A type error occurs when the value supplied as input to an operation is of the wrong type
 for that operation, for example when an integer is supplied to an operation that expects
 a node.</termdef> If a type error occurs in an instruction that is actually evaluated, then it <rfc2119>must</rfc2119>
 be signaled <phrase diff="chg" at="R">in the same way as a 
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>. Alternatively, an implementation
 <rfc2119>may</rfc2119> signal a type error during the analysis phase</phrase> in the same way as a 
 <termref def="dt-static-error">static error</termref>,
 even if it occurs in part of the stylesheet that is never evaluated, provided it can establish
 that execution of a particular construct would never succeed.</p>
				<p>It is <termref def="dt-implementation-defined">implementation-defined</termref>
  whether type errors are signaled statically.</p>
				<imp-def-feature>It is implementation-defined whether type errors are signaled statically.</imp-def-feature>
				<example><head>A Type Error</head>
					<p>The following
  construct contains a type error, because <code>42</code> is not allowed as an operand of the
  <elcode>xsl:apply-templates</elcode> instruction. An implementation <rfc2119>may</rfc2119> optionally signal this as a 
  static error, even though the offending instruction will never be evaluated, and the type error would
  therefore never be signaled as a dynamic error.</p>
					<eg role="error" xml:space="preserve"><![CDATA[<xsl:if test="false()">
  <xsl:apply-templates select="42"/>
</xsl:if>]]></eg>

<p>On the other hand, in the following example it is not possible to determine
statically whether the operand of <elcode>xsl:apply-templates</elcode> will have a suitable
dynamic type. An implementation <rfc2119>may</rfc2119> produce a warning in such cases, but it <rfc2119>must not</rfc2119> treat
it as an error.</p>

<eg><![CDATA[<xsl:template match="para">
  <xsl:param name="p" as="item()"/>
  <xsl:apply-templates select="$p"/>
</xsl:template>]]></eg>

				</example>
				<p>If more than one error arises, an implementation is not <rfc2119>required</rfc2119> to signal any errors
 other than the first one that it detects. It is 
 <termref def="dt-implementation-dependent">implementation-dependent</termref>
 which of the several errors is signaled. This applies both to static errors and to
 dynamic errors. An implementation is allowed to signal more than one error, but if any 
 errors have been signaled, it <rfc2119>must not</rfc2119> finish as if
 the transformation were successful.</p>
				<p>When a transformation signals one or more dynamic errors, the final state of
 any persistent resources updated by the transformation is 
 <termref def="dt-implementation-dependent">implementation-dependent</termref>. Implementations
 are not <rfc2119>required</rfc2119> to restore such resources to their initial state. In particular, where a transformation
 produces multiple result documents, it is possible that one or more serialized result documents <rfc2119>may</rfc2119> be
 written successfully before the transformation terminates, but the application cannot rely on
 this behavior.</p>
				<p>Everything said above about error handling applies equally to errors in evaluating XSLT
 instructions, and errors in evaluating XPath <termref def="dt-expression">expressions</termref>. 
 Static errors and dynamic errors
 may occur in both cases.</p>
			
				<p>
					<termdef id="dt-serialization-error" term="serialization error">If a transformation has successfully produced
 a <termref def="dt-final-result-tree">final result tree</termref>, it is still possible that errors may occur in serializing the result tree.
 For example, it may be impossible to serialize the result tree using the encoding selected by the user.
 Such an error is referred to as a <term>serialization error</term>.</termdef>
<phrase diff="add" at="ZA">If the processor performs serialization, then it <rfc2119>must</rfc2119> 
do so as specified in <specref ref="serialization"/>, 
and in particular it <rfc2119>must</rfc2119> signal any serialization errors that occur.</phrase></p>
	

<p diff="chg" at="Y">Errors are identified by a QName. For errors defined in this specification, 
the namespace of the QName is always <code>http://www.w3.org/2005/xqt-errors</code> (and is therefore
not given explicitly), while the local part is an 8-character code in the form <var>PPSSNNNN</var>.
Here <var>PP</var> is always <code>XT</code> (meaning XSLT), and <var>SS</var> is one of <code>SE</code>
(static error), <code>DE</code> (dynamic error), <code>RE</code> (recoverable dynamic error), or 
<code>TE</code> (type error). Note that the allocation of an error to one of these categories is purely
for convenience and carries no normative implications about the way the error is handled. Many errors,
for example, can be reported either dynamically or statically.</p>

<p diff="chg" at="Y">These error codes are used to label error conditions in this specification,
and are summarized in <specref ref="error-summary"/>). 
They are provided primarily for ease of reference.
Implementations <rfc2119>may</rfc2119> use these codes when signaling errors, but they are
not <rfc2119>required</rfc2119> to do so. An API specification, however, <rfc2119>may</rfc2119>
require the use of error codes based on these QNames. 
Additional errors defined by
an implementation (or by an application) <rfc2119>may</rfc2119> use 
QNames in an implementation-defined (or user-defined) namespace without risk of collision.</p>

<p diff="chg" at="Y">Errors defined in the <bibref ref="xpath20"/> and <bibref ref="xpath-functions"/> specifications use QNames
with a similar structure, in the same namespace. When errors occur in processing XPath expressions,
an XSLT processor <rfc2119>should</rfc2119> use the original error code reported by the XPath processor,
unless a more specific XSLT error code is available.</p>

			</div2>
		</div1>
		<div1 id="stylesheet-structure">
			<head>Stylesheet Structure</head>
			<p>
				<termdef id="dt-stylesheet-module" term="stylesheet module">A 
<termref def="dt-stylesheet">stylesheet</termref>
consists of one or more <term>stylesheet modules</term>, each one forming
all or part of an XML document.</termdef></p>

<note><p>A stylesheet module is represented by an <phrase diff="chg" at="Z">XDM element node</phrase> 
(see <bibref ref="xpath-datamodel"/>). 
<phrase diff="add" at="ZA">In the case of a standard stylesheet module, this
will be an <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element. In the case of a simplified
stylesheet module, it can be any element (not in the <termref def="dt-xslt-namespace">XSLT namespace</termref>) that has
an <code>xsl:version</code> attribute.</phrase></p>

<p>Although stylesheet modules will commonly be
maintained in the form of documents conforming to XML 1.0 or XML 1.1, this specification
does not mandate such a representation. As with <termref def="dt-source-tree">source trees</termref>,
the way in which stylesheet modules are constructed, from textual XML or otherwise, is outside
the scope of this specification.</p></note>

			
			<p>A stylesheet module is either a standard stylesheet module
or a simplified stylesheet module:</p>
			<ulist>
				<item>
					<p diff="chg" at="U">
						<termdef id="dt-standard-stylesheet-module" term="standard stylesheet module">A
<term>standard stylesheet module</term> is a tree, or part of a tree, consisting of an
 <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element
(see <specref ref="stylesheet-element"/>) together with its descendant nodes and 
associated attributes and namespaces.</termdef>
					</p>
				</item>
				<item>
					<p diff="chg" at="U">
						<termdef id="dt-simplified-stylesheet-module" term="simplified stylesheet module">A
<term>simplified stylesheet module</term> is a tree, or part
of a tree, consisting of a <termref def="dt-literal-result-element">literal result element</termref>
together with its descendant nodes and 
associated attributes and namespaces.
This element is not itself in the XSLT namespace, but it
 <rfc2119>must</rfc2119> have an <code>xsl:version</code> attribute, 
 which implies that it <rfc2119>must</rfc2119> have a namespace node that 
 declares a binding for the XSLT namespace.
For further details see <specref ref="simplified-stylesheet"/>.
						</termdef>
					</p>
				</item>
			</ulist>
			<p>Both forms of stylesheet module (standard and simplified) can exist either as an entire
XML document, or embedded as part of another XML document, typically 
<phrase diff="add" at="Z">but not necessarily</phrase> a source document that is to be processed
using the stylesheet.</p>

<p><termdef id="dt-standalone-stylesheet-module" term="standalone stylesheet module">A
<term>standalone stylesheet module</term> is a stylesheet module that comprises the whole of an XML document.</termdef></p>

<p><termdef id="dt-embedded-stylesheet-module" term="embedded stylesheet module">An 
<term>embedded stylesheet module</term> is a stylesheet module that is
embedded within another XML document, typically the source document
 that is being transformed.</termdef> (see <specref ref="embedded"/>).</p>
 
 <p>There are thus four kinds of stylesheet module:</p>
 
 <slist diff="add" at="R">
   <sitem>standalone standard stylesheet modules</sitem>
   <sitem>standalone simplified stylesheet modules</sitem>
   <sitem>embedded standard stylesheet modules</sitem>
   <sitem>embedded simplified stylesheet modules</sitem>
 </slist>
 
			
			<div2 id="xslt-namespace">
				<head>XSLT Namespace</head>
				<p>
					<termdef id="dt-xslt-namespace" term="XSLT namespace">The <term>XSLT namespace</term>
 has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to identify
 elements, attributes, and other names that have a special meaning defined in
 this specification.</termdef>
				</p>
				<note>
					<p>The <code>1999</code> in the URI indicates the year in which
the URI was allocated by the W3C.  It does not indicate the version of
XSLT being used, which is specified by attributes (see <specref ref="stylesheet-element"/> 
and <specref ref="simplified-stylesheet"/>).</p>
				</note>
				<p>XSLT <termref def="dt-processor">processors</termref> <rfc2119>must</rfc2119> use the XML namespaces 
mechanism <bibref ref="REC-xml-names"/> to recognize elements and attributes from this
namespace. Elements from the XSLT namespace are recognized only in the
<termref def="dt-stylesheet">stylesheet</termref> and not in the source document. The complete list of
XSLT-defined elements is specified in <specref ref="element-syntax-summary"/>.
<termref def="dt-implementation">Implementations</termref> <rfc2119>must not</rfc2119> extend the XSLT
namespace with additional elements or attributes. Instead, any
extension <rfc2119>must</rfc2119> be in a separate namespace.  Any namespace that is used
for additional instruction elements <rfc2119>must</rfc2119> be identified by means of the
<termref def="dt-extension-instruction">extension instruction</termref>
 mechanism specified in <specref ref="extension-instruction"/>.</p>
				<p>This specification uses a prefix of <code>xsl:</code> for referring
to elements in the XSLT namespace. However, XSLT stylesheets are free
to use any prefix, provided that there is a namespace declaration that
binds the prefix to the URI of the XSLT namespace.</p>

				<note><p>Throughout this specification, an element or attribute that is in no 
				namespace, or an <termref def="dt-expanded-qname">expanded-QName</termref> whose namespace part is an empty sequence, is
				referred to as having a <term>null namespace URI</term>.</p></note>

				<note>
					<p>The conventions used for the names of 
					<termref def="dt-xslt-element">XSLT elements</termref>,
attributes and functions are that names are all lower-case, use
hyphens to separate words, and use abbreviations only if they already
appear in the syntax of a related language such as XML or
HTML. Names of types defined in XML Schema however, are regarded as single words and are capitalized 
exactly as in XML Schema. This sometimes leads to composite function names such
as <xfunction>current-dateTime</xfunction>.</p>
				</note>
				
</div2>
<div2 id="reserved-namespaces"><head>Reserved Namespaces</head>				
				<p>
					<termdef id="dt-reserved-namespace" term="reserved namespace">The
 XSLT namespace, together with certain other namespaces
recognized by an XSLT processor, are classified as <term>reserved namespaces</term> 
and <rfc2119>must</rfc2119> be used only as specified in this and related specifications.</termdef>
 The reserved namespaces are those listed below.</p>
				<ulist>
					<item>
						<p>The <termref def="dt-xslt-namespace">XSLT namespace</termref>, described in 
						<specref ref="xslt-namespace"/>, is reserved.</p>
					</item>
					<item>

<p><termdef id="dt-standard-function-namespace" term="standard function namespace">The <term>standard function namespace</term>
<code diff="chg" at="Y">http://www.w3.org/2005/xpath-functions</code>
is used for functions in the function library defined in
<bibref ref="xpath-functions"/> and standard functions defined in this
specification.</termdef></p>
						
					</item>

					<item>
<p><termdef id="xml-namespace" term="XML namespace">The <term>XML namespace</term>, <phrase diff="add" at="M">defined
in <bibref ref="REC-xml-names"/> as <code>http://www.w3.org/XML/1998/namespace</code></phrase>,
 is used for attributes such as <code>xml:lang</code>, <code>xml:space</code>,
and <code>xml:id</code>.</termdef></p>
					</item>
					<item>
						<p>
							<termdef id="dt-schema-namespace" term="schema namespace">The <term>schema
namespace</term>
								<code>http://www.w3.org/2001/XMLSchema</code> is used 
as defined in <bibref ref="xmlschema-1"/>
							</termdef>. In a <termref def="dt-stylesheet">stylesheet</termref> this namespace may be used to refer
to built-in schema datatypes and to the constructor functions associated with those datatypes.</p>
					</item>
	
	
					<item>
						<p>
							<termdef id="dt-schema-instance-namespace" term="schema instance namespace">The <term>schema
instance namespace</term>
								<code>http://www.w3.org/2001/XMLSchema-instance</code> is used 
as defined in <bibref ref="xmlschema-1"/>
							</termdef>. Attributes in this namespace, if they appear
in a <termref def="dt-stylesheet">stylesheet</termref>, are treated by the XSLT processor in the same way as any other attributes.</p>
					</item>
				    
				</ulist>
				<p>Reserved namespaces may be used without restriction to refer to the names of
 elements and attributes in source documents and result documents. As far as the XSLT processor is concerned,
  reserved namespaces other than the XSLT namespace may be used without restriction in the names of
   <termref def="dt-literal-result-element">literal result elements</termref> and
 <termref def="dt-data-element">user-defined data elements</termref>, 
 and in the names of attributes of literal result elements or of 
 <termref def="dt-xslt-element">XSLT <phrase diff="chg" at="ZA">elements</phrase></termref>: 
 but other processors <rfc2119>may</rfc2119> impose restrictions or attach special meaning to them. Reserved namespaces <rfc2119>must not</rfc2119>
 be used, however, in the names of stylesheet-defined objects such as 
 <termref def="dt-variable">variables</termref> and <termref def="dt-stylesheet-function">stylesheet functions</termref>.</p>

<note diff="add" at="Q"><p>With the exception of the XML namespace, any of the above namespaces that
are used in a stylesheet must be explicitly declared with a namespace declaration. Although conventional
prefixes are used for these namespaces in this specification, any prefix may be used in a user stylesheet.</p></note>

				<p>
					<error spec="XT" type="static" class="SE" code="0080"><p>It is a <termref def="dt-static-error">static error</termref>
 to use a <termref def="dt-reserved-namespace">reserved namespace</termref> in the name of 
 a <termref def="dt-named-template">named template</termref>,
 a <termref def="dt-mode">mode</termref>,
 an <termref def="dt-attribute-set">attribute set</termref>, 
 a <termref def="dt-key">key</termref>,
a <termref def="dt-decimal-format">decimal-format</termref>,
 a <termref def="dt-variable">variable</termref> or <termref def="dt-parameter">parameter</termref>,
a <termref def="dt-stylesheet-function">stylesheet function</termref>, a
named <termref def="dt-output-definition">output definition</termref>, or a
<termref def="dt-character-map">character map</termref>.</p></error>
				</p>
				


</div2>
<div2 id="extension-attributes">
<head>Extension Attributes</head>

<p><termdef id="dt-extension-attribute" term="extension attribute">An 
element from the XSLT namespace may have any attribute not from
the XSLT namespace, provided that the <termref def="dt-expanded-qname">expanded-QName</termref> (see <bibref ref="xpath20"/>) of the
attribute has a non-null namespace URI. These attributes are referred to as <term>extension attributes</term>.</termdef>
The presence of an extension attribute <rfc2119>must not</rfc2119> cause the 
<termref def="dt-final-result-tree">final result trees</termref>
produced by the transformation to be different from the result trees 
that a conformant XSLT 2.0 processor might produce. 
They <rfc2119>must not</rfc2119> cause the processor to fail to 
signal an error that a conformant processor
is required to signal. This means that an extension attribute <rfc2119>must not</rfc2119> 
change the effect of any <termref def="dt-instruction">instruction</termref> except to the
extent that the effect is <termref def="dt-implementation-defined">implementation-defined</termref>
or <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>

<p diff="add" at="Z">Furthermore, if serialization is performed using one of the serialization
methods <code>xml</code>, <code>xhtml</code>, <code>html</code>, or <code>text</code> 
described in <specref ref="serialization"/>, the presence
of an extension attribute must not cause the serializer to behave in a way
that is inconsistent with the mandatory provisions of that specification.</p>

<note><p><termref def="dt-extension-attribute">Extension attributes</termref> may be used to
modify the behavior of <termref def="dt-extension-function">extension functions</termref> and
 <termref def="dt-extension-instruction">extension instructions</termref>. They may be used
 to select processing options in cases where the specification leaves the behavior 
 <termref def="dt-implementation-defined">implementation-defined</termref>
or <termref def="dt-implementation-dependent">implementation-dependent</termref>.
 They may also be used for optimization hints, for diagnostics, or for documentation.</p>
 
 <p diff="add" at="Z"><termref def="dt-extension-attribute">Extension attributes</termref> 
 <rfc2119>may</rfc2119> also be used to influence the behavior of the
serialization methods <code>xml</code>, <code>xhtml</code>, <code>html</code>, or <code>text</code>, 
to the extent that the
behavior of the serialization method is <termref def="dt-implementation-defined">implementation-defined</termref>
or <termref def="dt-implementation-dependent">implementation-dependent</termref>. 
For example, an extension attribute might be used
to define the amount of indentation to be used when <code>indent="yes"</code> is
specified. If a serialization method other than one of these four is
requested (using a prefixed QName in the method parameter) then extension
attributes may influence its behavior in arbitrary ways. Extension
attributes <rfc2119>must not</rfc2119> be used to cause the four standard serialization methods
to behave in a non-conformant way, for example by failing to report
serialization errors that a serializer is <rfc2119>required</rfc2119> to report. An
implementation that wishes to provide such options must create a new
serialization method for the purpose.</p>
  
 <p>An implementation that does not recognize the name of an extension attribute, or
 that does not recognize its value, <rfc2119>must</rfc2119> perform the transformation as if the extension attribute
 were not present. As always, it is permissible to produce warning messages.</p>
 
 <p>The namespace used for an extension attribute will be copied to the
 <termref def="dt-result-tree">result tree</termref> in the normal way if it is in scope for a <termref def="dt-literal-result-element">literal
 result element</termref>. This can be prevented using the <code>[xsl:]exclude-result-prefixes</code>
 attribute.</p>
 </note>
 
				<example><head>An Extension Attribute for <code>xsl:message</code></head>
					<p>The following code might be used to
indicate to a particular implementation that the <elcode>xsl:message</elcode>
instruction is to ask the user for confirmation before continuing with the transformation:</p>

<eg><![CDATA[<xsl:message
    abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions">Phase 1 complete</xsl:message>
]]></eg>
					<p>Implementations that do not recognize the namespace <code>http://vendor.example.com/xslt/extensions</code>
will simply ignore the extra attribute, and evaluate the <elcode>xsl:message</elcode> instruction in the
normal way.</p>
				</example>
				<p>
					<error spec="XT" type="static" class="SE" code="0090"><p>It is a <termref def="dt-static-error">static error</termref> for
 an element from the XSLT namespace to have an attribute 
whose namespace is either null 
(that is, an attribute with an unprefixed name) or the XSLT namespace, other than attributes defined
for the element in this document.</p></error>
				</p>

			</div2>
			<div2 id="xslt-media-type">
				<head>XSLT Media Type</head>
				
				<p>The media type <code>application/xslt+xml</code> 
				will be registered for XSLT stylesheet modules.</p>
				
				<p>The proposed definition of the media type is at
				<specref ref="xslt-mime-definition"/></p>
				
								
				<p>This media type <rfc2119>should</rfc2119> be used for an XML document containing a 
				<termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>
				at its top level, and it <rfc2119>may</rfc2119> also be used for a 
				<termref def="dt-simplified-stylesheet-module">simplified stylesheet module</termref>. It
				<rfc2119>should not</rfc2119> be used for an XML document containing an 
				<termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>.</p>

				
			</div2>
			<div2 id="standard-attributes">
				<head>Standard Attributes</head>
				<p>
					<termdef id="dt-standard-attributes" term="standard attributes">There are a number of 
<term>standard attributes</term> that may appear on any 
<termref def="dt-xslt-element">XSLT element</termref>: specifically
<code>version</code>, <code>exclude-result-prefixes</code>, 
<code>extension-element-prefixes</code>, 
<code>xpath-default-namespace</code><phrase diff="add" at="T">, 
<code>default-collation</code>, and <code>use-when</code>.</phrase></termdef>
				</p>

				<p>These attributes may also appear on a
<termref def="dt-literal-result-element">literal result element</termref>,
but in this case, to distinguish them from user-defined attributes, the
names of the attributes are in the <termref def="dt-xslt-namespace">XSLT namespace</termref>. 
They are thus typically
written as <code>xsl:version</code>, <code>xsl:exclude-result-prefixes</code>, 
					<code>xsl:extension-element-prefixes</code>, 
<code>xsl:xpath-default-namespace</code><phrase diff="add" at="T">,
<code>xsl:default-collation</code>, or <code>xsl:use-when</code></phrase>.</p>

				<p>It is <rfc2119>recommended</rfc2119> that all these attributes should also be permitted on
<termref def="dt-extension-instruction">extension instructions</termref>, but
this is at the discretion of the implementer of each extension instruction. They 
<rfc2119>may</rfc2119> also be permitted on <termref def="dt-data-element">user-defined data elements</termref>, 
though they will only have any useful effect in the case of data elements that are designed to
behave like XSLT declarations or instructions.</p>
				<p>In the following descriptions, these attributes are referred to
generically as <code>[xsl:]version</code>, and so on.</p>
				<p>These attributes all affect the element they appear on,  
        <phrase diff="chg" at="U">together with any elements and attributes that have 
        that element as an ancestor</phrase>. The
two forms with and without the XSLT namespace have the same effect; 
the XSLT namespace is used for the attribute if and only if
its parent element is <emph>not</emph> in the XSLT namespace.</p>
				<p>In the case of <code>[xsl:]version</code>, 
<code>[xsl:]xpath-default-namespace</code>, and <code>[xsl:]default-collation</code>,
the value can be overridden by a different value for the
same attribute appearing on a descendant element. The effective value of the
attribute for a particular stylesheet element is determined by the innermost
<phrase diff="chg" at="U">ancestor-or-self</phrase> element on which the attribute appears.</p>

<p diff="add" at="V">In an <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>,
<termref def="dt-standard-attributes">standard attributes</termref>
 appearing on ancestors of the outermost element of the stylesheet module have no effect.</p>

				<p>In the case of <code>[xsl:]exclude-result-prefixes</code> and
<code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these
attributes, the value is given as
 a whitespace-separated list of namespace prefixes, and the
effective value for an element is the combined set of 
namespace URIs designated by the prefixes that appear in this
attribute for that element and any of its ancestor elements. Again, the
two forms with and without the XSLT namespace are equivalent.</p>
<p diff="add" at="T">The effect of the <code>[xsl:]use-when</code> attribute is
described in <specref ref="conditional-inclusion"/>.</p>
				<p>Because these attributes may appear on any 
				<termref def="dt-xslt-element">XSLT element</termref>, they are not listed
in the syntax summary of each individual element. Instead 
<!--<phrase diff="add" at="T">(with the exception of <code>[xsl:]use-when</code>)</phrase>-->
they are listed and
described in the entry for the <elcode>xsl:stylesheet</elcode> and 
<elcode>xsl:transform</elcode> elements only.
This reflects the fact that these attributes are often used on the 
<elcode>xsl:stylesheet</elcode> element only, in which case they apply to the entire
<termref def="dt-stylesheet-module">stylesheet module</termref>.</p>
				<p>Note that the effect of these attributes does <emph>not</emph> extend to
<termref def="dt-stylesheet-module">stylesheet modules</termref> referenced
by <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> declarations.</p>
				<p>For the detailed effect of each attribute, see the following sections:</p>

<glist>
<gitem>
    <label><code>[xsl:]version</code></label>
    <def><p>see <specref ref="backwards"/> and <specref ref="forwards"/></p></def>
</gitem>
<gitem>
    <label><code>[xsl:]xpath-default-namespace</code></label>
    <def><p>see <specref ref="unprefixed-qnames"/></p></def>
</gitem>
<gitem>
    <label><code>[xsl:]exclude-result-prefixes</code></label>
    <def><p>see <specref ref="lre-namespaces"/></p></def>
</gitem>
<gitem>
    <label><code>[xsl:]extension-element-prefixes</code></label>
    <def><p>see <specref ref="extension-instruction"/></p></def>
</gitem>
<gitem>
    <label><code>[xsl:]use-when</code></label>
    <def><p>see <specref ref="conditional-inclusion"/></p></def>
</gitem>
<gitem>
    <label><code>[xsl:]default-collation</code></label>
    <def><p>see <specref ref="default-collation-attribute"/></p></def>
</gitem>
</glist>
				

			</div2>
			<div2 id="stylesheet-element">
				<head>Stylesheet Element</head>
				<e:element-syntax name="stylesheet" diff="chg" at="M">
					<e:attribute name="id">
						<e:data-type name="id"/>
					</e:attribute>
					<e:attribute name="extension-element-prefixes">
						<e:data-type name="tokens"/>
					</e:attribute>
					<e:attribute name="exclude-result-prefixes">
						<e:data-type name="tokens"/>
					</e:attribute>
					<e:attribute name="version" required="yes">
						<e:data-type name="number"/>
					</e:attribute>
					<e:attribute name="xpath-default-namespace">
						<e:data-type name="uri"/>
					</e:attribute>
					<e:attribute name="default-validation">
						<e:constant value="preserve"/>
						<e:constant value="strip"/>
					</e:attribute>
					<e:attribute name="default-collation">
						<e:data-type name="uri-list"/>
					</e:attribute>
					<e:attribute name="input-type-annotations">
						<e:constant value="preserve"/>
						<e:constant value="strip"/>
						<e:constant value="unspecified"/>
					</e:attribute>
					<e:sequence>
						<e:element repeat="zero-or-more" name="import"/>
						<e:model name="other-declarations"/>
					</e:sequence>
					<e:allowed-parents/>
				</e:element-syntax>
				<e:element-syntax name="transform" diff="chg" at="M">
					<e:attribute name="id">
						<e:data-type name="id"/>
					</e:attribute>
					<e:attribute name="extension-element-prefixes">
						<e:data-type name="tokens"/>
					</e:attribute>
					<e:attribute name="exclude-result-prefixes">
						<e:data-type name="tokens"/>
					</e:attribute>
					<e:attribute name="version" required="yes">
						<e:data-type name="number"/>
					</e:attribute>
					<e:attribute name="xpath-default-namespace">
						<e:data-type name="uri"/>
					</e:attribute>
					<e:attribute name="default-validation">
						<e:constant value="preserve"/>
						<e:constant value="strip"/>
					</e:attribute>
					<e:attribute name="default-collation">
						<e:data-type name="uri-list"/>
					</e:attribute>
					<e:attribute name="input-type-annotations">
						<e:constant value="preserve"/>
						<e:constant value="strip"/>
						<e:constant value="unspecified"/>
					</e:attribute>
					<e:sequence>
						<e:element repeat="zero-or-more" name="import"/>
						<e:model name="other-declarations"/>
					</e:sequence>
					<e:allowed-parents/>
				</e:element-syntax>
				<p>A stylesheet module is represented by an <elcode>xsl:stylesheet</elcode>
element in an XML document.  <elcode>xsl:transform</elcode> is allowed as
a synonym for <elcode>xsl:stylesheet</elcode>; everything
this specification says about the <elcode>xsl:stylesheet</elcode> element applies
equally to <elcode>xsl:transform</elcode>.</p>
				<p>An <elcode>xsl:stylesheet</elcode> element <rfc2119>must</rfc2119> have a
<code>version</code> attribute, indicating the version of XSLT that
the stylesheet <phrase diff="add" at="R">module</phrase> requires.</p>


					<p><error spec="XT" type="static" class="SE" code="0110"><p>The value of the <code>version</code> attribute
<rfc2119>must</rfc2119> be a number: specifically, it <rfc2119>must</rfc2119> be a 
<phrase diff="chg" at="T">a valid instance of the type <code>xs:decimal</code> as defined in 
<bibref ref="xmlschema-2"/></phrase>.</p></error> 
For this version of XSLT, the value <rfc2119>should</rfc2119> normally
be <code>2.0</code>.  A value of <code>1.0</code> indicates that the stylesheet module
was written with the intention that it <rfc2119>should</rfc2119> be processed using an XSLT 1.0 processor.</p>

<p>If a <termref def="dt-stylesheet">stylesheet</termref>
that specifies <code>[xsl:]version="1.0"</code> in the
outermost element of the <termref def="dt-principal-stylesheet-module">principal
stylesheet module</termref> (that is, <code>version="1.0"</code> in the case of a 
<termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>, or
<code>xsl:version="1.0"</code> in the case of a <termref def="dt-simplified-stylesheet-module">simplified
stylesheet module</termref>) is submitted to an XSLT 2.0 processor, the processor <rfc2119>should</rfc2119> output
a warning advising the user of possible incompatibilities, unless the user has requested otherwise. 
The processor <rfc2119>must</rfc2119> then process the stylesheet
using the rules for <termref def="dt-backwards-compatible-behavior">backwards-compatible behavior</termref>.
These rules require that if the processor does not support 
<termref def="dt-backwards-compatible-behavior">backwards-compatible behavior</termref>, it <rfc2119>must</rfc2119>
signal an error and <rfc2119>must not</rfc2119> execute the transformation.</p>
 
<p>When the value of the <code>version</code> attribute is greater than 2.0, 
<termref def="dt-forwards-compatible-behavior">forwards-compatible behavior</termref> 
is enabled (see <specref ref="forwards"/>).</p>

<note><p>XSLT 1.0 allowed the <code>[xsl:]version</code> attribute to take any numeric value,
and specified that if the value was not equal to 1.0, the <termref def="dt-stylesheet">stylesheet</termref> would be executed in
forwards compatible mode. XSLT 2.0 continues to allow the attribute to take any unsigned decimal value.
A software product that includes both an XSLT 1.0 processor and
an XSLT 2.0 processor (or that can execute as either) may use the <code>[xsl:]version</code> attribute to 
decide which processor to invoke; such behavior is outside the scope of this specification. 
When the stylesheet is executed with an XSLT 2.0 processor, the value
<code>1.0</code> is taken to indicate that the stylesheet <phrase diff="add" at="R">module</phrase>
was written with XSLT 1.0
in mind: if this value appears on the outermost element of the principal stylesheet module then
an XSLT 2.0 processor will either reject the stylesheet or execute it in backwards compatible
mode, as described above. 
Setting <code>version="2.0"</code> indicates that the <termref def="dt-stylesheet">stylesheet</termref> is to be
executed with neither backwards nor forwards compatible behavior enabled. Any other value less than
<code>2.0</code> enables backwards compatible behavior, while any value greater than <code>2.0</code>
enables forwards compatible behavior.</p>

<p diff="chg" at="T">When developing a <termref def="dt-stylesheet">stylesheet</termref> that is designed to execute under either XSLT 1.0 or XSLT 2.0,
the recommended practice is to create two alternative <termref def="dt-stylesheet-module">stylesheet modules</termref>, 
one specifying
<code>version="1.0"</code>, and the other specifying <code>version="2.0"</code>; these
modules can use <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> to incorporate 
the common code. When running under an XSLT 1.0 processor, the <code>version="1.0"</code> module can
be selected as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>;
when running under an XSLT 2.0 processor, the <code>version="2.0"</code> module can
be selected as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>.
Stylesheet modules that are included or imported should specify <code>version="2.0"</code> if they make use of XSLT 2.0 facilities,
and <code>version="1.0"</code> otherwise.</p></note>

<p diff="add" at="W">The effect of the <code>input-type-annotations</code> attribute is described
in <specref ref="stripping-annotations"/>.</p>

<p>The <code>default-validation</code> attribute defines the default value
of the <code>validation</code> attribute of all <phrase diff="add" at="T"><elcode>xsl:document</elcode></phrase>, <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
<elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, and <elcode>xsl:result-document</elcode> instructions,
 and of the <code>xsl:validation</code>
attribute of all <termref def="dt-literal-result-element">literal result elements</termref>. It also
determines the validation applied to the implicit 
<termref def="dt-final-result-tree">final result tree</termref> created in the absence of an
<elcode>xsl:result-document</elcode> instruction. 
This default applies within the <termref def="dt-stylesheet-module">stylesheet module</termref>:
it does not extend to included or imported stylesheet modules. 
If the attribute is omitted, the default is <code>strip</code>. 
<phrase diff="add" at="U">The permitted values are <code>preserve</code> and <code>strip</code>.</phrase>
For details of the effect of this attribute, see <specref ref="validation"/>.</p>

				<p>
					<error spec="XT" type="static" class="SE" code="0120"><p>An <elcode>xsl:stylesheet</elcode> element <rfc2119>must not</rfc2119> have
any text node children.</p></error> (This rule applies after stripping of 
<termref def="dt-whitespace-text-node">whitespace text nodes</termref> as described in
<specref ref="stylesheet-stripping"/>.)</p>
				<p>
					<termdef id="dt-top-level" term="top-level">An element occurring as
a child of an <elcode>xsl:stylesheet</elcode> element is called a
<term>top-level</term> element.</termdef>
				</p>
				<p>
					<termdef id="dt-declaration" term="declaration">Top-level 
elements fall into two categories: declarations, and 
user-defined data elements.
Top-level elements whose names are in the
<termref def="dt-xslt-namespace">XSLT namespace</termref> are <term>declarations</term>.
Top-level elements in any other namespace are
 <termref def="dt-data-element">user-defined data elements</termref>
(see <specref ref="user-defined-top-level"/>)</termdef>.</p>
				<p>The <termref def="dt-declaration">declaration</termref> elements
				permitted in the <elcode>xsl:stylesheet</elcode> element are:</p>
				<slist>
					<sitem><elcode>xsl:import</elcode></sitem>
					<sitem><elcode>xsl:include</elcode></sitem>
					<sitem><elcode>xsl:attribute-set</elcode></sitem>
					<sitem><elcode>xsl:character-map</elcode></sitem>
					<sitem><elcode>xsl:decimal-format</elcode></sitem>
					<sitem><elcode>xsl:function</elcode></sitem>
					<sitem><elcode>xsl:import-schema</elcode></sitem>
					<sitem><elcode>xsl:key</elcode></sitem>
					<sitem><elcode>xsl:namespace-alias</elcode></sitem>
					<sitem><elcode>xsl:output</elcode></sitem>
					<sitem><elcode>xsl:param</elcode></sitem>
					<sitem><elcode>xsl:preserve-space</elcode></sitem>
					<sitem><elcode>xsl:strip-space</elcode></sitem>
					<sitem><elcode>xsl:template</elcode></sitem>
					<sitem><elcode>xsl:variable</elcode></sitem>
				</slist>
				
<p diff="add" at="T">Note that the <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode>	elements
can act either as <termref def="dt-declaration">declarations</termref> or as <termref def="dt-instruction">instructions</termref>.
A global variable or parameter is defined using a declaration; a local variable or parameter using an instruction.</p>			
				
				<p>If there are <elcode>xsl:import</elcode> elements, these <rfc2119>must</rfc2119> come before
any other elements. Apart from this, the child elements of the <elcode>xsl:stylesheet</elcode>
element may appear in any order. The ordering of these elements does not affect the results
of the transformation unless there are conflicting declarations (for example, two template rules
with the same priority that match the same node). In general, it is an error for a <termref def="dt-stylesheet">stylesheet</termref>
to contain such conflicting declarations,
but in some cases the processor is allowed to recover from the error by choosing the declaration that
appears last in the stylesheet.</p>

<div3 id="default-collation-attribute">
<head>The <code>default-collation</code> attribute</head>

<p>The <code>default-collation</code> attribute is a <termref def="dt-standard-attributes">standard attribute</termref>
that may appear on any element in the XSLT namespace, or (as <code>xsl:default-collation</code>) on a 
<termref def="dt-literal-result-element">literal result element</termref>.</p>

<p>The attribute is used to specify the default collation used by all XPath expressions appearing in the attributes
of this element, or attributes of descendant elements, unless overridden by another <code>default-collation</code> attribute
on an inner element. It also determines the collation used by certain XSLT constructs (such as <elcode>xsl:key</elcode> and
<elcode>xsl:for-each-group</elcode>) within its scope.</p>

<p>The value of the attribute is a whitespace-separated list of collation URIs. 
<phrase diff="chg" at="Y">If any of these URIs is a relative URI, then it is resolved relative to the base URI
of the attribute's parent element. If the implementation recognizes one or
more of the resulting absolute collation URIs</phrase>, 
then it uses the first one that it recognizes as the default collation.</p>

<p><error spec="XT" type="static" class="SE" code="0125"><p>It is a <termref def="dt-static-error">static error</termref>
if the value of an <code>[xsl:]default-collation</code> attribute<phrase diff="add" at="Y">, 
after resolving against the base URI,</phrase> contains no URI that the implementation
recognizes as a collation URI.</p></error>
</p>

<note><p>The reason the attribute allows a list of collation URIs is that collation URIs will often be meaningful
only to one particular XSLT implementation. Stylesheets designed to run with several different implementations can 
therefore specify several different collation URIs, one for use with each. To avoid the above error condition, 
it is possible to specify the Unicode Codepoint Collation as the last collation URI in the list.</p></note>

<p>The <code>[xsl:]default-collation</code> attribute does not affect the collation used by <code>xsl:sort</code>.</p>
</div3> 



				<div3 id="user-defined-top-level">
					<head>User-defined Data Elements</head>
					<p>
						<termdef id="dt-data-element" term="user-defined data element">In addition to 
<termref def="dt-declaration">declarations</termref>, 
the <elcode>xsl:stylesheet</elcode> element may contain
any element not from the <termref def="dt-xslt-namespace">XSLT namespace</termref>,
 provided that the
<termref def="dt-expanded-qname">expanded-QName</termref> of the element has a non-null namespace URI.  Such
elements are referred to as <term>user-defined data elements</term>.</termdef></p>
						<p><error spec="XT" type="static" class="SE" code="0130"><p>It is a <termref def="dt-static-error">static error</termref>
 if the <elcode>xsl:stylesheet</elcode> element has
a child element whose name has a null namespace URI.</p></error>
					</p>
					<p>An implementation <rfc2119>may</rfc2119> attach <phrase diff="add" at="R">an
					<termref def="dt-implementation-defined">implementation-defined</termref></phrase>
					meaning to user-defined
data elements that appear in <phrase diff="chg" at="R">particular namespaces</phrase>. 
The set of namespaces that are recognized for such data elements is
 <termref def="dt-implementation-defined">implementation-defined</termref>.
The presence of
a user-defined data element <rfc2119>must not</rfc2119> change the behavior of 
<termref def="dt-xslt-element">XSLT elements</termref>
and functions defined in this document; for example, it is not
permitted for a user-defined data element to specify that
<elcode>xsl:apply-templates</elcode> should use different rules to resolve
conflicts. <phrase diff="add" at="R">The constraints on what user-defined data elements
can and cannot do are exactly the same as the constraints on <termref def="dt-extension-attribute">extension
attributes</termref>, described in <specref ref="extension-attributes"/>.</phrase>
Thus, an implementation is always free to ignore user-defined data elements,
 and <rfc2119>must</rfc2119> ignore such data elements without giving
an error if it does not recognize the namespace URI. 
</p>
					<imp-def-feature>The set of namespaces that are specially recognized by the implementation
					(for example, for user-defined
 data elements, and <termref def="dt-extension-attribute">extension attributes</termref>) is implementation-defined.</imp-def-feature>
 
 					<imp-def-feature>The effect of user-defined
 data elements whose name is in a namespace recognized by the implementation
  is implementation-defined.</imp-def-feature>
					<p>User-defined data elements can provide, for example,</p>
					<ulist>
						<item>
							<p>information used by <termref def="dt-extension-instruction">extension instructions</termref> 
or <termref def="dt-extension-function">extension functions</termref>
(see <specref ref="extension"/>),</p>
						</item>
						<item>
							<p>information about what to do with any <termref def="dt-final-result-tree">final result tree</termref>,</p>
						</item>
						<item>
							<p>information about how to construct <termref def="dt-source-tree">source trees</termref>,</p>
						</item>
						<item>
							<p>optimization hints for the <termref def="dt-processor">processor</termref>,</p>
						</item>
						<item>
							<p>metadata about the stylesheet,</p>
						</item>
						<item>
							<p>structured documentation for the stylesheet.</p>
						</item>
					</ulist>
					<p>A <termref def="dt-data-element">user-defined data element</termref>
<rfc2119>must not</rfc2119> precede an <elcode>xsl:import</elcode> element within a
<termref def="dt-stylesheet-module">stylesheet module</termref> 
<phrase diff="chg" at="ZA"><errorref spec="XT" class="SE" code="0200"/></phrase></p>
				</div3>
			</div2>
			<div2 id="simplified-stylesheet">
				<head>Simplified Stylesheet Modules</head>
				<p>A simplified syntax is allowed for a <termref def="dt-stylesheet-module">stylesheet module</termref>
that defines only a single template rule for the document node.
The stylesheet module may consist of
just a <termref def="dt-literal-result-element">literal result element</termref> 
(see <specref ref="literal-result-element"/>) together with its contents.
<phrase diff="add" at="R">The literal result element must have an <code>xsl:version</code>
attribute (and it must therefore also declare the XSLT namespace).</phrase>
  Such a stylesheet <phrase diff="add" at="R">module</phrase> is equivalent to a
standard stylesheet module whose <elcode>xsl:stylesheet</elcode> element contains a
<termref def="dt-template-rule">template rule</termref> containing the literal result element,
<phrase diff="add" at="R">minus its <code>xsl:version</code> attribute</phrase>;
the template rule has a match <termref def="dt-pattern">pattern</termref> of <code>/</code>.</p>
				<example><head>A Simplified Stylesheet</head>
					<p>For example:</p>
					<eg><![CDATA[<html xsl:version="2.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Expense Report Summary</title>
  </head>
  <body>
    <p>Total Amount: <xsl:value-of select="expense-report/total"/></p>
  </body>
</html>]]></eg>
					<p>has the same meaning as</p>
					<eg><![CDATA[<xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml">
<xsl:template match="/">
<html>
  <head>
    <title>Expense Report Summary</title>
  </head>
  <body>
    <p>Total Amount: <xsl:value-of select="expense-report/total"/></p>
  </body>
</html>
</xsl:template>
</xsl:stylesheet>]]></eg>

<p>Note that it is not possible, using a simplified stylesheet,
to request that the serialized output contains a <code>DOCTYPE</code> declaration.
This can only be done by using a standard stylesheet module, and using the
 <elcode>xsl:output</elcode> element.</p>
				</example>
				<p>More formally, a simplified stylesheet module is
equivalent to the standard stylesheet module that would be generated by
applying the following transformation to the simplified stylesheet module,
invoking the transformation by calling the
 <termref def="dt-named-template">named template</termref>
						<code>expand</code>, with
the containing literal result element as the <termref def="dt-context-node">context node</termref>:
				</p>
				<eg><![CDATA[<xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<xsl:template name="expand">
  <xsl:element name="xsl:stylesheet">
    <xsl:attribute name="version" select="@xsl:version"/>
    <xsl:element name="xsl:template">
      <xsl:attribute name="match">/</xsl:attribute>
      <xsl:copy-of select="."/>
    </xsl:element>
  </xsl:element>
</xsl:template>  

</xsl:stylesheet>]]></eg>

				<p>
					<error spec="XT" type="static" class="SE" code="0150"><p>A <termref def="dt-literal-result-element">literal result element</termref> that
 is used as the outermost element of a
simplified stylesheet module <rfc2119>must</rfc2119> have
 an <code>xsl:version</code> attribute.</p></error> This
indicates the version of XSLT that the stylesheet requires.  
For this version of XSLT, the value will normally be <code>2.0</code>; the
value <rfc2119>must</rfc2119> be a <phrase diff="chg" at="T">valid instance of the type
<code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"/></phrase>.</p>
				<p>Other
<termref def="dt-literal-result-element">literal result elements</termref> may also 
have an <code>xsl:version</code> attribute. When the <code>xsl:version</code> 
attribute is numerically less than
<code>2.0</code>, backwards-compatible processing behavior is enabled (see <specref ref="backwards"/>). 
When the <code>xsl:version</code> attribute is numerically greater than <code>2.0</code>, 
<termref def="dt-forwards-compatible-behavior">forwards-compatible behavior</termref> 
is enabled (see <specref ref="forwards"/>).</p>
				<p>The allowed content of a literal result element when used as a
simplified stylesheet is the same as when it occurs within a
<termref def="dt-sequence-constructor">sequence constructor</termref>. 
Thus, a literal result element used as the document element of
a simplified stylesheet cannot
contain <termref def="dt-declaration">declarations</termref>.
<phrase diff="add" at="ZA">Simplified stylesheets therefore cannot use 
<termref def="dt-global-variable">global variables</termref>,
<termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, 
<termref def="dt-stylesheet-function">stylesheet functions</termref>, 
<termref def="dt-key">keys</termref>, 
<termref def="dt-attribute-set">attribute-sets</termref>, or
<termref def="dt-output-definition">output definitions</termref>.  
In turn this means that the only useful way to initiate the transformation is to supply a document node as the
<termref def="dt-initial-context-node">initial context node</termref>, to be matched by the
implicit <code>match="/"</code> template rule using the <termref def="dt-default-mode">default mode</termref>. </phrase></p>
			</div2>
			
			
<div2 id="backwards">
<head>Backwards-Compatible Processing</head>

<p><termdef id="dt-backwards-compatible-behavior" term="backwards compatible behavior">An element 
enables backwards-compatible behavior for itself, its
attributes, its descendants and their attributes if it has an
<code>[xsl:]version</code> attribute (see <specref ref="standard-attributes"/>)
whose value is less than <code>2.0</code>.</termdef></p>

<p>An element
that has an <code>[xsl:]version</code> attribute whose value is greater than or equal to <code>2.0</code> 
disables backwards-compatible behavior for itself, its attributes, its
descendants and their attributes. The compatibility
behavior established by an element overrides
any compatibility behavior established by an ancestor element.</p>

<p>If an attribute containing an XPath <termref def="dt-expression">expression</termref> is processed with
 backwards-compatible behavior, then the expression is evaluated with <termref def="dt-compatibility-mode">XPath 1.0 compatibility mode</termref>
 set to <code>true</code>. For details of this mode, see <xspecref spec="XP" ref="static_context"/>.
 <phrase diff="add" at="ZB">Furthermore, 
in such an expression any function call for which no implementation is
available (unless it uses the 
<termref def="dt-standard-function-namespace">standard function namespace</termref>) is bound to a
fallback error function whose effect when evaluated is to raise a dynamic error 
<errorref spec="XT" class="DE" code="1425"/> . The effect is that with 
backwards-compatible behavior enabled, calls
on <termref def="dt-extension-function">extension functions</termref>
 that are not available in a particular implementation
do not cause an error unless the function call is actually evaluated. For
further details, see <specref ref="extension-functions"/>.</phrase></p>

<note diff="add" at="ZB"><p>This might appear to contradict the specification of XPath
2.0, which states that a static error [XPST0017]<!--<xerrorref spec="XP" class="ST" code="0017"/>-->
 is raised when an expression
contains a call to a function that is not present (with matching name and
arity) in the static context. This apparent contradiction is resolved by
specifying that the XSLT processor constructs a static context for the
expression in which every possible function name and arity (other than names in
the <termref def="dt-standard-function-namespace">standard function namespace</termref>) 
is present; when no other implementation of
the function is available, the function call is bound to a fallback error
function whose run-time effect is to raise a dynamic error.</p></note>


 <p>Certain XSLT constructs also produce different results when backwards-compatible behavior is enabled. 
 This is described separately for each such construct.</p>
 
<p>These rules do not apply to the <elcode>xsl:output</elcode> element, 
whose <code>version</code> attribute
 has an entirely different purpose: it is used to define the version of the output 
 method to be used for serialization.</p>


 <note><p><phrase diff="chg" at="R">By making use of backwards-compatible behavior, it is possible
 to write the stylesheet in a way that ensures that its results when processed with an XSLT 2.0 processor are
  identical to the effects of processing the same stylesheet using an 
 XSLT 1.0 processor.</phrase> The differences are described (non-normatively) in <specref ref="incompatibilities"/>. 
 To assist with transition, some parts of a stylesheet may be processed with backwards compatible behavior enabled,
  and other parts with this behavior disabled. All data values manipulated by an XSLT 2.0 processor are defined by
   the <phrase diff="chg" at="Z">XDM</phrase> data model, whether or not the relevant expressions use backwards compatible behavior.
  Because the same data model is used in both cases, expressions are fully composable. The result of evaluating
  instructions or expressions with backwards compatible behavior is fully defined in the XSLT 2.0 and XPath 2.0
  specifications, it is not defined by reference to the XSLT 1.0 and XPath 1.0 specifications. </p></note> 

				
				<p>It is
<termref def="dt-implementation-defined">implementation-defined</termref>
whether a particular XSLT 2.0 implementation supports backwards-compatible behavior.</p>
<p><error spec="XT" type="dynamic" class="DE" code="0160"><p>If an implementation does not support backwards-compatible
behavior, then it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if any element is evaluated that enables 
backwards-compatible behavior.</p></error>
				</p>
				<imp-def-feature>It is implementation-defined whether an XSLT 2.0 processor supports
backwards-compatible behavior.</imp-def-feature>
				
				<note><p>To write a stylesheet that works with both XSLT 1.0 and 2.0 processors, while making
				selective use of XSLT 2.0 facilities, it is necessary to understand both the rules for
				backwards-compatible behavior in XSLT 2.0, and the rules for forwards-compatible
				behavior in XSLT 1.0. If the <elcode>xsl:stylesheet</elcode> element specifies
				<code>version="2.0"</code>, then an XSLT 1.0 processor will ignore XSLT 2.0 
				<termref def="dt-declaration">declarations</termref> that were not defined in XSLT 1.0, for
				example <elcode>xsl:function</elcode> and 
				<elcode>xsl:import-schema</elcode>. If any new XSLT 2.0
				instructions are used (for example <elcode>xsl:analyze-string</elcode> or <elcode>xsl:namespace</elcode>),
				or if new XPath 2.0 features are used (for example, new functions, or syntax such as conditional
				expressions, or calls to a function defined using <elcode>xsl:function</elcode>), 
				then the stylesheet must provide fallback behavior that relies on XSLT 1.0 and XPath 1.0
				facilities only. The fallback behavior can be invoked by using the <elcode>xsl:fallback</elcode>
				instruction, or by testing the results of the <function>function-available</function> or 
				<function>element-available</function> functions, or by testing the value of the <code>xsl:version</code>
				property returned by the <function>system-property</function> function.</p></note>
			</div2>
			<div2 id="forwards" diff="chg" at="Y">
				<head>Forwards-Compatible Processing</head>

        <p>The intent of forwards-compatible behavior is to make it possible to
write a stylesheet that takes advantage of features introduced in some version of
XSLT subsequent to XSLT 2.0, while retaining the ability to execute the
stylesheet with an XSLT 2.0 processor using appropriate fallback behavior.</p>

<p>It is always possible to write conditional code to run under different XSLT
versions by using the <code>use-when</code> feature described in <specref ref="conditional-inclusion"/>. The
rules for forwards-compatible behavior supplement this mechanism in two
ways:</p>

<ulist>
<item><p>certain constructs in the stylesheet that mean nothing to an XSLT 2.0
processor are ignored, rather than being treated as errors.</p></item>

<item><p>explicit fallback behavior can be defined for instructions defined in a
future XSLT release, using the
<elcode>xsl:fallback</elcode> instruction.</p></item>
</ulist>

<p>The detailed rules follow.</p>


				<p>
					<termdef id="dt-forwards-compatible-behavior" term="forwards-compatible behavior">An element enables
<term>forwards-compatible behavior</term> for itself, its
attributes, its descendants and their attributes if it has an
<code>[xsl:]version</code> attribute (see <specref ref="standard-attributes"/>) 
whose value is greater than <code>2.0</code>.</termdef></p>

<p>An element that has an <code>[xsl:]version</code> attribute 
whose value is less than or equal to <code>2.0</code> 
disables forwards-compatible behavior for itself, its attributes, its
descendants and their attributes.
The compatibility behavior established by an element overrides
any compatibility behavior established by an ancestor element.</p>

<p>These rules do not apply to the <code>version</code> attribute
of the <elcode>xsl:output</elcode> element, which has an entirely different purpose: 
it is used to define the version of the output method to be used for serialization.</p>

<p>Within a section of a <termref def="dt-stylesheet">stylesheet</termref> where forwards-compatible
behavior is enabled:</p>

<ulist>
<item>
						<p>if an element in the XSLT namespace appears
						 as a child of the <elcode>xsl:stylesheet</elcode> element,
and XSLT 2.0 does not allow such elements to occur as children of the <elcode>xsl:stylesheet</elcode> element,
 then the element and its content <rfc2119>must</rfc2119> be ignored.</p>
					</item>

<item>
						<p>if an element has an attribute that XSLT 2.0 does not allow the element to have, then the
attribute <rfc2119>must</rfc2119> be ignored.</p></item>

<item><p>if an element in the XSLT namespace appears as part of a 
<termref def="dt-sequence-constructor">sequence constructor</termref>, and XSLT 2.0 does not allow
such elements to appear as part of a sequence constructor, then:</p>

  <olist><item><p>If the element has one or more <elcode>xsl:fallback</elcode> children, then no error
  is reported either statically or dynamically, and the result of evaluating the instruction is the concatenation of
  the sequences formed by evaluating the sequence constructors within its 
  <elcode>xsl:fallback</elcode> children, in document order. Siblings of the <elcode>xsl:fallback</elcode>
  elements are ignored, even if they are valid XSLT 2.0 instructions.</p></item>

  <item><p>If the element has no <elcode>xsl:fallback</elcode> children, then a static error is reported in the
  same way as if forwards-compatible behavior were not enabled.</p></item>
  </olist>
					</item>
          </ulist>


				<example><head>Forwards Compatible Behavior</head>
					<p><phrase diff="chg" at="R">For example, 
					an XSLT 2.0 <termref def="dt-processor">processor</termref> will</phrase>
 process the following stylesheet without error, although the
stylesheet includes elements from 
the <termref def="dt-xslt-namespace">XSLT namespace</termref> that are not
defined in this specification:</p>
					<eg><![CDATA[<xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <xsl:exciting-new-17.0-feature>
      <xsl:fly-to-the-moon/>
      <xsl:fallback>
        <html>
          <head>
            <title>XSLT 17.0 required</title>
          </head>
          <body>
            <p>Sorry, this stylesheet requires XSLT 17.0.</p>
          </body>
        </html>
      </xsl:fallback>
    </xsl:exciting-new-17.0-feature>
  </xsl:template>
</xsl:stylesheet>]]></eg>
				</example>
				<note>
					<p>If a stylesheet depends crucially on a <termref def="dt-declaration">declaration</termref>
introduced by a version of XSLT after 2.0, then
the stylesheet can use an <elcode>xsl:message</elcode> element with
<code>terminate="yes"</code> (see <specref ref="message"/>) to ensure
that implementations that conform to an earlier version of XSLT will not silently ignore the
<termref def="dt-declaration">declaration</termref>.</p>
				</note>
				<example><head>Testing the XSLT Version</head>
					<p>For example,</p>
					<eg diff="chg" at="R"><![CDATA[<xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:important-new-17.0-declaration/>

  <xsl:template match="/">
    <xsl:choose>
      <xsl:when test="number(system-property('xsl:version')) lt 17.0">
        <xsl:message terminate="yes">
          <xsl:text>Sorry, this stylesheet requires XSLT 17.0.</xsl:text>
        </xsl:message>
      </xsl:when>
      <xsl:otherwise>
        ...
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  ...
</xsl:stylesheet>]]></eg>
				</example>
			</div2>
			<div2 id="combining-modules">
				<head>Combining Stylesheet Modules</head>
				<p>XSLT provides two mechanisms to construct
 a <termref def="dt-stylesheet">stylesheet</termref> from multiple 
 <termref def="dt-stylesheet-module">stylesheet modules</termref>:</p>
				<ulist>
					<item><p>an inclusion mechanism that allows stylesheet modules to be combined
without changing the semantics of the modules being combined,
and</p></item>
					<item><p>an import mechanism that allows stylesheet modules to override each
other.</p></item>
				</ulist>
				
<div3 id="locating-modules" diff="add" at="R">
  <head>Locating Stylesheet Modules</head>				
				
<p>The include and import mechanisms use two declarations, <elcode>xsl:include</elcode> and
<elcode>xsl:import</elcode>, which are defined in the sections that follow.</p>

<p>These declarations use an <code>href</code> attribute, whose value is a 
<termref def="dt-uri-reference">URI reference</termref>, 
to identify the <termref def="dt-stylesheet-module">stylesheet module</termref> to be included
 or imported. If the value of this
attribute is a relative URI, it is resolved <phrase diff="chg" at="V">as described in
<specref ref="uri-references"/></phrase>.</p>

<p>After resolving against the base URI, the way in which the URI reference is
used to locate a <phrase diff="chg" at="U">representation of a
 <termref def="dt-stylesheet-module">stylesheet module</termref>, and the way in which
 the stylesheet module is constructed from that representation, are</phrase> 
<termref def="dt-implementation-defined">implementation-defined</termref>. In particular,
it is implementation-defined which URI schemes are supported, whether
fragment identifiers are supported, and what media types are supported.
Conventionally, the URI is a reference to a resource containing the
stylesheet module as a source XML document, or it may include a fragment
identifier that selects an embedded stylesheet module within a source XML
document; but the implementation is free to use other mechanisms to locate
the stylesheet module identified by the URI reference.</p>

<p>The referenced <termref def="dt-stylesheet-module">stylesheet module</termref>
 may be any of the four kinds of stylesheet module:
that is, it may be 
<termref def="dt-standalone-stylesheet-module">standalone</termref> or 
<termref def="dt-embedded-stylesheet-module">embedded</termref>, and it may be
<termref def="dt-standard-stylesheet-module">standard</termref> or 
<termref def="dt-simplified-stylesheet-module">simplified</termref>. If it is a 
<termref def="dt-simplified-stylesheet-module">simplified stylesheet module</termref> then
it is transformed into the equivalent <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>
by applying the transformation described in <specref ref="simplified-stylesheet"/>.</p>

<p>Implementations <rfc2119>may</rfc2119> choose to accept
URI references containing a fragment identifier defined 
by reference to the XPointer specification (see <bibref ref="xptr-framework"/>). Note that if 
the implementation does not support the use of fragment identifiers in the URI reference,
then it will not be possible to include an <termref def="dt-embedded-stylesheet-module">embedded
stylesheet module</termref>.</p>

<imp-def-feature>It is implementation-defined
what forms of URI reference are acceptable in the <code>href</code>
attribute of the <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode> elements, 
for example, the URI schemes that may be used, the forms of
fragment identifier that may be used, and the media types that
are supported.</imp-def-feature>

<p><error spec="XT" type="static" class="SE" code="0165"><p>It is a 
<termref def="dt-static-error">static error</termref> if the processor is not able to retrieve the resource
identified by the URI reference<error.extra> in the <code>href</code> attribute
of <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode></error.extra>, or if the resource that is retrieved does
not contain a stylesheet module conforming to this specification.</p></error></p>				

</div3>				
				
				<div3 id="include">
					<head>Stylesheet Inclusion</head>
					<e:element-syntax name="include">
						<e:in-category name="declaration"/>
						<e:attribute name="href" required="yes">
							<e:data-type name="uri-reference"/>
						</e:attribute>
						<e:empty/>
						<e:allowed-parents>
							<e:parent name="stylesheet"/>
							<e:parent name="transform"/>
						</e:allowed-parents>
					</e:element-syntax>
					<p>A stylesheet module may include another stylesheet module using an
<elcode>xsl:include</elcode> declaration.</p>

<p>The <elcode>xsl:include</elcode> declaration
has a <rfc2119>required</rfc2119> <code>href</code> attribute whose value is a URI reference
identifying the stylesheet module to be included.  This attribute is used as described
in <specref ref="locating-modules"/>.</p>


					
					<p>
						<error spec="XT" type="static" class="SE" code="0170"><p>An <elcode>xsl:include</elcode> element <rfc2119>must</rfc2119> be a
 <termref def="dt-top-level">top-level</termref> element.</p></error>
					</p>
					<p>
						<termdef id="dt-stylesheet-level" term="stylesheet level">A <term>stylesheet level</term>
is a collection of <termref def="dt-stylesheet-module">stylesheet modules</termref> connected
using <elcode>xsl:include</elcode> declarations: 
specifically, two stylesheet modules <var>A</var> and <var>B</var> are part of the same 
stylesheet level if one of them includes the other by means of an <elcode>xsl:include</elcode>
declaration, or if there is a third stylesheet module <var>C</var> that is in the same 
stylesheet level as both <var>A</var> and <var>B</var>.</termdef>
					</p>
					<p>
						<termdef id="dt-declaration-order" term="declaration order">The
 <termref def="dt-declaration">declarations</termref> within a
<termref def="dt-stylesheet-level">stylesheet level</termref> have a total ordering known
 as <term>declaration order</term>. The order of declarations within a stylesheet
 level is the same as the document order that would result if each stylesheet module were
 inserted textually in place of the <elcode>xsl:include</elcode> element that references it.</termdef>
In other respects, however, the effect of <elcode>xsl:include</elcode> is not equivalent to
the effect that would be obtained by textual inclusion.</p>
					<p>
						<error spec="XT" type="static" class="SE" code="0180"><p>It is a <termref def="dt-static-error">static error</termref> 
if a stylesheet module
 directly or indirectly includes itself.</p></error>
					</p>
					<note>
						<p>It is not intrinsically an error for a <termref def="dt-stylesheet">stylesheet</termref>
to include the same module more than once. However, doing so can cause errors
because of duplicate definitions.  Such multiple inclusions are less
obvious when they are indirect. For example, if stylesheet
<var>B</var> includes stylesheet <var>A</var>, stylesheet <var>C</var>
includes stylesheet <var>A</var>, and stylesheet <var>D</var> includes
both stylesheet <var>B</var> and stylesheet <var>C</var>, then
<var>A</var> will be included indirectly by <var>D</var> twice.  If
all of <var>B</var>, <var>C</var> and <var>D</var> are used as
independent stylesheets, then the error can be avoided by separating
everything in <var>B</var> other than the inclusion of <var>A</var>
into a separate stylesheet <var>B'</var> and changing <var>B</var> to
contain just inclusions of <var>B'</var> and <var>A</var>, similarly
for <var>C</var>, and then changing <var>D</var> to include
<var>A</var>, <var>B'</var>, <var>C'</var>.</p>
					</note>
				</div3>
				<div3 id="import">
					<head>Stylesheet Import</head>
					<e:element-syntax name="import">
						<e:in-category name="declaration"/>
						<e:attribute name="href" required="yes">
							<e:data-type name="uri-reference"/>
						</e:attribute>
						<e:empty/>
						<e:allowed-parents>
							<e:parent name="stylesheet"/>
							<e:parent name="transform"/>
						</e:allowed-parents>
					</e:element-syntax>
					<p>A stylesheet module may import another
<termref def="dt-stylesheet-module">stylesheet module</termref> using an <elcode>xsl:import</elcode>
						<termref def="dt-declaration">declaration</termref>.  
Importing a stylesheet <phrase diff="add" at="R">module</phrase> is the same
as including it (see <specref ref="include"/>) except that 
<termref def="dt-template-rule">template rules</termref> 
and other <termref def="dt-declaration">declarations</termref> in the 
importing <phrase diff="chg" at="R">module</phrase> take precedence over
template rules and declarations in the imported <phrase diff="chg" at="R">module</phrase>; this is
described in more detail below.</p>

<p>The <elcode>xsl:import</elcode> declaration
has a <rfc2119>required</rfc2119> <code>href</code> attribute whose value is a URI reference
identifying the stylesheet module to be included.  This attribute is used as described
in <specref ref="locating-modules"/>.</p>


					<p>
						<error spec="XT" type="static" class="SE" code="0190"><p>An <elcode>xsl:import</elcode> element
<rfc2119>must</rfc2119> be a <termref def="dt-top-level">top-level</termref> element.</p></error></p>
						<p><error spec="XT" type="static" class="SE" code="0200"><p>The
<elcode>xsl:import</elcode> element children <rfc2119>must</rfc2119> precede all other
element children of an <elcode>xsl:stylesheet</elcode> element, including
any <elcode>xsl:include</elcode> element children and any
<termref def="dt-data-element">user-defined data elements</termref>.</p></error>
					</p>
					<example><head>Using <code>xsl:import</code></head>
						<p>For example,</p>
						<eg><![CDATA[<xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:import href="article.xsl"/>
  <xsl:import href="bigfont.xsl"/>
  <xsl:attribute-set name="note-style">
    <xsl:attribute name="font-style">italic</xsl:attribute>
  </xsl:attribute-set>
</xsl:stylesheet>]]></eg>
					</example>
					<p>
						<termdef id="dt-import-tree" term="import tree">The
<termref def="dt-stylesheet-level">stylesheet levels</termref>
making up a <termref def="dt-stylesheet">stylesheet</termref> are
treated as forming an <term>import tree</term>.  In the import tree,
each stylesheet level has one child for each
<elcode>xsl:import</elcode> declaration that it contains.</termdef> The ordering 
of the children is the <termref def="dt-declaration-order">declaration order</termref>
of the <elcode>xsl:import</elcode> declarations within their stylesheet level.</p>

<p><termdef id="dt-import-precedence" term="import precedence">A <termref def="dt-declaration">declaration</termref>
							<var>D</var> in the stylesheet
is defined to have lower <term>import precedence</term> than another
declaration <var>E</var> if the stylesheet level containing <var>D</var> would be
visited before the stylesheet level containing <var>E</var> in a
post-order traversal of the import tree (that is, a traversal of the
import tree in which a stylesheet level is visited
after its children). Two declarations within the same stylesheet level have
the same import precedence.</termdef>
					</p>
					<p>For example, suppose</p>
					<ulist>
						<item>
							<p>stylesheet module <var>A</var> imports stylesheet modules <var>B</var>
and <var>C</var> in that order;</p>
						</item>
						<item>
							<p>stylesheet module <var>B</var> imports stylesheet module
<var>D</var>;</p>
						</item>
						<item>
							<p>stylesheet module <var>C</var> imports stylesheet module
<var>E</var>.</p>
						</item>
					</ulist>
					<p>Then the import tree has the following structure:</p>
					<eg><![CDATA[
         A
         |
     +---+---+
     |       |
     B       C
     |       |
     D       E
]]></eg>
					<p>The order of import precedence (lowest first) is
<var>D</var>, <var>B</var>, <var>E</var>, <var>C</var>, <var>A</var>.</p>
					<p>In general, a <termref def="dt-declaration">declaration</termref>
with higher import precedence takes precedence over a declaration with
lower import precedence.  This is defined in detail for each kind of declaration.</p>
					<p>
						<error spec="XT" type="static" class="SE" code="0210"><p>It is a <termref def="dt-static-error">static error</termref> if
 a stylesheet module directly or indirectly imports itself.</p></error>
					</p>
					<note>
						<p>The case where a stylesheet module with a particular
URI is imported several times is not treated specially. The effect is exactly the same as if
several stylesheet modules with different URIs but identical content were imported. This might or might
not cause an error, depending on the content of the stylesheet module.</p>
					</note>
				</div3>
			</div2>
			<div2 id="embedded">
				<head>Embedded Stylesheet Modules</head>

<p diff="chg" at="ZA">An <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>
is a <termref def="dt-stylesheet-module">stylesheet module</termref> whose containing element is not
the outermost element of the containing XML document. Both 
<termref def="dt-standard-stylesheet-module">standard stylesheet modules</termref> and
<termref def="dt-simplified-stylesheet-module">simplified stylesheet modules</termref>
may be embedded in this way.</p>

<p diff="chg" at="ZA">Two situations where embedded stylesheets may be useful are:</p>

<ulist diff="chg" at="ZA">
<item><p>The stylesheet may be embedded in the source document to be transformed.</p></item>
<item><p>The stylesheet may be embedded in an XML document that describes a sequence of processing
of which the XSLT transformation forms just one part.</p></item>
</ulist>

<p diff="chg" at="ZA">The <elcode>xsl:stylesheet</elcode> element <rfc2119>may</rfc2119> have an <code>id</code>
attribute to facilitate reference to the stylesheet module within the containing document.</p>

	<!--			<p>A <termref def="dt-standalone-stylesheet-module" diff="chg" at="R">standalone stylesheet module</termref>
				 is a complete XML document with the
<elcode>xsl:stylesheet</elcode> element as its document element. However,
a stylesheet module may also be embedded in another resource. Two forms
of embedding are possible:</p>
				<ulist>
					<item><p>the XSLT stylesheet may be textually embedded in a non-XML
resource, or</p></item>
					<item><p>the <elcode>xsl:stylesheet</elcode> element may occur in an XML
document other than as the document element.</p></item>
				</ulist>
				<p>To facilitate the second form of embedding, the
<elcode>xsl:stylesheet</elcode> element may have an <code diff="chg" at="W">id</code> attribute
that specifies a unique identifier.</p>-->
				<note>
					<p diff="chg" at="Y">In order for such an attribute value to be used as a fragment
          identifier in a URI, the <phrase diff="chg" at="Z">XDM attribute node</phrase> must generally have the 
          <code>is-id</code> property: see <xspecref spec="DM" ref="dm-is-id"/>. This property will typically be set
          if the attribute is defined in a DTD as being of type <code>ID</code>, or if is defined in a schema as being
          of type <code>xs:ID</code>. It is also necessary that the media type of the containing document should
          support the use of ID values as fragment identifiers. Such support is widespread in existing products, and
          is expected to be endorsed in respect of the media type <code>application/xml</code> by a future
          revision of <bibref ref="RFC3023"/>.</p>
         

<p>An alternative, if the implementation supports it, is to
use an <code>xml:id</code> attribute. XSLT allows this attribute (like other namespaced attributes)
to appear on any <termref def="dt-xslt-element">XSLT element</termref>.</p>
				</note>
				<example><head>The <code>xml-stylesheet</code> Processing Instruction</head>
					<p>The following example shows how the <code>xml-stylesheet</code>
processing instruction (see <bibref ref="xml-stylesheet"/>) can be used to allow a
source document to contain its own stylesheet. The URI reference uses a
relative URI with a fragment identifier to locate the
<elcode>xsl:stylesheet</elcode> element:</p>
					<eg><![CDATA[<?xml-stylesheet type="application/xslt+xml" href="#style1"?>
<!DOCTYPE doc SYSTEM "doc.dtd">
<doc>
<head>
<xsl:stylesheet id="style1"
                version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fo="http://www.w3.org/1999/XSL/Format">
<xsl:import href="doc.xsl"/>
<xsl:template match="id('foo')">
  <fo:block font-weight="bold"><xsl:apply-templates/></fo:block>
</xsl:template>
<xsl:template match="xsl:stylesheet">
  <!-- ignore -->
</xsl:template>
</xsl:stylesheet>
</head>
<body>
<para id="foo">
...
</para>
</body>
</doc>
]]></eg>
				</example>
				<note>
					<p>A stylesheet module that is embedded in the document to which it is
to be applied typically needs
to contain a <termref def="dt-template-rule">template rule</termref> that specifies that
<elcode>xsl:stylesheet</elcode> elements are to be ignored.</p>
				</note>
				<note>
					<p>The above example uses the pseudo-attribute <code diff="chg" at="Q">type="application/xslt+xml"</code>
in the <code>xml-stylesheet</code> processing instruction to denote an XSLT stylesheet. This usage
 is subject to <phrase diff="chg" at="R">confirmation</phrase>: 
see <specref ref="xslt-media-type"/>.
In the absence of a registered media type for XSLT stylesheets, some vendors' products
have adopted different conventions, notably <code>type="text/xsl"</code>.</p>
				</note>
				<note>
					<p>Support for the <code>xml-stylesheet</code> processing instruction is not
required for conformance with this Recommendation. <phrase diff="add" at="ZA">Implementations are not
constrained in the mechanisms they use to identify a stylesheet when a transformation is initiated:
see <specref ref="initiating"/>.</phrase></p>
				</note>
			</div2>

      <div2 id="conditional-inclusion">
      <head>Conditional Element Inclusion</head>

      <p>Any element in the XSLT namespace may have a <code>use-when</code> attribute whose
      value is an XPath expression that can be evaluated statically. If the attribute is present
      and the <xtermref spec="XP" ref="dt-ebv">effective boolean value</xtermref> of the
      expression is false, then the element, together with all the nodes having
      that element as an ancestor, is effectively excluded from the 
      <termref def="dt-stylesheet-module">stylesheet module</termref>. When a node
      is effectively excluded from a stylesheet module the stylesheet module has the same effect
      as if the node were not there. Among other things this means that no static or dynamic errors
      will be reported in respect of the element and its contents, other than errors in the
      <code>use-when</code> attribute itself.</p>

      <note><p>This does not apply to XML parsing or validation errors, which 
			will be reported in the usual way. 
			<phrase diff="add" at="Z">It also does not apply to attributes 
			that are necessarily processed
			before <code>[xsl:]use-when</code>, examples being <code>xml:space</code>
			and <code>[xsl:]xpath-default-namespace</code></phrase>.</p></note>

      <p>A <termref def="dt-literal-result-element">literal result element</termref>,
      <phrase diff="add" at="W">or any other element within a 
      <termref def="dt-stylesheet-module">stylesheet module</termref> that is not in the XSLT namespace,</phrase>
       may similarly carry an <code>xsl:use-when</code> attribute.</p>

      <p>If the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element itself is
      effectively excluded, the effect is to exclude all the children of the 
      <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element, but not the
      <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element or its attributes.</p>

      <note><p>This allows all the declarations that depend on the same condition to be
      included in one stylesheet module, and for their inclusion or exclusion to be controlled
      by a single <code>use-when</code> attribute at the level of the module.</p></note>

      <p>Conditional element exclusion happens after stripping of whitespace text nodes from the
      stylesheet, as described in <specref ref="stylesheet-stripping"/>.</p>

      <p>There are no syntactic constraints on the XPath expression that can be used as the value of the
      <code>use-when</code> attribute. However, there are severe constraints on the information provided
      in its evaluation context. These constraints are designed to ensure that the expression can be
      evaluated at the earliest possible stage of stylesheet processing, without any dependency 
      on information contained in the stylesheet itself or in any source document.</p>

      <p>Specifically, the components of the static and dynamic context are defined by the following two tables:</p>

      <table border="1" cellpadding="5" width="100%"><caption>Static Context Components for <code>use-when</code> Expressions</caption>
      <col align="left" width="30%"/>
			<col align="left"/>
			<thead><tr><th>Component</th><th>Value</th></tr></thead>
      <tbody>
      <tr><td valign="top">XPath 1.0 compatibility mode</td><td>false</td></tr>
      <tr><td valign="top">In scope namespaces</td><td>determined by the in-scope namespaces for the containing element
      in the stylesheet</td></tr>
      <tr><td valign="top">Default element/type namespace</td><td>determined by the <code>xpath-default-namespace</code> attribute
      if present (see <specref ref="unprefixed-qnames"/>); otherwise the null namespace</td></tr>
      <tr><td valign="top">Default function namespace</td><td>The <termref def="dt-standard-function-namespace">standard function namespace</termref></td></tr>
      <tr><td valign="top">In scope type definitions</td><td>The type definitions that would be available in the absence of any
      <elcode>xsl:import-schema</elcode> declaration</td></tr>
      <tr><td valign="top">In scope element declarations</td><td>None</td></tr>
      <tr><td valign="top">In scope attribute declarations</td><td>None</td></tr>
      <tr><td valign="top">In scope variables</td><td>None</td></tr>
      <tr><td valign="top">In scope functions</td><td>The <termref def="dt-core-function">core functions</termref> 
	  defined in <bibref ref="xpath-functions"/>,
      together with the functions <function>element-available</function>, <function>function-available</function>,
	  <phrase diff="add" at="ZB"><function>type-available</function>, </phrase>
      and <function>system-property</function> defined in this specification, plus 
      <phrase diff="add" at="ZB">the set of extension functions that are
	  present in the static context of every XPath expression (other than a use-when expression) within the
	  content of the element that is the parent of the <code>use-when</code> attribute</phrase>. 
	  Note that <termref def="dt-stylesheet-function">stylesheet functions</termref> are
      <emph>not</emph> included in the context, which means that the function <function>function-available</function> will
      return <code>false</code> in respect of such functions. <phrase diff="add" at="ZB">The effect of this
	  rule is to ensure that <function>function-available</function> returns true in respect of functions that
	  can be called within the scope of the <code>use-when</code> attribute. It also has the effect that
	  these extensions functions will be recognized within the <code>use-when</code> attribute itself;
	  however, the fact that a function is available in this sense gives no guarantee that a call on the 
	  function will succeed.</phrase></td></tr>
      <tr><td valign="top">In scope collations</td><td>Implementation-defined</td></tr>
      <tr><td valign="top">Default collation</td><td>The Unicode Codepoint Collation</td></tr>
      <tr><td valign="top">Base URI</td><td>The base URI of the containing element in the stylesheet</td></tr>
      <tr><td valign="top">Statically known documents</td><td>None</td></tr>
      <tr><td valign="top">Statically known collections</td><td>None</td></tr>
      </tbody></table>

      <p>&#xa0;</p>

      <table border="1" cellpadding="5" width="100%"><caption>Dynamic Context Components for <code>use-when</code> Expressions</caption>
      <col align="left" width="30%"/>
			<col align="left"/>
			<thead><tr><th>Component</th><th>Value</th></tr></thead>
      <tbody>
      <tr><td valign="top">Context item, position, and size</td><td>Undefined</td></tr>
      <tr><td valign="top">Dynamic variables</td><td>None</td></tr>
      <tr><td valign="top">Current date and time</td><td>Implementation-defined</td></tr>
      <tr><td valign="top">Implicit timezone</td><td>Implementation-defined</td></tr>
      <tr><td valign="top">Available documents</td><td>None</td></tr>
      <tr><td valign="top">Available collections</td><td>None</td></tr>
      </tbody></table>

	  <p diff="add" at="ZA">Within a <termref def="dt-stylesheet-module">stylesheet module</termref>,
	   all expressions contained in <code>[xsl:]use-when</code>
attributes are evaluated in a single <xtermref spec="FO" ref="execution-scope">execution scope</xtermref>. 
This need not be
the same execution scope as that used for <code>[xsl]:use-when</code> expressions in other
stylesheet modules, or as that used when evaluating XPath expressions appearing
elsewhere in the stylesheet module. This means that a function such as
<xfunction>current-date</xfunction> will return the same result when called in different
<code>[xsl:]use-when</code> expressions within the same stylesheet module, but will not
necessarily return the same result as the same call in an <code>[xsl:]use-when</code>
expression within a different stylesheet module, or as a call on
the same function executed during the transformation proper.</p>

      <p>The use of <code>[xsl:]use-when</code> is illustrated in the following examples.</p>

      <example>
      <head>Using Conditional Exclusion to Achieve Portability</head>
      <p>This example demonstrates the use of the <code>use-when</code> attribute to
      achieve portability of a stylesheet across schema-aware and non-schema-aware processors.</p>

      <eg><![CDATA[<xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/>

<xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2">
  <xsl:result-document validation="strict">
    <xsl:apply-templates/>
  </xsl:result-document>
</xsl:template>

<xsl:template match="/">
  <xsl:apply-templates/>
</xsl:template>]]></eg>

<p>The effect of these declarations is that a non-schema-aware processor ignores the 
<elcode>xsl:import-schema</elcode> declaration and the first template rule, and therefore
generates no errors in respect of the schema-related constructs in these declarations.</p>

</example>

<example>
<head>Including Variant Stylesheet Modules</head>
<p>This example includes different stylesheet modules depending on which XSLT processor
is in use.</p>

<eg><![CDATA[<xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/>
<xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/>]]></eg>
</example>

</div2>	
<div2 id="built-in-types"><head>Built-in Types</head>

<p>Every XSLT 2.0 processor includes the following named type definitions
in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref>:</p>

<ulist>
<item><p diff="chg" at="X">All the primitive atomic types defined in <bibref ref="xmlschema-2"/>, 
with the exception of <code>xs:NOTATION</code>. That is:
  <code>xs:string</code>,
  <code>xs:boolean</code>,
  <code>xs:decimal</code>,
  <code>xs:double</code>,
  <code>xs:float</code>,
  <code>xs:date</code>,
  <code>xs:time</code>,
  <code>xs:dateTime</code>,
  <code>xs:duration</code>,
  <code>xs:QName</code>,
  <code>xs:anyURI</code>,
  <code>xs:gDay</code>,
  <code>xs:gMonthDay</code>,
  <code>xs:gMonth</code>,
  <code>xs:gYearMonth</code>,
  <code>xs:gYear</code>,
  <code>xs:base64Binary</code>, and
  <code>xs:hexBinary</code>.</p></item>

<item><p diff="chg" at="X">The derived atomic type <code>xs:integer</code> defined in <bibref ref="xmlschema-2"/>.</p></item>

<item><p>The types <code>xs:anyType</code> and <code>xs:anySimpleType</code>.</p></item>

<item><p>The following types defined in <bibref ref="xpath20"/>:
  <phrase diff="chg" at="ZA"><code>xs:yearMonthDuration</code></phrase>,
  <phrase diff="chg" at="ZA"><code>xs:dayTimeDuration</code></phrase>,
  <phrase diff="chg" at="ZA"><code>xs:anyAtomicType</code></phrase>,
  <phrase diff="chg" at="ZA"><code>xs:untyped</code></phrase>, and 
  <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>.</p></item>
</ulist>


<p>A <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref> additionally supports:</p>

<ulist>
  <item diff="add" at="X"><p>All other built-in types defined in <bibref ref="xmlschema-2"/></p></item>
  <item><p>User-defined types, and element and attribute declarations, that are 
        imported using an <elcode>xsl:import-schema</elcode> declaration 
        as described in <specref ref="import-schema"/>. These may include both simple and complex types.</p></item>

</ulist>

<note><p>The names that are imported from the XML Schema namespace do not include all the
names of top-level types defined in either the Schema for Schemas or the Schema for Datatypes. The Schema
for Datatypes, as well as defining built-in types such as <code>xs:integer</code> and <code>xs:double</code>,
also defines types that are intended for use only within the Schema for DataTypes, such as
 <code>xs:derivationControl</code>. A <termref def="dt-stylesheet">stylesheet</termref> that is designed to process XML Schema documents as its
 input or output may import the Schema for Schemas.</p></note>

<p>An implementation may define mechanisms that allow additional 
<termref def="dt-schema-component">schema components</termref> to be added to the
<termref def="dt-in-scope-schema-component">in-scope schema components</termref> for the
stylesheet. For example, the mechanisms used to define
 <termref def="dt-extension-function">extension functions</termref>
(see <specref ref="extension-functions"/>) may also be used to
 import the types used in the interface to such functions.</p>
 				
 <imp-def-feature>An implementation may define mechanisms, above and beyond <elcode>xsl:import-schema</elcode>
 that allow <termref def="dt-schema-component">schema components</termref> such as type definitions to
 be made available within a stylesheet.</imp-def-feature>
 

<p>These <termref def="dt-schema-component">schema components</termref> are the only ones that may be
 referenced in XPath expressions within the stylesheet, or in the
<code>[xsl:]type</code> and <code>as</code> attributes of those elements that permit these attributes.</p> 

<p diff="add" at="Z">For a Basic XSLT Processor, schema built-in types that are not included in the
static context (for example, <code>xs:NCName</code>) are "unknown types" in the sense of
<xspecref spec="XP" ref="id-sequencetype-matching"/>. In the language of that section, a Basic XSLT Processor
<rfc2119>must</rfc2119> be able to determine whether these unknown types are derived from known
schema types such as <code>xs:string</code>. The purpose of this rule is to ensure that
system functions such as <xfunction>local-name-from-QName</xfunction>, which is defined to return
an <code>xs:NCName</code>, behave correctly. A stylesheet that uses a Basic XSLT Processor
will not be able to test whether the returned value is an <code>xs:NCName</code>, but it will
be able to use it as if it were an <code>xs:string</code>.
</p>
  
</div2>			
			<div2 id="import-schema">
				<head>Importing Schema Components</head>
				
<note><p>The facilities described in this section are not available
with a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>. 
They require a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>,
as described in <specref ref="conformance"/>.</p></note>				
				
				<e:element-syntax name="import-schema">
					<e:in-category name="declaration"/>
					<e:attribute name="namespace">
						<e:data-type name="uri-reference"/>
					</e:attribute>
					<e:attribute name="schema-location">
						<e:data-type name="uri-reference"/>
					</e:attribute>
					<e:element repeat="zero-or-one" name="xs:schema"/>
					<e:allowed-parents>
						<e:parent name="stylesheet"/>
						<e:parent name="transform"/>
					</e:allowed-parents>
				</e:element-syntax>
				<p>The <elcode>xsl:import-schema</elcode> declaration is used to identify 
				<termref def="dt-schema-component">schema components</termref> (that is,
top-level type definitions and 
top-level element and attribute declarations) 
that need to be available statically, that is, before any source document is
available. Names of such components used statically within the
 <termref def="dt-stylesheet">stylesheet</termref> must refer to an
 <termref def="dt-in-scope-schema-component">in-scope schema component</termref>,
 which means they must either be built-in types as defined in <specref ref="built-in-types"/>, 
  or they must be imported using an <elcode>xsl:import-schema</elcode> declaration.</p>

 
<p>The <elcode>xsl:import-schema</elcode> declaration identifies a
namespace containing the names of the components to be imported
 (or indicates that components whose names are in no namespace are to be imported).
The effect is that the names of top-level element and 
attribute declarations and type definitions from this namespace (or non-namespace) 
become available for use within
XPath expressions in the <termref def="dt-stylesheet">stylesheet</termref>, and within other stylesheet 
constructs such as the <code>type</code> and
<code>as</code> attributes of various <termref def="dt-xslt-element">XSLT elements</termref>.</p>

<p>The same schema components are available in all stylesheet modules; importing
components in one stylesheet module makes them available throughout the <termref def="dt-stylesheet">stylesheet</termref>.</p>

<p>The <code>namespace</code> and <code>schema-location</code> attributes are both optional.</p>

<p diff="add" at="V">If the <elcode>xsl:import-schema</elcode> element contains an <code>xs:schema</code> element, then
the <code>schema-location</code> attribute must be absent, and the <code>namespace</code> attribute must
either have the same value as the <code>targetNamespace</code> attribute of the <code>xs:schema</code>
element (if present), or must be absent, in which case its effective value is that of the 
<code>targetNamespace</code> attribute of the <code>xs:schema</code>
element if present or the zero-length string otherwise.</p>

<p diff="add" at="ZA"><error spec="XT" type="static" class="SE" code="0215"><p>It is a
<termref def="dt-static-error">static error</termref> if an <elcode>xsl:import-schema</elcode> 
element that contains an <code>xs:schema</code> element has a <code>schema-location</code> attribute,
or if it has a <code>namespace</code> attribute that conflicts with the target namespace
of the contained schema.</p></error></p>

<p>If two <elcode>xsl:import-schema</elcode> declarations specify the same namespace, 
or if both specify no namespace, then only the
one with highest <termref def="dt-import-precedence">import precedence</termref> is used.
If this leaves more than one, then all the declarations at the highest import precedence
 are used (which may cause conflicts, as described below).</p>



<p>After discarding any <elcode>xsl:import-schema</elcode> declarations under the above rule, the
effect of the remaining <elcode>xsl:import-schema</elcode> declarations is 
defined in terms of a hypothetical document called the synthetic schema document,
which is constructed as follows. The synthetic schema document defines an arbitrary target namespace
that is different from any namespace actually used by the application, and it contains
 <code>xs:import</code> elements corresponding one-for-one with the
 <elcode>xsl:import-schema</elcode> declarations in the
  <termref def="dt-stylesheet">stylesheet</termref>, with the following correspondence:</p>
  
 <ulist>
 <item><p>The <code>namespace</code> attribute of the <code>xs:import</code> element is copied from the <code>namespace</code>
 attribute of the <elcode>xsl:import-schema</elcode> declaration if it is <phrase diff="chg" at="V">explicitly present, or is implied by the
 <code>targetNamespace</code> attribute of a contained <code>xs:schema</code> element, </phrase>
 and is absent if it is absent.</p></item>
 <item><p>The <code>schemaLocation</code> attribute of the <code>xs:import</code> element is copied from the <code>schema-location</code>
 attribute of the <elcode>xsl:import-schema</elcode> declaration if present, and is absent if it is absent.
 <phrase diff="add" at="V">If there is a contained <code>xs:schema</code> element, the effective value of the
 <code>schemaLocation</code> attribute is a URI referencing a document containing a copy of the <code>xs:schema</code>
 element.</phrase></p></item>
 <item><p>The base URI of the <code>xs:import</code> element is the same as the base URI
  of the <elcode>xsl:import-schema</elcode> declaration.</p></item>

 </ulist>
 
<p>The schema components included 
in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref>
(that is, the components whose names are available 
for use within the stylesheet)
are the top-level element and attribute declarations and type definitions that
are available for reference within the synthetic schema document. See <bibref ref="xmlschema-1"/>
 (section 4.2.3, <emph>References to schema components across namespaces</emph>).</p>
 
<p><error spec="XT" type="static" class="SE" code="0220"><p>It is a
<termref def="dt-static-error">static error</termref> if the 
 synthetic schema document does not satisfy the constraints described in
<bibref ref="xmlschema-1"/> (section 5.1, <emph>Errors in Schema Construction and Structure</emph>). 
This includes, without loss of generality, conflicts such as multiple definitions of the same name.</p></error></p>





<note>

<p>The synthetic schema document does not need to be constructed by a real implementation. It is purely
a mechanism for defining the semantics of <elcode>xsl:import-schema</elcode> in terms of rules that
already exist within the XML Schema specification. In particular, it implicitly defines the
rules that determine whether the set of <elcode>xsl:import-schema</elcode> declarations are
mutually consistent.</p>

<p>These rules do not cause names to be imported transitively. The fact that
a name is available for reference within a schema document A does not of itself make the name available
for reference in a stylesheet that imports the target namespace of schema document A.
(See <bibref ref="xmlschema-1"/> section 3.15.3, Constraints on XML Representations of Schemas.) 
The stylesheet must import all the namespaces containing names that it actually references.</p>

<p>The <code>namespace</code> attribute indicates that a schema for the given namespace is required
by the <termref def="dt-stylesheet">stylesheet</termref>. This information may be enough on its own
 to enable an implementation to locate
the required schema components. The <code>namespace</code> attribute may be omitted
to indicate that a schema for names in no namespace is being imported. The zero-length
string is not a valid namespace URI, and is therefore not a valid value for the
 <code>namespace</code> attribute.</p>
                
<p>The <code>schema-location</code> attribute is a <termref def="dt-uri-reference">URI Reference</termref>
that gives a hint indicating where a schema document 
or other resource containing the required definitions may be found. It is likely that a 
<termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref> will 
be able to process a schema document found at this location.</p>

<p>The XML Schema specification gives implementations flexibility in how to handle
multiple imports for the same namespace. Multiple imports do not cause 
errors if the definitions do not conflict.</p> 
 
<p>A consequence of these rules is that it is not intrinsically an error if no schema
document can be located for a namespace identified in an <elcode>xsl:import-schema</elcode> declaration.
This will cause an error only if it results in the stylesheet containing references to names that have not
been imported.</p>

<p diff="add" at="V">An inline schema document (using an <code>xs:schema</code> element as a child of the <code>xsl:import-schema</code>
element) has the same status as an external schema document, in the sense that it acts as a hint for a source of schema
components in the relevant namespace. To ensure that the inline schema document is always used, it is advisable to
use a target namespace that is unique to this schema document.</p>

</note>
				

<p>The use of a namespace in an <elcode>xsl:import-schema</elcode> declaration does not by itself 
associate any namespace prefix with the namespace. 
If names from the namespace are used within the stylesheet module then
 a namespace declaration must be included in the stylesheet module, 
 in the usual way.</p>

 <example><head>An Inline Schema Document</head>

 <p>The following example shows an inline schema document. This declares a simple type
 <code>local:yes-no</code>, which the stylesheet then uses in the declaration of a variable.</p>

 <p>The example assumes the namespace declaration 
 <code>xmlns:local="http://localhost/ns/yes-no"</code></p>

 <eg><![CDATA[<xsl:import-schema>
  <xs:schema targetNamespace="http://localhost/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:simpleType name="local:yes-no">
      <xs:restriction base="xs:string">
        <xs:enumeration value="yes"/>
        <xs:enumeration value="no"/>
      </xs:restriction>
    </xs:simpleType>
  </xs:schema>
</xsl:import-schema>

<xs:variable name="condition" select="'yes'" as="local:yes-no"/>]]>
</eg>

 </example>
				
			
			</div2>



		</div1>
		<div1 id="data-model">
			<head>Data Model</head>

				<p>The data model used by XSLT is the XPath 2.0 and XQuery 1.0 data model 
				<phrase diff="add" at="Z">(XDM)</phrase>, as 
defined in <bibref ref="xpath-datamodel"/>. XSLT operates on source, result and
stylesheet documents using the same data model.</p>

<p>This section elaborates on some particular features of <phrase diff="chg" at="Z">XDM</phrase> as
it is used by XSLT:</p>
 
<p>The rules in <specref ref="stylesheet-stripping"/> and <specref ref="strip"/>
make use of the concept of a whitespace text node.</p>

<p><termdef id="dt-whitespace-text-node" term="whitespace text node">A <term>whitespace text node</term>
is a text node whose content consists entirely of whitespace characters (that is,
#x09, #x0A, #x0D, or #x20).</termdef></p> 

			<note>
				<p>Features of a source XML document that are not represented
in the <phrase diff="chg" at="Z">XDM tree</phrase> will have no effect on the operation of
an XSLT stylesheet. Examples of such features are entity references, CDATA sections,
character references, whitespace within element tags, and the choice of single or double
quotes around attribute values.</p>
			</note>
			
			
<div2 id="xml-versions">
<head>XML Versions</head>

<p>The <phrase diff="add" at="Z">XDM</phrase> data model defined in <bibref ref="xpath-datamodel"/> is capable of representing
either an XML 1.0 document (conforming to <bibref ref="REC-xml"/> and <bibref ref="REC-xml-names"/>) 
or an XML 1.1 document (conforming to <bibref ref="xml11"/> and <bibref ref="xml-names11"/>), and
it makes no distinction between the two.
In principle, therefore, XSLT 2.0 can be used with either of these XML versions.</p>

<p>Construction of the <phrase diff="chg" at="Z">XDM tree</phrase> is outside the scope of this specification, so XSLT 2.0 places no
formal requirements on an XSLT processor to accept input from either XML 1.0 documents or XML 1.1 documents
or both. This specification does define a serialization capability (see <specref ref="serialization"/>),
though from a conformance point of view it is an optional feature. Although facilities are described for
serializing the <phrase diff="chg" at="Z">XDM tree</phrase> as either XML 1.0 or XML 1.1 (and controlling the choice), there is again no
formal requirement on an XSLT processor to support either or both of these XML versions as serialization
targets.</p>

<p>Because the <phrase diff="chg" at="Z">XDM tree</phrase> is the same whether the original document was XML 1.0 or XML 1.1, the semantics
of XSLT processing do not depend on the version of XML used by the original document. There is no reason in principle
why all the input and output documents used in a single transformation must conform to the same version of
XML.</p>

<p>Some of the syntactic constructs in XSLT 2.0 and XPath 2.0, for example the productions <xnt spec="XML" ref="Char">Char</xnt>
and <xnt spec="Names" ref="NT-NCName">NCName</xnt>, are defined by reference to the XML and XML Namespaces specifications.
There are slight variations between the XML 1.0 and XML 1.1 versions of these productions. 
<phrase diff="chg" at="Z">Implementations <rfc2119>may</rfc2119> support either version; it is 
 <rfc2119>recommended</rfc2119>
that an XSLT 2.0 processor that implements the 1.1 versions <rfc2119>should</rfc2119> also provide a mode
that supports the 1.0 versions. It is thus <termref def="dt-implementation-defined">implementation-defined</termref> 
whether the XSLT processor supports XML 1.0 with XML Namespaces 1.0, or XML 1.1 with XML Namespaces 1.1, or supports both versions at user
option.</phrase></p>

<note diff="chg" at="Z"><p>The specification referenced as <bibref ref="REC-xml-names"/> was actually
published without a version number.</p></note>

<imp-def-feature>It is implementation-defined which versions of XML and XML Namespaces (1.0 and/or 1.1) are supported.</imp-def-feature>

<p>At the time of writing there is no published version of <bibref ref="xmlschema-2"/> that references the
XML 1.1 specifications. This means that data types such as <code>xs:NCName</code> and <code>xs:ID</code> are
constrained by the XML 1.0 rules, and do not allow the full range of values permitted by XML 1.1. 
This situation will not be resolved until a new
version of <bibref ref="xmlschema-2"/> becomes available; in the meantime, it is <rfc2119>recommended</rfc2119> 
that implementers wishing to support XML 1.1 should consult <bibref ref="SCHEMA-AND-XML-1.1"/> for guidance.
An XSLT 2.0 processor that supports XML 1.1 <rfc2119>should</rfc2119>
implement the rules in later versions of <bibref ref="xmlschema-2"/> as they become available.</p>


</div2> 

            <div2 id="stylesheet-stripping">
               <head>Stripping Whitespace from the Stylesheet</head>
               
               <p>The tree representing the stylesheet is preprocessed as follows:</p>
               
               <olist>
               <item><p>All comments and processing instructions are removed.</p></item>
               <item><p>Any text nodes that are now adjacent to each other are merged.</p></item>
               <item><p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref>
                that satisfies both the following conditions is removed from the tree:</p>
                  <ulist>
                  <item><p>The parent of the text node is not an <elcode>xsl:text</elcode> element</p></item>
                  <item><p>The text node does not have an ancestor element that has an
<code>xml:space</code> attribute with a value of
<code>preserve</code>, unless there is a closer ancestor element having an
<code>xml:space</code> attribute with a value of <code>default</code>.</p></item>
                  </ulist></item>
               <item><p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref>
                whose parent is one of the following elements
                  is removed from the tree, regardless of any <code>xml:space</code>
                  attributes:</p>
                  <slist>
                  <sitem><elcode>xsl:analyze-string</elcode></sitem>                  
                  <sitem><elcode>xsl:apply-imports</elcode></sitem>
                  <sitem><elcode>xsl:apply-templates</elcode></sitem>
                  <sitem><elcode>xsl:attribute-set</elcode></sitem>
                  <sitem><elcode>xsl:call-template</elcode></sitem>                  
                  <sitem><elcode>xsl:character-map</elcode></sitem>
                  <sitem><elcode>xsl:choose</elcode></sitem>
                  <sitem><elcode>xsl:next-match</elcode></sitem>
                  <sitem><elcode>xsl:stylesheet</elcode></sitem>                  
                  <sitem><elcode>xsl:transform</elcode></sitem>                  
                  </slist></item>
               <item><p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref>
                whose following-sibling node is an
                  <elcode>xsl:param</elcode> or <elcode>xsl:sort</elcode> element is removed from the tree, regardless of
                  any <code>xml:space</code> attributes.</p></item>
               </olist> 
  
  <p><error spec="XT" type="static" class="SE" code="0260"><p>Within an 
  <termref def="dt-xslt-element">XSLT element</termref> that is <rfc2119>required</rfc2119> to be empty,
  any content other than comments or processing instructions, including any 
  <termref def="dt-whitespace-text-node">whitespace text node</termref>
   preserved using the <code>xml:space="preserve"</code> attribute, is a
  <termref def="dt-static-error">static error</termref>.</p></error>
				</p>
				
<note diff="chg" at="U"><p>Using <code>xml:space="preserve"</code> in parts of the stylesheet that
contain <termref def="dt-sequence-constructor">sequence constructors</termref> will cause all text nodes in that part of the stylesheet, 
including those that contain whitespace only, to be copied to the result of the sequence constructor. 
When the result of the sequence constructor is used to form the content of an element, this can cause errors
if such text nodes are followed by attribute nodes generated using <elcode>xsl:attribute</elcode>.</p></note>				

<note><p>If an <code>xml:space</code> attribute is
specified on a <termref def="dt-literal-result-element">literal result element</termref>, 
it will be copied to the result tree in the same way as any other attribute.</p>
</note>

</div2>

<div2 id="stripping-annotations">
<head>Stripping Type Annotations from a Source Tree</head>

<p diff="add" at="X"><termdef id="dt-annotation" term="type annotation">The term
<term>type annotation</term> is used in this specification to refer to the value returned by the 
<code>dm:type-name</code> accessor of a node: see <xspecref spec="DM" ref="dm-type-name"/>.</termdef></p>

<p>There is sometimes a requirement to write stylesheets that produce the same
results whether or not the source documents have been validated against a
schema. To achieve this, an option is provided to remove any <termref def="dt-annotation">type annotations</termref>
on element and attribute nodes in a <termref def="dt-source-tree">source tree</termref>,
replacing them with an annotation of <phrase diff="chg" at="ZA"><code>xs:untyped</code></phrase> in the case of element
nodes, and <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase> in the case of attribute nodes.</p>

<p>Such stripping of <termref def="dt-annotation">type annotations</termref> can be requested by specifying
<code>input-type-annotations="strip"</code> on the <elcode>xsl:stylesheet</elcode>
 element. This attribute
has three permitted values: <code>strip</code>, <code>preserve</code>, 
and <code>unspecified</code>. The
default value is <code>unspecified</code>. Stripping of type annotations takes place if
at least one <termref def="dt-stylesheet-module">stylesheet module</termref>
 in the <termref def="dt-stylesheet">stylesheet</termref> specifies
<code>input-type-annotations="strip"</code>.</p>

<p><error spec="XT" type="static" class="SE" code="0265"><p> It is a 
<termref def="dt-static-error">static error</termref> if there is a
<termref def="dt-stylesheet-module">stylesheet module</termref>
 in the <termref def="dt-stylesheet">stylesheet</termref> that specifies 
 <code>input-type-annotations="strip"</code> and
another <termref def="dt-stylesheet-module">stylesheet module</termref> 
that specifies <code>input-type-annotations="preserve"</code>.</p></error></p>

<p>The <termref def="dt-source-tree">source trees</termref> to which this applies are the same as those affected by
<elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>: 
see <specref ref="strip"/>.</p>

<p diff="add" at="ZA">When type annotations are stripped, the following changes are made to the source tree:</p>

<ulist diff="add" at="ZA">
<item><p>The type annotation of every element node is changed to <code>xs:untyped</code></p></item>
<item><p>The type annotation of every attribute node is changed to <code>xs:untypedAtomic</code></p></item>
<item><p>The typed value of every element and attribute node is set to be the same as its string value, as
an instance of <code>xs:untypedAtomic</code>.</p></item>
<item><p>The <code>is-nilled</code> property of every element node is set to <code>false</code>.</p></item>
</ulist>

<p diff="add" at="ZA">The values of the <code>is-id</code> and <code>is-idrefs</code> properties are
not changed.</p>

<note><p>Stripping type annotations does not necessarily return the
document to the state it would be in had validation not taken place. In
particular, any defaulted elements and attributes that were added to the
tree by the validation process will still be present <phrase diff="add" at="ZA">, and
elements and attributes validated as IDs will still be accessible using the
 <xfunction>id</xfunction> function</phrase>.</p></note>





</div2>







			<div2 id="strip">
				<head>Stripping Whitespace from a Source Tree</head>

				
				<p>A <termref def="dt-source-tree">source tree</termref> supplied as input to the 
transformation process may contain <termref def="dt-whitespace-text-node">whitespace text nodes</termref>
 that are of no interest,
and that do not need to be retained by the transformation. Conceptually,
an XSLT <termref def="dt-processor">processor</termref> makes a copy of the source
tree from which unwanted <termref def="dt-whitespace-text-node">whitespace text nodes</termref>
 have been removed. This process is referred to as whitespace stripping. </p>

<p>For the purposes of this section, the term <term>source tree</term> means the document
containing the <termref def="dt-initial-context-node">initial context node</termref>, and any document
returned by the functions <function>document</function>, <xfunction>doc</xfunction>, or
 <xfunction>collection</xfunction>. It does not include documents passed as the values of
 <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> or returned from
 <termref def="dt-extension-function">extension functions</termref>.</p>

				<p>The stripping process takes as input a set of element names 
whose child <termref def="dt-whitespace-text-node">whitespace text nodes</termref> are to be preserved. 
The way in which this set of element names is established using the 
<elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode> declarations
 is described later in this section.</p>

				<p>A <termref def="dt-whitespace-text-node">whitespace text node</termref>
				 is preserved if either of the following apply:</p>
				<ulist>
					<item>
						<p>The element name of the parent of the text node is in the set
of whitespace-preserving element names.</p>
					</item>
					<item>
						<p>An ancestor element of the text node has an
<code>xml:space</code> attribute with a value of
<code>preserve</code>, and no closer ancestor element has
<code>xml:space</code> with a value of
<code>default</code>.</p>
					</item>
				</ulist>
				<p>Otherwise, the <termref def="dt-whitespace-text-node">whitespace text node</termref>
				 is stripped.</p>
				<p>The <code>xml:space</code> attributes are not removed from the
tree.</p>
				

				<e:element-syntax name="strip-space">
					<e:in-category name="declaration"/>
					<e:attribute name="elements" required="yes">
						<e:data-type name="tokens"/>
					</e:attribute>
					<e:empty/>
					<e:allowed-parents>
						<e:parent name="stylesheet"/>
						<e:parent name="transform"/>
					</e:allowed-parents>
				</e:element-syntax>
				<e:element-syntax name="preserve-space">
					<e:in-category name="declaration"/>
					<e:attribute name="elements" required="yes">
						<e:data-type name="tokens"/>
					</e:attribute>
					<e:empty/>
					<e:allowed-parents>
						<e:parent name="stylesheet"/>
						<e:parent name="transform"/>
					</e:allowed-parents>
				</e:element-syntax>
				<p>The set of
whitespace-preserving element names is specified by
<elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
					<termref def="dt-declaration">declarations</termref>.  Whether an
element name is included in the set of whitespace-preserving names is
determined by the best match among all the <elcode>xsl:strip-space</elcode> or
<elcode>xsl:preserve-space</elcode> declarations: it is included if and only
if there is no match or the best match is an
<elcode>xsl:preserve-space</elcode> element.  The
<elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
elements each have an <code>elements</code> attribute whose value is a
whitespace-separated list of <xnt spec="XP" ref="NameTest">NameTests</xnt>; an element name matches an
<elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
element if it matches one of the <xnt spec="XP" ref="NameTest">NameTests</xnt>. 
An element matches a <xnt spec="XP" ref="NameTest">NameTest</xnt> if and only if the 
<xnt spec="XP" ref="NameTest">NameTest</xnt> would be true for the
element as an XPath node test.  When more than one <elcode>xsl:strip-space</elcode> and
<elcode>xsl:preserve-space</elcode> element matches, the best matching
element is determined by the best matching <xnt spec="XP" ref="NameTest">NameTest</xnt>.  This is determined in the
same way as with <termref def="dt-template-rule">template rules</termref>:</p>
				<ulist>
					<item>
						<p>First, any match with lower <termref def="dt-import-precedence">import precedence</termref> than another
match is ignored.</p>
					</item>
					<item>
						<p>Next, any match that has a lower
<termref def="dt-default-priority">default priority</termref> than the
<termref def="dt-default-priority">default priority</termref> of
another match is ignored.</p>
					</item>
				</ulist>
				<p>
					<error spec="XT" type="dynamic" class="RE" code="0270"><p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref> if
 this <error.extra>the process of finding an <elcode>xsl:strip-space</elcode> or 
 <elcode>xsl:preserve-space</elcode> declaration to match an element in the source document</error.extra>
 leaves more than one match<phrase diff="add" at="X">, unless all the matched declarations are equivalent (that is,
 they are all <elcode>xsl:strip-space</elcode> or they are all <elcode>xsl:preserve-space</elcode>)</phrase>.  
 <error.action><phrase diff="chg" at="R">The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to select, from the matches that are left, the
one that occurs last in
 <termref def="dt-declaration-order">declaration order</termref>.</phrase>
 </error.action>
					</p></error>
				</p>

        <p diff="chg" at="X">If an element in a source document has a <termref def="dt-annotation">type annotation</termref> 
        that is a simple type or a complex type with
 simple content, then any whitespace text nodes among its children are preserved, regardless of
 any <elcode>xsl:strip-space</elcode> declarations. The reason for this 
 is that stripping a whitespace
 text node from an element with simple content could make the element invalid: for
 example, it could cause the <code>minLength</code> facet to be violated.</p>

<p>Stripping of <termref def="dt-annotation">type annotations</termref> happens before stripping of whitespace text nodes,
so this <phrase diff="chg" at="X">situation</phrase> 
will not occur if <code>input-type-annotations="strip"</code> is specified.</p>

				<note>
					
<p diff="add" at="Z">In <bibref ref="xpath-datamodel"/>, processes are described for constructing an
<phrase diff="chg" at="Z">XDM tree</phrase> from an Infoset or from a PSVI. Those processes
deal with whitespace according to their own rules, and the provisions in
this section apply to the resulting tree. In practice this means that
elements that are defined in a DTD or a Schema to contain element-only
content will have <termref def="dt-whitespace-text-node">whitespace text nodes</termref> stripped, regardless of the
<elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode> declarations in the stylesheet.</p>

<p>However, source trees are not necessarily constructed using those processes;
indeed, they are not necessarily constructed by parsing XML documents.
Nothing in the XSLT specification constrains how the source tree is
constructed, or what happens to <termref def="dt-whitespace-text-node">whitespace text nodes</termref> during its construction. The
provisions in this section relate only to whitespace text nodes that are
present in the tree supplied as input to the XSLT processor. The XSLT
processor cannot preserve whitespace text nodes unless they were actually
present in the supplied tree.</p>

				</note>
				
				
			</div2>
			
			<div2 id="id-in-data-model"><head>Attribute Types and DTD Validation</head>

      <p diff="add" at="V">The mapping from the Infoset to the <phrase diff="chg" at="Z">XDM</phrase> data model, described in 
      <bibref ref="xpath-datamodel"/>, does not retain attribute types. This means, for example, that an attribute
      described in the DTD as having attribute type <code>NMTOKENS</code> will be annotated in <phrase diff="chg" at="Z">the XDM tree</phrase>
      as <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase> rather than <code>xs:NMTOKENS</code>, and its typed value
      will consist of a single <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase> value rather than a sequence of 
      <code>xs:NMTOKEN</code> values.</p>

      <p diff="add" at="V">Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in the
      <phrase diff="chg" at="Z">XDM tree</phrase> as having the <code>is-id</code> or <code>is-idrefs</code> properties. It is these properties,
      rather than any <termref def="dt-annotation">type annotation</termref>, that are examined by the functions <xfunction>id</xfunction> and
      <xfunction>idref</xfunction> described in <bibref ref="xpath-functions"/>.</p>
			
			
			
			</div2>

<div2 id="limits" diff="add" at="Z"><head>Limits</head>

	<p>The XDM data model (see <bibref ref="xpath-datamodel"/>) leaves it to the host language to
	define limits. This section describes the limits that apply to XSLT.</p>

	<p>Limits on some primitive data types are defined in <bibref ref="xmlschema-2"/>.
	Other limits, listed below, are <termref def="dt-implementation-defined">implementation-defined</termref>.
	Note that this does not necessarily mean that each limit must be a simple constant: it may vary depending
	on environmental factors such as available resources.</p>

	<imp-def-feature>Limits on the value space of primitive data types, where not fixed 
	by <bibref ref="xmlschema-2"/>, are implementation-defined.</imp-def-feature>

    <p>The following limits are <termref def="dt-implementation-defined">implementation-defined</termref>:</p>

	<olist>
	<item><p>For the <code>xs:decimal</code> type, the maximum number of decimal digits 
(the <code>totalDigits</code> facet). This must be at least 18 digits. (Note, however, that
support for the full value range of <code>xs:unsignedLong</code> requires 20 digits.) </p></item>

<item><p>For the types <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>, <code>xs:gYear</code>, 
and <code>xs:gYearMonth</code>: the range of values of the year component, which must be
at least +0001 to +9999; and the maximum number of fractional second digits, which must be at least 3.</p></item>

<item><p>For the <code>xs:duration</code> type: the maximum absolute values of the 
years, months, days, hours, minutes, and seconds components. </p></item>

<item><p>For the <phrase diff="chg" at="ZA"><code>xs:yearMonthDuration</code></phrase> type: the maximum absolute value, 
expressed as an integer number of months.</p></item> 

<item><p>For the <phrase diff="chg" at="ZA"><code>xs:dayTimeDuration</code></phrase> type: the maximum absolute value, 
expressed as a decimal number of seconds.</p></item> 

<item><p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>, <code>xs:base64Binary</code>, <code>xs:QName</code>, 
<code>xs:anyURI</code>, <code>xs:NOTATION</code>, and types derived from them: the maximum length of the value. </p></item>

<item><p>For sequences, the maximum number of items in a sequence.</p></item>
</olist>
</div2>
		
<div2 id="d-o-e-in-data-model">
<head>Disable Output Escaping</head>

<p>For backwards compatibility reasons, XSLT 2.0 continues to
support the <code>disable-output-escaping</code> feature introduced in XSLT 1.0.
This is an optional feature and implementations are not <rfc2119>required</rfc2119> to support it.
A new facility, that of named <termref def="dt-character-map">character maps</termref>
(see <specref ref="character-maps"/>) is introduced in XSLT 2.0. It provides similar
capabilities to <code>disable-output-escaping</code>, but without distorting the
data model.</p>

<p>If an <termref def="dt-implementation">implementation</termref> supports 
the <code>disable-output-escaping</code> attribute
of <elcode>xsl:text</elcode> and <elcode>xsl:value-of</elcode>, 
 (see <specref ref="disable-output-escaping"/>), then the data model
for trees constructed by the <termref def="dt-processor">processor</termref> is augmented with a boolean value
representing the value of this property. <phrase diff="add" at="P">This boolean value, however, can be
set only within a <termref def="dt-final-result-tree">final result tree</termref> that is being passed to the serializer.</phrase></p>
				<p>Conceptually, each character in a text node on <phrase diff="add" at="P">such</phrase>
				a result tree has a boolean
property indicating whether the serializer <phrase diff="chg" at="R">is to</phrase> disable the normal rules
for escaping of special characters (for example, outputting of <code>&amp;</code>
as <code>&amp;amp;</code>) in respect of this character or attribute node.</p>
				
				<note>
					<p>In practice, the nodes in a <termref def="dt-final-result-tree">final result tree</termref> will often be streamed
					directly from the XSLT processor to the serializer. In such an implementation,
					<code>disable-output-escaping</code> can be viewed not so much a property stored with nodes
					in the tree, but rather as additional information passed across the interface between the
					XSLT processor and the serializer.</p>
				</note>
				
				
			</div2>

		</div1>
		<div1 id="constructs">
			<head>Features of the XSLT Language</head>
			<div2 id="qname">
				<head>Qualified Names</head>
				<p>The name of a stylesheet-defined object, specifically 
				a <termref def="dt-named-template">named template</termref>,
 a <termref def="dt-mode">mode</termref>,
 an <termref def="dt-attribute-set">attribute set</termref>, 
 a <termref def="dt-key">key</termref>,
a <termref def="dt-decimal-format">decimal-format</termref>,

 a <termref def="dt-variable">variable</termref> or <termref def="dt-parameter">parameter</termref>,
a <termref def="dt-stylesheet-function">stylesheet function</termref>, a
named <termref def="dt-output-definition">output definition</termref>,
<phrase diff="add" at="Q">or a <termref def="dt-character-map">character map</termref></phrase>
is specified as a <termref def="dt-qname">QName</termref> <phrase diff="add" at="R">using the syntax
for <xnt spec="Names" ref="NT-QName">QName</xnt> as defined in <bibref ref="REC-xml-names"/></phrase>.</p>
				<p>
					<termdef id="dt-qname" term="QName">A <term>QName</term> is
always written in the form <code>(NCName ":")? NCName</code>, that is, a local name
optionally preceded by a namespace prefix. When two QNames are compared, however,
they are considered equal if the corresponding
 <termref def="dt-expanded-qname">expanded-QNames</termref> are the same, as described below.</termdef>
				</p>
				
<p>Because an atomic value of type <code>xs:QName</code> is
sometimes referred to loosely as a QName, this specification also uses the term
<termref def="dt-lexical-qname">lexical QName</termref> to emphasize that it is referring
to a <xnt spec="Names" ref="NT-QName">QName</xnt> in its lexical form rather than its expanded form. 
This term is used
especially when strings containing lexical QNames are manipulated as run-time values.</p>

<p><termdef id="dt-lexical-qname" term="lexical QName">A <term>lexical QName</term> 
is a string representing a <termref def="dt-qname">QName</termref> in the form
<code>(NCName ":")? NCName</code>, that is, a local name
optionally preceded by a namespace prefix.</termdef></p>
				


				<p><termdef id="dt-defining-element" term="defining element"><phrase diff="chg" at="U">A
        string in the form of a lexical QName</phrase> may occur 
				as the value of an attribute node in a stylesheet
module, or within an XPath <termref def="dt-expression">expression</termref> contained in 
such an attribute node, or as the result
of evaluating an XPath expression contained in such an attribute node. 
The element
containing this attribute node is referred to as the <term>defining element</term> of the QName.</termdef></p>
				

				<p>
					<termdef id="dt-expanded-qname" term="expanded-QName">An
<term>expanded-QName</term> <phrase diff="add" at="U">contains a pair of values, 
namely a local name and an optional namespace URI. It may also contain a namespace prefix.</phrase>
Two expanded-QNames are equal if the namespace URIs are the same 
(or both absent) and the local names are the same. <phrase diff="add" at="U">The prefix plays
no part in the comparison, but is used only if the expanded-QName needs to be converted back
to a string.</phrase></termdef>
				</p>

				<p>If the QName has a prefix, then the
prefix is expanded into a URI reference using the namespace
declarations in effect on its <termref def="dt-defining-element">defining element</termref>.  The
<termref def="dt-expanded-qname">expanded-QName</termref>
consisting of the local part of the name and the possibly null URI
reference is used as the name of the object.  The default namespace of the defining element
(<phrase diff="chg" at="T">see <xspecref spec="DM" ref="ElementNode"/></phrase>) is
<emph>not</emph> used for unprefixed names.</p>

<p>There are <phrase diff="chg" at="Z">three</phrase> cases where the default namespace 
<phrase diff="chg" at="T">of the <termref def="dt-defining-element">defining element</termref></phrase>
 <emph>is</emph> used when expanding an unprefixed QName:</p>

<olist>
<item><p>Where a QName is used to define the name of an element 
being constructed. 
This applies both to cases where the name is known
statically (that is, the name of a literal result element) and to cases where it is
computed dynamically (the value of the <code>name</code> attribute
 of the <elcode>xsl:element</elcode> instruction).</p></item>

<item><p>The default namespace is used when expanding the first argument
of the function <function>element-available</function>.</p></item>

<item diff="add" at="Z"><p>The default namespace applies to any unqualified element names
appearing in the <code>cdata-section-elements</code> attribute of
<elcode>xsl:output</elcode> or <elcode>xsl:result-document</elcode></p></item>

</olist>

				<p>In the case of an unprefixed QName used as a
				 <code>NameTest</code> within an XPath <termref def="dt-expression">expression</termref>
(see <specref ref="expressions"/>) <phrase diff="add" at="O">, and in certain other contexts</phrase>, the namespace
to be used in expanding the QName may be specified by means of the 
<code diff="chg" at="O">[xsl:]xpath-default-namespace</code>
attribute, as specified in <specref ref="unprefixed-qnames"/>.</p>
				<p>
				

 				
					<error spec="XT" type="static" class="SE" code="0280"><p>In the case of a <phrase diff="add" at="R">prefixed</phrase> 
					<termref def="dt-qname">QName</termref> 
used as the value of an attribute in the
<termref def="dt-stylesheet">stylesheet</termref>, or appearing within 
 an XPath <termref def="dt-expression">expression</termref> in the stylesheet,
it is a <termref def="dt-static-error">static error</termref> if the <termref def="dt-defining-element">defining element</termref> has
no namespace node whose name matches the prefix of the <termref def="dt-qname">QName</termref>.</p></error>
				</p>

<p><error spec="XT" type="dynamic" class="DE" code="0290"><p>Where the result of evaluating an XPath expression (or an
attribute value template) is required to be a <termref def="dt-lexical-qname">lexical QName</termref>,
<phrase diff="add" at="R">then unless otherwise specified</phrase>
it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the <termref def="dt-defining-element">defining element</termref> has
no namespace node whose name matches the prefix of the <termref def="dt-lexical-qname">lexical QName</termref>. 
<phrase diff="chg" at="R">This error <rfc2119>may</rfc2119> be signaled as a
 <termref def="dt-static-error">static error</termref>
if the value of the expression can be determined statically.</phrase></p></error></p>
					
			
			</div2>

			<div2 id="unprefixed-qnames">
				<head>Unprefixed QNames in Expressions and Patterns</head>
				
				<p>The attribute <code diff="chg" at="O">[xsl:]xpath-default-namespace</code> 
(see <specref ref="standard-attributes"/>) may be used
on an element in the <termref def="dt-stylesheet">stylesheet</termref> to define the namespace that will be
used for an unprefixed element name <phrase diff="add" at="O">or type name</phrase>
 within an XPath expression, and in certain other contexts listed below.</p>
 
<p>The value of the attribute is the namespace URI to be used.</p>

<p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, this attribute has an effective value, which is the
value of the <code>[xsl:]xpath-default-namespace</code> on that element or on the innermost containing
element that specifies such an attribute, or the zero-length string if no containing element
specifies such an attribute.</p>

<p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, 
the effective value of this attribute determines 
the value of the <emph>default namespace for element and type names</emph> in the 
static context of any XPath expression contained in an attribute
of that element <phrase diff="add" at="ZA">(including XPath expressions in 
<termref def="dt-attribute-value-template">attribute value templates</termref>)</phrase>. 
The effect of this is specified in <bibref ref="xpath20"/>; in summary, it
determines the namespace used for any unprefixed type name in the SequenceType production, 
and for any element name appearing in a path expression or in the SequenceType production.</p>

<p>The effective value of this attribute similarly applies to <phrase diff="chg" at="R">any of
the following constructs appearing within its scope</phrase>:</p>

<ulist>
<item><p>any unprefixed element name or type name
used in a <termref def="dt-pattern">pattern</termref></p></item>
<item><p>any unprefixed element name 
used in the <code>elements</code> attribute of the <elcode>xsl:strip-space</elcode>
or <elcode>xsl:preserve-space</elcode> instructions</p></item> 
<item><p>any unprefixed element name or type name
used in the <code>as</code> attribute of an <termref def="dt-xslt-element">XSLT element</termref></p></item> 
<item><p>any unprefixed type name
used in the <code>type</code> attribute of an <termref def="dt-xslt-element">XSLT element</termref></p></item> 
<item diff="add" at="ZA"><p>any unprefixed type name
used in the <code>xsl:type</code> attribute of a 
<termref def="dt-literal-result-element">literal result element</termref>.</p></item> 
</ulist>




<p>The <code diff="chg" at="O">[xsl:]xpath-default-namespace</code> attribute <rfc2119>must</rfc2119> be in the
 <termref def="dt-xslt-namespace">XSLT namespace</termref> 
 if and only if its parent element is <emph>not</emph> in the XSLT namespace.</p>

<p>If the effective value of the attribute is a zero-length string,
which will be the case if it is explicitly set to a zero-length string or if it is
not specified at all, then an unprefixed element name or type name refers to a name
that is in no namespace. The default namespace 
<phrase diff="chg" at="T">of the parent element (see <xspecref spec="DM" ref="ElementNode"/>)</phrase> 
is <emph>not</emph> used.</p> 

<p diff="chg" at="ZA">The attribute does not affect other names, for example function names,
variable names, or template names, or strings that are interpreted as
<termref def="dt-lexical-qname">lexical QNames</termref> during stylesheet evaluation,
such as the <termref def="dt-effective-value">effective value</termref> of the <code>name</code>
attribute of <elcode>xsl:element</elcode> or the string supplied as the first argument to 
the <function>key</function> function.</p>
				
			</div2>

			<div2 id="expressions">
				<head>Expressions</head>
				<p>XSLT uses the expression language defined by XPath 2.0 <bibref ref="xpath20"/>.  
Expressions are used in XSLT for a variety of purposes including:</p>
				<ulist>
					<item><p>selecting nodes for processing;</p></item>
					<item><p>specifying conditions for different ways of processing a node;</p></item>
					<item><p>generating text to be inserted in a <termref def="dt-result-tree">result tree</termref>.</p></item>
				</ulist>
				<p diff="chg" at="M">
					<termdef id="dt-expression" term="expression">Within this specification, the term
<term>XPath expression</term>, or simply <term>expression</term>, means
a string that matches the production 
<phrase diff="chg" at="Q"><xnt spec="XP" ref="Expr">Expr</xnt></phrase>
defined in <bibref ref="xpath20"/>.</termdef>
				</p>
				
				<p>An XPath expression may occur as the value of certain attributes on
XSLT-defined elements, and also within curly brackets in
 <termref def="dt-attribute-value-template">attribute value
templates</termref>.</p>
			
<p>Except where 
<termref def="dt-forwards-compatible-behavior">forwards-compatible behavior</termref>
is enabled (see <specref ref="forwards"/>), it is a 
<termref def="dt-static-error">static error</termref>
if the value of such an 
attribute, <error.extra>an attribute defined as containing an XPath
 <termref def="dt-expression">expression</termref></error.extra> or the text between curly
brackets in an attribute value template, does not match the
XPath production <xnt spec="XP" ref="Expr">Expr</xnt>, or if it fails to satisfy
other static constraints defined in the XPath specification, for example
that all variable references <rfc2119>must</rfc2119> refer to <termref def="dt-variable">variables</termref> that are
in scope. <phrase diff="add" at="W">Error codes are defined in <bibref ref="xpath20"/>.</phrase></p>

				
<p>The transformation fails with a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if any XPath
  <termref def="dt-expression">expression</termref>
 is evaluated and raises a dynamic error. 
 <phrase diff="add" at="W">Error codes are defined in <bibref ref="xpath20"/>.</phrase></p>


					<p>The transformation fails with a 
<termref def="dt-type-error">type error</termref>
if an XPath <termref def="dt-expression">expression</termref> raises a type error, or if the result of evaluating
the XPath <termref def="dt-expression">expression</termref> is evaluated and raises a type error,
or if the XPath processor signals a type error during static analysis of an
 <termref def="dt-expression">expression</termref>.
 <phrase diff="add" at="W">Error codes are defined in <bibref ref="xpath20"/>.</phrase></p>

 			
				<p>
					<termdef id="dt-required-type" term="required type">The context within a <termref def="dt-stylesheet">stylesheet</termref>
where an XPath <termref def="dt-expression">expression</termref>
 <phrase diff="chg" at="M">appears may specify</phrase> the <term>required type</term> of
the expression. The required type indicates the type of the value that the
expression is expected to return.</termdef> If no required type is specified, the
expression may return any value: in effect, the required type is then <code>item()*</code>.
				</p>
<p><termdef id="dt-function-conversion-rules" term="function conversion rules">Except where otherwise indicated, the actual
value of an <termref def="dt-expression">expression</termref> is converted to the <termref def="dt-required-type">required type</termref>
using the <term>function conversion rules</term>. These are the rules defined in
<bibref ref="xpath20"/> for converting the supplied argument of a function call to the
required type of that argument, as defined in the function signature. The relevant
rules are those that apply when
 <termref def="dt-compatibility-mode">XPath 1.0 compatibility mode</termref> is set to <code>false</code>.</termdef></p>
 
<p>This specification also invokes the
 XPath 2.0 <termref def="dt-function-conversion-rules">function conversion rules</termref>
to convert the result of evaluating an XSLT <termref def="dt-sequence-constructor">sequence constructor</termref> to
a required type (for example, the sequence constructor enclosed in an <elcode>xsl:variable</elcode>, 
<elcode>xsl:template</elcode>, or <elcode>xsl:function</elcode> element).</p>

<p>Any <termref def="dt-dynamic-error">dynamic error</termref> or
<termref def="dt-type-error">type error</termref> that occurs when applying the 
<termref def="dt-function-conversion-rules">function conversion rules</termref> to
convert a value to a required type results in the transformation failing, in the
same way as if the error had occurred while evaluating an expression.</p>

<note><p>Note the distinction between the two kinds of error that may occur. Attempting to convert
an integer to a date is a type error, because such a conversion is never possible. Type errors can be reported
statically if they can be detected statically, whether or not the construct in question is ever evaluated.
Attempting to convert the string <code>2003-02-29</code> to a date is a dynamic error rather than a type error, 
because the problem is with this particular value, not with its type.
Dynamic errors are reported only if the instructions or expressions that cause them are actually evaluated.</p></note>

				

</div2>
<div2 id="static-and-dynamic-context" diff="chg" at="U">
<head>The Static and Dynamic Context</head>

<p>XPath defines the concept of an 
<xtermref spec="XP" ref="dt-expression-context">expression context</xtermref> which
contains all the information that can affect the result of evaluating an 
<termref def="dt-expression">expression</termref>. The expression context has
two parts, the <xtermref spec="XP" ref="dt-static-context">static context</xtermref>,
and the <xtermref spec="XP" ref="dt-dynamic-context">dynamic context</xtermref>.
The components that make up the expression context are defined in the XPath specification
(see <xspecref spec="XP" ref="context"/>). This section describes the way
in which these components are initialized when an XPath expression is contained within an
XSLT stylesheet.</p>

<p>As well as providing values for the static and dynamic context components defined in the
XPath specification, XSLT defines additional context components of its own. These context components
are used by XSLT instructions (for example, <elcode>xsl:next-match</elcode> and <elcode>xsl:apply-imports</elcode>),
and also by the functions in the extended function library described in this specification.</p>

<p>The following four sections describe:</p>

<slist>
<sitem><specref ref="static-context"/></sitem>
<sitem><specref ref="additional-static-context"/></sitem>
<sitem><specref ref="xpath-dynamic-context"/></sitem>
<sitem><specref ref="additional-dynamic-context"/></sitem>
</slist>



<div3 id="static-context"><head>Initializing the Static Context</head>

<p>The <xtermref spec="XP" ref="dt-static-context">static context</xtermref> of an XPath
expression appearing in an XSLT stylesheet is initialized as follows. In these rules,
the term <term>containing element</term> means the element within the stylesheet that is
the parent of the attribute whose value contains the XPath expression in question,
and the term <term>enclosing element</term> means the containing element or any of its ancestors.</p>

<ulist>
 <item>
    <p><termref def="dt-compatibility-mode">XPath 1.0 compatibility mode</termref>
     is set to true
    if and only if the containing element
    occurs in part of the <termref def="dt-stylesheet">stylesheet</termref> where
    <termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>
    is enabled (see <specref ref="backwards"/>).</p>
 </item>
	<item>
		<p>The <xtermref spec="XP" ref="dt-static-namespaces">statically known namespaces</xtermref> 
		are the namespace declarations that are in scope for the containing element.</p>
	</item>
	<item>
		<p>The <xtermref spec="XP" ref="dt-def-elemtype-ns">default element/type namespace</xtermref>
		is the namespace defined by the
<code>[xsl:]xpath-default-namespace</code> attribute on the innermost enclosing element
that has such an attribute, as described in
<specref ref="unprefixed-qnames"/>. The value of this attribute
is a namespace URI. <phrase diff="add" at="R">If there is no 
<code>[xsl:]xpath-default-namespace</code> attribute on an enclosing element,
the default namespace for element names and type names is the null namespace.</phrase></p>
	</item>
					<item>
						<p>The <xtermref spec="XP" ref="dt-def-fn-ns">default function namespace</xtermref> is the 
<termref def="dt-standard-function-namespace">standard function namespace</termref>,
defined in <bibref ref="xpath-functions"/>. This means that it is not necessary to declare this
namespace in the <termref def="dt-stylesheet">stylesheet</termref>, nor is it necessary 
to use the prefix <code>fn</code> (or any other prefix) in calls to the <termref def="dt-core-function">core functions</termref>.</p>
					</item>
					<item>
						<p>The <xtermref spec="XP" ref="dt-issd">in-scope schema definitions</xtermref>
for the XPath expression are the same as the 
<termref def="dt-in-scope-schema-component">in-scope schema components</termref> for the
 <termref def="dt-stylesheet">stylesheet</termref>, and are as specified in <specref ref="built-in-types"/>.</p>
						
						
					</item>
					<item>
						<p>The <xtermref spec="XP" ref="dt-in-scope-variables">in-scope variables</xtermref> are <phrase diff="add" at="R">defined by</phrase> the
						 <termref def="dt-variable-binding-element">variable binding elements</termref> that are in scope
for the containing element (see <specref ref="variables-and-parameters"/>).</p>
					</item>
					<item>
						<p>The <xtermref spec="XP" ref="dt-function-signature">function signatures</xtermref> are the <termref def="dt-core-function">core functions</termref> defined 
						in <bibref ref="xpath-functions"/>, 
            the constructor functions for all the atomic types in the
            <xtermref spec="XP" ref="dt-issd">in-scope schema definitions</xtermref>,
            the additional
functions defined in this specification, the <termref def="dt-stylesheet-function">stylesheet
functions</termref> defined in the stylesheet, plus any <termref def="dt-extension-function">extension
functions</termref> bound using <termref def="dt-implementation-defined">implementation-defined</termref> 
mechanisms (see <specref ref="extension"/>).</p>

<note><p>It follows from the above that a conformant XSLT processor must implement the
entire library of <termref def="dt-core-function">core functions</termref> defined in <bibref ref="xpath-functions"/>.</p></note>

							
					</item>
					<item>
						<p>The <xtermref spec="XP" ref="dt-static-collations">statically known collations</xtermref> are 
<termref def="dt-implementation-defined">implementation-defined</termref>.
<phrase diff="add" at="R">However, the set of in-scope collations <rfc2119>must</rfc2119> always include
the Unicode codepoint collation, defined in <xspecref spec="FO" ref="string-compare"/>.</phrase></p>
						
						
					</item>
<item>
<p>The <xtermref spec="XP" ref="dt-def-collation">default collation</xtermref> is 
defined by the value of the <code>[xsl:]default-collation</code> attribute on the innermost enclosing
element that has such an attribute. For details, see <specref ref="default-collation-attribute"/>.</p>


<p><termdef id="dt-default-collation" term="default collation">In 
this specification the term <term>default collation</term> means the collation that
is used by XPath operators such as <code>eq</code> and <code>lt</code> appearing in
XPath expressions within the stylesheet.</termdef></p>

<p>This collation is also used by default when comparing strings
in the evaluation of the <elcode>xsl:key</elcode> and <elcode>xsl:for-each-group</elcode>
elements. This <rfc2119>may</rfc2119> also
(but need not necessarily) be the same as the default collation used for <elcode>xsl:sort</elcode> elements
within the stylesheet. Collations used by <elcode>xsl:sort</elcode> are described in
<specref ref="collating-sequences"/>.</p> 
						
						
					</item>
					<item>
						<p>The <xtermref spec="XP" ref="dt-base-uri">base URI</xtermref> is the base URI of the containing element. The concept
						of the base URI of a node is defined in <xspecref spec="DM" ref="dm-base-uri"/></p>
					</item>


                </ulist> 
                
</div3>
<div3 id="additional-static-context">
<head>Additional Static Context Components used by XSLT</head>

<p>Some of the components of the XPath static context are used also by 
<termref def="dt-xslt-element">XSLT elements</termref>. For
example, the <elcode>xsl:sort</elcode> element makes use of the collations defined in the static
context, and attributes such as <code>type</code> and <code>as</code> may reference types defined
in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref>.</p>

<p>Many top-level declarations in a stylesheet, and attributes on the <elcode>xsl:stylesheet</elcode>
element, affect the behavior of instructions within the stylesheet. Each of these constructs is
described in its appropriate place in this specification.</p>

<p>A number of these constructs are of particular significance because they are
used by functions defined in XSLT, which are added to the library of functions available for use in
XPath expressions within the stylesheet. These are:</p>

<ulist>
<item><p>The set of named keys, used by the <function>key</function> function</p></item>
<item><p>The set of named decimal formats, used by the <function>format-number</function> function</p></item>
<item><p>The values of system properties, used by the <function>system-property</function> function</p></item>
<item><p>The set of available instructions, used by the <function>element-available</function> function</p></item>
</ulist>
</div3>

<div3 id="xpath-dynamic-context">
<head>Initializing the Dynamic Context</head>
<p>For convenience, the dynamic context is described in two parts: the
<termref def="dt-focus">focus</termref>, which represents the place in the source document that
is currently being processed, and a collection of additional context variables.</p>

<p diff="add" at="Z">A number of functions specified in <bibref ref="xpath-functions"/> 
are defined to be <xtermref spec="FO" ref="stable">stable</xtermref>, meaning that if they are called
twice during the same <xtermref spec="FO" ref="execution-scope">execution scope</xtermref>, 
with the same arguments, then they return the same results
(see <xspecref spec="FO" ref="terminology"/>). 
In XSLT, the execution of a stylesheet defines the execution scope.
This means, for example, that if the function <xfunction>current-dateTime</xfunction> is called repeatedly during
a transformation, it produces the same result each time. By implication, the components
of the dynamic context on which these functions depend are also stable for the duration
of the transformation. Specifically, the following components defined in <xspecref spec="XP" ref="eval_context"/>
<!--[XPath section 2.1.2]-->
must be stable: <emph>function implementations</emph>, <emph>current dateTime</emph>, <emph>implicit timezone</emph>,
<emph>available documents</emph>, <emph>available collections</emph>, and <emph>default collection</emph>.
The values of global variables and stylesheet parameters are also stable
for the duration of a transformation. The focus is <emph>not</emph> stable; 
the additional dynamic context components defined in <specref ref="additional-dynamic-context"/> 
are also <emph>not</emph> stable.</p>

<p diff="add" at="ZA">As specified in <bibref ref="xpath-functions"/>, implementations may provide user options that relax the
requirement for the <xfunction>doc</xfunction> and <xfunction>collection</xfunction> functions 
(and therefore, by implication,
the <function>document</function> function) to return stable results. By default, however, the
functions must be stable. The manner in which such user options are provided, if
at all, is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>	

<p diff="add" at="ZA">XPath expressions contained in <code>[xsl:]use-when</code>
 attributes are not considered to be evaluated "during the
transformation" as defined above. For details see <specref ref="conditional-inclusion"/>.</p>
			
			<div4 id="focus">
				<head>Maintaining Position: the Focus</head>
				<p>
					<termdef id="dt-focus" term="focus">When a
 <termref def="dt-sequence-constructor">sequence constructor</termref> is
 evaluated, the <termref def="dt-processor">processor</termref> keeps track of which 
 items are being processed 
 by means of a set of implicit variables referred to collectively as the
  <term>focus</term>.</termdef>
 More specifically, the focus consists of the following three values:</p>
				<ulist>
					<item>
						<p>
							<termdef id="dt-context-item" term="context item">The <term>context item</term> is the item currently
 being processed. An item (see <bibref ref="xpath-datamodel"/>) is either an atomic value (such as an
 integer, date, or string), or a node. The context item is initially set to the
  <termref def="dt-initial-context-node">initial context node</termref>
  supplied when the transformation is invoked (see <specref ref="initiating"/>).
 It changes
 whenever instructions such as <elcode>xsl:apply-templates</elcode> and <elcode>xsl:for-each</elcode>
 are used to process a sequence of items; each item in such a sequence becomes the context item
 while that item is being processed.</termdef> The context item is returned by the XPath 
 <termref def="dt-expression">expression</termref> <code>.</code> (dot).</p>
 
					</item>
					<item>
						<p>
							<termdef id="dt-context-position" term="context position">The <term>context position</term> is the position of
the context item within the sequence of items currently being processed. It changes whenever the
context item changes. When an instruction such as <elcode>xsl:apply-templates</elcode> or
 <elcode>xsl:for-each</elcode> is used to process
a sequence of items, the first item in the sequence is processed with a context position of 1, the
second item with a context position of 2, and so on.</termdef> The context position is returned
by the XPath <termref def="dt-expression">expression</termref> <code>position()</code>.</p>
					</item>
					<item>
						<p>
							<termdef id="dt-context-size" term="context size">The <term>context size</term> is the number of items in
the sequence of items currently being processed. It changes
 whenever instructions such as <elcode>xsl:apply-templates</elcode> and <elcode>xsl:for-each</elcode>
 are used to process a sequence of items; during the processing of each one of those items, the
 context size is set to the count of the number of items in the sequence (or equivalently, the position
 of the last item in the sequence).</termdef> The context size is returned
by the XPath <termref def="dt-expression">expression</termref> <code>last()</code>.</p>
					</item>
				</ulist>
				<p>
					<termdef id="dt-context-node" term="context node">If the <termref def="dt-context-item">context item</termref>
 is a node (as distinct
from an atomic value such as an integer), then it is also referred to as the <term>context node</term>.
The context node is not an independent variable, it changes whenever the context item changes. When
the context item is an atomic value, there is no context
 node.</termdef>
The context node is returned by the XPath <termref def="dt-expression">expression</termref> <code>self::node()</code>, and it is used
as the starting node for all relative path expressions.</p>

<p>Where the containing element of an XPath expression is an
 <termref def="dt-instruction">instruction</termref>
or a <termref def="dt-literal-result-element">literal result element</termref>, 
the initial context item, context position, and context size 
for the XPath <termref def="dt-expression">expression</termref> are the same as
the <termref def="dt-context-item">context item</termref>,
<termref def="dt-context-position">context position</termref>, and
<termref def="dt-context-size">context size</termref> for the 
evaluation of the containing instruction or literal result element.</p>

<p>In other cases (for example, where the containing element is <elcode>xsl:sort</elcode>,
<elcode>xsl:with-param</elcode>, or <elcode>xsl:key</elcode>), 
the rules are given in the specification of the containing element.</p>


				<p>The <function>current</function> function can be used within any XPath <termref def="dt-expression">expression</termref>
to select the item that was supplied as the context item to the XPath expression by the XSLT processor.
Unlike <code>.</code> (dot) this is unaffected by changes to the context item that occur within
the XPath expression. The <function>current</function> function is described in
 <specref ref="current-function"/>.</p>
				<p>On completion of an instruction that changes the <termref def="dt-focus">focus</termref>
 (such as <elcode>xsl:apply-templates</elcode> or
 <elcode>xsl:for-each</elcode>), the focus reverts to its previous value.</p>
				<p>When a <termref def="dt-stylesheet-function">stylesheet function</termref> is called,
the focus within the body of the function is initially undefined. <phrase diff="add" at="O">The focus
is also undefined on initial entry to the <termref def="dt-stylesheet">stylesheet</termref> if no <termref def="dt-initial-context-node">initial context node</termref>
is supplied.</phrase></p>
<p>When the focus is
undefined, evaluation of any <termref def="dt-expression">expression</termref> that 
references the context item, context position, or context size results
in a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> 
<!--<xerrorref spec="XP" class="DY" code="0002"/>--> [XPDY0002]
				</p>
				<p>The description above gives an outline of the way the
 <termref def="dt-focus">focus</termref> works. Detailed rules for the effect
of each instruction are given separately with the description of that instruction. In the absence
of specific rules, an instruction uses the same focus as its parent instruction.</p>

<p><termdef id="dt-singleton-focus" term="singleton focus">A <term>singleton focus</term> 
based on a node <var>N</var>
has the <termref def="dt-context-item">context item</termref> (and therefore the 
<termref def="dt-context-node">context node</termref>) set to <var>N</var>, 
and the <termref def="dt-context-position">context position</termref>
and <termref def="dt-context-size">context size</termref> both set to 1 (one).</termdef>
				</p>			
				</div4>
        <div4 id="evaluation-context">
        <head>Other components of the XPath Dynamic Context</head>
			
				
<p>The previous section explained how the <termref def="dt-focus">focus</termref> for an XPath
expression appearing in an XSLT stylesheet is initialized. 
This section explains how the other components of the 
<xtermref spec="XP" ref="dt-dynamic-context">dynamic context</xtermref> of an XPath
expression are initialized.</p>

<ulist>

<item>
	<p>The <xtermref spec="XP" ref="dt-variable-values">dynamic variables</xtermref> are the current values of the in-scope 
	<termref def="dt-variable-binding-element">variable binding elements</termref>.</p>
</item>

<item diff="add" at="R">
    <p>The <emph>current date and time</emph> represents an 
    <termref def="dt-implementation-dependent">implementation-dependent</termref> point in time 
    during processing of the transformation; it does not change during the course of the transformation.</p>
</item>

<item diff="add" at="R">
    <p>The <xtermref spec="XP" ref="dt-timezone">implicit timezone</xtermref> is 
    <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
    <imp-def-feature>The implicit timezone for a transformation is implementation-defined.</imp-def-feature>
</item>

<item>
    <p diff="chg" at="U">The <xtermref spec="XP" ref="dt-known-docs">available documents</xtermref>, 
    and the <xtermref spec="XP" ref="dt-known-collections">available collections</xtermref>
    are determined as part of the process for initiating a transformation (see <specref ref="initiating"/>).</p>
    
    <p>The <xtermref spec="XP" ref="dt-known-docs">available documents</xtermref>
     are defined as part of the XPath 2.0 dynamic context to support
    the <xfunction>doc</xfunction> function, but this component is also referenced by the similar XSLT 
    <function>document</function> function: see <specref ref="document"/>. This variable defines
    a mapping between URIs passed to the <xfunction>doc</xfunction> or <function>document</function> 
    function and the document nodes that are returned.</p>
    
    <note><p>Defining this as part of the evaluation context is a formal way of
    specifying that the way in which URIs get turned into document nodes is outside the control of the
    language specification, and depends entirely on the run-time environment in which the transformation
     takes place.</p></note>
     
     <p>The XSLT-defined <function>document</function> function
     allows the use of URI references containing fragment identifiers. 
     The interpretation of a fragment identifier
     depends on the media type of the resource representation. 
     Therefore, the information supplied in 
     <xtermref spec="XP" ref="dt-known-docs">available documents</xtermref> for XSLT processing
     must provide not only a mapping from URIs to document nodes as required by XPath, but also a mapping
     from URIs to media types.</p></item>

     <item diff="add" at="W"><p>The <xtermref spec="XP" ref="dt-default-collection">default collection</xtermref>
     is <termref def="dt-implementation-defined">implementation-defined</termref>. This allows options such
     as setting the default collection to be an empty sequence, or to be undefined.</p></item>

				</ulist>
        </div4>
				</div3>

				<div3 id="additional-dynamic-context">
				<head>Additional Dynamic Context Components used by XSLT</head>
				
				
				<p>In addition to the values that make up the <termref def="dt-focus">focus</termref>,
an XSLT processor maintains a number of other dynamic context components that reflect aspects of the evaluation
context. These components are fully described in the sections of the specification that maintain and use them.
They are:</p>
				<ulist>
					<item>
						<p>The <termref def="dt-current-template-rule">current template rule</termref>, which is the
 <termref def="dt-template-rule">template rule</termref>
most recently invoked by an <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
or <elcode>xsl:next-match</elcode> instruction: see <specref ref="apply-imports"/>;
</p></item>

<item><p diff="chg" at="Z">The <termref def="dt-current-mode">current mode</termref>, which is the
 <termref def="dt-mode">mode</termref>
set by the most recent call of <elcode>xsl:apply-templates</elcode> 
(for a full definition see <specref ref="modes"/>);</p></item>

<item><p>The <termref def="dt-current-group">current group</termref>
and <termref def="dt-current-grouping-key">current grouping key</termref>, 
which provide information about the collection of items currently being processed
by an <elcode>xsl:for-each-group</elcode> instruction: see <specref ref="current-group"/>
and <specref ref="current-grouping-key"/>;</p></item>

<item><p>The <termref def="dt-current-captured-substrings">current captured substrings</termref>: 
this is a sequence of strings, which is maintained when a string
is matched against a regular expression using the <elcode>xsl:analyze-string</elcode> instruction,
and which is accessible using the <function>regex-group</function> function: 
see <specref ref="regex-group"/>.</p></item>

<item><p>The <termref def="dt-output-state">output state</termref>: this is a flag whose two possible
values are <termref def="dt-final-output-state">final output state</termref> and
<termref def="dt-temporary-output-state">temporary output state</termref>. This flag indicates whether
instructions are currently writing to a <termref def="dt-final-result-tree">final result tree</termref>
 or to an internal data structure. The
initial setting is <termref def="dt-final-output-state">final output state</termref>, and it is switched
to <termref def="dt-temporary-output-state">temporary output state</termref> by instructions such as
<elcode>xsl:variable</elcode>. For more details, see <specref ref="creating-result-trees"/>.</p></item>

</ulist>

<p>The following non-normative table summarizes the initial state of each
 of the components in the
evaluation context, and the instructions which cause the state of the component to change.</p>

<table border="1" cellpadding="5">
<thead>
<tr><th align="left">Component</th>
<th align="left">Initial Setting</th>
<th align="left">Set by</th>
<th align="left">Cleared by</th></tr>
</thead>
<tbody>
<tr>
<td valign="top"><termref def="dt-focus">focus</termref></td>
<td valign="top">singleton focus based on the 
<termref def="dt-initial-context-node">initial context node</termref> if supplied</td>
<td valign="top"><elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
<elcode>xsl:for-each-group</elcode>, <elcode>xsl:analyze-string</elcode></td>
<td valign="top">calls on <termref def="dt-stylesheet-function">stylesheet functions</termref></td>
</tr>

<tr>
<td valign="top"><termref def="dt-current-template-rule">current template rule</termref></td>
<td valign="top"><phrase diff="chg" at="Z">If a 
<termref def="dt-named-template">named template</termref> is supplied as the entry point
to the transformation, then null; otherwise the
 <termref def="dt-initial-template">initial template</termref></phrase></td>
<td valign="top"><elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
<elcode>xsl:next-match</elcode></td>
<td valign="top"><elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>, and
<phrase diff="chg" at="Z"><elcode>xsl:analyze-string</elcode></phrase>,
and calls on <termref def="dt-stylesheet-function">stylesheet functions</termref>. Also cleared while
evaluating global variables or default values of stylesheet parameters, and the sequence constructors
contained in <elcode>xsl:key</elcode> and <elcode>xsl:sort</elcode>.</td>
</tr>

<tr>
<td valign="top"><termref def="dt-current-mode">current mode</termref></td>
<td valign="top">the initial <termref def="dt-mode">mode</termref></td>
<td valign="top"><elcode>xsl:apply-templates</elcode></td>
<td valign="top">calls on <termref def="dt-stylesheet-function">stylesheet functions</termref></td>
</tr>

<tr>
<td valign="top"><termref def="dt-current-group">current group</termref></td>
<td valign="top">empty sequence</td>
<td valign="top"><elcode>xsl:for-each-group</elcode></td>
<td valign="top">calls on <termref def="dt-stylesheet-function">stylesheet functions</termref></td>
</tr>

<tr>
<td valign="top"><termref def="dt-current-grouping-key">current grouping key</termref></td>
<td valign="top">empty sequence</td>
<td valign="top"><elcode>xsl:for-each-group</elcode></td>
<td valign="top">calls on <termref def="dt-stylesheet-function">stylesheet functions</termref></td>
</tr>

<tr>
<td valign="top"><termref def="dt-current-captured-substrings">current captured substrings</termref></td>
<td valign="top">empty sequence</td>
<td valign="top"><elcode>xsl:matching-substring</elcode></td>
<td valign="top"><elcode>xsl:non-matching-substring</elcode>; 
calls on <termref def="dt-stylesheet-function">stylesheet functions</termref></td>
</tr>

<tr>
<td valign="top"><termref def="dt-output-state">output state</termref></td>
<td valign="top"><termref def="dt-final-output-state">final output state</termref></td>
<td valign="top">Set to <termref def="dt-temporary-output-state">temporary output state</termref> by instructions
such as <elcode>xsl:variable</elcode>, <elcode>xsl:attribute</elcode>, etc., and by
calls on <termref def="dt-stylesheet-function">stylesheet functions</termref></td>
<td valign="top">None</td>
</tr>
</tbody>
</table>


</div3>




			</div2>
			<div2 id="patterns">
				<head>Patterns</head>
				<p>A <termref def="dt-template-rule">template rule</termref> identifies the
nodes to which it applies by means of a pattern.  As well as
being used in template rules, patterns are used for numbering (see
<specref ref="number"/>), for grouping (see
<specref ref="grouping"/>), 
 and for declaring <termref def="key">keys</termref> (see <specref ref="key"/>).</p>
				<p>
					<termdef id="dt-pattern" term="pattern">A <term>pattern</term> specifies
 a set of conditions on a node. A
node that satisfies the conditions matches the pattern; a node that
does not satisfy the conditions does not match the pattern.  The
syntax for patterns is a subset of the syntax for <termref def="dt-expression">expressions</termref>.</termdef> 
As explained in detail below, a node matches a pattern
 if the node can be selected by <phrase diff="add" at="Q">deriving an equivalent expression, and</phrase>
 evaluating this expression with
respect to some possible context.</p>

<div3 id="pattern-examples"><head>Examples of Patterns</head>

				<example><head>Patterns</head>
					<p>Here are some examples of patterns:</p>
					<ulist>
						<item>
							<p>
								<code>para</code> matches any <code>para</code> element.</p>
						</item>
						<item>
							<p>
								<code>*</code> matches any element.</p>
						</item>
						<item>
							<p>
								<code>chapter|appendix</code> matches any
<code>chapter</code> element and any <code>appendix</code>
element.</p>
						</item>
						<item>
							<p>
								<code>olist/entry</code> matches any <code>entry</code> element with
an <code>olist</code> parent.</p>
						</item>
						<item>
							<p>
								<code>appendix//para</code> matches any <code>para</code> element with
an <code>appendix</code> ancestor element.</p>
						</item>
						<item><p>
						    <code diff="chg" at="T">schema-element(us:address)</code> matches any element that is annotated as
						     an instance of the
						    type defined by the schema element declaration <code>us:address</code>,
						    and whose name is either <code>us:address</code> or the name of another element
						    in its substitution group.
						    </p></item>
						<item><p>
						    <code>attribute(*, xs:date)</code> matches any attribute 
						    annotated as being of type <code>xs:date</code>.</p></item>						    
						<item>
							<p>
								<code>/</code> matches a document node.</p>
						</item>
						<item>
						    <p>
						    <code>document-node()</code> matches a document node.</p>
						</item>
						<item>
						    <p>
						    <code diff="chg" at="T">document-node(schema-element(my:invoice))</code> matches the document node 
						    of a document whose document element <phrase diff="chg" at="T">is named 
                <code>my:invoice</code> and matches the type defined by the global
						    element declaration</phrase> <code>my:invoice</code>.</p>
						</item>
						<item>
							<p>
								<code>text()</code> matches any text node.</p>
						</item>
						<item>
							<p>
								<code>node()</code> matches any node other than an attribute
node, namespace node, or document node.</p>
						</item>
						<item>
							<p>
								<code>id("W33")</code> matches the element with unique ID <code>W33</code>.
							</p>
						</item>
						<item>
							<p>
								<code>para[1]</code> matches any <code>para</code> element
that is the first <code>para</code> child element of its
parent. <phrase diff="add" at="Q">It also matches a parentless <code>para</code> element.</phrase></p>
						</item>
						<item>
							<p>
								<code>//para</code> matches any <code>para</code> element
that has a parent node.</p>
						</item>						
						<item>
							<p>
								<code>bullet[position() mod 2 = 0]</code> matches any
<code>bullet</code> element that is an even-numbered <code>bullet</code>
child of its parent.</p>
						</item>
						<item>
							<p>
								<code>div[@class="appendix"]//p</code> matches any
<code>p</code> element with a <code>div</code> ancestor element that
has a <code>class</code> attribute with value
<code>appendix</code>.
							</p>
						</item>
						<item>
							<p>
								<code>@class</code> matches any <code>class</code> attribute
(<emph>not</emph> any element that has a <code>class</code>
attribute).</p>
						</item>
						<item>
							<p>
								<code>@*</code> matches any attribute node.</p>
						</item>
					</ulist>
				</example>

</div3>
<div3 id="pattern-syntax"><head>Syntax of Patterns</head>

				<p>
					<error spec="XT" type="static" class="SE" code="0340"><p>Where an attribute is
defined to contain a <termref def="dt-pattern">pattern</termref>,
it is a <termref def="dt-static-error">static error</termref> if the
 pattern does not match the production <nt def="NT-Pattern">Pattern</nt>.</p></error>
  Every pattern is a legal XPath
<termref def="dt-expression">expression</termref>, but the converse is not true: <code>2+2</code>
is an example of a legal XPath expression that is not a pattern.
The XPath expressions that can be used as patterns are those that
match the grammar for <nt def="NT-Pattern">Pattern</nt>, given below.</p>
				<p>Informally, a <nt def="NT-Pattern">Pattern</nt> is
a set of path expressions separated by <code>|</code>, 
where each step
in the path expression is constrained to be an <xnt spec="XP" ref="AxisStep">AxisStep</xnt> that uses only the
<code>child</code> or <code>attribute</code> axes.  Patterns may
also use the <code>//</code> operator.
A <xnt ref="Predicate" spec="XP">Predicate</xnt> within the <xnt spec="XP" ref="PredicateList">PredicateList</xnt> 
in a pattern 
can contain arbitrary XPath expressions (enclosed between square brackets) 
in the same way as a <xnt spec="XP" ref="Predicate">predicate</xnt> in a path expression.</p>

<p>Patterns may start with an
<xfunction>id</xfunction> or <function>key</function> function call,
provided that the value to be matched is supplied as either a literal or a reference to
a <termref def="dt-variable">variable</termref> or <termref def="dt-parameter">parameter</termref>, 
and the key name (in the case of the <function>key</function> function)
is supplied as a string literal. <phrase diff="chg" at="O">These patterns will
never match a node in a tree whose root is not a document node.</phrase></p>


				<p>If a pattern occurs in part of the <termref def="dt-stylesheet">stylesheet</termref> where
<termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>
is enabled (see <specref ref="backwards"/>), then 
<phrase diff="chg" at="O">the semantics of the pattern are defined on the basis that the equivalent
XPath expression is evaluated with 
<termref def="dt-compatibility-mode">XPath 1.0 compatibility mode</termref> set to true.</phrase></p>

				<scrap headstyle="show">
					<head>Patterns</head>
					<prodgroup pcw5="1" pcw2="10">
						<prod id="NT-Pattern">
							<lhs>Pattern</lhs>
							<rhs>
								<nt def="NT-PathPattern">PathPattern</nt>
							</rhs>
							<rhs>| <nt def="NT-Pattern">Pattern</nt> '|' <nt def="NT-PathPattern">PathPattern</nt>
							</rhs>
						</prod>
						<prod id="NT-PathPattern">
							<lhs>PathPattern</lhs>
							<rhs>
								<nt def="NT-RelativePathPattern">RelativePathPattern</nt>
							</rhs>
							<rhs>| '/' <nt def="NT-RelativePathPattern">RelativePathPattern</nt>?</rhs>
							<rhs>| '//' <nt def="NT-RelativePathPattern">RelativePathPattern</nt>
							</rhs>
							<rhs>| <nt def="NT-IdKeyPattern">IdKeyPattern</nt> (('/' | '//') <nt def="NT-RelativePathPattern">RelativePathPattern</nt>)?</rhs>
						</prod>
						<prod id="NT-RelativePathPattern">
							<lhs>RelativePathPattern</lhs>
							<rhs>
								<nt def="NT-PatternStep">PatternStep</nt> (('/' | '//') <nt def="NT-RelativePathPattern">RelativePathPattern</nt>)?</rhs>
						</prod>
						<prod id="NT-PatternStep">
							<lhs>PatternStep</lhs>
							<rhs>
								<nt def="NT-PatternAxis">PatternAxis</nt>? <xnt spec="XP" ref="NodeTest">NodeTest</xnt> <xnt spec="XP" ref="PredicateList">PredicateList</xnt></rhs>
						</prod>
						<prod id="NT-PatternAxis">
							<lhs>PatternAxis</lhs>
							<rhs>('child' '::' | 'attribute' '::' | '@') </rhs>
						</prod>
						<prod id="NT-IdKeyPattern">
							<lhs>IdKeyPattern</lhs>
							<rhs>'id' '(' <nt def="NT-IdValue">IdValue</nt> ')'</rhs>
							<rhs>| 'key' '(' <xnt spec="XP" ref="StringLiteral">StringLiteral</xnt> ',' <nt def="NT-KeyValue">KeyValue</nt> ')'</rhs>
						</prod>
						<prod id="NT-IdValue">
							<lhs>IdValue</lhs>
							<rhs>
								<xnt spec="XP" ref="StringLiteral">StringLiteral</xnt> | <xnt spec="XP" ref="VarRef">VarRef</xnt>
							</rhs>
						</prod>
						<prod id="NT-KeyValue">
							<lhs>KeyValue</lhs>
							<rhs>
								<xnt spec="XP" ref="Literal">Literal</xnt> | <xnt spec="XP" ref="VarRef">VarRef</xnt>
							</rhs>
					    </prod>
				
					</prodgroup>
				</scrap>
				<p>The constructs <xnt spec="XP" ref="NodeTest">NodeTest</xnt>, 
				<xnt spec="XP" ref="PredicateList">PredicateList</xnt>,
				<xnt spec="XP" ref="VarRef">VarRef</xnt>,  
<xnt spec="XP" ref="Literal">Literal</xnt>, and
<xnt spec="XP" ref="StringLiteral">StringLiteral</xnt> are part of the XPath expression
language, and are defined in <bibref ref="xpath20"/>.</p>

</div3>
<div3 id="pattern-semantics"><head>The Meaning of a Pattern</head>

<p>The meaning of a pattern is defined formally as follows.</p>

<p>First we define the concept of an <emph>equivalent expression</emph>. In general,
the equivalent expression is the XPath expression that takes the same lexical form as the pattern as written.
However, if the pattern contains a <code>PathPattern</code> that is a <code>RelativePathPattern</code>, then
the first <code>PatternStep</code> <var>PS</var> of this <code>RelativePathPattern</code> is adjusted to allow it to match
a parentless element or attribute node, as follows:</p>

<ulist diff="chg" at="R">
<item><p>If the <code>NodeTest</code> in <var>PS</var> is <code>document-node()</code> (optionally
with arguments), and if no explicit axis is specified, then the axis in step
 <var>PS</var> is taken as <code>self</code> rather than <code>child</code>.</p></item>

<item><p>If <var>PS</var> uses the child axis (explicitly or 
implicitly), and if the <code>NodeTest</code> in <var>PS</var> is not <code>document-node()</code> (optionally
with arguments),
then the axis in step <var>PS</var> is replaced by <code>child-or-top</code>, which is defined as follows.
If the context node is a parentless element, comment, processing-instruction, or text node
then the <code>child-or-top</code> axis selects the context node; otherwise it selects the children of
the context node. It is a forwards axis whose principal node kind is element.</p></item>

<item><p>If <var>PS</var> uses the attribute axis, 
then the axis in step <var>PS</var> is replaced by <code>attribute-or-top</code>, which is defined as follows.
If the context node is an attribute node with no parent,
then the <code>attribute-or-top</code> axis selects the context node; otherwise it selects the attributes of
the context node. It is a forwards axis whose principal node kind is attribute.

</p></item>

</ulist>

<p>The axes <code>child-or-top</code>  and <code>attribute-or-top</code> are introduced
only for definitional purposes. They cannot be used explicitly in a user-written pattern or expression.</p>


<note><p>The purpose of these adjustments is to ensure that a pattern such as <code>person</code> matches any
element named <code>person</code>, even if it has no parent; and similarly, that the pattern <code>@width</code>
matches any attribute named <code>width</code>, even a parentless attribute. The rule also ensures that
a pattern using a <code>NodeTest</code> of the form <code>document-node(...)</code> matches a document node.
The pattern <code>node()</code> will
match any element, text node, comment, or processing instruction, whether or not it has a parent.
For backwards compatibility reasons, the pattern <code>node()</code>, when used without an explicit axis,
 does not match document nodes, attribute nodes, or namespace nodes. The rules are also phrased to ensure
 that positional patterns of the form <code>para[1]</code> continue to count nodes relative to their parent,
 if they have one.</p></note>
 
<p>Let the equivalent expression, calculated according to these rules, be <var>EE</var>.</p>

<p>To determine whether a node <var>N</var> matches the pattern, 
evaluate the <termref def="dt-expression">expression</termref>
<code diff="chg" at="R">root(.)//(<var>EE</var>)</code> with a 
<termref def="dt-singleton-focus">singleton focus</termref> based on <var>N</var>.
If the result is a sequence of nodes that includes <var>N</var>, then node <var>N</var>
matches the pattern; otherwise node <var>N</var> does not match the pattern.</p>




				<example><head>The Semantics of Patterns</head>
					<p>The pattern <code>p</code> matches any <code>p</code> element,
because a <code>p</code> element will always be present in the result
of evaluating the <termref def="dt-expression">expression</termref> 
<code diff="chg" at="R">root(.)//(child-or-top::p)</code>. Similarly, <code>/</code>
matches <phrase diff="chg" at="R">a document node, and only a document node,</phrase>
because the result of the 
<termref def="dt-expression">expression</termref> <code>root(.)//(/)</code>
returns the root node of the tree containing the context node <phrase diff="add" at="R">if and
only if it is a document node.</phrase></p>
				

				<p>The pattern <code>node()</code> matches all nodes selected by the expression
<code diff="chg" at="R">root(.)//(child-or-top::node())</code>, that is, all element, text, comment, and processing
instruction nodes, whether or not they have a parent. It does not match attribute or namespace nodes because the 
expression does not select nodes using the attribute or namespace axes.
<phrase diff="add" at="Q">It does not match document nodes 
because for backwards compatibility reasons the <code>child-or-top</code> axis does not
match a document node.</phrase></p>	

</example>			
	
				
					<p>Although the semantics of patterns are specified formally in
terms of expression evaluation, it is possible to understand pattern
matching using a different model.  In a pattern, <code>|</code> indicates alternatives; a
pattern with one or more <code>|</code> separated alternatives matches
if any one of the alternatives matches.  A pattern such as <code>book/chapter/section</code>
can be examined from right to left. A node will only match this pattern
 if it is a <code>section</code> element;
and then, only if its parent is a <code>chapter</code>; and then, only
if the parent of that <code>chapter</code> is a <code>book</code>. When the
pattern uses the <code>//</code> operator, one can still read it from right to
left, but this time testing the ancestors of a node rather than its parent.
For example <code>appendix//section</code> matches every <code>section</code>
element that has an ancestor <code>appendix</code> element.</p>
					<p>The formal definition, however, is useful for understanding the meaning
of a pattern such as <code>para[1]</code>. This matches any node selected
by the expression <code diff="chg" at="R">root(.)//(child-or-top::para[1])</code>: that is, any <code>para</code>
element that is the first <code>para</code> child of its parent, <phrase diff="add" at="Q"> or a
<code>para</code> element that has no parent.</phrase></p>


				<note>
					<p>An implementation, of course, may use any
algorithm it wishes for evaluating patterns, so long as the result corresponds
with the formal definition above. An implementation that followed the formal
definition by evaluating the equivalent expression and then testing the membership of
a specific node in the result would probably be very inefficient.</p>
				</note>
</div3>			



<div3 id="pattern-errors"><head>Errors in Patterns</head>

<p diff="add" at="U">Any <termref def="dt-dynamic-error">dynamic error</termref> or 
<termref def="dt-type-error">type error</termref> that occurs during the evaluation
of a <termref def="dt-pattern">pattern</termref> against a particular node is treated as a 
<termref def="dt-recoverable-error">recoverable error</termref> even if the error
would not be recoverable under other circumstances. The 
<termref def="dt-optional-recovery-action">optional recovery action</termref> is to treat
the pattern as not matching that node.</p>

<note diff="add" at="U"><p>The reason for this provision is that it is difficult for the stylesheet
author to predict which predicates in a pattern will actually be evaluated. In the case of
match patterns in template rules, it is not even possible to predict which patterns will be evaluated
against a particular node. Making errors in patterns recoverable enables an implementation,
if it chooses to do so, to report such errors while stylesheets are under development, while 
masking them if they occur during production running.</p></note> 

<p>One particular optimization is <rfc2119>required</rfc2119> by this specification: for a
<nt def="NT-PathPattern">PathPattern</nt> that starts with <code>/</code> or <code>//</code> or with an 
<nt def="NT-IdKeyPattern">IdKeyPattern</nt>,
the result of testing this pattern against a node in a tree whose root is not a document node
must be a non-match, rather than a dynamic error. This rule applies 
to each <nt def="NT-PathPattern">PathPattern</nt> within a <nt def="NT-Pattern">Pattern</nt>.</p>				
				
<note><p>Without the above rule, any attempt to apply templates to a parentless element
node would create the risk of a dynamic error if the stylesheet has a template rule specifying
 <code>match="/"</code>.</p></note>				
				

</div3>
</div2>

			
			<div2 id="attribute-value-templates">
				<head>Attribute Value Templates</head>
				<p>
					<termdef id="dt-attribute-value-template" term="attribute value template">In an 
attribute that is designated as an
<term>attribute value template</term>, such as an attribute of a
<termref def="dt-literal-result-element">literal result element</termref>, 
an <termref def="dt-expression">expression</termref> can be used by surrounding
the expression with curly brackets (<code>{}</code>)</termdef>.</p>
				<p>An attribute value template consists of an alternating
sequence of fixed parts and variable parts. A variable part consists of
an XPath <termref def="dt-expression">expression</termref> enclosed
 in curly brackets (<code>{}</code>). A fixed part
may contain any characters, except that a left curly bracket <rfc2119>must</rfc2119> be written as 
<code>{{</code> and a right curly bracket <rfc2119>must</rfc2119> be written as <code>}}</code>.</p>
				<note>
					<p>An expression within a variable part may contain an unescaped curly bracket
within a <xnt spec="XP" ref="StringLiteral">StringLiteral</xnt> <phrase diff="chg" at="R">or within a comment</phrase>.</p>
				</note>

				<p>
					<error spec="XT" type="static" class="SE" code="0350"><p>It is a <termref def="dt-static-error">static error</termref>
if an unescaped left curly bracket appears in a fixed part of an attribute value template without a matching right
curly bracket.</p></error>
				</p>
<p diff="chg" at="ZA">It is a <termref def="dt-static-error">static error</termref>
if the string contained between matching curly brackets in an attribute value template
does not match the XPath production <xnt spec="XP" ref="Expr">Expr</xnt>, or if it contains
other XPath static errors. The error is signaled using the appropriate XPath error code.</p> 
				<p>
					<error spec="XT" type="static" class="SE" code="0370"><p>It is a <termref def="dt-static-error">static error</termref> 
if an unescaped right curly bracket occurs in a fixed part of an attribute value template.</p></error></p>

				<p>
					<termdef id="dt-effective-value" term="effective value">The 
result of evaluating an attribute value template is referred to as the
<term>effective value</term> of the attribute.</termdef> The effective value
is the string obtained by concatenating the expansions
of the fixed and variable parts:</p>

<ulist>
<item><p>The expansion of a fixed part is obtained by
replacing any double curly brackets (<code>{{</code> or <code>}}</code>) by the
corresponding single curly bracket.</p></item>
<item><p>The expansion of a variable part is obtained
by evaluating the enclosed XPath
<termref def="dt-expression">expression</termref> and converting the resulting value to a string.
<phrase diff="chg" at="W">This
conversion is done using the rules given in <specref ref="constructing-simple-content"/>.</phrase></p></item>
</ulist>
				
				<note><p>This process can generate dynamic errors, for example if
				the sequence contains an element with a complex content type (which cannot
				be atomized).</p></note>
				
				<p>If <termref def="dt-backwards-compatible-behavior">backwards
				compatible behavior</termref> is enabled for the attribute, the rules for converting the
				value of the expression to a string are modified as follows. After 
				<termref def="dt-atomization">atomizing</termref> the result of the expression,
				all items other than the first item in the resulting sequence are discarded, and the effective
				value is obtained by converting the first item in the sequence to a string. 
				If the atomized sequence is empty, the result is a zero-length string.</p>


				<p>Curly brackets are
not treated specially in an attribute value in an XSLT <termref def="dt-stylesheet">stylesheet</termref> unless the
attribute is specifically designated as one that permits an
attribute value template; in an element syntax summary, the value
of such attributes is surrounded by curly brackets.</p>
				<note>
					<p>Not all attributes are designated as attribute value
templates.  Attributes whose value is an
 <termref def="dt-expression">expression</termref> or
  <termref def="dt-pattern">pattern</termref>,
attributes of <termref def="dt-declaration">declaration</termref> elements
and attributes that refer to named XSLT objects are <phrase diff="add" at="Z">generally</phrase> not designated as
attribute value templates <phrase diff="add" at="Z">(an exception is the <code>format</code>
attribute of <elcode>xsl:result-document</elcode>)</phrase>.  Namespace declarations
are not <phrase diff="chg" at="Z">XDM attribute nodes</phrase> and are therefore never treated as 
attribute value templates.</p>
				</note>
				<example><head>Attribute Value Templates</head>
					<p>The following example creates an <code>img</code> result element
from a <code>photograph</code> element in the source; the value of the
<code>src</code> and <code>width</code> attributes are computed using
XPath expressions enclosed in attribute value templates:</p>
					<eg><![CDATA[<xsl:variable name="image-dir" select="'/images'"/>

<xsl:template match="photograph">
  <img src="{$image-dir}/{href}" width="{size/@width}"/>
</xsl:template>]]></eg>
					<p>With this source</p>
					<eg><![CDATA[<photograph>
  <href>headquarters.jpg</href>
  <size width="300"/>
</photograph>]]></eg>
					<p>the result would be</p>
					<eg><![CDATA[<img src="/images/headquarters.jpg" width="300"/>]]></eg>
				</example>
				<example><head>Producing a Space-Separated List</head>
					<p>The following example shows how the values in a sequence are output
					as a space-separated list. The following literal result element:</p>
					<eg><![CDATA[<temperature readings="{10.32, 5.50, 8.31}"/>]]></eg>
					<p>produces the output node:</p>
					<eg><![CDATA[<temperature readings="10.32 5.5 8.31"/>]]></eg>
				</example>
				<p>Curly brackets are <emph>not</emph> recognized recursively inside
expressions.</p>
				<example><head>Curly Brackets can not be Nested</head>
					<p>For example:</p>
					<eg role="error" xml:space="preserve"><![CDATA[<a href="#{id({@ref})/title}">]]></eg>
					<p>is <emph>not</emph> allowed.  Instead, use simply:</p>
					<eg><![CDATA[<a href="#{id(@ref)/title}">]]></eg>
				</example>
			</div2>
			<div2 id="sequence-constructors" diff="chg" at="Q">
				<head>Sequence Constructors</head>


					<p><termdef id="dt-sequence-constructor" term="sequence constructor">A <term>sequence
constructor</term> is a sequence of zero or more
 sibling nodes in the <termref def="dt-stylesheet">stylesheet</termref> that 
can be evaluated to return a sequence of nodes and atomic values. The way that the resulting
sequence is used depends on the containing instruction.</termdef></p>

				<p>Many <termref def="dt-xslt-element">XSLT elements</termref>, 
				<phrase diff="chg" at="ZA">and also</phrase>
 <termref def="dt-literal-result-element">literal result elements</termref>, are defined to take 
 a <termref def="dt-sequence-constructor">sequence constructor</termref> as
their content.</p>

				
<p>Four kinds of nodes may be encountered in a sequence constructor:</p>

<ulist>

<item><p><emph>Text nodes</emph> appearing in the <termref def="dt-stylesheet">stylesheet</termref> 
(if they have not been
removed in the process of whitespace stripping: see <specref ref="stylesheet-stripping"/>) are copied
to create a new parentless text node in the result sequence.</p></item>

<item><p><termref def="dt-literal-result-element">Literal result elements</termref> 
are evaluated to create a new parentless element node,
having the same <termref def="dt-expanded-qname">expanded-QName</termref>
 as the literal result element, which is added to the result
sequence: see <specref ref="literal-result-element"/></p></item>

<item><p>XSLT <termref def="dt-instruction">instructions</termref> produce
a sequence of zero, one, or more items as their result. 
These items are added to the result sequence. For most XSLT instructions, these
items are nodes, but some instructions (<elcode>xsl:sequence</elcode> and <elcode>xsl:copy-of</elcode>)
can also produce atomic values. Several instructions,
such as <elcode>xsl:element</elcode>, return a newly constructed parentless node (which may
have its own attributes, namespaces, children, and other descendants). Other instructions, such
as <elcode>xsl:if</elcode>, pass on the items produced by their own nested sequence
constructors. The <elcode>xsl:sequence</elcode>
instruction may return atomic values, or existing nodes.</p></item>

<item><p><termref def="dt-extension-instruction">Extension instructions</termref> 
(see <specref ref="extension-instruction"/>) also produce a sequence of items as their
result. The items in this sequence are added to the result sequence.</p></item>
</ulist>



<p>There are several ways the result of a sequence constructor may be used.</p>

<ulist>

<item><p>The sequence may be bound to a variable or returned from a stylesheet function,
in which case it becomes available as a value to be manipulated in arbitrary ways by XPath expressions. 
The sequence is bound to a variable when the sequence constructor appears within one of the
 elements <elcode>xsl:variable</elcode>,
<elcode>xsl:param</elcode>, or <elcode>xsl:with-param</elcode>, when this
instruction has an <code>as</code> attribute. The sequence is returned from a stylesheet function
when the sequence constructor appears within the <elcode>xsl:function</elcode> element.</p>

<note><p>This will typically expose to the stylesheet elements, attributes, and other nodes that have
not yet been attached to a parent node in a <termref def="dt-result-tree">result tree</termref>. 
The semantics of XPath expressions when applied to 
parentless nodes are well-defined; however, such expressions should be used with care. For example, the expression
<code>/</code> <phrase diff="chg" at="Z">causes a type error if the root of the tree containing the context node
 is not a document node.</phrase>.</p>

<p>Parentless attribute nodes require particular care because they have no namespace nodes associated
with them. <phrase diff="chg" at="Z">A parentless attribute node is not permitted to contain namespace-sensitive
content (for example, a QName or an XPath expression) because there
is no information enabling the prefix to be resolved to a namespace URI.</phrase> Parentless attributes
can be useful in an application (for example, they provide an alternative to the use of
attribute sets: see <specref ref="attribute-sets"/>) but they need to be handled with care.</p></note>

</item> 

<item><p>The sequence may be returned as the result of the containing element. 

 This happens
when the instruction containing the sequence constructor is 
<elcode>xsl:analyze-string</elcode>,
<elcode>xsl:apply-imports</elcode>,
<elcode>xsl:apply-templates</elcode>, 
<elcode>xsl:call-template</elcode>, 
<elcode>xsl:choose</elcode>,
<elcode>xsl:fallback</elcode>,
<elcode>xsl:for-each</elcode>, 
<elcode>xsl:for-each-group</elcode>,
<elcode>xsl:if</elcode>, 
<elcode>xsl:matching-substring</elcode>, 
<elcode>xsl:next-match</elcode>, 
<elcode>xsl:non-matching-substring</elcode>,
<elcode>xsl:otherwise</elcode>,
<elcode>xsl:perform-sort</elcode>, 
<elcode>xsl:sequence</elcode>, 
or <elcode>xsl:when</elcode></p></item>

<item><p>The sequence may be used to construct the content of a new element or document node. This
happens when the sequence constructor appears as the content of a 
<termref def="dt-literal-result-element">literal result element</termref>, or of one of
the instructions <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, 
<phrase diff="add" at="Z"><elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>,</phrase> 
or <elcode>xsl:message</elcode>.
It also happens when the sequence constructor is contained in one of the elements <elcode>xsl:variable</elcode>,
<elcode>xsl:param</elcode>, or <elcode>xsl:with-param</elcode>, when this
instruction has no <code>as</code> attribute. For details, see <specref ref="constructing-complex-content"/>.</p></item>

<item><p>The sequence may be used to construct the <termref def="dt-string-value">string value</termref>
 of an attribute node, <phrase diff="add" at="R">text node</phrase>, namespace node,
comment node, or processing instruction node. This happens when the sequence constructor is contained
in one of the elements <elcode>xsl:attribute</elcode>, 
<phrase diff="add" at="R"><elcode>xsl:value-of</elcode></phrase>, <elcode>xsl:namespace</elcode>, 
<elcode>xsl:comment</elcode>, or <elcode>xsl:processing-instruction</elcode>.
For details, see <specref ref="constructing-simple-content"/>.</p></item>

</ulist>

				<note>
					<p>The term <emph><phrase diff="chg" at="Q">sequence</phrase> constructor</emph>
replaces <emph>template</emph> as used in XSLT 1.0. 
The change is made partly for clarity (to avoid confusion
with <termref def="dt-template-rule">template rules</termref> and
<termref def="dt-named-template">named templates</termref>), 
 but also to reflect a more formal definition of the semantics.
Whereas XSLT 1.0 described a template as a sequence of instructions that write
to the result tree, XSLT 2.0 describes a <phrase diff="chg" at="Q">sequence</phrase> constructor as something that can be
evaluated to return a sequence of <phrase diff="chg" at="Q">items</phrase>; what happens to these items depends on the containing
instruction.</p>
				</note> 

<div3 id="constructing-complex-content">
<head>Constructing Complex Content</head>

<p>This section describes how the sequence obtained by evaluating a 
<termref def="dt-sequence-constructor">sequence constructor</termref>
may be used to construct the children of a newly constructed document node,
or the children, attributes and namespaces of a newly constructed element node.
The sequence of items may be obtained by evaluating the 
<termref def="dt-sequence-constructor">sequence constructor</termref> contained in an
instruction such as <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, 
<phrase diff="add" at="T"><elcode>xsl:document</elcode></phrase>, <elcode>xsl:result-document</elcode>, or a 
<termref def="dt-literal-result-element">literal result element</termref>.</p>

<p diff="add" at="U">When constructing the content of an element, the <code>inherit-namespaces</code>
attribute of the <elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode> instruction, or the
<code>xsl:inherit-namespaces</code> property of the literal result element, determines whether 
namespace nodes are to be inherited. The effect of this attribute is described in the rules that
follow.</p>

<p>The sequence is processed as follows 
<phrase diff="add" at="U">(applying the rules in the order they are listed)</phrase>:</p>

<olist>

<item><p>The containing instruction may generate attribute nodes and/or
namespace nodes, as specified in the rules for the individual instruction. For example,
these nodes may be produced by expanding an <code>[xsl:]use-attribute-sets</code> attribute,
or by expanding the attributes of a <termref def="dt-literal-result-element">literal result element</termref>.
Any such nodes are prepended to the sequence produced by evaluating the 
<termref def="dt-sequence-constructor">sequence constructor</termref>.</p></item>

<item><p>Any atomic value in the sequence is cast to a string.</p>

<note><p>Casting from <code>xs:QName</code> or <code>xs:NOTATION</code> to <code>xs:string</code>
 always succeeds, because these values retain a prefix for this purpose. However, there is no guarantee that
 the prefix used will always be meaningful in the context where the resulting string is used.</p></note>


</item>

 
<item><p>Any consecutive sequence of strings within the result sequence is converted 
to a single text node, whose <termref def="dt-string-value">string value</termref> contains
 the content of each of the strings in turn, with a single space (#x20) used as a separator
 between successive strings.</p></item>


<item><p>Any document node within the result sequence is replaced by a sequence containing 
each of its children, in document order.</p></item>

<item><p>Zero-length text nodes within the result sequence are removed.</p></item>

<item><p>Adjacent text nodes within the result sequence are merged into a single text node.</p></item>

<item><p>Invalid namespace and attribute nodes are detected as follows.</p>

<p><error spec="XT" type="dynamic" class="DE" code="0410"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
 the result sequence used to construct the content of an element node
 contains a namespace node or attribute node that is preceded
in the sequence by a node that is neither a namespace node nor an attribute node.</p></error></p>

<p><error spec="XT" type="dynamic" class="DE" code="0420"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
 the result sequence used to construct the content of a document node 
 contains a namespace node or attribute node.</p></error></p>

<p><error spec="XT" type="dynamic" class="DE" code="0430"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
the result sequence contains two or more namespace nodes having the same name but different
 <termref def="dt-string-value">string values</termref> (that is, 
namespace nodes that map the same prefix to different namespace URIs).</p></error></p>

<p><error spec="XT" type="dynamic" class="DE" code="0440"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
the result sequence contains a namespace node with no name and the element node being constructed has a
 null namespace URI (that is, it is an error to define a default namespace when the element is in no namespace).
</p></error></p></item>

<item><p>If the result sequence contains two or more namespace nodes with the same name (or no name)
and the same <termref def="dt-string-value">string value</termref> (that is, two namespace nodes mapping the same prefix to the same namespace URI), then
all but one of the duplicate nodes are discarded.</p>

<note><p>Since the order of namespace nodes is undefined, it is not significant which of the duplicates
 is retained.</p></note></item>

<item><p>If an attribute <var>A</var> in the result sequence has the same name as another attribute 
<var>B</var> that appears later in the
result sequence, then attribute <var>A</var> is discarded from the result sequence.</p></item>    

<item><p>Each node in the resulting sequence is attached as a namespace, attribute, or child
of the newly constructed element or document node. Conceptually this involves making a deep
copy of the node; in practice, however, copying the node will only be necessary if the existing node
can be referenced independently of the parent to which it is being attached. When copying an element
or processing instruction
node, its base URI property is changed to be the same as that of its new parent, unless it has an
<code>xml:base</code> attribute (see <bibref ref="xmlbase"/>) that overrides this.
If the <phrase diff="add" at="Y">copied</phrase> element has an <code>xml:base</code> attribute, its base URI
is the value of that attribute, resolved (if it is relative) against the base URI of the new parent node.</p></item>

<item><p>If the newly constructed node is an element node, then namespace fixup is applied to this node, as described
in <specref ref="namespace-fixup"/>.</p></item>

<item><p>If the newly constructed node is an element node, and if namespaces are inherited, then each
namespace node of the newly constructed element (including any produced as a result of the
namespace fixup process) is copied to each descendant element of the newly constructed element,
unless that element or an intermediate element already has a namespace node with the same name
(or absence of a name) <phrase diff="add" at="ZB">or that descendant element or an intermediate
element is in no namespace and the namespace node has no name</phrase>.</p></item>


</olist>

				<example>
				<head>A Sequence Constructor for Complex Content</head>
							
<p>Consider the following stylesheet fragment:</p>
<eg><![CDATA[<td>
  <xsl:attribute name="valign">top</xsl:attribute>
  <xsl:value-of select="@description"/>
</td>]]></eg>
					<p>This fragment consists of a literal result element <code>td</code>, containing
a sequence constructor that consists of two instructions: <elcode>xsl:attribute</elcode> and
<elcode>xsl:value-of</elcode>. The sequence constructor is evaluated to produce a sequence of two nodes: a
parentless attribute node, and a parentless text node. 
The <code>td</code> instruction causes a <code>td</code> element
to be created; the new attribute therefore becomes an attribute of the new <code>td</code> element,
while the text node created by the <elcode>xsl:value-of</elcode> instruction becomes a child of the
<code>td</code> element (unless it is zero-length, in which case it is 
discarded).</p>
				</example>

<example diff="add" at="Z">
				<head>Space Separators in Element Content</head>
							
<p>Consider the following stylesheet fragment:</p>
<eg><![CDATA[<doc>
  <e><xsl:sequence select="1 to 5"/></e>
  <f>
    <xsl:for-each select="1 to 5">
      <xsl:value-of select="."/>
    </xsl:for-each>
  </f>
</doc>]]></eg>

<p>This produces the output (when indented):</p>

<eg><![CDATA[<doc>
  <e>1 2 3 4 5</e>
  <f>12345</f>
</doc>]]></eg>

<p>The difference between the two cases is that for the <code>e</code> element, the sequence constructor
generates a sequence of five atomic values, which are therefore separated by spaces. For the <code>f</code>
element, the content is a sequence of five text nodes, which are concatenated without space separation.</p>

<p>It is important to be aware of the distinction between <elcode>xsl:sequence</elcode>, which returns the value
of its <code>select</code> expression unchanged, and <elcode>xsl:value-of</elcode>, which constructs a text node.</p>
</example>

				

</div3>

<div3 id="constructing-simple-content">
<head>Constructing Simple Content</head>

						<p>The <elcode>xsl:attribute</elcode>, <elcode>xsl:comment</elcode>, 
<elcode>xsl:processing-instruction</elcode>, 
 <elcode>xsl:namespace</elcode><phrase diff="add" at="R">, and <elcode>xsl:value-of</elcode></phrase>
 elements create nodes that cannot have children. 
 <phrase diff="chg" at="R">Specifically, the <elcode>xsl:attribute</elcode> instruction creates
 an attribute node, <elcode>xsl:comment</elcode> creates a comment node, 
<elcode>xsl:processing-instruction</elcode> creates a processing instruction node, 
 <elcode>xsl:namespace</elcode> creates a namespace node, and  <elcode>xsl:value-of</elcode>
 creates a text node.
 The string value of the new node is constructed using either
 the <code>select</code> attribute of the instruction, or the <termref def="dt-sequence-constructor">sequence
 constructor</termref> that forms the content of the instruction. The <code>select</code> attribute
 allows the content to be specified by means of an XPath expression, while the sequence constructor allows
 it to be specified by means of a sequence of XSLT instructions. The <code>select</code> attribute
 or sequence constructor is evaluated to produce a result sequence, </phrase>
  and the <termref def="dt-string-value">string value</termref> of the new
 node is derived from this result sequence according to the rules below.</p>

 <p>These rules are also used to compute the <termref def="dt-effective-value">effective value</termref>
 of an <termref def="dt-attribute-value-template">attribute value template</termref>. In this case the sequence
 being processed is the result of evaluating an XPath expression enclosed between curly brackets, and the
 separator is a single space character.</p>
 
 <olist>

 <item><p>Zero-length text nodes in the sequence are discarded.</p></item>

 <item><p>Adjacent text nodes in the sequence are merged into a single text node.</p></item>
 
 
 <item><p>The sequence is <termref def="dt-atomization">atomized</termref>.</p></item>

<item><p>Every value in the atomized sequence is cast to a string.</p></item>

<item><p>The strings within the resulting sequence are concatenated, with a 
(possibly zero-length) separator inserted between successive strings.
 <phrase diff="add" at="V">The default separator is a single space.</phrase>
  In the case of <elcode>xsl:attribute</elcode> and
<elcode>xsl:value-of</elcode>, a different separator can be specified using the <code>separator</code>
attribute of the instruction; it is permissible for this to be a zero-length string, in which case
the strings are concatenated with no separator. In the case of <elcode>xsl:comment</elcode>, 
<elcode>xsl:processing-instruction</elcode>, and <elcode>xsl:namespace</elcode><phrase diff="add" at="W">, and
when expanding an <termref def="dt-attribute-value-template">attribute value template</termref></phrase>, the default
separator cannot be changed.</p></item>

<item diff="add" at="ZA"><p>In the case of <elcode>xsl:processing-instruction</elcode>, 
any leading spaces in the resulting string are removed.</p></item>

<item><p>The <phrase diff="chg" at="ZA">resulting string</phrase> forms the 
<termref def="dt-string-value">string value</termref> of the new attribute, namespace, comment, 
processing-instruction, or text node.</p></item>
 
</olist>

<example diff="add" at="Z">
				<head>Space Separators in Attribute Content</head>
							
<p>Consider the following stylesheet fragment:</p>
<eg><![CDATA[<doc>
  <xsl:attribute name="e" select="1 to 5"/>
  <xsl:attribute name="f">
    <xsl:for-each select="1 to 5">
      <xsl:value-of select="."/>
    </xsl:for-each>
  </xsl:attribute>
</doc>]]></eg>

<p>This produces the output:</p>

<eg><![CDATA[<doc e="1 2 3 4 5" f="12345"/>]]></eg>

<p>The difference between the two cases is that for the <code>e</code> attribute, the sequence constructor
generates a sequence of five atomic values, which are therefore separated by spaces. For the <code>f</code>
attribute, the content is supplied as a sequence of five text nodes, which are concatenated without space separation.</p>

<p>Specifying <code>separator=""</code> on the first <elcode>xsl:attribute</elcode> instruction would cause 
the attribute value to be <code>e="12345"</code>. A <code>separator</code> attribute on the second 
<elcode>xsl:attribute</elcode> instruction would have no effect, since the separator only affects the way
adjacent atomic values are handled: separators are never inserted between adjacent text nodes.</p>

</example>


<note><p>If an attribute value template contains a sequence of fixed and variable
parts, no additional whitespace is inserted between the expansions of the fixed and variable parts.
For example, the <termref def="dt-effective-value">effective value</termref> of the attribute
<code>a="chapters{4 to 6}"</code> is <code>a="chapters4 5 6"</code>.</p></note>

</div3>


	<div3 id="namespace-fixup">
				<head>Namespace Fixup</head>

				
				<p diff="chg" at="V">In a tree supplied to or constructed by an XSLT processor, the 
constraints relating to namespace nodes that are specified in <bibref ref="xpath-datamodel"/> 
<rfc2119>must</rfc2119> be satisfied. For example</p>
				<ulist>
<item>
	<p>If an element node has an <termref def="dt-expanded-qname">expanded-QName</termref> with a non-null
namespace URI, then that element node <phrase diff="chg" at="M"><rfc2119>must</rfc2119></phrase> have at least one namespace
node whose <termref def="dt-string-value">string value</termref> is the same as that namespace URI.</p>
</item>
<item>
	<p>If an element node has an attribute node whose
	 <termref def="dt-expanded-qname">expanded-QName</termref> has a non-null
namespace URI, then the element <rfc2119>must</rfc2119> have at
least one namespace node whose <termref def="dt-string-value">string value</termref> is the same as that
namespace URI and whose name is non-empty.</p>
</item>

<item>
	<p>Every element <rfc2119>must</rfc2119> have a namespace node whose
	 <termref def="dt-expanded-qname">expanded-QName</termref> has
local-part <code>xml</code> and whose <termref def="dt-string-value">string value</termref> is
<code>http://www.w3.org/XML/1998/namespace</code>. The namespace prefix
<code>xml</code> must not be associated with any other namespace URI, and the namespace URI 
<code>http://www.w3.org/XML/1998/namespace</code> must not be associated with any other prefix.</p>
</item>
					
<item><p>A namespace node <rfc2119>must not</rfc2119> have the name <code>xmlns</code>.</p></item>

</ulist>




<p diff="chg" at="M">
<termdef id="dt-namespace-fixup" term="namespace fixup">The rules for the individual XSLT instructions that 
construct a <termref def="dt-result-tree">result tree</termref> (see <specref ref="creating-new-nodes"/>) prescribe some of the situations
in which namespace nodes are written to the tree. These rules, however, are not sufficient
to ensure that the prescribed constraints are always satisfied. The XSLT processor <rfc2119>must</rfc2119> therefore
add additional namespace nodes to satisfy these constraints. This process is referred to
as <term>namespace fixup</term>.</termdef></p>

<p>The actual namespace nodes that are added to the tree by the namespace fixup process are
<termref def="dt-implementation-dependent">implementation-dependent</termref>, 
provided firstly, that at the end of the process the above constraints
<rfc2119>must</rfc2119> all be satisfied, and secondly, that a namespace node <rfc2119>must not</rfc2119> be added to the tree unless the namespace
node is necessary either to satisfy these constraints, or to enable the tree to be serialized using 
the original namespace prefixes from the source document or <termref def="dt-stylesheet">stylesheet</termref>.</p>


<p>Namespace fixup <rfc2119>must not</rfc2119> result in an element having multiple
namespace nodes with the same name.</p>

<p>Namespace fixup <rfc2119>may</rfc2119>, if necessary to resolve conflicts, 
change the namespace prefix contained in the QName value that holds the name of an element or attribute 
node. <phrase diff="add" at="ZB">This includes the option to add or remove a prefix.</phrase>
However, namespace fixup <rfc2119>must not</rfc2119> change the prefix component contained
in a value of type <code>xs:QName</code> or <code>xs:NOTATION</code> that forms the typed value 
of an element or attribute node.</p>

<note diff="add" at="Y"><p>Namespace fixup is not used to create namespace declarations for <code>xs:QName</code> 
or <code>xs:NOTATION</code> values appearing in the content of an element or attribute.</p>

<p>Where
values acquire such types as the result of validation, namespace fixup does not come into play, because
namespace fixup happens before validation: in this situation, it is the user's responsibility to ensure that the
element being validated has the required namespace nodes to enable validation to succeed.</p>

<p>Where existing elements are copied along with their existing type annotations 
(<code>validation="preserve"</code>) the rules require that existing namespace nodes are also
copied, so that any namespace-sensitive values remain valid.</p>

<p>Where existing attributes are copied along with their existing type annotations, the
rules of the XDM data model require that a parentless attribute node cannot contain a namespace-sensitive
typed value; this means that it is an error to copy an attribute using <code>validation="preserve"</code>
if it contains namespace-sensitive content.</p>
</note>

<p diff="add" at="U"><error spec="XT" type="dynamic" class="DE" code="0485"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if namespace fixup is 
 performed on an element that contains among the typed values of the element and its attributes
 two values of type <code>xs:QName</code> or <code>xs:NOTATION</code> containing conflicting namespace prefixes,
 that is, two values that use the same prefix to refer to different namespace URIs.</p></error></p>


<p>Namespace fixup is applied to every element that is constructed using a 
<termref def="dt-literal-result-element">literal result element</termref>, or one of the
instructions <elcode>xsl:element</elcode>, <elcode>xsl:copy</elcode>, or <elcode>xsl:copy-of</elcode>.
An implementation is not <rfc2119>required</rfc2119> to perform namespace fixup for 
elements in any source document, that is, for a document in the 
initial input sequence, documents
loaded using the <function>document</function>, <xfunction>doc</xfunction> or <xfunction>collection</xfunction> function,
documents supplied as the value of a
<termref def="dt-stylesheet-parameter">stylesheet parameter</termref>, or documents
returned by an <termref def="dt-extension-function">extension function</termref> 
or <termref def="dt-extension-instruction">extension instruction</termref>.</p>

<note diff="chg" at="X"><p>A source document (an input document, a document returned by the
 <function>document</function>,  <xfunction>doc</xfunction> or <xfunction>collection</xfunction> functions,
 a document returned by an extension function or extension instruction, 
 or a document supplied as a stylesheet parameter) is required to satisfy the constraints described in 
 <bibref ref="xpath-datamodel"/>, including the constraints imposed by the namespace fixup process.
 The effect of supplying a pseudo-document that does not meet these constraints is undefined.</p></note>
				
<p>In an Infoset (see <bibref ref="xml-infoset"/>) 
created from a document conforming to <bibref ref="REC-xml-names"/>,
it will always be true that if a parent element 
has an in-scope namespace with a non-empty namespace prefix, then its child elements will also
have an in-scope namespace with the same namespace prefix, though possibly with a different namespace URI.
This constraint is removed in <bibref ref="xml-names11"/>. XSLT 2.0 supports the creation of result
trees that do not satisfy this constraint: the namespace fixup process does not add a namespace node
to an element merely because its parent node in the <termref def="dt-result-tree">result tree</termref> 
has such a namespace node.
<phrase diff="add" at="U">However, the process of constructing the children of a new element, which is
described in <specref ref="constructing-complex-content"/>, does cause the namespaces of a parent
element to be inherited by its children unless this is prevented using <code>[xsl:]inherit-namespaces="no"</code>
on the instruction that creates the parent element.</phrase></p>

<note><p>This has implications on serialization, defined in <bibref ref="xslt-xquery-serialization"/>. It
means that it is possible to create <termref def="dt-final-result-tree">final result trees</termref> 
that cannot be faithfully serialized as XML 1.0
documents. When such a result tree is serialized as XML 1.0, namespace declarations written
for the parent element will be inherited by its child elements as if the corresponding namespace
nodes were present on the child element<phrase diff="add" at="R">, except in the case of the default
namespace, which can be undeclared using the construct <code>xmlns=""</code></phrase>. 
When the same result tree is serialized as XML 1.1, however, it is possible
to undeclare any namespace on the child element <phrase>(for example, <code>xmlms:foo=""</code>)</phrase>
to prevent this inheritance taking place.</p></note>
			</div3>
</div2>
<div2 id="uri-references"><head>URI References</head>

<p><termdef id="dt-uri-reference" term="URI Reference">Within this specification, the term
<term>URI Reference</term>, unless otherwise stated, refers to a string in the lexical space of
the <code>xs:anyURI</code> data type as defined in <bibref ref="xmlschema-2"/>.</termdef> Note that this
is a wider definition than that in <bibref ref="RFC3986"/>: 
<phrase diff="chg" at="Y">in particular, it is designed
to accommodate Internationalized Resource Identifiers (IRIs) 
as described in <bibref ref="RFC3987"/>, and thus allows the use of non-ASCII characters
without escaping.</phrase></p>


<p>URI References are used in XSLT with three main roles:</p>
<slist>
<sitem>As namespace URIs</sitem>
<sitem>As collation URIs</sitem>
<sitem>As identifiers for resources such as stylesheet modules; these resources are typically accessible 
using a protocol such as HTTP.
Examples of such identifiers are the URIs used in the <code>href</code> attributes of <elcode>xsl:import</elcode>,
<elcode>xsl:include</elcode>, and <elcode>xsl:result-document</elcode>.</sitem>
</slist>

<p>The rules for namespace URIs are given in <bibref ref="REC-xml-names"/> and <bibref ref="xml-names11"/>. Those
specifications deprecate the use of relative URIs as namespace URIs.</p> 

<p>The rules for collation URIs are given in <bibref ref="xpath-functions"/>.</p>

<p>URI references used to identify external resources must conform to the same rules as the locator attribute
(<code>href</code>) defined in section 5.4 of <bibref ref="xlink"/>. If the URI reference is relative, then
it is resolved (unless otherwise specified) against the base URI of the containing element node, according to the rules of
<phrase diff="chg" at="X"><bibref ref="RFC3986"/></phrase>, after first escaping all characters that need to be escaped to make it a valid
RFC3986 URI reference. (But a relative URI in the <code>href</code> attribute of <elcode>xsl:result-document</elcode>
is resolved against the <termref def="dt-base-output-uri">Base Output URI</termref>.)</p>

<p>Other URI references appearing in an XSLT stylesheet document, for example the system identifiers of external
entities or the value of the <code>xml:base</code> attribute, must follow the rules in their respective
specifications.</p>

</div2>


		</div1>
		<div1 id="rules">
			<head>Template Rules</head>
			<p>Template rules define the processing that can be applied
			to nodes that match a particular <termref def="dt-pattern">pattern</termref>.</p>
			<div2 id="defining-templates" diff="add" at="Q">
				<head>Defining Templates</head>
				<e:element-syntax name="template">
					<e:in-category name="declaration"/>
					<e:attribute name="match">
						<e:data-type name="pattern"/>
					</e:attribute>
					<e:attribute name="name">
						<e:data-type name="qname"/>
					</e:attribute>
					<e:attribute name="priority">
						<e:data-type name="number"/>
					</e:attribute>
					<e:attribute name="mode">
						<e:data-type name="tokens"/>
					</e:attribute>
					<e:attribute name="as">
						<e:data-type name="sequence-type"/>
					</e:attribute>					
					<e:sequence>
						<e:element repeat="zero-or-more" name="param"/>
						<e:model name="sequence-constructor"/>
					</e:sequence>
					<e:allowed-parents>
						<e:parent name="stylesheet"/>
						<e:parent name="transform"/>
					</e:allowed-parents>
				</e:element-syntax>

<p><termdef id="dt-template" term="template">An <elcode>xsl:template</elcode> declaration
defines a <term>template</term>, which contains a 
<phrase diff="chg" at="R"><termref def="dt-sequence-constructor">sequence constructor</termref></phrase>
 for creating
nodes and/or atomic values. A template can serve either as a 
<termref def="dt-template-rule">template rule</termref>, invoked by matching nodes against
a <termref def="dt-pattern">pattern</termref>, or as a <termref def="dt-named-template">named template</termref>,
invoked explicitly by name. It is also possible for the same template to serve in both capacities.</termdef></p>

<p diff="chg" at="W"><error spec="XT" type="static" class="SE" code="0500"><p>An 
<elcode>xsl:template</elcode> element <rfc2119>must</rfc2119> have either a <code>match</code>
attribute or a <code>name</code> attribute, or both.  An <elcode>xsl:template</elcode> element
that has no <code>match</code> attribute <rfc2119>must</rfc2119> have no <code>mode</code> attribute and no
<code>priority</code> attribute.</p></error></p>

<p>If an <elcode>xsl:template</elcode> element has a <code>match</code> attribute, then
it is a <termref def="dt-template-rule">template rule</termref>. If it has a <code>name</code> attribute,
then it is a <termref def="dt-named-template">named template</termref>.</p>

<p>A <termref def="dt-template">template</termref> may be invoked in a number of ways,
depending on whether it is a <termref def="dt-template-rule">template rule</termref>, 
a <termref def="dt-named-template">named template</termref>, or both. The result of invoking the template is the
result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref>
 contained in the <elcode>xsl:template</elcode> element (see <specref ref="sequence-constructors"/>).</p>

<p>If an <code>as</code> attribute is present, the <code>as</code> attribute defines the required type
of the result.
The result of evaluating the
 <termref def="dt-sequence-constructor">sequence constructor</termref>
is then converted to the required type using the
 <termref def="dt-function-conversion-rules">function conversion rules</termref>.
 If no <code>as</code> attribute is specified, the default value is <code>item()*</code>, which permits
any value. No conversion then takes place.</p>

<p><error spec="XT" type="type" class="TE" code="0505"><p>It is a <termref def="dt-type-error">type error</termref>
if the result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref>
cannot be converted to the required type.</p></error></p>

</div2>
<div2 id="defining-template-rules"><head>Defining Template Rules</head>

<p>This section describes <termref def="dt-template-rule">template rules</termref>.
<termref def="dt-named-template">Named templates</termref> are described
in <specref ref="named-templates"/>.</p>

<p>A <termref def="dt-template-rule">template rule</termref> is specified using
the <elcode>xsl:template</elcode> element 
<phrase diff="add" at="Q">with a <code>match</code> attribute</phrase>. 
The <code>match</code> attribute is a <nt def="NT-Pattern">Pattern</nt> 
that identifies the node or nodes to which the rule applies.
The result of applying the template rule is the
result of evaluating the <phrase diff="chg" at="Q">sequence</phrase> constructor contained in the 
<elcode>xsl:template</elcode> element, with the matching node used
as the <termref def="dt-context-node">context node</termref>.</p>


				
				<example><head>A simple Template Rule</head>
					<p>For example, an XML document might contain:</p>
					<eg><![CDATA[This is an <emph>important</emph> point.]]></eg>
					<p>The following <termref def="dt-template-rule">template rule</termref> 
					matches <code>emph</code> elements and
produces a <code>fo:wrapper</code> element with a
<code>font-weight</code> property of <code>bold</code>.</p>
					<eg><![CDATA[<xsl:template match="emph">
  <fo:wrapper font-weight="bold" xmlns:fo="http://www.w3.org/1999/XSL/Format">
    <xsl:apply-templates/>
  </fo:wrapper>
</xsl:template>
]]></eg>

				</example>

<p>A <termref def="dt-template-rule">template rule</termref> is evaluated when
an <elcode>xsl:apply-templates</elcode> instruction selects a node that matches the pattern
specified in the <code>match</code> attribute. The <elcode>xsl:apply-templates</elcode> instruction
is described in the next section. If several template rules match a selected node, only one of them
is evaluated, as described in <specref ref="conflict"/>.</p>

			</div2>
			<div2 id="applying-templates">
				<head>Applying Template Rules</head>
				<e:element-syntax name="apply-templates">
					<e:in-category name="instruction"/>
					<e:attribute name="select">
						<e:data-type name="expression"/>
					</e:attribute>
					<e:attribute name="mode">
						<e:data-type name="token"/>
					</e:attribute>
					<e:choice repeat="zero-or-more">
						<e:element name="sort"/>
						<e:element name="with-param"/>
					</e:choice>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				<p>The <elcode>xsl:apply-templates</elcode> instruction
takes as input a sequence of nodes (typically nodes in a <termref def="dt-source-tree">source tree</termref>), and produces
as output a sequence of items; these will often be nodes to be
 added to a <termref def="dt-result-tree">result tree</termref>.</p>
 
<p>If the instruction has one or more <elcode>xsl:sort</elcode>
children, then the input sequence is sorted as described in <specref ref="sorting"/>.
The result of this sort is referred to below as the <term>sorted sequence</term>;
if there are no <elcode>xsl:sort</elcode> elements, then the sorted sequence is the same
as the input sequence.</p> 

<p>Each node in the input sequence is processed by finding a
<termref def="dt-template-rule">template rule</termref> whose <termref def="dt-pattern">pattern</termref>
 matches that node. If there is more than one,
the best among them is chosen, using rules described in <specref ref="conflict"/>.
If there is no template rule whose pattern matches the node, a built-in template rule 
is used (see <specref ref="built-in-rule"/>). The chosen template rule is evaluated.
The rule that matches the <var>N</var>th node in the sorted sequence is
evaluated with that node as the <termref def="dt-context-item">context item</termref>, with
<var>N</var> as the <termref def="dt-context-position">context position</termref>, 
and with the length of the sorted sequence as the <termref def="dt-context-size">context size</termref>.
Each template rule that is evaluated produces a sequence of items as its result. 
The resulting sequences 
(one for each node in the sorted sequence) are then concatenated, to form
a single sequence. They are concatenated retaining the order of the nodes 
in the sorted sequence. The final concatenated sequence
 forms the result of the 
<elcode>xsl:apply-templates</elcode> instruction.

				</p>
				<example>
				<head>Applying Template Rules</head>
				<p>Suppose the source document is as follows:</p>
				
<eg><![CDATA[<message>Proceed <emph>at once</emph> to the exit!</message>]]></eg>

<p>This can be processed using the two template rules shown below.</p>

<eg><![CDATA[<xsl:template match="message">
  <p>
    <xsl:apply-templates select="child::node()"/>
  </p>
</xsl:template>

<xsl:template match="emph">
  <b>
    <xsl:apply-templates select="child::node()"/>
  </b>
</xsl:template>]]></eg>

<p>There is no template rule
for the document node; the built-in template rule for this node will cause the <code>message</code>
element to be processed. The template rule for the <code>message</code> element causes a <code>p</code>
element to be written to the <termref def="dt-result-tree">result tree</termref>; the contents of this <code>p</code> element are constructed
as the result of the <elcode>xsl:apply-templates</elcode> instruction. This instruction selects
the three child nodes of the <code>message</code> element (a text node containing the value "<code>Proceed </code>",
an <code>emph</code> element node, and a text node containing the value "<code> to the exit!</code>").
The two text nodes are processed using the built-in template rule for text nodes, which returns a copy
of the text node. The <code>emph</code> element is processed using the explicit template rule that specifies
<code>match="emph"</code>.</p>

<p>When the <code>emph</code> element is processed, this template rule constructs a <code>b</code> element. The
contents of the <code>b</code> element are constructed by means of another <elcode>xsl:apply-templates</elcode>
instruction, which in this case selects a single node (the text node containing the value "<code>at once</code>").
This is again processed using the built-in template rule for text nodes, which returns a copy of the text node.</p>

<p>The final result of the <code>match="message"</code> template rule thus consists of a <code>p</code> element
node with three children: a text node containing the value "<code>Proceed </code>", a <code>b</code> element that
is the parent of a text node containing the value "<code>at once</code>", and a text node containing the value
"<code> to the exit!</code>". This <termref def="dt-result-tree">result tree</termref> might be serialized as:</p>

<eg><![CDATA[<p>Proceed <b>at once</b> to the exit!</p>]]></eg>				


				</example>
				
<p>The default value of the <code>select</code> attribute is <code>child::node()</code>, 
which causes all the children of context node to be processed.</p>


<p diff="chg" at="X"><error spec="XT" type="type" class="TE" code="0510"><p>It is a
 <termref def="dt-type-error">type error</termref> if 
an <elcode>xsl:apply-templates</elcode> instruction with no <code>select</code> attribute is evaluated when
the <termref def="dt-context-item">context item</termref> is not a node. 
</p></error></p>

			
<p>A <code>select</code> attribute can be used to process nodes
selected by an expression instead of processing all children.  The
value of the <code>select</code> attribute is an
<termref def="dt-expression">expression</termref>.  The expression <rfc2119>must</rfc2119>
evaluate to a sequence of nodes (it can contain
zero, one, or more nodes).</p>

<p><error spec="XT" type="type" class="TE" code="0520"><p>It is a
 <termref def="dt-type-error">type error</termref> if 
the sequence returned by the <code>select</code> expression 
<error.extra>of <elcode>xsl:apply-templates</elcode></error.extra>
contains an item that is not a node.</p></error></p>

<note><p>In XSLT 1.0, the <code>select</code> attribute selected a set of nodes, which
by default were processed in document order. In XSLT 2.0, it selects a sequence of nodes.
In cases that would have been valid in XSLT 1.0, the expression will return a sequence of
nodes in document order, so the effect is the same.</p></note>

				<example><head>Applying Templates to Selected Nodes</head>
					<p>The following example processes all of the <code>given-name</code> children
of the <code>author</code> elements that are children of
<code>author-group</code>:</p>
					<eg><![CDATA[<xsl:template match="author-group">
  <fo:wrapper>
    <xsl:apply-templates select="author/given-name"/>
  </fo:wrapper>
</xsl:template>]]></eg>
					
				</example>
				<example><head>Applying Templates to Nodes that are not Descendants</head>
					<p>It is also possible to process elements that are not descendants of
the context node.  This example assumes that a <code>department</code>
element has <code>group</code> children and <code>employee</code>
descendants. It finds an employee's department and then processes
the <code>group</code> children of the <code>department</code>.</p>
					<eg><![CDATA[<xsl:template match="employee">
  <fo:block>
    Employee <xsl:apply-templates select="name"/> belongs to group
    <xsl:apply-templates select="ancestor::department/group"/>
  </fo:block>
</xsl:template>]]></eg>
				</example>
				<example><head>Matching by Schema-Defined Types</head>
				<p>It is possible to write template rules that are matched according to
				the schema-defined type of an element or attribute. The following example
				applies different formatting to the children of an element depending on their
				type:</p>
<eg><![CDATA[<xsl:template match="product">
  <table>
    <xsl:apply-templates select="*"/>
  </table>
</xsl:template>

<xsl:template match="product/*" priority="3">
  <tr>
    <td><xsl:value-of select="name()"/></td>
    <td><xsl:next-match/></td>
  </tr>
</xsl:template>

<xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2">  
  <xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/>
</xsl:template>

<xsl:template match="product/element(*, xs:date)" priority="2">
  <xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/>
</xsl:template>

<xsl:template match="product/*" priority="1.5">
  <xsl:value-of select="."/>
</xsl:template>]]></eg>

<p>The <elcode>xsl:next-match</elcode> instruction is described in <specref ref="apply-imports"/>.</p>

				</example>				
				
				<example><head>Re-ordering Elements in the Result Tree</head>
					<p>Multiple <elcode>xsl:apply-templates</elcode> elements can be used within a
single template to do simple reordering.  The following example
creates two HTML tables. The first table is filled with domestic sales
while the second table is filled with foreign sales.</p>
					<eg><![CDATA[<xsl:template match="product">
  <table>
    <xsl:apply-templates select="sales/domestic"/>
  </table>
  <table>
    <xsl:apply-templates select="sales/foreign"/>
  </table>
</xsl:template>]]></eg>
				</example>
				
					
					<example><head>Processing Recursive Structures</head>
					
					<p>It is possible for there to be two matching descendants where one
is a descendant of the other.  This case is not treated specially:
both descendants will be processed as usual.</p>
						<p> For example, given a source document</p>
						<eg><![CDATA[<doc><div><div></div></div></doc>]]></eg>
						<p>the rule</p>
						<eg><![CDATA[<xsl:template match="doc">
  <xsl:apply-templates select=".//div"/>
</xsl:template>]]></eg>
						<p>will process both the outer <code>div</code> and inner <code>div</code>
elements.</p>

<p>This means that if the template rule for the <code>div</code> element processes its own children,
then these grandchildren will be processed more than once, which is probably not what is required. 
The solution is to process one level at a time in a recursive descent, by using <code>select="div"</code>
in place of <code>select=".//div"</code></p>
					</example>
				
				<note>
					<p><phrase diff="chg" at="R">The <elcode>xsl:apply-templates</elcode> instruction
					 is most commonly used</phrase> to
process nodes that are descendants of the context node.  Such use
of <elcode>xsl:apply-templates</elcode> cannot result in non-terminating
processing loops.  However, when <elcode>xsl:apply-templates</elcode> is
used to process elements that are not descendants of the context node,
the possibility arises of non-terminating loops. For example,</p>
					<eg role="error"><![CDATA[<xsl:template match="foo">
  <xsl:apply-templates select="."/>
</xsl:template>]]></eg>
					<p>Implementations may be able to detect such loops in some cases, but
the possibility exists that a <termref def="dt-stylesheet">stylesheet</termref> may enter a non-terminating
loop that an implementation is unable to detect. This may present a
denial of service security risk.</p>
				</note>
			</div2>
			<div2 id="conflict">
				<head>Conflict Resolution for Template Rules</head>
				<p>It is possible for a node in a source document to match more than one 
<termref def="dt-template-rule">template rule</termref>.
<phrase diff="add" at="R">When this happens, only one template rule is evaluated for the node.</phrase>
 The template rule to be used is determined as follows:</p>
				<olist>
					<item>
					
<p diff="add" at="T">First, only the matching template rule or rules 
with the highest <termref def="dt-import-precedence">import precedence</termref> are considered. 
Other matching template rules with lower precedence are eliminated from consideration.</p>					
						
					</item>
					<item>
<p diff="add" at="T">Next, of the remaining matching 
rules, only those with the highest priority are considered. Other matching 
template rules with lower priority are eliminated from consideration. The priority of a template rule is
specified by the <code>priority</code> attribute on the <elcode>xsl:template</elcode> declaration.</p>					
					
						
<p><error spec="XT" type="static" class="SE" code="0530"><p>The value of this attribute
 <error.extra>the <code>priority</code> attribute of the <elcode>xsl:template</elcode> element</error.extra>
 <rfc2119>must</rfc2119> <phrase diff="chg" at="T">conform to the rules for the <code>xs:decimal</code>
 type defined in <bibref ref="xmlschema-2"/>. Negative values are permitted.</phrase>.</p></error>
							
						</p>
						<p>
							<termdef id="dt-default-priority" term="default priority">If no <code>priority</code>
attribute is specified on the <elcode>xsl:template</elcode> element, a <term>default
priority</term> is computed, based on the syntax of the pattern supplied in the <code>match</code> attribute.</termdef>
The rules are as follows:
						</p>
						<ulist>
							<item>
								<p>If the pattern contains multiple alternatives separated by
<code>|</code> , 
then the template rule is treated equivalently to a set of template
rules, one for each alternative. However,
it is not an error if a node matches more than one of the alternatives. </p>
							</item>
							<item>
							    <p>If the pattern has the form <code>/</code>, then the priority is &#x2212;0.5.</p>
							</item>
							<item>
								<p>If the pattern has the form of a <termref def="dt-qname">QName</termref> 
								optionally preceded by a <nt def="NT-PatternAxis">PatternAxis</nt>
or has the form <code>processing-instruction(</code><xnt spec="XP" ref="StringLiteral">StringLiteral</xnt><code>)</code> 
or <code>processing-instruction(</code><xnt spec="Names" ref="NT-NCName">NCName</xnt><code>)</code>
optionally preceded by a <nt def="NT-PatternAxis">PatternAxis</nt>,
then the priority is 0.</p>
							</item>
							<item>
							    <p>If the pattern has the form of an <xnt spec="XP" ref="ElementTest">ElementTest</xnt> or
							    <xnt spec="XP" ref="AttributeTest">AttributeTest</xnt>, 
							    optionally preceded by a <nt def="NT-PatternAxis">PatternAxis</nt>,
							    then the priority is as shown in the table below. In this table, the symbols
							    <var>E</var>, <var>A</var>, and <var>T</var> represent an arbitrary element name,
							    attribute name, and type name respectively, while the 
							    symbol <code>*</code> represents itself.
							     The presence or absence of the 
                  <phrase diff="chg" at="T">symbol <code>?</code> following a type name</phrase>
							    does not affect the priority.</p>
							    
					
<table border="1" cellpadding="5">
<thead>
  <tr><th align="left">Format</th><th align="left">Priority</th><th align="left">Notes</th></tr>
</thead>
<tbody>							    
  <tr><td><code>element()</code></td><td>&#x2212;0.5</td><td>(equivalent to <code>*</code>)</td></tr>
  <tr><td><code>element(*)</code></td><td>&#x2212;0.5</td><td>(equivalent to <code>*</code>)</td></tr>
  <tr><td><code>attribute()</code></td><td>&#x2212;0.5</td><td>(equivalent to <code>@*</code>)</td></tr>
  <tr><td><code>attribute(*)</code></td><td>&#x2212;0.5</td><td>(equivalent to <code>@*</code>)</td></tr>
  <tr><td><code>element(<var>E</var>)</code></td><td>0</td><td>(equivalent to E)</td></tr>
  <tr><td><code>element(*,<var>T</var>)</code></td><td>0</td><td>(matches by type only)</td></tr>
  <tr><td><code>attribute(<var>A</var>)</code></td><td>0</td><td>(equivalent to <code>@A</code>)</td></tr>
  <tr><td><code>attribute(*,<var>T</var>)</code></td><td>0</td><td>(matches by type only)</td></tr>  
  <tr><td><code>element(<var>E</var>,<var>T</var>)</code></td><td>0.25</td><td>(matches by name and type)</td></tr>
  <tr><td><code>schema-element(<var>E</var>)</code></td><td>0.25</td><td>(matches by substitution group and type)</td></tr>
  <tr><td><code>attribute(<var>A</var>,<var>T</var>)</code></td><td>0.25</td><td>(matches by name and type)</td></tr>
  <tr><td><code>schema-attribute(<var>A</var>)</code></td><td>0.25</td><td>(matches by name and type)</td></tr>
</tbody></table>
							    
							    
							    
							    
							</item>
<item>
<p>If the pattern has the form of a <xnt spec="XP" ref="DocumentTest">DocumentTest</xnt>,
then if it includes no <xnt spec="XP" ref="ElementTest">ElementTest</xnt> 
<phrase diff="add" at="ZA">or <xnt spec="XP" ref="SchemaElementTest">SchemaElementTest</xnt></phrase>
the priority is &#x2212;0.5. If it does
include an <xnt spec="XP" ref="ElementTest">ElementTest</xnt>
<phrase diff="add" at="ZA">or <xnt spec="XP" ref="SchemaElementTest">SchemaElementTest</xnt></phrase>, then the priority is the same as the priority
of that <xnt spec="XP" ref="ElementTest">ElementTest</xnt>
<phrase diff="add" at="ZA">or <xnt spec="XP" ref="SchemaElementTest">SchemaElementTest</xnt></phrase>, computed according to the table above.</p>

</item>
<item>
	<p>If the pattern has the form <xnt spec="Names" ref="NT-NCName">NCName</xnt><code>:*</code> 
or <code>*:</code><xnt spec="Names" ref="NT-NCName">NCName</xnt>,
optionally preceded by a <nt def="NT-PatternAxis">PatternAxis</nt>,
then the priority is &#x2212;0.25.</p>
							</item>
							<item>
								<p>If the pattern is any other
								 <xnt spec="XP" ref="NodeTest">NodeTest</xnt>, 
								 optionally preceded by a <nt def="NT-PatternAxis">PatternAxis</nt>,
then the priority is &#x2212;0.5.</p>
							</item>
							<item>
								<p>Otherwise, the priority is 0.5.</p>
							</item>
						</ulist>
						<note>
							<p>In many cases this means that highly selective patterns have higher
priority than less selective patterns. The most common kind of pattern (a pattern that tests for a
node of a <phrase diff="chg" at="P">particular kind, with a particular
 <termref def="dt-expanded-qname">expanded-QName</termref> 
or a particular type) </phrase> has
priority 0. The next less specific kind of pattern (a pattern that
tests for a node of a particular kind and an <termref def="dt-expanded-qname">expanded-QName</termref> with a
particular namespace URI) has priority &#x2212;0.25.  Patterns less specific
than this (patterns that just test for nodes <phrase diff="chg" at="Q">of a given kind</phrase>)
have priority &#x2212;0.5.  <phrase diff="add" at="Q">Patterns that specify both the name
and the required type have a priority of +0.25, putting them above patterns that
only specify the name <emph>or</emph> the type.</phrase>
Patterns more specific than <phrase diff="chg" at="Q">this, for example patterns that
include predicates or that specify the ancestry of the required node, </phrase>
have priority 0.5.</p>

<p>However, it is not invariably true that
a more selective pattern has higher priority than a less selective pattern.
For example, the priority of the pattern <code>node()[self::*]</code> is higher than that of
the pattern <code>salary</code>. <phrase diff="add" at="Q">Similarly, the patterns <code>attribute(*, xs:decimal)</code> and
<code>attribute(*, xs:short)</code> have the same priority, despite the fact that the latter pattern matches
a subset of the nodes matched by the former.</phrase>
Therefore, to achieve clarity in a <termref def="dt-stylesheet">stylesheet</termref>
it is good practice to allocate explicit priorities.</p>
						</note>
					</item>
				</olist>
				<p>
					<error spec="XT" type="dynamic" class="RE" code="0540"><p>It is a
					 <termref def="dt-recoverable-error">recoverable dynamic error</termref> if
 the conflict resolution algorithm for template rules
 leaves more than one matching template
rule.  <error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to select, from the matching
template rules that are left, the one that occurs last in
<termref def="dt-declaration-order">declaration order</termref>.</error.action>
					</p></error>
				</p>
			</div2>
			
			
<div2 id="modes">
<head>Modes</head>

<p><termdef id="dt-mode" term="mode"><term>Modes</term> 
allow a node in a <termref def="dt-source-tree">source tree</termref> to be processed multiple times, each time
producing a different result. They also allow different sets 
of <termref def="dt-template-rule">template rules</termref>
to be active when processing different
trees, for example when processing documents loaded using the <function>document</function> function
(see <specref ref="document"/>) or when processing
 <termref def="dt-temporary-tree">temporary trees</termref>.</termdef></p>

<p><termdef id="dt-default-mode" term="default mode">There is always a <term>default mode</term>
available. The default mode is an unnamed <termref def="dt-mode">mode</termref>, and it is used when
no <code>mode</code> attribute is specified on an <elcode>xsl:apply-templates</elcode> instruction.</termdef></p>

<p>Every <termref def="dt-mode">mode</termref> other than the
<termref def="dt-default-mode">default mode</termref> is identified by a <termref def="dt-qname">QName</termref>.</p>

<p>A <termref def="dt-template-rule">template rule</termref> is applicable to
one or more modes. The modes to which it is applicable are defined by the <code>mode</code> attribute
of the <elcode>xsl:template</elcode> element. 
If the attribute is omitted, then the template rule is applicable to the <termref def="dt-default-mode">default mode</termref>. If the attribute
is present, then its value <rfc2119>must</rfc2119> be a non-empty whitespace-separated list of tokens, each of which defines a mode
to which the template rule is applicable. Each token <rfc2119>must</rfc2119> be one of the following:</p>

<ulist>
<item><p>a <termref def="dt-qname">QName</termref>, which is expanded as described
in <specref ref="qname"/> to define the name of the mode</p></item>
<item><p>the token <code>#default</code>, to indicate that the template rule is applicable
 to the <termref def="dt-default-mode">default mode</termref></p></item>
<item><p>the token <code>#all</code>, to indicate that the
template rule is applicable to all modes <phrase diff="add" at="ZB">(that is, to the default
mode and to every mode that is named in an <elcode>xsl:apply-templates</elcode> instruction
or <elcode>xsl:template</elcode> declaration anywhere in the stylesheet)</phrase>.</p></item>
</ulist>

<p><error spec="XT" type="static" class="SE" code="0550"><p>It is a <termref def="dt-static-error">static error</termref>
if the list <error.extra>of modes in the <code>mode</code>
attribute of <elcode>xsl:template</elcode></error.extra> is empty,
if the same token is included more than once in the list, if the list contains an invalid token,
 or if the token <code>#all</code> appears together with any other value.</p></error></p>

<p>The  <elcode>xsl:apply-templates</elcode>
element also has an optional <code>mode</code> attribute. The value of this
attribute <rfc2119>must</rfc2119> either be a <termref def="dt-qname">QName</termref>, which is expanded as described
in <specref ref="qname"/> to define the name of a mode, or the token <code>#default</code>, to 
indicate that the <termref def="dt-default-mode">default mode</termref> is to be used, or the token <code>#current</code>, to indicate that
the <termref def="dt-current-mode">current mode</termref> is to be used. 
If the attribute is omitted, the <termref def="dt-default-mode">default mode</termref> is used.</p>

<p>When searching for a template rule to process each node selected by
the <elcode>xsl:apply-templates</elcode> instruction, only those template rules that are
applicable to the selected mode are considered.</p>

<p><termdef id="dt-current-mode" term="current mode">At any point in the processing
of a stylesheet, there is a <term>current mode</term>.  When the transformation is initiated,
the current mode is the <termref def="dt-default-mode">default mode</termref>, <phrase diff="chg" at="P">unless a different initial
mode has been supplied, as described in <specref ref="initiating"/>.</phrase> 
Whenever an <elcode>xsl:apply-templates</elcode>
instruction is evaluated, the current mode becomes the mode selected by this instruction.</termdef>
When a stylesheet function is called, the current mode becomes the <termref def="dt-default-mode">default mode</termref>.
No other instruction changes the current mode. On completion of the <elcode>xsl:apply-templates</elcode>
instruction, <phrase diff="add" at="P">or on return from a stylesheet function call, </phrase>
the current mode reverts to its previous value. The current mode is used when an
<elcode>xsl:apply-templates</elcode> instruction uses the syntax <code>mode="#current"</code>;
it is also used by the <elcode>xsl:apply-imports</elcode>
<phrase diff="add" at="O">and <elcode>xsl:next-match</elcode></phrase>
instructions (see <specref ref="apply-imports"/>).</p>

</div2>


			<div2 id="built-in-rule">
				<head>Built-in Template Rules</head>
				<p>When a node is selected by <elcode>xsl:apply-templates</elcode> and there is no
template rule in the <termref def="dt-stylesheet">stylesheet</termref> that can be used to 
process that node, a built-in template rule is evaluated instead. </p>
				<p>The built-in template rules apply to all modes.</p>
				
				<p>The built-in rule for document nodes and element nodes
is equivalent to calling <elcode>xsl:apply-templates</elcode> with no <code>select</code>
attribute, and with the <code>mode</code> attribute set to <code>#current</code>. If
the built-in rule was invoked with parameters, those parameters are passed on in the implicit
<elcode>xsl:apply-templates</elcode> instruction.</p>

<example><head>Using a Built-In Template Rule</head>
				<p>For example, suppose the stylesheet contains the following instruction:</p>
				<eg><![CDATA[<xsl:apply-templates select="title" mode="mm">
  <xsl:with-param name="init" select="10"/>
</xsl:apply-templates>]]></eg>
				<p>If there is no explicit template rule that matches the <code>title</code> element,
then the following implicit rule is used:</p>
				<eg><![CDATA[<xsl:template match="title" mode="#all">
  <xsl:param name="init"/>
  <xsl:apply-templates mode="#current">
    <xsl:with-param name="init" select="$init"/>
  </xsl:apply-templates>
</xsl:template>]]></eg>
</example>
				<p>The built-in <termref def="dt-template-rule">template rule</termref> 
for text and attribute nodes returns a text node containing the <termref def="dt-string-value">string value</termref> of the context node.
 It is effectively:</p>

<eg diff="chg" at="T"><![CDATA[<xsl:template match="text()|@*" mode="#all">
  <xsl:value-of select="string(.)"/>
</xsl:template>]]></eg>

<note diff="add" at="T"><p>This text node may have a string value that is zero-length.</p></note>

				<p>The built-in <termref def="dt-template-rule">template rule</termref> for processing instructions and comments
does nothing (it returns the empty sequence).</p>
				<eg><![CDATA[<xsl:template match="processing-instruction()|comment()" mode="#all"/>]]></eg>
				<p>The built-in <termref def="dt-template-rule">template rule</termref> for namespace nodes is also to do
nothing. There is no pattern that can match a namespace node, <phrase diff="chg" at="R">so the
built-in template rule is always used when <elcode>xsl:apply-templates</elcode> selects a
namespace node.</phrase></p>
				<p>The built-in <termref def="dt-template-rule">template rules</termref>
have lower <termref def="dt-import-precedence">import precedence</termref> than all other
template rules.  Thus, the stylesheet author can override a built-in template
rule by including an explicit template rule.</p>
			</div2>
			<div2 id="apply-imports">
				<head>Overriding Template Rules</head>
				<e:element-syntax name="apply-imports">
					<e:in-category name="instruction"/>
					<e:element name="with-param" repeat="zero-or-more"/>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				<e:element-syntax name="next-match" diff="add" at="O">
					<e:in-category name="instruction"/>
					<e:choice repeat="zero-or-more">
					    <e:element name="with-param"/>
				        <e:element name="fallback"/>
				    </e:choice>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>

				<p>A <termref def="dt-template-rule">template rule</termref> that
 is being used to override another template rule
  (see <specref ref="conflict"/>) can use the
<elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>
instruction to invoke the overridden template rule. The <elcode>xsl:apply-imports</elcode> instruction
only considers template rules in imported stylesheet modules; the <elcode>xsl:next-match</elcode>
instruction considers all other template rules of lower <termref def="dt-import-precedence">import precedence</termref>
 and/or priority.
 <phrase diff="chg" at="R">Both instructions will invoke the built-in template rule for the node (see
 <specref ref="built-in-rule"/>) if no other template rule is found.</phrase></p>
				<p>
<termdef id="dt-current-template-rule" term="current template rule">At any point in the processing
 of a <termref def="dt-stylesheet">stylesheet</termref>, there may be a
<term>current template rule</term>.  Whenever a <termref def="dt-template-rule">template rule</termref> is
chosen <phrase diff="chg" at="Y">as a result of evaluating <elcode>xsl:apply-templates</elcode>, 
<elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode></phrase>, 
the template rule becomes the current
template rule for the evaluation of the rule's sequence constructor. When an
<elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
<phrase diff="add" at="Z">or <elcode>xsl:analyze-string</elcode> 
instruction is evaluated, or when evaluating a sequence constructor contained in
an <elcode>xsl:sort</elcode> or <elcode>xsl:key</elcode> element, or when</phrase>
a <termref def="dt-stylesheet-function">stylesheet function</termref>
 is called (see <specref ref="stylesheet-functions"/>), the current
template rule becomes null for the evaluation of that instruction
or function.</termdef>
				</p>
				<p>The current template rule is not affected by invoking
named templates (see <specref ref="named-templates"/>) or named attribute
sets (see <specref ref="attribute-sets"/>). While evaluating a 
<termref def="dt-global-variable">global variable</termref>
<phrase diff="chg" at="M">or the default value of a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref></phrase>
 (see <specref ref="global-variables"/>) 
the current template rule is null.</p>

<note diff="add" at="Q"><p>These rules ensure that when <elcode>xsl:apply-imports</elcode> or
<elcode>xsl:next-match</elcode> is called, the <termref def="dt-context-item">context item</termref>
 is the same as when the
current template rule was invoked, and is always a node.</p></note>
				<p>
					<phrase diff="add" at="O">Both <elcode>xsl:apply-imports</elcode> 
					and <elcode>xsl:next-match</elcode> search</phrase> for 
a <termref def="dt-template-rule">template rule</termref> that matches the
<termref def="dt-context-node">context node</termref>, and that is applicable to the 
<termref def="dt-current-mode">current mode</termref>
 (see <specref ref="modes"/>). In choosing
a template rule, <phrase diff="add" at="O">they use</phrase> the usual criteria such as the priority and 
<termref def="dt-import-precedence">import precedence</termref> of 
the template rules, but <phrase diff="add" at="O">they consider as candidates only
a subset of the template rules in the <termref def="dt-stylesheet">stylesheet</termref>. This subset differs between the
two instructions:</phrase></p>

<ulist>
<item><p>The <elcode>xsl:apply-imports</elcode> instruction
considers as candidates 
only those template rules contained in <termref def="dt-stylesheet-level">stylesheet levels</termref>
that are descendants in the <termref def="dt-import-tree">import tree</termref>
of the <termref def="dt-stylesheet-level">stylesheet 
level</termref> that contains the
 <termref def="dt-current-template-rule">current template rule</termref>.</p>
				<note>
					<p>This is <emph>not</emph> the same as saying that the search considers
all template rules whose import precedence is lower than that of the current template rule.</p>
				</note>
</item>
<item><p>The <elcode>xsl:next-match</elcode> instruction
considers as candidates all those template rules that come after the 
<termref def="dt-current-template-rule">current template rule</termref>
in the ordering of template rules implied by the conflict resolution rules
given in <specref ref="conflict"/>. That is, it considers all template rules
with lower <termref def="dt-import-precedence">import precedence</termref>
 than the <termref def="dt-current-template-rule">current template rule</termref>, 
plus the template rules that are at the same import precedence
that have lower priority than the current template rule. If the processor
has recovered from the error that occurs when two matching template rules have the
same import precedence and priority, then it also considers all matching template rules 
with the same import precedence and priority that occur before the current template
rule in <termref def="dt-declaration-order">declaration order</termref>.</p>

<note diff="add" at="ZA"><p>As explained in <specref ref="conflict"/>, a template rule whose
match pattern contains multiple alternatives separated by <code>|</code> is treated equivalently
to a set of template rules, one for each alternative. This means that where the same node matches
more than one alternative, and the alternatives have different priority, it is possible for an
<elcode>xsl:next-match</elcode> instruction to cause the current template rule
to be invoked recursively. This situation does not occur when the alternatives have the 
same priority.</p></note>

</item>

</ulist>

				<p>If no matching template rule is found that satisfies these criteria, the
built-in template rule for the
 node <phrase diff="chg" at="P">kind</phrase> is used (see <specref ref="built-in-rule"/>).</p>

				<p>An <elcode>xsl:apply-imports</elcode> 
				<phrase diff="add" at="O">or <elcode>xsl:next-match</elcode></phrase> instruction may use
<elcode>xsl:with-param</elcode> child elements to pass
parameters to the chosen <termref def="dt-template-rule">template rule</termref>
(see <specref ref="with-param"/>). It also passes on any <termref def="dt-tunnel-parameter">tunnel parameters</termref>
as described in <specref ref="tunnel-params"/>.</p>
				<p>
					<error spec="XT" type="dynamic" class="DE" code="0560"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
<elcode>xsl:apply-imports</elcode> <phrase diff="add" at="O">or <elcode>xsl:next-match</elcode></phrase> is evaluated when the
 <termref def="dt-current-template-rule">current template rule</termref> is null.</p></error>
				</p>
				
				<example><head>Using <code>xsl:apply-imports</code></head>
					<p>For example, suppose the stylesheet <code>doc.xsl</code> contains a
<termref def="dt-template-rule">template rule</termref> for <code>example</code> elements:</p>
					<eg><![CDATA[<xsl:template match="example">
  <pre><xsl:apply-templates/></pre>
</xsl:template>]]></eg>
					<p>Another stylesheet could import <code>doc.xsl</code> and modify the
treatment of <code>example</code> elements as follows:</p>
					<eg><![CDATA[<xsl:import href="doc.xsl"/>

<xsl:template match="example">
  <div style="border: solid red">
     <xsl:apply-imports/>
  </div>
</xsl:template>]]></eg>
					<p>The combined effect would be to transform an <code>example</code>
into an element of the form:</p>
					<eg><![CDATA[<div style="border: solid red"><pre>...</pre></div>]]></eg>
				</example>
				<p>An <elcode>xsl:fallback</elcode> instruction appearing as a child
				of an <elcode>xsl:next-match</elcode> instruction is ignored by an XSLT 2.0 processor,
				but can be used to define fallback behavior when the stylesheet is processed by an
				XSLT 1.0 processor in forwards-compatible mode.</p>
			</div2>
		</div1>
		<div1 id="for-each">
			<head>Repetition</head>
			<e:element-syntax name="for-each">
				<e:in-category name="instruction"/>
				<e:attribute name="select" required="yes">
					<e:data-type name="expression"/>
				</e:attribute>
				<e:sequence>
					<e:element repeat="zero-or-more" name="sort"/>
					<e:model name="sequence-constructor"/>
				</e:sequence>
				<e:allowed-parents>
					<e:parent-category name="sequence-constructor"/>
				</e:allowed-parents>
			</e:element-syntax>
			<p>The <elcode>xsl:for-each</elcode> instruction
processes each item in a sequence of items, evaluating the
<termref def="dt-sequence-constructor">sequence constructor</termref>
within the <elcode>xsl:for-each</elcode> instruction once for each item
in that sequence.</p>
			<p>
The <code>select</code> attribute is <rfc2119>required</rfc2119>, and 
the <termref def="dt-expression">expression</termref> <rfc2119>must</rfc2119> evaluate to a sequence, 
called the input sequence. If there is an <elcode>xsl:sort</elcode>
element present (see <specref ref="sorting"/>) the input sequence
is sorted to produce a sorted sequence. Otherwise, the sorted sequence
is the same as the input sequence.</p>
			<p diff="chg" at="T">The <elcode>xsl:for-each</elcode> instruction contains a
 <termref def="dt-sequence-constructor">sequence constructor</termref>.   
The <termref def="dt-sequence-constructor">sequence constructor</termref>
is evaluated once for each item in the sorted sequence,
with the <termref def="dt-focus">focus</termref> set as follows:</p>
			<ulist>
				<item>
					<p>The <termref def="dt-context-item">context item</termref> is the item being processed. 
If this is a node, it will
also be the <termref def="dt-context-node">context node</termref>. If it
is not a node, there will be no context node: that is, <phrase diff="chg" at="T">any attempt to
reference the context node will result in a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>.</phrase>
					</p>
				</item>
				<item>
					<p>The <termref def="dt-context-position">context position</termref> is the position of this item 
in the sorted sequence.</p>
				</item>
				<item>
					<p>The <termref def="dt-context-size">context size</termref> is the size
 of the sorted sequence (which is the same as the
size of the input sequence).</p>
				</item>
				
			</ulist>
			<p> For each item in the input sequence, evaluating the
 <termref def="dt-sequence-constructor">sequence constructor</termref> produces a sequence
of items (see <specref ref="sequence-constructors"/>). 
These output sequences are concatenated; <phrase diff="chg" at="R">if item <var>Q</var> follows
item <var>P</var> in the sorted sequence, then the result of evaluating the sequence constructor
with <var>Q</var> as the context item is concatenated after the result of evaluating the sequence constructor 
with <var>P</var> as the context item.</phrase>
The result of the <elcode>xsl:for-each</elcode> instruction
is the concatenated sequence of items.</p>
			
			<note>
				<p>With XSLT 1.0, the selected nodes were processed in document order.
With XSLT 2.0, XPath expressions that would have been valid under XPath 1.0 (such
as path expressions and union expressions) will return a sequence of nodes
that is already in document order, so backwards compatibility is maintained.</p>
			</note>
			<example><head>Using <code>xsl:for-each</code></head>
				<p>For example, given an XML document with this structure</p>
				<eg><![CDATA[<customers>
  <customer>
    <name>...</name>
    <order>...</order>
    <order>...</order>
  </customer>
  <customer>
    <name>...</name>
    <order>...</order>
    <order>...</order>
  </customer>
</customers>]]></eg>
				<p>the following would create an HTML document containing a table with
a row for each <code>customer</code> element</p>
				<eg><![CDATA[<xsl:template match="/">
  <html>
    <head>
      <title>Customers</title>
    </head>
    <body>
      <table>
	<tbody>
	  <xsl:for-each select="customers/customer">
	    <tr>
	      <th>
		<xsl:apply-templates select="name"/>
	      </th>
	      <xsl:for-each select="order">
		<td>
		  <xsl:apply-templates/>
		</td>
	      </xsl:for-each>
	    </tr>
	  </xsl:for-each>
	</tbody>
      </table>
    </body>
  </html>
</xsl:template>]]></eg>
			</example>
		</div1>
		<div1 id="conditionals">
			<head>Conditional Processing</head>
			<p>There are two instructions in XSLT that support conditional
processing: <elcode>xsl:if</elcode> and
<elcode>xsl:choose</elcode>. The <elcode>xsl:if</elcode> instruction provides
simple if-then conditionality; the <elcode>xsl:choose</elcode> instruction
supports selection of one choice when there are several
possibilities.</p>
			<div2 id="xsl-if">
				<head>Conditional Processing with <elcode>xsl:if</elcode>
				</head>
				<e:element-syntax name="if">
					<e:in-category name="instruction"/>
					<e:attribute name="test" required="yes">
						<e:data-type name="expression"/>
					</e:attribute>
					<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				<p>The <elcode>xsl:if</elcode> element has a mandatory <code>test</code> attribute,
which specifies an <termref def="dt-expression">expression</termref>.
The content is a
 <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>
				<p>The result of the <elcode>xsl:if</elcode> instruction
depends on the <xtermref spec="XP" ref="dt-ebv">effective boolean value</xtermref> of the expression
in the <code>test</code> attribute. The rules for determining the
effective boolean value of an expression are given in <bibref ref="xpath20"/>: they
are the same as the rules used for XPath conditional expressions.</p>
				<p>If the effective boolean value of
				the <termref def="dt-expression">expression</termref> is true, then
the <termref def="dt-sequence-constructor">sequence constructor</termref> is evaluated
(see <specref ref="sequence-constructors"/>),
and the resulting node sequence is returned as the result of
the <elcode>xsl:if</elcode> instruction; otherwise, 
<phrase diff="add" at="R">the sequence constructor is not evaluated, and</phrase> 
the empty sequence is returned.</p>
				<example><head>Using <code>xsl:if</code></head>
					<p>In the following example, the names in a group of names are formatted
as a comma separated list:</p>
					<eg><![CDATA[<xsl:template match="namelist/name">
  <xsl:apply-templates/>
  <xsl:if test="not(position()=last())">, </xsl:if>
</xsl:template>]]></eg>
					<p>The following colors every other table row yellow:</p>
					<eg><![CDATA[<xsl:template match="item">
  <tr>
    <xsl:if test="position() mod 2 = 0">
       <xsl:attribute name="bgcolor">yellow</xsl:attribute>
    </xsl:if>
    <xsl:apply-templates/>
  </tr>
</xsl:template>]]></eg>
				</example>
			</div2>
			<div2 id="xsl-choose">
				<head>Conditional Processing with <elcode>xsl:choose</elcode>
				</head>
				<e:element-syntax name="choose">
					<e:in-category name="instruction"/>
					<e:sequence>
						<e:element repeat="one-or-more" name="when"/>
						<e:element repeat="zero-or-one" name="otherwise"/>
					</e:sequence>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				<e:element-syntax name="when">
					<e:attribute name="test" required="yes">
						<e:data-type name="expression"/>
					</e:attribute>
					<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent name="choose"/>
					</e:allowed-parents>
				</e:element-syntax>
				<e:element-syntax name="otherwise">
					<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent name="choose"/>
					</e:allowed-parents>
				</e:element-syntax>
				
<p>The <elcode>xsl:choose</elcode> element selects one among a number of
possible alternatives. It consists of a sequence of one or more
<elcode>xsl:when</elcode> elements followed by an optional
<elcode>xsl:otherwise</elcode> element.  Each <elcode>xsl:when</elcode>
element has a single attribute, <code>test</code>, which specifies an
<termref def="dt-expression">expression</termref>. The content of the
<elcode>xsl:when</elcode> and <elcode>xsl:otherwise</elcode> elements is a
<termref def="dt-sequence-constructor">sequence constructor</termref>.</p>

<p>When an <elcode>xsl:choose</elcode> element is processed, each
of the <elcode>xsl:when</elcode> elements is tested in turn
(that is, in <phrase diff="chg" at="R">the order that</phrase> the elements appear in the stylesheet),
until one of the 
<elcode>xsl:when</elcode> elements is satisfied. <phrase diff="add" at="R">If none of the
<elcode>xsl:when</elcode> elements is satisfied, then the <elcode>xsl:otherwise</elcode> element
is considered, as described below.</phrase></p>

<p>An <elcode>xsl:when</elcode> element is satisfied if
the <xtermref spec="XP" ref="dt-ebv">effective boolean value</xtermref> of the <termref def="dt-expression">expression</termref>
in its <code>test</code> attribute is <code>true</code>. The rules for determining the
effective boolean value of an expression are given in <bibref ref="xpath20"/>: they
are the same as the rules used for XPath conditional expressions.</p>

<p>The content
of the first, and only the first, <elcode>xsl:when</elcode> element 
that is satisfied is evaluated, 
and the resulting sequence is returned as the result of the
<elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode>
element is satisfied,
the content of the <elcode>xsl:otherwise</elcode> element is
evaluated, and the resulting sequence is returned as the result
of the <elcode>xsl:choose</elcode> instruction.
If no <elcode>xsl:when</elcode> element is satisfied, and no
<elcode>xsl:otherwise</elcode> element is present, the result of the
<elcode>xsl:choose</elcode> instruction
is an empty sequence.</p>

<p>Only the <phrase diff="chg" at="Q">sequence</phrase> constructor 
of the selected <elcode>xsl:when</elcode> or <elcode>xsl:otherwise</elcode>
instruction is evaluated. The <code>test</code> expressions
for <elcode>xsl:when</elcode> instructions after the selected one are not evaluated.</p>

				<example><head>Using <code>xsl:choose</code></head>
					<p>The following example enumerates items in an ordered list using
arabic numerals, letters, or roman numerals depending on the depth to
which the ordered lists are nested.</p>
					<eg><![CDATA[<xsl:template match="orderedlist/listitem">
  <fo:list-item indent-start='2pi'>
    <fo:list-item-label>
      <xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/>
      <xsl:choose>
        <xsl:when test='$level=1'>
          <xsl:number format="i"/>
        </xsl:when>
        <xsl:when test='$level=2'>
          <xsl:number format="a"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number format="1"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:text>. </xsl:text>
    </fo:list-item-label>
    <fo:list-item-body>
      <xsl:apply-templates/>
    </fo:list-item-body>
  </fo:list-item>
</xsl:template>]]></eg>
				</example>
			</div2>
		</div1>
		<div1 id="variables-and-parameters">
			<head>Variables and Parameters</head>

<p><termdef id="dt-variable-binding-element" term="variable-binding element">The 
two elements <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode>
are referred to as <term>variable-binding elements</term>
</termdef>.</p>


<p><termdef id="dt-variable" term="variable">The <elcode>xsl:variable</elcode> element declares a
<term>variable</term>, which may be a <termref def="dt-global-variable">global variable</termref>
 or a <termref def="dt-local-variable">local variable</termref>.</termdef></p>
 
<p><termdef id="dt-parameter" term="parameter">The <elcode>xsl:param</elcode>
element declares a <term>parameter</term>, which may be a 
<termref def="dt-stylesheet-parameter">stylesheet parameter</termref>,
a <termref def="dt-template-parameter">template parameter</termref>,
or a <termref def="dt-function-parameter">function parameter</termref>. A parameter
is a <termref def="dt-variable">variable</termref> with the additional property that its value can be set
by the caller when the stylesheet, the template, or the function is invoked.</termdef></p>

<p><termdef id="dt-value" term="value">A variable is a binding between a name and a value.  
The <term>value</term> of a variable is
any sequence (of nodes and/or atomic values), as defined in <bibref ref="xpath-datamodel"/>.</termdef></p>

<div2 id="variables"><head>Variables</head>

			<e:element-syntax name="variable" diff="chg" at="Q">
				<e:in-category name="declaration"/>
				<e:in-category name="instruction"/>
				<e:attribute name="name" required="yes">
					<e:data-type name="qname"/>
				</e:attribute>
				<e:attribute name="select">
					<e:data-type name="expression"/>
				</e:attribute>
				<e:attribute name="as">
					<e:data-type name="sequence-type"/>
				</e:attribute>
				<e:model name="sequence-constructor"/>
				<e:allowed-parents>
					<e:parent name="stylesheet"/>
					<e:parent name="transform"/>
					<e:parent name="function"/>
					<e:parent-category name="sequence-constructor"/>
				</e:allowed-parents>
			</e:element-syntax>


			

			<p>The <elcode>xsl:variable</elcode> element has a
<rfc2119>required</rfc2119> <code>name</code> attribute, which specifies the name of the
variable.  The value of the <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, which is expanded as described
in <specref ref="qname"/>.</p>
			<p>The <elcode>xsl:variable</elcode> element has an
optional <code diff="chg" at="M">as</code> attribute, which specifies the
<termref def="dt-required-type">required type</termref> of the
variable.  The value of the <code diff="chg" at="M">as</code> attribute is a 
<xnt spec="XP" ref="SequenceType">SequenceType</xnt>, 
as defined in <bibref ref="xpath20"/>.</p>

<p><termdef id="dt-supplied-value" term="supplied value">The value of the variable is 
computed using the <termref def="dt-expression">expression</termref> given in the
<code>select</code> attribute or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>,
as described in <specref ref="variable-values"/>. 
This value is referred to as the <term>supplied value</term> of the variable.</termdef>
<phrase diff="add" at="R">If the <elcode>xsl:variable</elcode> element has a <code>select</code>
attribute, then the sequence constructor <rfc2119>must</rfc2119> be empty.</phrase></p>

<p>If the <code diff="chg" at="M">as</code> attribute 
is specified, then the <termref def="dt-supplied-value">supplied value</termref> of the
variable is converted to the required type, using the 
<termref def="dt-function-conversion-rules" diff="add" at="M">function conversion rules</termref>.</p>

<p><error spec="XT" type="type" class="TE" code="0570"><p>It is a <termref def="dt-type-error">type error</termref>
if the <termref def="dt-supplied-value">supplied value</termref> of a variable
cannot be converted to the required type.</p></error>
			</p>
			<p>If the <code diff="chg" at="M">as</code> attribute is omitted, the
			 <termref def="dt-supplied-value">supplied value</termref> of the variable is used
directly, and no conversion takes place.</p>
			
			
			
			


</div2>
<div2 id="parameters"><head>Parameters</head>

			<e:element-syntax name="param" diff="chg" at="M">
				<e:in-category name="declaration"/>
				<e:attribute name="name" required="yes">
					<e:data-type name="qname"/>
				</e:attribute>
				<e:attribute name="select">
					<e:data-type name="expression"/>
				</e:attribute>
				<e:attribute name="as">
					<e:data-type name="sequence-type"/>
				</e:attribute>
				<e:attribute name="required">
					<e:constant value="yes"/>
					<e:constant value="no"/>
				</e:attribute>
				<e:attribute name="tunnel">
					<e:constant value="yes"/>
					<e:constant value="no"/>
				</e:attribute>				
				<e:model name="sequence-constructor"/>
				<e:allowed-parents>
					<e:parent name="stylesheet"/>
					<e:parent name="transform"/>
					<e:parent name="function"/>
					<e:parent name="template"/>
				</e:allowed-parents>
			</e:element-syntax>

<p>The <elcode>xsl:param</elcode> element may be used as a child of <elcode>xsl:stylesheet</elcode>, to define
a parameter to the transformation; or as a child of <elcode>xsl:template</elcode> to define a parameter to a
template, which may be supplied when the template is invoked using <elcode>xsl:call-template</elcode>,
<elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>
<phrase diff="add" at="O">or <elcode>xsl:next-match</elcode></phrase>; or as a child of <elcode>xsl:function</elcode> to define a parameter
to a stylesheet function, which may be supplied when the function is called from an XPath <termref def="dt-expression">expression</termref>.</p>

			<p>The <elcode>xsl:param</elcode> element has a
<rfc2119>required</rfc2119> <code>name</code> attribute, which specifies the name of the
parameter.  The value of the <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, which is expanded as described
in <specref ref="qname"/>.</p>

<p><error spec="XT" type="static" class="SE" code="0580"><p>It is a <termref def="dt-static-error">static error</termref> if two
parameters of a template or of a stylesheet function have the same name.</p></error></p>

<note diff="add" at="R"><p>For rules concerning stylesheet parameters, see <specref ref="global-variables"/>. Local 
variables may <termref def="dt-shadows">shadow</termref> template parameters and function parameters: see
<specref ref="scope-of-variables"/>.</p></note>

<p>The <termref def="dt-supplied-value">supplied value</termref> of the parameter is the
value supplied by the caller. If no value was supplied by the caller, and if the parameter
is not mandatory, then the supplied value is 
computed using the <termref def="dt-expression">expression</termref> given in the
<code>select</code> attribute or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>,
as described in <specref ref="variable-values"/>.
<phrase diff="add" at="R">If the <elcode>xsl:param</elcode> element has a <code>select</code>
attribute, then the sequence constructor <rfc2119>must</rfc2119> be empty.</phrase></p>

<note diff="add" at="R"><p>This specification does not dictate whether and when the default value
of a parameter is evaluated. For example, if the default is specified as 
<code>&lt;xsl:param name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</code>, then it is not specified whether a
distinct <code>foo</code> element node will be created on each invocation of the template, or whether
the same <code>foo</code> element node will be used for each invocation. However, it is permissible for the default
value to depend on the values of other parameters, or on the evaluation context, in which case the default must
effectively be evaluated on each invocation.</p></note>

			<p>The <elcode>xsl:param</elcode> element has an
optional <code diff="chg" at="M">as</code> attribute, which specifies the
<termref def="dt-required-type">required type</termref> of the
parameter.  The value of the <code diff="chg" at="M">as</code> attribute is a 
<xnt spec="XP" ref="SequenceType">SequenceType</xnt>, 
as defined in <bibref ref="xpath20"/>.</p>

<p>If the <code diff="chg" at="M">as</code> attribute 
is specified, then the <termref def="dt-supplied-value">supplied value</termref> of the
parameter is converted to the required type, using the
<termref def="dt-function-conversion-rules" diff="add" at="M">function conversion rules</termref>.</p>

<p><error spec="XT" type="type" class="TE" code="0590"><p>It is a <termref def="dt-type-error">type error</termref>
if the conversion of the <termref def="dt-supplied-value">supplied value</termref> of a
parameter to its required type fails.</p></error></p>
			
<p>If the <code diff="chg" at="M">as</code> attribute is omitted, the
 <termref def="dt-supplied-value">supplied value</termref> of the 
parameter is used directly, and no conversion takes place.</p>

			

<p>The optional <code>required</code> attribute may be used
to indicate that a parameter is mandatory. This attribute may be specified for 
<termref def="dt-stylesheet-parameter">stylesheet parameters</termref> and for
<termref def="dt-template-parameter">template parameters</termref>;
it <rfc2119>must not</rfc2119> be specified for <termref def="dt-function-parameter">function parameters</termref>, 
which are always mandatory. <phrase diff="add" at="R">A parameter is mandatory
if it is a <termref def="dt-function-parameter">function parameter</termref> or
if the <code>required</code> attribute is present and has the value <code>yes</code>. Otherwise,
the parameter is optional. If the parameter is mandatory, then </phrase>
the <elcode>xsl:param</elcode> element <rfc2119>must</rfc2119> be empty and <rfc2119>must not</rfc2119> have a <code>select</code>
attribute.</p>

<p><error spec="XT" type="type" class="TE" code="0600"><p>If a default value is given explicitly, that is, 
if there is either a <code>select</code>
attribute or a non-empty <termref def="dt-sequence-constructor">sequence constructor</termref>, then 
it is a <termref def="dt-type-error">type error</termref> if the default value
cannot be converted to the required type, using the
<termref def="dt-function-conversion-rules" diff="add" at="M">function conversion rules</termref>.</p></error></p>

<p>If an optional parameter has no <code>select</code>
attribute and has an empty <termref def="dt-sequence-constructor">sequence constructor</termref>, 
and if there is no <code>as</code> attribute, then the default value of the parameter 
is a zero length string.</p>

<p><error spec="XT" type="dynamic" class="DE" code="0610"><p>If an optional parameter has no <code>select</code>
attribute and has an empty <termref def="dt-sequence-constructor">sequence constructor</termref>, 
and if there is an <code>as</code> attribute, then the default value of the parameter 
is an empty sequence. If the empty sequence is not a valid instance of the required type
defined in the <code>as</code> attribute, then the parameter is treated as a required
parameter, which means that it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if the caller supplies no value for the parameter.</p></error></p> 

<note diff="add" at="R"><p>The effect of these rules is that specifying
<code>&lt;xsl:param name="p" as="xs:date" select="2"/&gt;</code>
is an error, but if the default value of the parameter is never used, then the processor has discretion whether
or not to report the error. By contrast, 
<code>&lt;xsl:param name="p" as="xs:date"/&gt;</code>
 is treated as if <code>required="yes"</code>
had been specified: the empty sequence is not a valid instance of <code>xs:date</code>, so in effect there is no default
value and the parameter is therefore treated as being mandatory.</p></note>

<p>The optional <code>tunnel</code> attribute may be used
to indicate that a parameter is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. 
The default is <code>no</code>; the value <code>yes</code> may be specified only
for <termref def="dt-template-parameter">template parameters</termref>.
Tunnel parameters are described in <specref ref="tunnel-params"/></p>


				

</div2>




			<div2 id="variable-values">
				<head>Values of Variables and Parameters</head>
				<p>A <termref def="dt-variable-binding-element">variable-binding element</termref>
 may specify the <termref def="dt-supplied-value">supplied value</termref> of the <termref def="dt-variable">variable</termref> 
 or <termref def="dt-parameter">parameter</termref> in
<phrase diff="chg" at="Q">four</phrase> different ways.</p>
				<ulist>
				
<item><p>If the <termref def="dt-variable-binding-element">variable-binding element</termref> has a <code>select</code>
attribute, then the value of the attribute <rfc2119>must</rfc2119> be an
<termref def="dt-expression">expression</termref> and the <termref def="dt-supplied-value">supplied value</termref> of the variable
is the value that results from evaluating the expression.  In this
case, the content of the variable-binding element <rfc2119>must</rfc2119> be empty.</p></item>

<item><p>If the <termref def="dt-variable-binding-element">variable-binding element</termref> 
has empty content and <phrase diff="chg" at="Q">has neither 
a <code>select</code> attribute nor an <code>as</code> attribute</phrase>, 
then the <termref def="dt-supplied-value">supplied value</termref> of the variable is a
zero-length string. Thus</p>
<eg><![CDATA[<xsl:variable name="x"/>]]></eg>
<p>is equivalent to</p>
<eg><![CDATA[<xsl:variable name="x" select="''"/>]]></eg>
</item>

<item><p diff="chg" at="ZA">If a 
<termref def="dt-variable-binding-element">variable-binding element</termref> has no <code>select</code>
attribute and has non-empty content (that is, the variable-binding element
has one or more child nodes), and has no <code>as</code> attribute,
then the content of the
variable-binding element specifies the <termref def="dt-supplied-value">supplied value</termref>. 
The content of the variable-binding element is a
<termref def="dt-sequence-constructor">sequence constructor</termref>; a new
document is constructed with a document
node having as its children
the sequence of nodes that results from evaluating the sequence constructor
and then applying the rules given in <specref ref="constructing-complex-content"/>.
The value of the variable is then a singleton sequence containing 
this document node. For further information, see
<specref ref="temporary-trees"/>.
</p></item>

<item><p>If a <termref def="dt-variable-binding-element">variable-binding element</termref>
 has an <code>as</code> attribute but no <code>select</code> attribute, 
then the <termref def="dt-supplied-value">supplied value</termref>
is the sequence that results from evaluating the (possibly empty)
<termref def="dt-sequence-constructor">sequence constructor</termref> contained within
 the variable-binding element (see <specref ref="sequence-constructors"/>).
</p></item>

</ulist>

<p>These combinations are summarized in the table below.</p>

<table border="1" cellpadding="5">
<col width="12%"/><col width="12%"/><col width="12%"/><col/>
<thead>
<tr>
<th align="left">select attribute</th>
<th align="left">as attribute</th>
<th align="left">content</th>
<th align="left">Effect</th>
</tr>
</thead>
<tbody>
<tr><td valign="top">present</td><td valign="top">absent</td><td valign="top">empty</td>
<td valign="top">Value is obtained by evaluating the <code>select</code> attribute</td></tr>
<tr><td valign="top">present</td><td valign="top">present</td><td valign="top">empty</td>
<td valign="top">Value is obtained by evaluating the <code>select</code> attribute, adjusted to the type required by the <code>as</code> attribute</td></tr>
<tr><td valign="top">present</td><td valign="top">absent</td><td valign="top">present</td>
<td valign="top">Static error</td></tr>
<tr><td valign="top">present</td><td valign="top">present</td><td valign="top">present</td>
<td valign="top">Static error</td></tr>
<tr><td valign="top">absent</td><td valign="top">absent</td><td valign="top">empty</td>
<td valign="top">Value is a zero-length string</td></tr>
<tr><td valign="top">absent</td><td valign="top">present</td><td valign="top">empty</td>
<td valign="top">Value is an empty sequence, provided the <code>as</code> attribute permits an empty sequence</td></tr>
<tr><td valign="top">absent</td><td valign="top">absent</td><td valign="top">present</td>
<td valign="top"><phrase diff="chg" at="ZA">Value is a document node whose content
is obtained by evaluating the sequence constructor</phrase></td></tr>
<tr><td valign="top">absent</td><td valign="top">present</td><td valign="top">present</td>
<td valign="top">Value is obtained by evaluating the sequence constructor, adjusted to the type required by the <code>as</code> attribute</td></tr>

</tbody>
</table>

<p><error spec="XT" type="static" class="SE" code="0620"><p>It is a <termref def="dt-static-error">static error</termref> if 
a <termref def="dt-variable-binding-element">variable-binding element</termref> has a <code>select</code>
attribute and has non-empty content.</p></error></p>

<example>
<head>Values of Variables</head>
<p>The value of the following variable is the sequence of integers (1, 2, 3):</p>

<eg><![CDATA[<xsl:variable name="i" as="xs:integer*" select="1 to 3"/>]]></eg>

<p>The value of the following variable is an integer, assuming that the attribute
<code>@size</code> exists, and is annotated either as an integer, or as 
<phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>:</p>

<eg><![CDATA[<xsl:variable name="i" as="xs:integer" select="@size"/>]]></eg>

<p>The value of the following variable is a zero-length string:</p>

<eg><![CDATA[<xsl:variable name="z"/>]]></eg>

<p>The value of the following variable is document node containing an empty element as a 
child:</p>

<eg><![CDATA[<xsl:variable name="doc"><c/></xsl:variable>]]></eg>

<p>The value of the following variable is sequence of integers (2, 4, 6):</p>

<eg><![CDATA[<xsl:variable name="seq" as="xs:integer*">
  <xsl:for-each select="1 to 3">
    <xsl:sequence select=".*2"/>
  </xsl:for-each>
</xsl:variable>]]></eg>

<p>The value of the following variable is sequence of parentless attribute nodes:</p>

<eg><![CDATA[<xsl:variable name="attset" as="attribute()+">
  <xsl:attribute name="x">2</xsl:attribute>
  <xsl:attribute name="y">3</xsl:attribute>
  <xsl:attribute name="z">4</xsl:attribute>    
</xsl:variable>]]></eg>

<p>The value of the following variable is an empty sequence:</p>

<eg diff="chg" at="Z"><![CDATA[<xsl:variable name="empty" as="empty-sequence()"/>]]></eg>

</example>



<p>The actual value of the variable depends on the <termref def="dt-supplied-value">supplied value</termref>,
as described above, and the required type, which is determined by 
the value of the <code diff="chg" at="M">as</code> attribute.</p>

				<example><head>Pitfalls with Numeric Predicates</head>
					<p>When a variable is used to select nodes by position, be careful
not to do:</p>
						<eg><![CDATA[<xsl:variable name="n">2</xsl:variable>
...
<xsl:value-of select="td[$n]"/>]]></eg>
<p diff="chg" at="Z">This will output the values of all the <code>td</code> elements, space-separated
(or in backwards compatibility mode, the value of the first <code>td</code> element), because the
variable <code>n</code> will be bound to a node, not a number. Instead, do one of the following:</p>
						<eg><![CDATA[<xsl:variable name="n" select="2"/>
...
<xsl:value-of select="td[$n]"/>]]></eg>
						<p>or</p>
						<eg><![CDATA[<xsl:variable name="n">2</xsl:variable>
...
<xsl:value-of select="td[position()=$n]"/>]]></eg>

						<p>or</p>
						<eg><![CDATA[<xsl:variable name="n" as="xs:integer">2</xsl:variable>
...
<xsl:value-of select="td[$n]"/>]]></eg>
					
				</example>
			</div2>
			
			<div2 id="temporary-trees">
				<head><phrase diff="chg" at="ZA">Creating implicit document nodes</phrase></head>
<p diff="chg" at="ZA">A document node is created implicitly when evaluating an
<elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or <elcode>xsl:with-param</elcode>
 element that has non-empty content and that has
no <code>as</code> attribute. This element is referred
to as the variable-binding element. The value of the <termref def="dt-variable">variable</termref> 
is a single node, the document node
of the <termref def="dt-temporary-tree">temporary tree</termref>. The
content of the document node is formed from the result of evaluating
the <termref def="dt-sequence-constructor">sequence constructor</termref> 
contained within the variable-binding element,
as described in <specref ref="constructing-complex-content"/>.
				</p>
				
<note><p>The construct:</p>

<eg><![CDATA[<xsl:variable name="tree">
  <a/>
</xsl:variable>]]></eg>

<p>can be regarded as a shorthand for:</p>

<eg><![CDATA[<xsl:variable name="tree" as="document-node()">
  <xsl:document validation="preserve">
    <a/>
  </xsl:document>  
</xsl:variable>]]></eg></note>
				
<p>The base URI of the document node 
is taken from the base URI of the variable binding element in the stylesheet.
(See <xspecref spec="DM" ref="dm-base-uri"/> in <bibref ref="xpath-datamodel"/>)</p>

<p diff="add" at="ZA">No document-level validation takes place (which means, for example, that there is
no checking that ID values are unique). However, type annotations on nodes within the new tree are copied
unchanged.</p>

<note><p>The base URI of other nodes in the tree is determined by the rules
for constructing complex content. The effect of these rules is that the base URI of a node in the
 temporary tree is determined as
if all the nodes in the temporary tree came from a single entity whose URI
was the base URI of the <termref def="dt-variable-binding-element">variable-binding element</termref>. 
Thus, the base URI of the document node will be equal
to the base URI of the variable-binding element; an
<code>xml:base</code> attribute within the temporary tree will change the
base URI for its parent element and that element's descendants, just
as it would within a document constructed by parsing.</p></note>

<p>The <code>document-uri</code> and <code>unparsed-entities</code> 
properties of the new document node are set to empty.</p>


<p>A <termref def="dt-temporary-tree">temporary tree</termref> is
 available for processing
in exactly the same way as any source document. For example, its nodes
are accessible using path expressions, and they can be processed using
instructions such as <elcode>xsl:apply-templates</elcode> and <elcode>xsl:for-each</elcode>.
Also, the <function>key</function> and <xfunction>id</xfunction> functions
 can be used to find nodes
within a temporary tree <phrase diff="add" at="ZA">rooted at a document node</phrase>, 
provided that at the time the function is called, the context item
is a node within the temporary tree.</p>
				 

				
				<example><head>Two-Phase Transformation</head>
					<p>For example, the following stylesheet uses a temporary tree as the intermediate
result of a two-phase transformation, using different <termref def="dt-mode">modes</termref>
 for the two phases (see <specref ref="modes"/>). <phrase diff="add" at="T">Typically, the template
 rules in module <code>phase1.xsl</code> will be declared with <code>mode="phase1"</code>, while
 those in module <code>phase2.xsl</code> will be declared with <code>mode="phase2"</code>: </phrase></p>

					<eg><![CDATA[<xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<xsl:import href="phase1.xsl"/>
<xsl:import href="phase2.xsl"/>

<xsl:variable name="intermediate">
  <xsl:apply-templates select="/" mode="phase1"/>
</xsl:variable>

<xsl:template match="/">
  <xsl:apply-templates select="$intermediate" mode="phase2"/>
</xsl:template>

</xsl:stylesheet>]]></eg>
				</example>
				<note>
					<p>The algorithm for matching nodes against template rules is
exactly the same regardless which tree the nodes come from. <phrase diff="add" at="T">If different
template rules are to be used when processing different trees, then unless </phrase>nodes
from different trees can be distinguished by means of <termref def="dt-pattern">patterns</termref>,
it is  
a good idea to use <termref def="dt-mode">modes</termref> to ensure that each tree is
processed using the appropriate set of template rules.</p>
				</note>
			</div2>
			<div2 id="global-variables">
				<head>Global Variables and Parameters</head>
				<p>Both <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> are
allowed as <termref def="dt-declaration">declaration</termref> elements<phrase diff="add" at="M">:
that is, they may appear as children of the <elcode>xsl:stylesheet</elcode> element.</phrase></p>
 
<p><termdef id="dt-global-variable" term="global variable">A 
top-level <termref def="dt-variable-binding-element">variable-binding element</termref>
 declares a <term>global variable</term> that
is visible everywhere (except where it
is <termref def="dt-shadows">shadowed</termref> by another
binding).</termdef></p>

<p><termdef id="dt-stylesheet-parameter" term="stylesheet parameter">A top-level <elcode>xsl:param</elcode> element
declares a <term>stylesheet parameter</term>.
A stylesheet parameter is a global variable with the additional property 
that its value can be supplied
by the caller when a transformation is initiated.</termdef> <phrase diff="add" at="R">As described in
<specref ref="parameters"/>, a stylesheet parameter may be declared as being mandatory, or may have
a default value specified for use when no value is supplied by the caller.</phrase>
<phrase diff="chg" at="R">The mechanism by which the caller supplies a value
for a stylesheet parameter is <termref def="dt-implementation-defined">implementation-defined</termref>.</phrase>
An XSLT <termref def="dt-processor">processor</termref> <rfc2119>must</rfc2119> provide such a mechanism.</p>

<p diff="add" at="T">It is an error if no value is supplied for a mandatory stylesheet
parameter <errorref spec="XT" class="DE" code="0050"/>.</p>

				<p>If a <termref def="dt-stylesheet">stylesheet</termref> contains more than one
binding for a global variable of a particular name, then the binding with the
highest <termref def="dt-import-precedence">import
precedence</termref> is used.</p>
<p><error spec="XT" type="static" class="SE" code="0630"><p>It is a
<termref def="dt-static-error">static error</termref> if a
 <termref def="dt-stylesheet">stylesheet</termref> contains more than one binding of a global
variable with the same name and same
 <termref def="dt-import-precedence">import precedence</termref><phrase diff="add" at="R">,
 unless it also contains another binding with the same name and higher import precedence</phrase>.</p></error>
				</p>
				<p>For a global variable or the default value of a stylesheet parameter, 
the <termref def="dt-expression">expression</termref> or <termref def="dt-sequence-constructor">sequence constructor</termref>
 specifying the variable value is
evaluated with a <termref def="dt-singleton-focus">singleton focus</termref> based
on the <phrase diff="chg" at="ZA">root</phrase> node of the 
<phrase diff="chg" at="ZA">tree</phrase> containing the 
<termref def="dt-initial-context-node">initial context node</termref>. 
An XPath error will be reported if the evaluation of a global variable or parameter 
references the context item, context position, or context size when no initial context node is supplied.
<phrase diff="add" at="Y">The values of other components of the dynamic context are the initial values
as defined in <specref ref="xpath-dynamic-context"/> and <specref ref="additional-dynamic-context"/></phrase>.</p>
				<example><head>A Stylesheet Parameter</head>
					<p>The following example declares a global parameter
						<code>para-font-size</code>,
which is referenced in an <termref def="dt-attribute-value-template">attribute value template</termref>.</p>
					<eg diff="chg" at="O"><![CDATA[<xsl:param name="para-font-size" as="xs:string">12pt</xsl:param>

<xsl:template match="para">
 <fo:block font-size="{$para-font-size}">
   <xsl:apply-templates/>
 </fo:block>
</xsl:template>
]]></eg>
					<p>The implementation <phrase diff="chg" at="R">must</phrase> provide a mechanism allowing the user to supply
a value for the parameter <code>para-font-size</code> when invoking the stylesheet; the value <code>12pt</code>
acts as a default.</p>
				</example>
			</div2>

			<div2 id="local-variables">
				<head>Local Variables and Parameters</head>
<p diff="chg" at="M"><termdef id="dt-local-variable" term="local variable">As 
well as being allowed as <termref def="dt-declaration">declaration</termref> elements, the
<elcode>xsl:variable</elcode> element is also
allowed in <termref def="dt-sequence-constructor">sequence constructors</termref>. Such a variable
is known as a <term>local variable</term>.</termdef></p>

<p diff="chg" at="M"><termdef id="dt-template-parameter" term="template parameter">
An <elcode>xsl:param</elcode> element may appear as a child of an <elcode>xsl:template</elcode>
element, before any non-<elcode>xsl:param</elcode> children of that element. Such a parameter
is known as a <term>template parameter</term>. A template parameter is a 
<termref def="dt-local-variable">local variable</termref> with the additional 
property that its value can be set when the template
is called, using any of the instructions <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-templates</elcode>,
<elcode>xsl:apply-imports</elcode>, <phrase diff="add" at="O">or <elcode>xsl:next-match</elcode></phrase>.</termdef></p>

<p diff="chg" at="M"><termdef id="dt-function-parameter" term="function parameter">
An <elcode>xsl:param</elcode> element may appear as a child of an <elcode>xsl:function</elcode>
element, before any non-<elcode>xsl:param</elcode> children of that element. Such a parameter
is known as a <term>function parameter</term>. A function parameter is a 
<termref def="dt-local-variable">local variable</termref> with the additional 
property that its value can be set when the function
is called, using a function call in an XPath <termref def="dt-expression">expression</termref>.</termdef></p>

				<p>The result of evaluating
a local <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode> element (that is,
the contribution it makes to the result of the
 <termref def="dt-sequence-constructor">sequence constructor</termref> it is part of)
is an empty sequence.</p>
</div2>	


<div2 id="scope-of-variables"><head>Scope of Variables</head>

<p>For any <termref def="dt-variable-binding-element">variable-binding element</termref>, 
there is a region 
<phrase diff="chg" at="T">(more specifically, a set of element nodes)</phrase>
of the <termref def="dt-stylesheet">stylesheet</termref> 
  within which the binding is 
visible. The set of variable bindings in scope for an
XPath <termref def="dt-expression">expression</termref> consists of those bindings that 
are visible at the point in
the stylesheet where the expression occurs.</p>

<p>A global <termref def="dt-variable-binding-element">variable binding element</termref> is
visible everywhere in the <termref def="dt-stylesheet">stylesheet</termref> 
(including other <termref def="dt-stylesheet-module">stylesheet modules</termref>) except within the 
<elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode>
element itself and any region where it is
<termref def="dt-shadows">shadowed</termref> by another variable binding.</p> 			

<p>A local <termref def="dt-variable-binding-element">variable binding element</termref>
 is visible for all following siblings and their descendants<phrase diff="add" at="T">, with two exceptions:
 it is not visible in any region where it is <termref def="dt-shadows">shadowed</termref> by
  another variable binding, and it is not visible within the subtree rooted at an <elcode>xsl:fallback</elcode>
  instruction that is a sibling of the variable binding element.</phrase>
The binding is not visible for the <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode>
element itself.</p>

<p><termdef id="dt-shadows" term="shadows">A binding <term>shadows</term> another
binding if the binding occurs at a point where the other binding is visible, and
the bindings have the same name.
</termdef> 
  It is not an error if a binding
established by a local <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode>
					<termref def="dt-shadows">shadows</termref> a global binding. In this case, the global
binding will not be visible in the region of the <termref def="dt-stylesheet">stylesheet</termref> where it
is shadowed by the other binding.</p>
<example><head>Local Variable Shadowing a Global Variable</head>
<p>The following is allowed:</p>
<eg><![CDATA[<xsl:param name="x" select="1"/>
<xsl:template name="foo">
  <xsl:variable name="x" select="2"/>
</xsl:template>]]></eg>
</example>
				
<p>It is also not an error if a binding established by a local <elcode>xsl:variable</elcode> 
 element <termref def="dt-shadows">shadows</termref>
a binding established by another local <elcode>xsl:variable</elcode> 
or <elcode>xsl:param</elcode>.</p>

				<example><head>Misuse of Variable Shadowing</head>
					<p>The following is not an error, but 
					the effect is probably not what was intended. The template outputs
					<code>&lt;x value="1"/&gt;</code>, because the declaration of the inner
					variable named <code>$x</code> has no effect on the value of the outer
					variable named <code>$x</code>.</p>
<eg><![CDATA[<xsl:variable name="x" select="1"/>
<xsl:template name="foo">
  <xsl:for-each select="1 to 5">
    <xsl:variable name="x" select="$x+1"/>
  </xsl:for-each>
  <x value="{$x}"/>
</xsl:template>]]></eg>
				</example>				
				
				<note>
					<p>Once a variable has been given a value, the value cannot subsequently
be changed. XSLT does not provide an equivalent to the 
assignment operator available in many procedural programming languages. 
</p>
					<p>This is because an assignment operator
 would make it harder to create an implementation that
processes a document other than in a batch-like way, starting at the
beginning and continuing through to the end.</p>
				</note>

					<p>As well as global variables and local variables, an XPath
					 <termref def="dt-expression">expression</termref> may also declare range variables
for use locally within an expression. For details, see <bibref ref="xpath20"/>.</p>
					<p>Where a reference to a variable occurs in an XPath expression, it is resolved first by reference
to range variables that are in scope, then by reference to local variables and parameters, and finally by reference
to global variables and parameters. A range variable may shadow a local variable or a global variable.
XPath also allows a range variable to shadow another range variable.</p>
				
			</div2>

			<div2 id="circularity">
				<head>Circular Definitions</head>
				<p>
					<termdef id="dt-circularity" term="circularity" diff="chg" at="V">A <term>circularity</term> is said to exist
					if a construct such as a <termref def="dt-global-variable">global variable</termref>, an
					<termref def="dt-attribute-set">attribute set</termref>, or a <termref def="dt-key">key</termref> 
					is defined in terms of itself. For example, if the
					<termref def="dt-expression">expression</termref> or <termref def="dt-sequence-constructor">sequence constructor</termref>
specifying the value of a <termref def="dt-global-variable">global variable</termref> <var>X</var> references a
global variable <var>Y</var>, then the value for <var>Y</var> <rfc2119>must</rfc2119>
be computed before the value of <var>X</var>.   A circularity exists if it
is impossible to do this for all global variable definitions.</termdef>
				</p>
				
<example><head>Circular Variable Definitions</head>
<p>The following two declarations create a circularity:</p>
<eg role="error"><![CDATA[<xsl:variable name="x" select="$y+1"/>
<xsl:variable name="y" select="$x+1"/>]]></eg></example>

<example><head>Circularity involving Variables and Functions</head>
				<p>The definition of a global variable can be circular even if no other variable is involved.
For example the following two declarations (see <specref ref="stylesheet-functions"/> for
an explanation of the <elcode>xsl:function</elcode> element) also create a circularity:</p>
				<eg role="error"><![CDATA[<xsl:variable name="x" select="my:f()"/>

<xsl:function name="my:f">
  <xsl:sequence select="$x"/>
</xsl:function>
]]></eg>
</example>

<example><head>Circularity involving Variables and Templates</head>
				<p>The definition of a variable is also circular if the evaluation of the
variable invokes an <elcode>xsl:apply-templates</elcode> instruction and the variable is
referenced in the pattern used in the <code>match</code> attribute of any template rule
in the <termref def="dt-stylesheet">stylesheet</termref>. For example the following definition is circular:</p>
				<eg role="error"><![CDATA[<xsl:variable name="x">
  <xsl:apply-templates select="//param[1]"/>
</xsl:variable>

<xsl:template match="param[$x]">1</xsl:template>
]]></eg>
</example>

<example><head>Circularity involving Variables and Keys</head>
				<p>Similarly, a variable definition is circular if it causes a call on the <function>key</function>
function, and the definition of that <termref def="key">key</termref> refers to that variable in its
<code>match</code> or <code>use</code> attributes. So the following definition is circular:</p>
				<eg role="error"><![CDATA[<xsl:variable name="x" select="my:f(10)"/>

<xsl:function name="my:f">
  <xsl:param name="arg1"/>
  <xsl:sequence select="key('k', $arg1)"/>
</xsl:function>

<xsl:key name="k" match="item[@code=$x]" use="@desc"/>
]]></eg>
</example>
				<p>
					<error spec="XT" type="dynamic" class="DE" code="0640"><p>In general, a <termref def="dt-circularity">circularity</termref>
 in a <termref def="dt-stylesheet">stylesheet</termref> is a 
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>.</p></error>
However, as with all other dynamic errors, an implementation will signal
the error only if it actually executes the instructions and expressions that
participate in the circularity. 
Because different implementations may optimize the execution of a stylesheet
in different ways, it is
 <termref def="dt-implementation-dependent">implementation-dependent</termref>
 whether a particular circularity will actually be signaled.</p>
				<p>For example, in the following declarations, the function declares a
<phrase diff="chg" at="O">local variable <code>$b</code>, but it returns a result that does
not require the variable to be evaluated. It is <termref def="dt-implementation-dependent">implementation-dependent</termref>
whether the value is actually evaluated</phrase>, and it is therefore
implementation-dependent whether the circularity is signaled as an error:</p>
				<eg role="error"><![CDATA[<xsl:variable name="x" select="my:f(1)/>

<xsl:function name="my:f">
  <xsl:param name="a"/>
  <xsl:variable name="b" select="$x"/>  
  <xsl:sequence select="$a + 2"/>
</xsl:function>
]]></eg>
				<p>Circularities usually involve global variables or parameters, but they
can also exist between <termref def="key">key</termref> definitions (see <specref ref="key"/>), between
named <termref def="dt-attribute-set">attribute sets</termref> (see <specref ref="attribute-sets"/>),
 or between
any combination of these constructs. For example, a circularity exists if a
key definition invokes a function that references an attribute set that calls the <function>key</function>
function, supplying the name of the original key definition as an argument.</p>
				<p>Circularity is not the same as recursion. Stylesheet functions
 (see <specref ref="stylesheet-functions"/>)
and named templates (see <specref ref="named-templates"/>) may
call other functions and named templates without restriction. With careless coding,
recursion may be non-terminating. Implementations are <rfc2119>required</rfc2119>
to signal circularity as a <termref def="dt-dynamic-error">dynamic error</termref>, 
but they are not <rfc2119>required</rfc2119> to detect non-terminating recursion.</p>
			</div2>

		</div1>
		<div1 id="callable-components">
			<head>Callable Components</head>
			<p>This section describes three constructs that can be used
to provide subroutine-like functionality that can be invoked from anywhere in
the stylesheet: named templates (see <specref ref="named-templates"/>), named attribute
sets (see <specref ref="attribute-sets"/>) and
 <termref def="dt-stylesheet-function">stylesheet functions</termref>
(see <specref ref="stylesheet-functions"/>).</p>
			<div2 id="named-templates">
				<head>Named Templates</head>
				<e:element-syntax name="call-template">
					<e:in-category name="instruction"/>
					<e:attribute name="name" required="yes">
						<e:data-type name="qname"/>
					</e:attribute>
					<e:element repeat="zero-or-more" name="with-param"/>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				
<p><termdef id="dt-named-template" term="named template">Templates can be invoked by name.  
An <elcode>xsl:template</elcode>
element with a <code>name</code> attribute defines a <term>named template</term>.</termdef>
The value of the <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, 
which is expanded as described
in <specref ref="qname"/>. If an <elcode>xsl:template</elcode> element has
a <code>name</code> attribute, it may, but need not, also have a
<code>match</code> attribute.  An <elcode>xsl:call-template</elcode>
instruction invokes a template by name; it has a <rfc2119>required</rfc2119>
<code>name</code> attribute that identifies the template to be
invoked.  Unlike <elcode>xsl:apply-templates</elcode>, the
<elcode>xsl:call-template</elcode> instruction does not change 
the <termref def="dt-focus">focus</termref>.</p>

<p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an
<elcode>xsl:template</elcode> element <phrase diff="chg" at="R">have no effect when</phrase>
 the <termref def="dt-template">template</termref>
is invoked by an <elcode>xsl:call-template</elcode> instruction.  Similarly,
the <code>name</code> attribute on an <elcode>xsl:template</elcode>
element <phrase diff="chg" at="R">has no effect when</phrase> the template is invoked by an
<elcode>xsl:apply-templates</elcode> instruction.</p>

<p><error spec="XT" type="static" class="SE" code="0650"><p>It is a <termref def="dt-static-error">static error</termref> if
a <termref def="dt-stylesheet">stylesheet</termref> contains an <elcode>xsl:call-template</elcode> instruction whose <code>name</code> attribute does
not match the <code>name</code> attribute of any <elcode>xsl:template</elcode> in the <termref def="dt-stylesheet">stylesheet</termref>.</p></error></p>

<p><error spec="XT" type="static" class="SE" code="0660"><p>It is a <termref def="dt-static-error">static error</termref> if a
<termref def="dt-stylesheet">stylesheet</termref> contains more than one <termref def="dt-template">template</termref> with
the same name and the same <termref def="dt-import-precedence">import
precedence</termref><phrase diff="add" at="R">, unless it also contains a <termref def="dt-template">template</termref>
with the same name and higher <termref def="dt-import-precedence">import
precedence</termref></phrase>.</p></error></p>

<p>The target <termref def="dt-template">template</termref> for an <elcode>xsl:call-template</elcode>
instruction is the template whose <code>name</code> attribute matches the 
<code>name</code> attribute of the <elcode>xsl:call-template</elcode>
instruction and that has higher <termref def="dt-import-precedence">import precedence</termref> 
than any other template with this name. The result of evaluating an <elcode>xsl:call-template</elcode>
instruction is the sequence
produced by evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref>
contained in its target <termref def="dt-template">template</termref> 
(see <specref ref="sequence-constructors"/>).</p>


				<div3 id="with-param">
					<head>Passing Parameters to Templates</head>
					<e:element-syntax name="with-param" diff="chg" at="R">
						<e:attribute name="name" required="yes">
							<e:data-type name="qname"/>
						</e:attribute>
						<e:attribute name="select">
							<e:data-type name="expression"/>
						</e:attribute>
						<e:attribute name="as">
							<e:data-type name="sequence-type"/>
						</e:attribute>
        				<e:attribute name="tunnel">
        					<e:constant value="yes"/>
        					<e:constant value="no"/>
        				</e:attribute>		
						<e:model name="sequence-constructor"/>
						<e:allowed-parents>
							<e:parent name="apply-templates"/>
							<e:parent name="apply-imports"/>
							<e:parent name="call-template"/>
							<e:parent name="next-match"/>							
						</e:allowed-parents>
					</e:element-syntax>
					
					
					<p>Parameters are passed to templates using the
<elcode>xsl:with-param</elcode> element.  The <rfc2119>required</rfc2119> <code>name</code>
attribute specifies the name of the <termref def="dt-template-parameter">template parameter</termref> (the variable the value
of whose binding is to be replaced).  The value of the
<code>name</code> attribute is a <termref def="dt-qname">QName</termref>, which is expanded as described
in <specref ref="qname"/>.</p>
					<p>
						<elcode>xsl:with-param</elcode> is allowed
within <elcode>xsl:call-template</elcode>,
<elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, 
<phrase diff="add" at="O">and <elcode>xsl:next-match</elcode></phrase>.</p>

<p><error spec="XT" type="static" class="SE" code="0670"><p>It is a <termref def="dt-static-error">static error</termref> if
a single <elcode>xsl:call-template</elcode>,
<elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
 <phrase diff="add" at="O">or <elcode>xsl:next-match</elcode></phrase>
element contains two or more <elcode>xsl:with-param</elcode> elements
with <phrase diff="chg" at="R">matching <code>name</code> attributes</phrase>.</p></error></p>
					<p>The value of the parameter is
specified in the same way as for <elcode>xsl:variable</elcode> and
<elcode>xsl:param</elcode> (see <specref ref="variable-values"/>)<phrase diff="add" at="R">,
taking account of the values of the <code>select</code> and <code>as</code> attributes and
the content of the <elcode>xsl:with-param</elcode> element, if any.</phrase></p>

<note diff="add" at="R"><p>It is possible to have an <code>as</code> attribute on the
<elcode>xsl:with-param</elcode> element that differs from the <code>as</code> attribute
on the corresponding <elcode>xsl:param</elcode> element describing the formal parameters
of the called template.</p>

<p>In this situation, the supplied value of the parameter will first be
processed according to the rules of the <code>as</code> attribute on the
<elcode>xsl:with-param</elcode> element, and the resulting value will then be further
processed according to the rules of the <code>as</code> attribute on the <elcode>xsl:param</elcode>
element.</p> 

<p>For example, suppose the supplied value is a node with <termref def="dt-annotation">type annotation</termref>
<phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>, and the <elcode>xsl:with-param</elcode> element specifies
<code>as="xs:integer"</code>, while the <elcode>xsl:param</elcode> element specifies <code>as="xs:double"</code>.
Then the node will first be atomized and the resulting untyped atomic
value will be cast to <code>xs:integer</code>. If this succeeds, the <code>xs:integer</code> will
then be promoted to an <code>xs:double</code>.</p></note>

<p>The <termref def="dt-focus">focus</termref> used
for computing the value specified by the <elcode>xsl:with-param</elcode>
element is the same as that used for the
<elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, 
<elcode>xsl:next-match</elcode>, or <elcode>xsl:call-template</elcode>
element within which it occurs.</p>

<p><error spec="XT" type="static" class="SE" code="0680"><p>In the case of <elcode>xsl:call-template</elcode>,
it is a <termref def="dt-static-error">static error</termref> 
to pass a <phrase diff="add" at="Y">non-tunnel</phrase> parameter named <var>x</var> to a template that does not have a
<termref def="dt-template-parameter">template parameter</termref> named 
<var>x</var><phrase diff="add" at="T">, unless <termref def="dt-backwards-compatible-behavior">backwards
compatible behavior</termref> is enabled for the <elcode>xsl:call-template</elcode> instruction</phrase>.</p></error> This is
not an error in the case of <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
<phrase diff="add" at="O">and <elcode>xsl:next-match</elcode></phrase>; in these cases
the parameter is simply ignored.</p>

<p>The optional <code>tunnel</code> attribute may be used
to indicate that a parameter is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. 
The default is <code>no</code>.
Tunnel parameters are described in <specref ref="tunnel-params"/></p>



<p><error spec="XT" type="static" class="SE" code="0690"><p>It is 
a <termref def="dt-static-error">static error</termref> if
a template that is invoked using <elcode>xsl:call-template</elcode> declares a 
<termref def="dt-template-parameter">template parameter</termref> 
specifying <code>required="yes"</code> <phrase diff="add" at="R">and not specifying
<code>tunnel="yes"</code></phrase>, if no value for
this parameter is supplied by the calling instruction.</p></error></p>

<p><error spec="XT" type="dynamic" class="DE" code="0700"><p>In other
cases, <error.extra>with <elcode>xsl:apply-templates</elcode>,
<elcode>xsl:apply-imports</elcode>, 
and <elcode>xsl:next-match</elcode>, or <elcode>xsl:call-template</elcode> with <termref def="dt-tunnel-parameter">tunnel parameters</termref></error.extra>
it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
the template that is invoked declares a <termref def="dt-template-parameter">template parameter</termref>
 with <code>required="yes"</code> and no value for
this parameter is supplied by the calling instruction.</p></error></p>



<example><head>A Named Template</head>
						<p>This example defines a named template for a
<code>numbered-block</code> with an argument to control the format of
the number.</p>
						<eg><![CDATA[<xsl:template name="numbered-block">
  <xsl:param name="format">1. </xsl:param>
  <fo:block>
    <xsl:number format="{$format}"/>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="ol//ol/li">
  <xsl:call-template name="numbered-block">
    <xsl:with-param name="format">a. </xsl:with-param>
  </xsl:call-template>
</xsl:template>]]></eg>
					</example>
					<note>
						<p>Arguments to
						 <termref def="dt-stylesheet-function">stylesheet functions</termref> are supplied as part of an XPath
function call: see <specref ref="stylesheet-functions"/>
						</p>
					</note>
				</div3>
				
<div3 id="tunnel-params" diff="add" at="R">
  <head>Tunnel Parameters</head>
  
  <p><termdef id="dt-tunnel-parameter" term="tunnel parameter">A parameter passed to a template may be
  defined as a <term>tunnel parameter</term>. Tunnel parameters have the property that they are automatically
  passed on by the called template to any further templates that it calls, and so on recursively.</termdef>
  Tunnel parameters thus allow values to be set that are accessible during an entire phase of stylesheet processing,
  without the need for each template that is used during that phase to be aware of the parameter.</p>
  
  <note><p>Tunnel parameters are conceptually similar to dynamically-scoped variables in some functional
  programming languages.</p></note>
  
  <p>A <termref def="dt-tunnel-parameter">tunnel parameter</termref> is created by using
   an <elcode>xsl:with-param</elcode> element that specifies
  <code>tunnel="yes"</code>. A template that requires access to the value of a tunnel parameter must declare
  it using an <elcode>xsl:param</elcode> element that also specifies <code>tunnel="yes"</code>.</p>
  
  <p>On any template call using an <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>,
  <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>	instruction, a set of 
  <termref def="dt-tunnel-parameter">tunnel parameters</termref>
  is passed from the calling template to the called template. This set consists of any parameters explicitly
  created using <code>&lt;xsl:with-param tunnel="yes"&gt;</code>, overlaid on a base set of tunnel parameters.
  If the <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>,
  <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>	instruction has an <elcode>xsl:template</elcode>
  declaration as an ancestor element in the stylesheet, then the base set consists of the tunnel parameters that were
  passed to that template; otherwise (for example, if the instruction is within a global variable declaration, an
  <termref def="dt-attribute-set">attribute set</termref> declaration, or a
  <termref def="dt-stylesheet-function">stylesheet function</termref>), the base set is empty. 
  If a parameter created using <code>&lt;xsl:with-param tunnel="yes"&gt;</code> has the same 
  <termref def="dt-expanded-qname">expanded-QName</termref> as a parameter in the base set,
  then the parameter created using <elcode>xsl:with-param</elcode> overrides the parameter in the base set;
  otherwise, the parameter created using <elcode>xsl:with-param</elcode> is added to the base set.</p>
  
  <p>When a template accesses the value of a <termref def="dt-tunnel-parameter">tunnel parameter</termref>
   by declaring it with <code>xsl:param tunnel="yes"</code>,
  this does not remove the parameter from the base set of tunnel parameters that is passed on to any templates called
  by this template.</p>
  
  <p>Two sibling <elcode>xsl:with-param</elcode> elements must have distinct parameter names, even if one
  is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>
   and the other is not. Equally, two sibling <elcode>xsl:param</elcode> elements representing
    <termref def="dt-template-parameter">template parameters</termref>
  must have distinct parameter names, even if one
  is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>
   and the other is not. However, the tunnel parameters that are implicitly passed in
  a template call may have names that duplicate the names of non-tunnel parameters that are explicitly passed
  on the same call.</p>

  <p><termref def="dt-tunnel-parameter">Tunnel parameters</termref> are not passed in calls to 
  <termref def="dt-stylesheet-function">stylesheet functions</termref>.</p>
  
  <p>All other options of <elcode>xsl:with-param</elcode> and <elcode>xsl:param</elcode> are available
  with <termref def="dt-tunnel-parameter">tunnel parameters</termref> just as with non-tunnel parameters. 
  For example, parameters may be declared as mandatory
  or optional, a default value may be specified, and a required type may be specified. If any conversion is
  required from the supplied value of a tunnel parameter to the required type specified in <elcode>xsl:param</elcode>,
  then the converted value is used within the receiving template, but the value that is passed on in any further template
  calls is the original supplied value before conversion. Equally, any default value is local to the template: specifying
  a default value for a tunnel parameter does not change the set of tunnel parameters that is passed on in further
  template calls.</p>
  
  <p>The set of <termref def="dt-tunnel-parameter">tunnel parameters</termref> that is passed to the
  <termref def="dt-initial-template">initial template</termref> is empty.</p>
  
  <p><termref def="dt-tunnel-parameter">Tunnel parameters</termref> are passed unchanged through a
  built-in template rule (see <specref ref="built-in-rule"/>).</p>
  
  <example><head>Using Tunnel Parameters</head>
  
  <p>Suppose that the equations in a scientific paper are to be sequentially numbered, but that the
  format of the number depends on the context in which the equations appear. It is possible to reflect
  this using a rule of the form:</p>
  
<eg diff="chg" at="T"><![CDATA[<xsl:template match="equation">
  <xsl:param name="equation-format" select="'(1)'" tunnel="yes"/>
  <xsl:number level="any" format="{$equation-format}"/>
</xsl:template>]]></eg>
  
  <p>At any level of processing above this level, it is possible to determine how the equations will
  be numbered, for example:</p>
  
<eg><![CDATA[<xsl:template match="appendix">
  ...
  <xsl:apply-templates>
    <xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/>
  </xsl:apply-templates>
  ...
</xsl:template>]]></eg>
  
  <p>The parameter value is passed transparently through all the intermediate layers of template rules until it
  reaches the rule with <code>match="equation"</code>. The effect is similar to using a global variable, except 
  that the parameter can take different values during different phases of the transformation.</p>
  </example>
	</div3>			
			</div2>
			<div2 id="attribute-sets">
				<head>Named Attribute Sets</head>
				<e:element-syntax name="attribute-set">
					<e:in-category name="declaration"/>
					<e:attribute name="name" required="yes">
						<e:data-type name="qname"/>
					</e:attribute>
					<e:attribute name="use-attribute-sets">
						<e:data-type name="qnames"/>
					</e:attribute>
					<e:element repeat="zero-or-more" name="attribute"/>
					<e:allowed-parents>
						<e:parent name="stylesheet"/>
						<e:parent name="transform"/>
					</e:allowed-parents>
				</e:element-syntax>
				<p>
					<termdef id="dt-attribute-set" term="attribute set">The
 <elcode>xsl:attribute-set</elcode> element defines a named <term>attribute set</term>: that is,
 a collection of attribute <phrase diff="chg" at="R">definitions</phrase>
  that can be used repeatedly on different constructed elements.</termdef></p>
 
<p>The <rfc2119>required</rfc2119> <code>name</code> attribute specifies the name of the
attribute set.  The value of the <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, 
which is expanded as described
in <specref ref="qname"/>. The content of the <elcode>xsl:attribute-set</elcode>
element consists of zero or more <elcode>xsl:attribute</elcode> instructions
that are evaluated to produce the attributes in the set.</p>

<p>The result of evaluating an attribute set is a sequence of attribute nodes. Evaluating
the same attribute set more than once can produce different results, because although an attribute
set does not have parameters, it may contain expressions or instructions whose value depends on the 
evaluation context.</p>

<p><termref def="dt-attribute-set">Attribute sets</termref> are used by specifying a
<code>use-attribute-sets</code> attribute on the <elcode>xsl:element</elcode> or
<elcode>xsl:copy</elcode> instruction, 
or by specifying an <code>xsl:use-attribute-sets</code>
attribute on a literal result element. An attribute set may be defined in terms
of other attribute sets by using the 
<code>use-attribute-sets</code> attribute on the <elcode>xsl:attribute-set</elcode> element itself. 
The value of the <code>[xsl:]use-attribute-sets</code> 
attribute is in each case a whitespace-separated
list of names of attribute sets.  Each name is specified as a <termref def="dt-qname">QName</termref>, 
which is expanded as described in <specref ref="qname"/>.</p>

<p>Specifying a
<code>use-attribute-sets</code> attribute is broadly equivalent to adding
<elcode>xsl:attribute</elcode> instructions for each of the attributes in each
of the named attribute sets to the beginning of the content of the
instruction with the <code>[xsl:]use-attribute-sets</code> attribute, in the
same order in which the names of the attribute sets are specified in
the <code>use-attribute-sets</code> attribute.</p>

<p>More formally, an <code>xsl:use-attribute-sets</code> attribute is expanded using the
following recursive algorithm, or any algorithm that produces the same results:</p>

<ulist>
<item><p>The value of the attribute is tokenized as a list of QNames.</p></item> 

<item><p>Each QName in the list is processed, in order, as follows:</p>

  <ulist>
  <item><p>The QName must match the <code>name</code> attribute of one or more <elcode>xsl:attribute-set</elcode>
  declarations in the stylesheet.</p></item>
  
  <item><p>Each <elcode>xsl:attribute-set</elcode> declaration whose name matches is 
  processed as follows. Where two such declarations have different <termref def="dt-import-precedence">import
  precedence</termref>, the one with lower import precedence is processed first. Where two declarations have
  the same import precedence, they are processed in <termref def="dt-declaration-order">declaration order</termref>.</p>
  
    <ulist>
    <item><p>If the <elcode>xsl:attribute-set</elcode> declaration has a <code>use-attribute-sets</code>
    attribute, the attribute is expanded by applying this algorithm recursively.</p></item>
    
    <item><p>If the <elcode>xsl:attribute-set</elcode> declaration contains one or more <elcode>xsl:attribute</elcode>
    instructions, these instructions are evaluated (following the rules for evaluating a
    <termref def="dt-sequence-constructor">sequence constructor</termref>: 
    see <specref ref="sequence-constructors"/>) to produce
    a sequence of attribute nodes. These attribute nodes are appended to the result sequence.</p></item>
    </ulist>
    
  </item>
  </ulist>
  
</item>
</ulist>



<p>The <elcode>xsl:attribute</elcode> instructions are evaluated using the same 
<termref def="dt-focus">focus</termref>
 as is used for evaluating the element that is the parent of
the <code>[xsl:]use-attribute-sets</code> attribute forming the initial input to the algorithm. However, the static context
for the evaluation depends on the position of the <elcode>xsl:attribute</elcode> instruction in the stylesheet: thus,
only local variables declared within
an <elcode>xsl:attribute</elcode> instruction, and global variables, are visible.</p>

<p>The set of attribute nodes produced by expanding <code>xsl:use-attribute-sets</code> may
include several attributes with the same name. When
the attributes are added to an element node, only the last of the duplicates 
will take effect.</p> 

<p>The way in which each instruction uses the results of expanding the <code>[xsl:]use-attribute-sets</code>
attribute is described in the specification for the relevant instruction: see <specref ref="literal-result-element"/>, 
<specref ref="xsl-element"/>, and <specref ref="copying"/>.</p> 

<p><error spec="XT" type="static" class="SE" code="0710"><p>It is a <termref def="dt-static-error">static error</termref> if the value of the
<code>use-attribute-sets</code> attribute of an <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, or
<elcode>xsl:attribute-set</elcode> element, or the <code>xsl:use-attribute-sets</code> attribute of a
<termref def="dt-literal-result-element">literal result element</termref>, is not a 
<phrase diff="chg" at="T">whitespace-separated</phrase> sequence
of <termref def="dt-qname">QNames</termref>, or if it contains a QName that does not match the <code>name</code>
attribute of any <elcode>xsl:attribute-set</elcode> declaration in the stylesheet.</p></error></p>

<p><error spec="XT" type="static" class="SE" code="0720"><p>It is a <termref def="dt-static-error">static error</termref> if an 
<elcode>xsl:attribute-set</elcode> element directly
or indirectly references itself via the names contained in the <code>use-attribute-sets</code> attribute.</p></error></p>


<p>Each attribute node produced by expanding an attribute set has a <termref def="dt-annotation">type annotation</termref> determined by the
rules for the <elcode>xsl:attribute</elcode> instruction that created the attribute node: see
<specref ref="annotation-for-constructed-attribute"/>. These type annotations may be preserved, stripped,
or replaced as determined by the rules for the instruction that creates the element in which the attributes
are used.</p>

<p>Attribute sets are used as follows:</p>

<ulist>
<item><p>The <elcode>xsl:copy</elcode> and <elcode>xsl:element</elcode> instructions have an
 <code>use-attribute-sets</code> attribute. The sequence of attribute nodes produced by evaluating
 this attribute is prepended to the sequence produced by evaluating the 
 <termref def="dt-sequence-constructor">sequence constructor</termref> contained within the
 instruction.</p></item>
 
<item><p><termref def="dt-literal-result-element">Literal result elements</termref> allow an
<code>xsl:use-attribute-sets</code> attribute, which is evaluated in the same way
as the <code>use-attribute-sets</code> attribute of <elcode>xsl:element</elcode> and
<elcode>xsl:copy</elcode>. The sequence of attribute nodes produced by evaluating
 this attribute is prepended to the sequence of attribute nodes produced by evaluating the attributes
 of the literal result element, which in turn is prepended to the sequence produced by evaluating the 
 <termref def="dt-sequence-constructor">sequence constructor</termref> contained with the
 literal result element.</p></item>
</ulist>


				<example><head>Using Attribute Sets</head>
					<p>The following example creates a named <termref def="dt-attribute-set">attribute set</termref>
						<code>title-style</code> and uses it in a <termref def="dt-template-rule">template rule</termref>.</p>
					<eg><![CDATA[<xsl:template match="chapter/heading">
  <fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style">
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:attribute-set name="title-style">
  <xsl:attribute name="font-size">12pt</xsl:attribute>
  <xsl:attribute name="font-weight">bold</xsl:attribute>
</xsl:attribute-set>]]></eg>
				</example>

<example><head>Overriding Attributes in an Attribute Set</head>


<p>The following example creates a named attribute set
<code>base-style</code> and uses it in a template rule with multiple specifications of the attributes:</p>

<glist>
<gitem>
<label>font-family</label>
<def><p>is specified only in the attribute set</p></def>
</gitem>
<gitem>
<label>font-size</label>
<def><p>is specified in the attribute set, is specified
             on the literal result element, and in an
             <elcode>xsl:attribute</elcode> instruction</p></def>
</gitem>
<gitem>
<label>font-style</label>
<def><p>is specified in the attribute set, and on
             the literal result element</p></def>
</gitem>

<gitem>
<label>font-weight</label>
<def><p>is specified in the attribute set, and in an
             <elcode>xsl:attribute</elcode> instruction</p></def>
</gitem>
</glist>

<!--
<table cellspacing="5">
<tbody>
<tr><td valign="top"><code>font-family</code></td>is specified only in the attribute set<td></td></tr>
 <tr><td valign="top"><code>font-size</code></td><td>is specified in the attribute set, is specified
             on the literal result element, and in an
             <elcode>xsl:attribute</elcode> element</td></tr>
 <tr><td valign="top"><code>font-style</code></td><td>is specified in the attribute set, and on
             the literal result element</td></tr>
 <tr><td valign="top"><code>font-weight</code></td><td>is specified in the attribute set, and in an
             <elcode>xsl:attribute</elcode> element</td></tr>
</tbody>             
</table>-->

<p>Stylesheet fragment:</p>

<eg><![CDATA[<xsl:attribute-set name="base-style">
  <xsl:attribute name="font-family">Univers</xsl:attribute>
  <xsl:attribute name="font-size">10pt</xsl:attribute>
  <xsl:attribute name="font-style">normal</xsl:attribute>
  <xsl:attribute name="font-weight">normal</xsl:attribute>
</xsl:attribute-set>

<xsl:template match="o">
  <fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic">
    <xsl:attribute name="font-size">14pt</xsl:attribute>
    <xsl:attribute name="font-weight">bold</xsl:attribute>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>

<p>Result:</p>

<eg><![CDATA[<fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold">
...
</fo:block>
]]></eg>



</example>


			</div2>
			<div2 id="stylesheet-functions">
				<head>Stylesheet Functions</head>
				<p>
					<termdef id="dt-stylesheet-function" term="stylesheet function">An <elcode>xsl:function</elcode> 
declaration declares the name, parameters, and implementation of a
 <term>stylesheet function</term>
 that can be called from any XPath
<termref def="dt-expression">expression</termref> within the <termref def="dt-stylesheet">stylesheet</termref>.</termdef></p>


				
					<e:element-syntax name="function" diff="chg" at="Q">
						<e:in-category name="declaration"/>
						<e:attribute name="name" required="yes">
							<e:data-type name="qname"/>
						</e:attribute>
						<e:attribute name="as" required="no">
							<e:data-type name="sequence-type"/>
						</e:attribute>
						<e:attribute name="override" required="no">
							<e:constant value="yes"/>
							<e:constant value="no"/>
						</e:attribute>
    					<e:sequence>
    						<e:element repeat="zero-or-more" name="param"/>
    						<e:model name="sequence-constructor"/>
    					</e:sequence>						
						<e:allowed-parents>
							<e:parent name="stylesheet"/>
							<e:parent name="transform"/>
						</e:allowed-parents>
					</e:element-syntax>
					
					<p>The <elcode>xsl:function</elcode> declaration
 defines a <termref def="dt-stylesheet-function">stylesheet function</termref> that
can be called from any XPath <termref def="dt-expression">expression</termref> 
used in the <termref def="dt-stylesheet">stylesheet</termref> (including
an XPath expression used within a predicate in 
a <termref def="dt-pattern">pattern</termref>).
  The <code>name</code> attribute specifies the name of the
function.  The value of the <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, 
which is expanded as described
in <specref ref="qname"/>.</p>

					<p>An <elcode>xsl:function</elcode> declaration can only
appear as a top-level element in a <phrase diff="chg" at="R">stylesheet module</phrase>.</p>

<p><error spec="XT" type="static" class="SE" code="0740"><p>A 
<termref def="dt-stylesheet-function">stylesheet function</termref>
 <rfc2119>must</rfc2119> have a prefixed name,
to remove any risk of a clash with a function in the default function namespace. It is a 
<termref def="dt-static-error">static error</termref> if the name has no prefix.</p></error>.</p>
				<note>
					<p>To prevent the namespace declaration used for the function name appearing in the
result document, use the <code>exclude-result-prefixes</code> attribute
on the <elcode>xsl:stylesheet</elcode> element: see <specref ref="lre-namespaces"/>.</p>

<p diff="chg" at="ZA">The prefix <rfc2119>must not</rfc2119> refer to a <termref def="dt-reserved-namespace">reserved namespace</termref>:
<errorref spec="XT" class="SE" code="0080"/></p>
				</note>


					<p>The content of the <elcode>xsl:function</elcode>
element consists of zero or more <elcode>xsl:param</elcode> elements
that specify the formal arguments of the function, followed by
<phrase diff="chg" at="Q">a <termref def="dt-sequence-constructor">sequence constructor</termref>
 that defines the value to be returned by the function.</phrase></p>

<p><termdef id="dt-arity" term="arity">The <term>arity</term> of a stylesheet
function is the number of <elcode>xsl:param</elcode> elements in the function definition.</termdef>
Optional arguments are not allowed.</p>

<p><error spec="XT" type="static" class="SE" code="0760"><p>Because arguments to a stylesheet
function call <rfc2119>must</rfc2119> all be specified, the <elcode>xsl:param</elcode> elements within an
<elcode>xsl:function</elcode> element <rfc2119>must not</rfc2119> specify a default value: this means they
<rfc2119>must</rfc2119> be empty, and <rfc2119>must not</rfc2119> have a <code>select</code> attribute.</p></error></p>

<p>A <termref def="dt-stylesheet-function">stylesheet function</termref>
 is included in the <emph>in-scope functions</emph> of the static
context for all XPath expressions used in the <termref def="dt-stylesheet">stylesheet</termref>, unless </p>

<ulist>
<item><p>there is another <termref def="dt-stylesheet-function">stylesheet function</termref> with the same
name and <termref def="dt-arity">arity</termref>, and higher <termref def="dt-import-precedence">import precedence</termref>, or</p></item>

<item><p>the <code>override</code> attribute has the value <code>no</code> and there
 is already a function with the same name and <termref def="dt-arity">arity</termref> in the in-scope functions.</p></item>
      
</ulist>

<p>The optional <code>override</code> attribute defines what happens if this function
has the same name and <termref def="dt-arity">arity</termref> as a function 
provided by the implementer or made available in the static context
using an implementation-defined mechanism. If the <code>override</code> attribute has the value <code>yes</code>,
then this function is used in preference; if it has the value <code>no</code>, then the other function
is used in preference. The default value is <code>yes</code>.</p>

					<note>
						<p>Specifying <code>override="yes"</code> ensures interoperable behavior: 
the same code will execute with all processors. Specifying <code>override="no"</code> is useful when writing
a fallback implementation of a function that is available with some processors but not others: it
allows the vendor's implementation of the function <phrase diff="add" at="T">(or a user's implementation
written as an extension function)</phrase> to be used in preference to the stylesheet
implementation, which is useful when the <phrase diff="chg" at="T">extension function</phrase>
 is more efficient.</p>

<p diff="add" at="T">The <code>override</code> attribute does <emph>not</emph> affect the rules for deciding
which of several <termref def="dt-stylesheet-function">stylesheet functions</termref>
 with the same name and <termref def="dt-arity">arity</termref> takes precedence.</p>
					</note>
 
<p><error spec="XT" type="static" class="SE" code="0770"><p>It is a <termref def="dt-static-error">static error</termref> for
a <termref def="dt-stylesheet">stylesheet</termref> to contain two or more functions with the same <termref def="dt-expanded-qname">expanded-QName</termref>,
the same <termref def="dt-arity">arity</termref>, and the same 
<termref def="dt-import-precedence">import precedence</termref>, unless there is 
another function with the same <termref def="dt-expanded-qname">expanded-QName</termref>
and arity, and a higher import precedence.</p></error>
					</p>

<p>As defined in XPath, the function that is executed as the
          result of a function call is identified by looking in the in-scope
          functions of the static context for a function whose
          name and <termref def="dt-arity">arity</termref> matches the name and number of arguments in
          the function call. </p>

<note>
<p>Functions are not polymorphic. Although the XPath function call mechanism allows two
functions to have the same name and different <termref def="dt-arity">arity</termref>, 
 it does
not allow them to be distinguished by the types of their arguments.</p>
</note>

<p>The optional <code>as</code> attribute indicates the 
<termref def="dt-required-type">required type</termref> of the result of the function.
The value of the <code diff="chg" at="M">as</code> attribute is a
 <xnt spec="XP" ref="SequenceType">SequenceType</xnt>, as defined in <bibref ref="xpath20"/>.</p>

<p><error spec="XT" type="type" class="TE" code="0780"><p>If the <code>as</code> attribute 
<error.extra>of <elcode>xsl:function</elcode>
		</error.extra>
is specified, then the result evaluated by the 
<termref def="dt-sequence-constructor">sequence constructor</termref>
(see <specref ref="sequence-constructors"/>) is converted to the required type,
using the <termref def="dt-function-conversion-rules" diff="add" at="M">function conversion rules</termref>.
It is a <termref def="dt-type-error">type error</termref>
if this conversion fails.</p></error> 
If the <code diff="chg" at="M">as</code> attribute is omitted, the calculated result is used
as supplied, and no conversion takes place.</p>


<p>If a <termref def="dt-stylesheet-function">stylesheet function</termref> has been
 defined with a particular <termref def="dt-expanded-qname">expanded-QName</termref>, then a call
on <function>function-available</function> will return true when called with
an argument that is a <termref def="dt-lexical-qname" diff="chg" at="Y">lexical QName</termref> that expands to this
 same <termref def="dt-expanded-qname">expanded-QName</termref>.</p>


					
					
					
					<p>The <elcode>xsl:param</elcode> elements define the formal arguments to the
function. These are interpreted positionally. When the function is called
using a function-call in an XPath <termref def="dt-expression">expression</termref>, the first argument supplied is
assigned to the first <elcode>xsl:param</elcode> element, the second argument
supplied is assigned to the second <elcode>xsl:param</elcode> element, and so on.</p>
						
					<p>The <code diff="chg" at="M">as</code> attribute of the <elcode>xsl:param</elcode> element defines the
required type of the parameter. The rules for converting the values of the actual arguments
supplied in the function call to the types required by each <elcode>xsl:param</elcode> element
are defined in <bibref ref="xpath20"/>. 
The rules that apply are those for the case where 
<termref def="dt-compatibility-mode">XPath 1.0 compatibility mode</termref>
is set to <code>false</code>.</p>

<p><error spec="XT" type="type" class="TE" code="0790"><p>If the value 
of a parameter to a <termref def="dt-stylesheet-function">stylesheet function</termref>
 cannot be converted to the required type,
a <termref def="dt-type-error">type error</termref> is signaled.</p></error></p>
 
<p>If the <code>as</code> attribute is omitted, 
 no conversion takes place and any value is accepted.</p>
					
					
					
					<p>Within the body of a stylesheet function, the
<termref def="dt-focus">focus</termref>
 is initially undefined; this means that any attempt to reference the context item, context position,
 or context size is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>.
 <phrase diff="chg" at="ZA"><!--<xerrorref spec="XP" class="DY" code="0002"/>-->[XPDY0002]</phrase></p>
 
<p>It is not possible within the body of the 
<termref def="dt-stylesheet-function">stylesheet function</termref> to access the values of
local variables that were in scope in the place where the function call was written. Global
variables, however, remain available.</p>
					
					
					<example><head>A Stylesheet Function</head>
<p>The following example creates a recursive <termref def="dt-stylesheet-function">stylesheet function</termref>
 named <code>str:reverse</code> that reverses the words in a supplied sentence, 
and then invokes this function from within a <termref def="dt-template-rule">template rule</termref>. </p>

<eg><![CDATA[<xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:str="http://example.com/namespace"
  version="2.0"
  exclude-result-prefixes="str">

<xsl:function name="str:reverse" as="xs:string">
  <xsl:param name="sentence" as="xs:string"/>
  <xsl:sequence  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"/>
</xsl:function>

<xsl:template match="/">
<output>
  <xsl:value-of select="str:reverse('DOG BITES MAN')"/>
</output>
</xsl:template>

</xsl:transform>]]></eg>

<p>An alternative way of writing the same function is to implement the conditional
logic at the XSLT level, thus:</p>

<eg><![CDATA[<xsl:function name="str:reverse" as="xs:string">
  <xsl:param name="sentence" as="xs:string"/>
  <xsl:choose>
    <xsl:when test="contains($sentence, ' ')">  
      <xsl:sequence select="concat(str:reverse(substring-after($sentence, ' ')),
                                ' ',
                                substring-before($sentence, ' '))"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:sequence select="$sentence"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>]]></eg>

					</example>
					<example><head>Declaring the Return Type of a Function</head>
<p>The following example illustrates the use of the <code>as</code> attribute
 in a function definition.
It returns a string containing the representation of its integer argument, expressed
as a roman numeral. For example, the function call <code>num:roman(7)</code> will return
the string <code>"vii"</code>. This example uses the <elcode>xsl:number</elcode> instruction,
described in <specref ref="number"/>. The <elcode>xsl:number</elcode> instruction returns a text node,
and the <termref def="dt-function-conversion-rules">function conversion rules</termref>
are invoked to convert this text node to the type declared in the <elcode>xsl:function</elcode>
element, namely <code>xs:string</code>. So the text node is
 <termref def="dt-atomization">atomized</termref> to a string.</p>
<eg><![CDATA[<xsl:function name="num:roman" as="xs:string">
  <xsl:param name="value" as="xs:integer"/>
  <xsl:number value="$value" format="i"/>
</xsl:function>]]></eg>
					</example>


				
				
			</div2>
		</div1>
		<div1 id="creating-new-nodes">
			<head>Creating Nodes and Sequences</head>
			<p>This section describes instructions that directly create new nodes,
			or sequences of nodes and atomic values.</p>
			

<div2 id="literal-result-element">
<head>Literal Result Elements</head>
<p>
<termdef id="dt-literal-result-element" term="literal result element">In 
a <termref def="dt-sequence-constructor">sequence constructor</termref>, an element in 
the <termref def="dt-stylesheet">stylesheet</termref> that does not belong to
the <termref def="dt-xslt-namespace">XSLT namespace</termref> and 
that is not an <termref def="dt-extension-instruction">extension instruction</termref> (see <specref ref="extension-instruction"/>) is classified as a 
<term>literal result element</term>.</termdef>
A literal result element is evaluated to construct a new element node
with the same <termref def="dt-expanded-qname">expanded-QName</termref> 
<phrase diff="add" at="U">(that is, the same namespace URI, local name, and namespace prefix)</phrase>.
The result of evaluating a literal result element
is a node sequence containing one element, the newly constructed element node.</p>
				<p>The content
of the element is a <termref def="dt-sequence-constructor">sequence constructor</termref>
(see <specref ref="sequence-constructors"/>).
The sequence obtained by evaluating this sequence constructor, after prepending
any attribute nodes produced as described in <specref ref="attributes-for-lres"/> and namespace nodes
produced as described in <specref ref="lre-namespaces"/>, is used to construct
the content of the element, following the rules in <specref ref="constructing-complex-content"/>	
				</p>

<p diff="add" at="X">The base URI of the new element is copied from the base URI of the literal
result element in the stylesheet, unless the content of the new element includes an <code>xml:base</code>
attribute, in which case the base URI of the new element is the value of that attribute, resolved (if it is a relative
URI) against the base URI of the literal result element in the stylesheet. 
(Note, however, that this is only relevant when creating a parentless
element. When the literal result element is copied
to form a child of an element or document node, the base URI of the new copy is taken from that 
of its new parent.)</p> 

				<div3 id="setting-annotation-for-lre" diff="chg" at="Q">
					<head>Setting the Type Annotation for Literal Result Elements</head>

<p>The attributes <code>xsl:type</code> and <code>xsl:validation</code> may be used on a 
literal result element to invoke validation of
 the contents of the element against a type definition or element declaration
 in a schema, 
and to determine the <termref def="dt-annotation">type annotation</termref> that the new element node will carry.
These attributes also affect the type annotation carried by any elements and attributes that have
the new element node as an ancestor.
These two attributes are both optional, and if one is specified then the other <rfc2119>must</rfc2119> be omitted.</p>

<p diff="chg" at="ZB">The value of the <code>xsl:validation</code> attribute, if present, must be
one of the values <code>strict</code>, <code>lax</code>, <code>preserve</code>, or <code>strip</code>.
The value of the <code>xsl:type</code> attribute, if present, must be a <termref def="dt-qname">QName</termref>
identifying a type definition that is present in the <termref def="dt-in-scope-schema-component">in-scope
schema components</termref> for the stylesheet. Neither attribute may be specified as an
<termref def="dt-attribute-value-template">attribute value template.</termref>
The effect of these attributes is described in
 <specref ref="validation"/>.</p>

				</div3>
				<div3 id="attributes-for-lres">
					<head>Attribute Nodes for Literal Result Elements</head>
					
<p>Attribute nodes for a literal result element may be created by including 
 <elcode>xsl:attribute</elcode> instructions within the <termref def="dt-sequence-constructor">sequence constructor</termref>.
Additionally, attribute nodes are created corresponding to the attributes of the literal result element in the stylesheet,
and as a result of expanding the <code>xsl:use-attribute-sets</code> attribute of the literal result element,
if present.</p>

<p>The sequence that is used to construct the content of the literal result element (as described in
<specref ref="constructing-complex-content"/>) is the concatenation of the following four sequences, in order:</p>

<olist diff="add" at="R">
<item><p>The sequence of namespace nodes produced as described in <specref ref="lre-namespaces"/>.</p>
</item>

<item><p>The sequence of attribute nodes produced by expanding the <code>xsl:use-attribute-sets</code> attribute
(if present) following the rules given in <specref ref="attribute-sets"/></p></item>

<item><p>The attributes produced by processing the attributes of the literal result element itself, other than
attributes in the <termref def="xslt-namespace">XSLT namespace</termref>. The way these are processed is described
below.</p></item>

<item><p>The sequence produced by evaluating the contained 
<termref def="dt-sequence-constructor">sequence constructor</termref>, if the element is not empty.</p></item>
</olist>

<note diff="add" at="R"><p>The significance of this order is that an attribute produced by an 
<code>xsl:attribute</code><phrase diff="add" at="ZA">, <elcode>xsl:copy</elcode>, or <elcode>xsl:copy-of</elcode></phrase>
 instruction
in the content of the literal result element takes precedence over an attribute produced by expanding an attribute
of the literal result element itself, which in turn takes precedence over an attribute produced by expanding
the <code>xsl:use-attribute-sets</code> attribute. This is because of the rules in
<specref ref="constructing-complex-content"/>, which specify that when two or more attributes in the sequence have
the same name, all but the last of the duplicates are discarded.</p>

<p diff="add" at="T">Although the above rules place namespace nodes before attributes, 
this is not strictly necessary, because the rules in <specref ref="constructing-complex-content"/>
allow the namespaces and attributes to appear in any 
order so long as both come before other kinds of node. The order 
of namespace nodes and attribute nodes in the sequence has no effect 
on the relative position of the nodes in document order once they 
are added to a tree.</p>

</note>				
					
<p>Each attribute of the literal result element, other than an attribute in the 
<termref def="dt-xslt-namespace">XSLT namespace</termref>, is processed to produce an 
attribute for the element in the <termref def="dt-result-tree">result tree</termref>.</p>

					<p>The value of such an attribute is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>: it can therefore contain <termref def="dt-expression">expressions</termref> contained
in curly brackets (<code>{}</code>). The new attribute node 
will have the same <termref def="dt-expanded-qname">expanded-QName</termref> 
<phrase diff="add" at="U">(that is, the same namespace URI, local name, and namespace prefix)</phrase>
 as the attribute in the stylesheet tree, and its
<termref def="dt-string-value">string value</termref> will be the same as the <termref def="dt-effective-value">effective value</termref>
of the attribute in the stylesheet tree. 
The <termref def="dt-annotation">type annotation</termref> on the attribute will initially be 
<phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>, and the <termref def="dt-typed-value">typed value</termref>
 of the attribute node will be the same 
as its <termref def="dt-string-value">string value</termref>.</p>

<note><p>The eventual <termref def="dt-annotation">type annotation</termref> of the attribute in the 
<termref def="dt-result-tree">result tree</termref> depends 
on the <code>xsl:validation</code> and <code>xsl:type</code> attributes of the parent literal result element,
and on the instructions used to create its ancestor elements. 
If the <code>xsl:validation</code> attribute is set to 
<code>preserve</code> or <code>strip</code>, the type annotation will be 
<phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>, and the <termref def="dt-typed-value">typed value</termref>
 of the attribute node will be the same 
as its <termref def="dt-string-value">string value</termref>. 
If the <code>xsl:validation</code> attribute is set to 
<code>strict</code> or <code>lax</code>, or if the <code>xsl:type</code> attribute
is used, the type annotation on the attribute will be set as
 a result of the schema validation process applied to the parent element.
 If neither attribute is present, the type annotation on the attribute 
 will be <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>.</p></note>


	

<p diff="add" at="ZA">If the name of a constructed attribute is <code>xml:id</code>, the processor must perform
attribute value normalization by effectively applying the <xfunction>normalize-space</xfunction> function to
the value of the attribute, and the resulting attribute node must be given the
<code>is-id</code> property.</p>

<p diff="add" at="ZB"><error spec="XT" type="dynamic" class="RE" code="0795"><p>It 
is a <termref def="dt-recoverable-error">recoverable dynamic
error</termref> if the name of a constructed attribute is <code>xml:space</code> and the value is not
either <code>default</code> or <code>preserve</code>. 
<error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to construct
the attribute with the value as requested.</error.action></p></error>. This applies whether
the attribute is constructed using a literal result element, or by using the <elcode>xsl:attribute</elcode>,
<elcode>xsl:copy</elcode>, or <elcode>xsl:copy-of</elcode> instructions.</p>  

					<note>
						<p>The <code>xml:base</code>, 
<code>xml:lang</code>, <code>xml:space</code>,
and <code>xml:id</code>
attributes have two effects in XSLT. They
behave as standard XSLT attributes, which means for example that if they appear on
a literal result element, they will be copied to the <termref def="dt-result-tree">result tree</termref> in the same
way as any other attribute. In addition, they have their standard meaning
as defined in the core XML specifications. Thus, an <code>xml:base</code>
attribute in the stylesheet affects the base URI of the element on which it appears,
and an <code>xml:space</code> attribute affects the interpretation of 
<termref def="dt-whitespace-text-node">whitespace text
nodes</termref> within that element. One consequence of this is that 
it is inadvisable to write these attributes
 as attribute value templates: although an XSLT processor
will understand this notation, the XML parser will not. See
also <specref ref="namespace-aliasing"/> which describes how to use <elcode>xsl:namespace-alias</elcode>
with these attributes.</p>
					
						<p>The same is true of the schema-defined attributes
<code>xsi:type</code>, <code>xsi:nil</code>, 
<phrase diff="add" at="Z"><code>xsi:noNamespaceSchemaLocation</code></phrase>,
and <code>xsi:schemaLocation</code>.
If the stylesheet is processed by a schema processor,
these attributes will be recognized and interpreted by the schema processor, but 
<phrase diff="chg" at="ZA">in addition the XSLT processor treats them like any other attribute
on a literal result element: that is, their <termref def="dt-effective-value">effective value</termref> 
(after expanding <termref def="dt-attribute-value-template">attribute value templates</termref>) is copied to the result
tree in the same way as any other attribute.</phrase> If the <termref def="dt-result-tree">result tree</termref> 
is validated, the copied
attributes will again be recognized and interpreted by the schema processor.</p>
						
						<p>None of these attributes
will be generated in the <termref def="dt-result-tree">result tree</termref> unless the stylesheet writes them to the result
tree explicitly, in the same way as any other attribute.</p>
					</note>
					
<p><error spec="XT" type="static" class="SE" code="0805"><p>It is a
 <termref def="dt-static-error">static error</termref>
if an attribute on a literal result element is in the <termref def="dt-xslt-namespace">XSLT namespace</termref>,
unless it is one of the attributes explicitly defined in this specification.</p></error></p>					

<note diff="add" at="T"><p>If there is a need to create attributes in the XSLT namespace,
this can be achieved using <elcode>xsl:attribute</elcode>, or by means of the 
<elcode>xsl:namespace-alias</elcode> declaration.</p></note> 
					
				</div3>
				<div3 id="lre-namespaces">
					<head>Namespace Nodes for Literal Result Elements</head>
					<p>The created element node will have a copy of the namespace
nodes that were present on the element node in the stylesheet tree
with the exception of any namespace node whose <termref def="dt-string-value">string value</termref>
is designated as an <term>excluded namespace</term>. Special considerations
apply to aliased namespaces: see <specref ref="namespace-aliasing"/></p>
					<p>The following namespaces are designated as excluded namespaces:</p>
					<ulist>
						<item>
							<p>The <termref def="dt-xslt-namespace">XSLT namespace</termref> URI
 (<code>http://www.w3.org/1999/XSL/Transform</code>)</p>
						</item>
						<item>
							<p>A namespace URI declared as an extension namespace 
(see <specref ref="extension-instruction"/>)</p>
						</item>
						<item>
							<p>A namespace URI designated by using an <code>[xsl:]exclude-result-prefixes</code>
attribute either on the literal result element itself or
on an ancestor element. The attribute <rfc2119>must</rfc2119> be in the XSLT namespace only
if its parent element is <emph>not</emph> in the XSLT namespace.</p>
							
<p>The value of the attribute is either <code>#all</code>,
or a whitespace-separated
list of tokens, each of which is either a namespace prefix
or <code>#default</code>. The namespace bound to each of the
prefixes is designated as an excluded namespace.</p>

<p diff="chg" at="T"><error class="SE" type="static" spec="XT" code="0808"><p>It is a
 <termref def="dt-static-error">static error</termref> if a namespace prefix 
 is used within the <code>[xsl:]exclude-result-prefixes</code> attribute and there
 is no namespace binding in scope for that prefix.</p></error></p>

<p>The default namespace 
of the parent element of the <code>[xsl:]exclude-result-prefixes</code>
attribute (see <xspecref spec="DM" ref="ElementNode"/>) 
may be designated as an
excluded namespace by including <code>#default</code> in the list of
namespace prefixes.</p>

<p diff="add" at="T"><error class="SE" type="static" spec="XT" code="0809"><p>It is a
 <termref def="dt-static-error">static error</termref> if the value <code>#default</code> 
 is used within the <code>[xsl:]exclude-result-prefixes</code> attribute and 
 the parent element of the <code>[xsl:]exclude-result-prefixes</code>
attribute has no default namespace.</p></error></p>

<p>The value <code>#all</code> indicates that all namespaces 
that are in scope for the stylesheet element that is the
parent of the <code>[xsl:]exclude-result-prefixes</code> attribute
are designated as excluded namespaces.</p>
							<p>The designation of a namespace as an excluded
namespace is effective within the subtree of the stylesheet module rooted at
the element bearing the <code>[xsl:]exclude-result-prefixes</code> attribute;
a subtree rooted at an <elcode>xsl:stylesheet</elcode> element
does not include any stylesheet modules imported or included by children
of that <elcode>xsl:stylesheet</elcode> element.</p>
						</item>
					</ulist>
					<p>The excluded namespaces, as described above, <emph>only</emph> affect namespace
 nodes copied from the stylesheet when processing a literal result element.
There is no guarantee that an excluded namespace will not appear on the <termref def="dt-result-tree">result tree</termref>
for some other reason. Namespace nodes are also written to the result tree
as part of the process of namespace fixup (see <specref ref="namespace-fixup"/>), 
or as the result of instructions such as 
<elcode>xsl:copy</elcode> and <elcode>xsl:element</elcode>.</p>

					<note>
						<p>When a stylesheet uses a namespace declaration only for the
purposes of addressing a <termref def="dt-source-tree">source tree</termref>, specifying the prefix in the
<code>[xsl:]exclude-result-prefixes</code> attribute will avoid superfluous
namespace declarations in the serialized <termref def="dt-result-tree">result tree</termref>. The attribute is also useful
to prevent namespaces used solely for the naming of stylesheet functions or extension functions from
appearing in the serialized result tree.</p>
					</note>
					
<example>
<head>Excluding Namespaces from the Result Tree</head>
<p>For example, consider the following stylesheet:</p>
<eg><![CDATA[<xsl:stylesheet xsl:version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri">
  exclude-result-prefixes="#all">
  
<xsl:template match="/">
  <foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/>
</xsl:template>

</xsl:stylesheet>]]></eg>

<p>The result of this stylesheet will be:</p>

<eg><![CDATA[<foo xmlns:d="d.uri"/>]]></eg>

<p>The namespaces <code>a.uri</code> and <code>b.uri</code> are excluded by virtue of the
<code>exclude-result-prefixes</code> attribute on the <elcode>xsl:stylesheet</elcode> element, and
the namespace <code>c.uri</code> is excluded by virtue of the <code>xsl:exclude-result-prefixes</code> 
attribute on the <code>foo</code> element. The setting <code>#all</code> does not affect the namespace
<code>d.uri</code> because <code>d.uri</code> is not an in-scope namespace for the <elcode>xsl:stylesheet</elcode>
element. The element in the <termref def="dt-result-tree">result tree</termref> does not have a namespace node corresponding to <code>xmlns:a2="a.uri"</code>
because the effect of <code>exclude-result-prefixes</code> is to designate the namespace URI <code>a.uri</code>
as an excluded namespace, irrespective of how many prefixes are bound to this namespace URI.</p>

<p>If the stylesheet is changed so that the literal result element has an attribute <code>b:bar="3"</code>,
then the element in the <termref def="dt-result-tree">result tree</termref> will typically have
 a namespace declaration <code>xmlns:b="b.uri"</code>
 <phrase diff="chg" at="Z">(the processor may choose a different namespace prefix 
 if this is necessary to avoid conflicts)</phrase>. The
<code>exclude-result-prefixes</code> attribute makes <code>b.uri</code> an excluded namespace, so
the namespace node is not automatically copied from the stylesheet, but the
presence of an attribute whose name is in the namespace <code>b.uri</code> forces the namespace fixup process
(see <specref ref="namespace-fixup"/>) to introduce a namespace node for this namespace.</p>
</example>

<p diff="add" at="U">A literal result element may have an optional <code>xsl:inherit-namespaces</code>
attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>.
If the value is set to <code>yes</code>, or
is omitted, then the namespace nodes created for the newly constructed element are copied
to the children and descendants of the newly constructed element, as described in 
<specref ref="constructing-complex-content"/>. If the value is set to <code>no</code>, then these
namespace nodes are not automatically copied to the children. This may result in namespace
undeclarations (such as <code>xmlns=""</code> or, in the case of XML 1.1, <code>xmlns:p=""</code>)
appearing on the child elements when a <termref def="dt-final-result-tree">final result tree</termref> 
is serialized.</p>					
					
				</div3>
				<div3 id="namespace-aliasing">
					<head>Namespace Aliasing</head>
					<p>When a stylesheet is used to define a transformation
whose output is itself a stylesheet module, or in certain other cases where
the result document uses namespaces that it would be inconvenient to use
in the stylesheet, namespace aliasing can be used to declare a mapping
between a namespace URI used in the stylesheet and the corresponding
namespace URI to be used in the result document.</p>
					<p>
						<termdef id="dt-literal-namespace-uri" term="literal namespace URI">A
 namespace URI in the stylesheet tree that is being used to
specify a namespace URI in the <termref def="dt-result-tree">result tree</termref> 
is called a <term>literal namespace URI</term>.</termdef></p> 

<p><termdef id="dt-target-namespace-uri" term="target namespace URI">The 
namespace URI that is to be used in the <termref def="dt-result-tree">result tree</termref>
as a substitute for a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is called the
<term>target namespace URI</term>.</termdef></p>

<p diff="add" at="ZA">Either of the <termref def="dt-literal-namespace-uri">literal namespace URI</termref>
or the <termref def="dt-target-namespace-uri">target namespace URI</termref> can be <emph>null</emph>: this is treated
as a reference to the set of names that are in no namespace.</p>
 					
					<e:element-syntax name="namespace-alias">
						<e:in-category name="declaration"/>
						<e:attribute name="stylesheet-prefix" required="yes">
							<e:data-type name="prefix"/>
							<e:constant value="#default"/>
						</e:attribute>
						<e:attribute name="result-prefix" required="yes">
							<e:data-type name="prefix"/>
							<e:constant value="#default"/>
						</e:attribute>
						<e:empty/>
						<e:allowed-parents>
							<e:parent name="stylesheet"/>
							<e:parent name="transform"/>
						</e:allowed-parents>
					</e:element-syntax>
					<p>
						<termdef id="dt-alias" term="alias">A stylesheet can use the
<elcode>xsl:namespace-alias</elcode> element to declare that a
<termref def="dt-literal-namespace-uri">literal namespace URI</termref> is being used as an 
<term>alias</term> for a 
<termref def="dt-target-namespace-uri">target namespace URI</termref>.</termdef></p>

<p>The effect is that when names in the namespace identified by the
 <termref def="dt-literal-namespace-uri">literal namespace
URI</termref> are copied to the <termref def="dt-result-tree">result tree</termref>, 
 the namespace URI in the result tree will be the 
<termref def="dt-target-namespace-uri">target namespace URI</termref>, 
instead of the literal namespace URI. This applies to:</p>
					<ulist>
						<item>
							<p>the namespace URI in the <termref def="dt-expanded-qname">expanded-QName</termref> of a literal
result element in the stylesheet</p>
						</item>
						<item>
							<p>the namespace URI in the <termref def="dt-expanded-qname">expanded-QName</termref> of an attribute
specified on a literal result element in the stylesheet</p>
						</item>
						
					</ulist>

<p diff="add" at="U">Where namespace aliasing changes the namespace URI part of the 
<termref def="dt-expanded-qname">expanded-QName</termref> containing the name
of an element or attribute node, the namespace prefix in that expanded-QName is replaced by
 the prefix indicated by the <code>result-prefix</code> attribute of the
<elcode>xsl:namespace-alias</elcode> declaration.</p>
					
					<p>The <elcode>xsl:namespace-alias</elcode>
element declares that the namespace URI bound to the prefix specified
by the <code>stylesheet-prefix</code> is the
<termref def="dt-literal-namespace-uri">literal namespace
URI</termref>, and the namespace URI bound to the prefix specified by the
<code>result-prefix</code> attribute is the
<termref def="dt-target-namespace-uri">target namespace URI</termref>.
Thus, the
<code>stylesheet-prefix</code> attribute specifies the namespace URI
that will appear in the stylesheet, and the
<code>result-prefix</code> attribute specifies the corresponding
namespace URI that will appear in the <termref def="dt-result-tree">result tree</termref>.
					</p>

<p>The default namespace (as declared by <code>xmlns</code>) may be specified by
using <code>#default</code> instead of a prefix. <phrase diff="add" at="ZA">If no default
namespace is in force, specifying <code>#default</code> denotes the null namespace URI.
This allows elements that are in no namespace in the stylesheet to acquire a namespace in the result
document, or vice versa.</phrase></p>

<p>If a <termref def="dt-literal-namespace-uri">literal namespace URI</termref>
is declared to be an alias for multiple different 
<termref def="dt-literal-namespace-uri">target namespace URIs</termref>, then
the declaration with the highest <termref def="dt-import-precedence">import precedence</termref> is used.</p>

<p><error spec="XT" type="static" class="SE" code="0810"><p>It is
a <termref def="dt-static-error">static error</termref> if there is more
 than one such declaration 
 <error.extra>more than one <elcode>xsl:namespace-alias</elcode> declaration</error.extra>
 with the same <termref def="dt-literal-namespace-uri">literal namespace
URI</termref> and the same 
 <termref def="dt-import-precedence">import precedence</termref>
and different values for the <termref def="dt-target-namespace-uri">target namespace URI</termref>,
unless there is also an <elcode>xsl:namespace-alias</elcode> declaration
 with the same <termref def="dt-literal-namespace-uri">literal namespace
URI</termref> and a higher import precedence.  
						</p></error>
					</p>

<p diff="add" at="Z"><error spec="XT" type="static" class="SE" code="0812"><p>It is
a <termref def="dt-static-error">static error</termref> if a value other than <code>#default</code>
is specified for either the <code>stylesheet-prefix</code> or the <code>result-prefix</code>
attributes of the <elcode>xsl:namespace-alias</elcode> element when there is no in-scope binding
for that namespace prefix.</p></error></p>

				
<p>When a literal result element is processed, its namespace nodes are handled as follows:</p>

<ulist>

<item><p>A namespace node whose string value is a 
<termref def="dt-literal-namespace-uri">literal namespace URI</termref>
 is not copied to the <termref def="dt-result-tree">result tree</termref>.</p></item>

<item><p>A namespace node whose string value is a 
<termref def="dt-target-namespace-uri">target namespace URI</termref>
is copied to the <termref def="dt-result-tree">result tree</termref>, 
whether or not the URI identifies an excluded namespace.</p></item>

</ulist>

<p>In the event that the same URI is used as a 
<termref def="dt-literal-namespace-uri">literal namespace URI</termref> and a
<termref def="dt-target-namespace-uri">target namespace URI</termref>, the second
of these rules takes precedence.</p>

<note><p>These rules achieve the effect that the element generated
from the literal result element will have an in-scope namespace node that binds the
<code>result-prefix</code> to the <termref def="dt-target-namespace-uri">target namespace URI</termref>,
provided that the namespace declaration associating this prefix with this URI is in scope for
both the <elcode>xsl:namespace-alias</elcode> instruction and for the literal result element.
Conversely, the <code>stylesheet-prefix</code> and the 
<termref def="dt-literal-namespace-uri">literal namespace URI</termref> will not normally appear
in the <termref def="dt-result-tree">result tree</termref>.</p></note>


					

					<example><head>Using <code>xsl:namespace-alias</code> to Generate a Stylesheet</head>
						<p>When literal result elements are being used to create element,
attribute, or namespace nodes that use 
the <termref def="dt-xslt-namespace">XSLT namespace</termref> URI, the
stylesheet may use an alias. </p>
						<p>For example, the stylesheet</p>
						<eg><![CDATA[<xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias">

<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/>

<xsl:template match="/">
  <axsl:stylesheet version="2.0">
    <xsl:apply-templates/>
  </axsl:stylesheet>
</xsl:template>

<xsl:template match="elements">
  <axsl:template match="/">
     <axsl:comment select="system-property('xsl:version')"/>
     <axsl:apply-templates/>
  </axsl:template>
</xsl:template>

<xsl:template match="block">
  <axsl:template match="{.}">
     <fo:block><axsl:apply-templates/></fo:block>
  </axsl:template>
</xsl:template>

</xsl:stylesheet>]]></eg>
						<p>will generate an XSLT stylesheet from a document of the form:</p>
						<eg><![CDATA[<elements>
<block>p</block>
<block>h1</block>
<block>h2</block>
<block>h3</block>
<block>h4</block>
</elements>]]></eg>
						<p>The output of the transformation will be a stylesheet such as the following.
Whitespace has been added for clarity. Note that an implementation may output different namespace prefixes 
from those appearing in this example; however, the rules guarantee that there
will be a namespace node that binds the prefix <code>xsl</code> to the URI <code>http://www.w3.org/1999/XSL/Transform</code>,
which makes it safe to use the QName <code>xsl:version</code> in the content of the generated stylesheet.</p>

<eg><![CDATA[<xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format">

<xsl:template match="/">
  <xsl:comment select="system-property('xsl:version')"/>
  <xsl:apply-templates/>
</xsl:template>
  
<xsl:template match="p">
  <fo:block><xsl:apply-templates/></fo:block>
</xsl:template>

<xsl:template match="h1">
  <fo:block><xsl:apply-templates/></fo:block>
</xsl:template>

<xsl:template match="h2">
  <fo:block><xsl:apply-templates/></fo:block>
</xsl:template>

<xsl:template match="h3">
  <fo:block><xsl:apply-templates/></fo:block>
</xsl:template>

<xsl:template match="h4">
  <fo:block><xsl:apply-templates/></fo:block>
</xsl:template>

</xsl:stylesheet>]]></eg>
					</example>
					<note>
						<p>It may be necessary also to use aliases for namespaces other
than the XSLT namespace URI.  For example, it can be useful to
define an alias for the namespace <code>http://www.w3.org/2001/XMLSchema-instance</code>, 
so that the stylesheet can use the attributes <code>xsi:type</code>, 
<code>xsi:nil</code>, and <code>xsi:schemaLocation</code> on a literal result element, without
running the risk that a schema processor will interpret these as applying to the stylesheet itself.
Equally, literal result elements
belonging to a namespace dealing with digital signatures might cause
XSLT stylesheets to be mishandled by general-purpose security
software; using an alias for the namespace would avoid the possibility
of such mishandling.</p></note>


<example>
<head>Aliasing the XML Namespace</head>
<p>It is possible to define an alias for the XML
namespace.</p>
<eg><![CDATA[
<xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0">

<xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/>

<xsl:template match="/">
  <name axml:space="preserve">
    <first>James</first>
    <xsl:text> </xsl:text>
    <last>Clark</last>
  </name>
</xsl:template>

</xsl:stylesheet>]]></eg>

<p>produces the output:</p>

<eg><![CDATA[<name xml:space="preserve"><first>James</first> <last>Clark</last></name>]]></eg>

<p>This allows an <code>xml:space</code> attribute to be generated in the output without
affecting the way the stylesheet is parsed. The same technique can be used for other attributes
such as <code>xml:lang</code>, 
<code>xml:base</code>, and <code>xml:id</code>.</p>

</example>

<note diff="add" at="T"><p>Namespace aliasing is only necessary when literal result elements are used. The problem of
reserved namespaces does not arise when using <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode>
to construct the <termref def="dt-result-tree">result tree</termref>. Therefore, as an alternative to using <elcode>xsl:namespace-alias</elcode>,
it is always possible to achieve the desired effect by replacing literal result elements with 
<elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode> instructions.</p></note>
				</div3>
			</div2>
			<div2 id="xsl-element">
				<head>Creating Element Nodes Using <code>xsl:element</code>
				</head>
				<e:element-syntax name="element" diff="chg" at="R">
					<e:in-category name="instruction"/>
					<e:attribute name="name" required="yes">
						<e:attribute-value-template>
							<e:data-type name="qname"/>
						</e:attribute-value-template>
					</e:attribute>
					<e:attribute name="namespace">
						<e:attribute-value-template>
							<e:data-type name="uri-reference"/>
						</e:attribute-value-template>
					</e:attribute>
					<e:attribute name="inherit-namespaces">
						<e:constant value="yes"/>
						<e:constant value="no"/>
					</e:attribute>
					<e:attribute name="use-attribute-sets">
						<e:data-type name="qnames"/>
					</e:attribute>
    				<e:attribute name="type">
    					<e:data-type name="qname"/>
    				</e:attribute>
					<e:attribute name="validation">
						<e:constant value="strict"/>
						<e:constant value="lax"/>
						<e:constant value="preserve"/>
						<e:constant value="strip"/>
					</e:attribute>
					<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				
				<p>The <elcode>xsl:element</elcode> instruction allows an element to be
created with a computed name.  The <termref def="dt-expanded-qname">expanded-QName</termref> of the
element to be created is specified by a <rfc2119>required</rfc2119> <code>name</code>
attribute and an optional <code>namespace</code> attribute.</p>

<p>The content of the <elcode>xsl:element</elcode> instruction is a
 <termref def="dt-sequence-constructor">sequence constructor</termref> for the
children, attributes, and namespaces of the created element.
The sequence obtained by evaluating this sequence constructor 
(see <specref ref="sequence-constructors"/>) is used to construct
the content of the element, as described in <specref ref="constructing-complex-content"/>.</p>

<p>The <elcode>xsl:element</elcode> element may have a
<code>use-attribute-sets</code> attribute, whose value is a whitespace-separated list of QNames that identify
<elcode>xsl:attribute-set</elcode> declarations. If this attribute is present, it is expanded as
described in <specref ref="attribute-sets"/> to produce a sequence of attribute nodes. This sequence is
prepended to the sequence produced as a result of evaluating the <!--<code>select</code> attribute or-->
<termref def="dt-sequence-constructor">sequence constructor</termref>, as described in
<specref ref="constructing-complex-content"/>.</p>
				
<p>The result of evaluating the 
<elcode>xsl:element</elcode> instruction, except in error cases, is 
 the newly constructed element node.</p>
 
<p>The <code>name</code> attribute is interpreted as an
 <termref def="dt-attribute-value-template">attribute value template</termref>,
 whose <termref def="dt-effective-value">effective value</termref> <rfc2119>must</rfc2119> be a
 <termref def="dt-lexical-qname">lexical QName</termref>.</p>

<p><error spec="XT" type="dynamic" class="DE" code="0820"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
 the <termref def="dt-effective-value">effective value</termref>
of the <code>name</code> attribute <error.extra>of the
<elcode>xsl:element</elcode> instruction</error.extra> is not a <termref def="dt-lexical-qname">lexical QName</termref>.
</p></error></p>

<p><error spec="XT" type="dynamic" class="DE" code="0830"><p>In the 
case of an <elcode>xsl:element</elcode> instruction
with no <code>namespace</code> attribute, 
it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
 the <termref def="dt-effective-value">effective value</termref>
of the <code>name</code> attribute is a <termref def="dt-qname">QName</termref>
whose prefix is not declared in an in-scope namespace declaration for the <elcode>xsl:element</elcode> 
instruction.</p></error></p>
														

				<p>If the <code>namespace</code> attribute is
not present then the <termref def="dt-qname">QName</termref> is
expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> using the namespace declarations in
effect for the <elcode>xsl:element</elcode> element, including any default
namespace declaration.</p>
				<p>If the <code>namespace</code> attribute is present, then it too is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>. The <termref def="dt-effective-value">effective value</termref>
 <phrase diff="chg" at="Y"><rfc2119>must</rfc2119> be in the lexical space 
 of the <code>xs:anyURI</code> type.</phrase>  If
the string is zero-length, then the <termref def="dt-expanded-qname">expanded-QName</termref> of the element has a null
namespace URI.  Otherwise, the string is used as the namespace URI of
the <termref def="dt-expanded-qname">expanded-QName</termref> of the element to be created. The local part of the
<termref def="dt-lexical-qname">lexical QName</termref> specified by the
<code>name</code> attribute is used as the local part of the
<termref def="dt-expanded-qname">expanded-QName</termref> of the element to be created.</p>

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="0835"><p>
It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
 the <termref def="dt-effective-value">effective value</termref>
of the <code>namespace</code> attribute 
<error.extra>of the <elcode>xsl:element</elcode> instruction</error.extra>
is not in the lexical space of the <code>xs:anyURI</code> data type.</p></error></p>

<note diff="chg" at="X"><p>The <phrase diff="add" at="Z">XDM</phrase> data model requires the name of a node to be an instance of <code>xs:QName</code>, 
and XML Schema defines the namespace part of an <code>xs:QName</code> to be an instance of <code>xs:anyURI</code>.
However, the schema specification, and the specifications that it refers to,
give implementations some flexibility in how strictly they enforce these constraints.</p></note>

<p>The prefix of the <termref def="dt-lexical-qname">lexical QName</termref> 
				specified in the
<code>name</code> attribute (or the absence of a prefix) is copied to the prefix part of the
 <termref def="dt-expanded-qname">expanded-QName</termref>
representing the name of the new element node. 
In the event of a conflict <phrase diff="chg" at="ZB">a prefix 
may subsequently be added, changed, or removed</phrase> 
during the namespace fixup process (see <specref ref="namespace-fixup"/>).</p>

<p>The <elcode>xsl:element</elcode> instruction has an optional <code>inherit-namespaces</code>
attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>.
If the value is set to <code>yes</code>, or
is omitted, then the namespace nodes created for the newly constructed element (whether these were
copied from those of the source node, or generated as a result of namespace fixup) are copied
to the children and descendants of the newly constructed element, as described in 
<specref ref="constructing-complex-content"/>. If the value is set to <code>no</code>, then these
namespace nodes are not automatically copied to the children. This may result in namespace
undeclarations (such as <code>xmlns=""</code> or, in the case of XML Namespaces 1.1, <code>xmlns:p=""</code>)
appearing on the child elements when a <termref def="dt-final-result-tree">final result tree</termref> is serialized.</p>				

<p diff="add" at="X">The base URI of the new element is copied from the base URI of the <elcode>xsl:element</elcode>
instruction in the stylesheet, unless the content of the new element includes an <code>xml:base</code>
attribute, in which case the base URI of the new element is the value of that attribute, resolved (if it is a relative
URI) against the base URI of the <elcode>xsl:element</elcode> instruction in the stylesheet. 
(Note, however, that this is only relevant when creating parentless elements. 
When the new element is copied
to form a child of an element or document node, the base URI of the new copy is taken from that 
of its new parent.)</p> 

				<div3 id="annotation-for-constructed-element">
					<head>Setting the Type Annotation for a Constructed Element Node</head>
					
<p>The optional attributes <code>type</code> and
 <code>validation</code> may be used on the <elcode>xsl:element</elcode>
instruction to invoke validation of
 the contents of the element against a type definition or element declaration
 in a schema, 
and to determine the <termref def="dt-annotation">type annotation</termref> that the new element node will carry.
These attributes also affect the type annotation carried by any elements and attributes that have
the new element node as an ancestor.
These two attributes are both optional, and if one is specified then the other <rfc2119>must</rfc2119> be omitted.
The permitted values of these attributes and their semantics are described in
 <specref ref="validation"/>.</p>
 
 <note><p>The final type annotation of the element in the <termref def="dt-result-tree">result tree</termref> 
 also depends on the
 <code>type</code> and <code>validation</code> attributes of the instructions used to create the ancestors
 of the element.</p></note>					

				</div3>
			</div2>
			<div2 id="creating-attributes">
				<head>Creating Attribute Nodes Using <code>xsl:attribute</code>
				</head>
				<e:element-syntax name="attribute">
					<e:in-category name="instruction"/>
					<e:attribute name="name" required="yes">
						<e:attribute-value-template>
							<e:data-type name="qname"/>
						</e:attribute-value-template>
					</e:attribute>
					<e:attribute name="namespace">
						<e:attribute-value-template>
							<e:data-type name="uri-reference"/>
						</e:attribute-value-template>
					</e:attribute>
    				<e:attribute name="select">
    					<e:data-type name="expression"/>
    				</e:attribute>					
					<e:attribute name="separator">
						<e:attribute-value-template>
							<e:data-type name="string"/>
						</e:attribute-value-template>
					</e:attribute>
    				<e:attribute name="type">
    					<e:data-type name="qname"/>
    				</e:attribute>
					<e:attribute name="validation">
						<e:constant value="strict"/>
						<e:constant value="lax"/>
						<e:constant value="preserve"/>
						<e:constant value="strip"/>
					</e:attribute>
					<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent name="attribute-set"/>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>

				<p>The <elcode>xsl:attribute</elcode> element can be used to add
attributes to result elements whether created by literal result
elements in the stylesheet or by instructions such as
<elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode>. 
The <termref def="dt-expanded-qname">expanded-QName</termref> of the
attribute to be created is specified by a <rfc2119>required</rfc2119> <code>name</code>
attribute and an optional <code>namespace</code> attribute.
<phrase diff="add" at="R">Except in error cases,</phrase> 
the result of evaluating an <elcode>xsl:attribute</elcode> instruction
 is the newly constructed attribute node.</p>
 
<p>The string value of the new attribute node may be defined either by using the <code>select</code>
attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the
content of the <elcode>xsl:attribute</elcode> element. These are mutually exclusive. If neither is present,
the value of the new attribute node will be a zero-length string. The way in which the
value is constructed is specified in <specref ref="constructing-simple-content"/>.</p>

<p><error spec="XT" type="static" class="SE" code="0840"><p>It is a <termref def="dt-static-error">static error</termref> if
the <code>select</code> attribute of the <elcode>xsl:attribute</elcode> element is present unless the
element has empty content.</p></error></p> 

<p>If the <code>separator</code> attribute is present,
then the <termref def="dt-effective-value">effective value</termref> of 
this attribute is used to separate adjacent items in the result sequence, as described in 
<specref ref="constructing-simple-content"/>. In the absence of this attribute, the default
separator is a single space (#x20) when the content is specified using the <code>select</code>
attribute, or a zero-length string when the content is specified using a 
<termref def="dt-sequence-constructor">sequence constructor</termref>.</p> 


<p>The <code>name</code> attribute is interpreted as
an <termref def="dt-attribute-value-template">attribute value template</termref><phrase diff="add" at="R">,
whose <termref def="dt-effective-value">effective value</termref> <rfc2119>must</rfc2119> be a
<termref def="dt-lexical-qname">lexical QName</termref>.</phrase></p>
				 
<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="0850"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if 
the <termref def="dt-effective-value">effective value</termref>
						of the <code>name</code> attribute <error.extra>of an 
<elcode>xsl:attribute</elcode> instruction</error.extra> 
is not a <termref def="dt-lexical-qname">lexical QName</termref>.</p></error></p>

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="0855"><p>In the case 
of an <elcode>xsl:attribute</elcode> instruction with no <code>namespace</code> attribute, 
it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
 the <termref def="dt-effective-value">effective value</termref>
of the <code>name</code> attribute is the string <code>xmlns</code>.</p></error></p>	

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="0860"><p>In the case 
of an <elcode>xsl:attribute</elcode> instruction
with no <code>namespace</code> attribute, 
it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
 the <termref def="dt-effective-value">effective value</termref>
of the <code>name</code> attribute is a <termref def="dt-lexical-qname">lexical QName</termref>
whose prefix is not declared in an in-scope namespace declaration for the 
<elcode>xsl:attribute</elcode> instruction.</p></error></p>	

				<p>If the <code>namespace</code> attribute is not
present, then the <termref def="dt-lexical-qname">lexical QName</termref> is
expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> using the namespace declarations in
effect for the <elcode>xsl:attribute</elcode> element, <emph>not</emph>
including any default namespace declaration.</p>
				<p>If the <code>namespace</code> attribute is present, then it too is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>. The <termref def="dt-effective-value">effective value</termref>
 <phrase diff="chg" at="Y"><rfc2119>must</rfc2119> be in the lexical space 
 of the <code>xs:anyURI</code> type.</phrase>  If the string is zero-length, then the
<termref def="dt-expanded-qname">expanded-QName</termref> of the attribute has a null namespace URI.  Otherwise,
the string is used as the namespace URI of the <termref def="dt-expanded-qname">expanded-QName</termref> of the
attribute to be created. The local part of the <termref def="dt-lexical-qname">lexical QName</termref> specified by the
<code>name</code> attribute is used as the local part of the
<termref def="dt-expanded-qname">expanded-QName</termref> of the attribute to be created.</p>

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="0865"><p>
It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
 the <termref def="dt-effective-value">effective value</termref>
of the <code>namespace</code> attribute 
<error.extra>of the <elcode>xsl:attribute</elcode> instruction</error.extra>
is not in the lexical space of the <code>xs:anyURI</code> data type.</p></error></p>

          <note diff="add" at="W"><p>The same considerations apply as for elements: 
          <errorref spec="XT" class="DE" code="0835"/>
          in <specref ref="xsl-element"/>.</p></note>

<p>The prefix of the <termref def="dt-lexical-qname">lexical QName</termref> 
				specified in the
<code>name</code> attribute (or the absence of a prefix) is copied to the prefix part of the
 <termref def="dt-expanded-qname">expanded-QName</termref>
representing the name of the new attribute node. In the event of a conflict this prefix (or absence of a prefix) 
may subsequently be changed 
during the namespace fixup process (see <specref ref="namespace-fixup"/>). If the attribute is in a non-null
namespace and no prefix is specified, then the namespace fixup process will invent a prefix.</p>

<p>If the name of a constructed attribute is <code>xml:id</code>, 
<phrase diff="add" at="ZA">the processor must perform attribute value normalization
by effectively applying the <xfunction>normalize-space</xfunction> function to the value
of the attribute,</phrase> and 
the resulting attribute
node must be given the <code>is-id</code> property. This applies whether the attribute is constructed using the <elcode>xsl:attribute</elcode>
instruction or whether it is constructed using an attribute of a literal result element. This does not imply any
constraints on the value of the attribute, or on its uniqueness, and it does not affect the <termref def="dt-annotation">type annotation</termref>
of the attribute, unless the containing document is validated.</p>

<note><p>The effect of setting the <code>is-id</code> property is that the parent element
can be located within the containing document by use of the <xfunction>id</xfunction> function.
In effect, XSLT when constructing a document performs some of the functions of
 an <code>xml:id</code> processor, as defined in <bibref ref="xml-id"/>; the other aspects of
 <code>xml:id</code> processing are performed during validation.</p></note>

<example>
<head>Creating a List-Valued Attribute</head>
<p>The following instruction creates the attribute <code>colors="red green blue"</code>:</p>
<eg><![CDATA[<xsl:attribute name="colors" select="'red', 'green', 'blue'"/>]]></eg>
</example>
 

				<example><head>Namespaces are not Attributes</head>
					<p>It is not an error to write:</p>
					<eg><![CDATA[<xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace">http://www.w3.org/1999/XSL/Transform</xsl:attribute>]]></eg>
					<p>However, this will not result in the namespace declaration
<code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> being output. Instead, it will 
produce an attribute node with local name <code>xsl</code>, and with a system-allocated namespace
prefix mapped to the namespace URI <code>file://some.namespace</code>. This is because the
namespace fixup process is not allowed to use <code>xmlns</code> as the name of a namespace node.</p>
				</example>
				
				
				<p>As described in <specref ref="constructing-complex-content"/>,
				<phrase diff="add" at="Q">in a sequence that is used to construct the content of an element,</phrase>
any attribute nodes <rfc2119>must</rfc2119> appear in the sequence
before any element, text, comment, or processing instruction nodes. 
Where the sequence contains two
or more attribute nodes with the same <termref def="dt-expanded-qname">expanded-QName</termref>, the one that comes last
is the only one that takes effect.</p>

			
<note diff="add" at="R"><p>If a collection of attributes is generated repeatedly, this
can be done conveniently by using named attribute sets: see <specref ref="attribute-sets"/></p></note>				
				
				<div3 id="annotation-for-constructed-attribute">
					<head>Setting the Type Annotation for a Constructed Attribute Node</head>

<p>The optional attributes <code>type</code> 
and <code>validation</code> may be used on the <elcode>xsl:attribute</elcode>
instruction to invoke validation of
 the contents of the attribute against a type definition or attribute declaration in a schema,  
and to determine the <termref def="dt-annotation">type annotation</termref> that the new attribute node will carry.
These two attributes are both optional, and if one is specified then the other <rfc2119>must</rfc2119> be omitted.
The permitted values of these attributes and their semantics are described in
 <specref ref="validation"/>.</p>
 
 <note><p>The final <termref def="dt-annotation">type annotation</termref> of the attribute in the 
 <termref def="dt-result-tree">result tree</termref> also depends on the
 <code>type</code> and <code>validation</code> attributes of the instructions used to create the ancestors
 of the attribute.</p></note>		 			



				</div3>
			</div2>
			<div2 id="creating-text-nodes">
				<head>Creating Text Nodes</head>
				
<p>This section describes three different ways of creating text nodes: by means of
literal text nodes in the stylesheet, or by using the <elcode>xsl:text</elcode> and <elcode>xsl:value-of</elcode>
instructions. It is also possible to create text nodes using the <elcode>xsl:number</elcode> instruction
described in <specref ref="number"/>.</p>

<p>If and when the sequence that results from 
evaluating a <termref def="dt-sequence-constructor">sequence constructor</termref>
is used to form the content of a node, as described in
<specref ref="constructing-simple-content"/> and
<specref ref="constructing-complex-content"/>, adjacent text nodes
in the sequence are merged. Within the sequence itself, however, they exist as distinct nodes.</p>

<example>
<head>A sequence of text nodes</head>
<p>The following function returns a sequence of three text nodes:</p>
<eg><![CDATA[<xsl:function name="f:wrap">
  <xsl:param name="s"/>
  <xsl:text>(</xsl:text>
  <xsl:value-of select="$s"/>
  <xsl:text>)</xsl:text>
</xsl:function>]]></eg>
<p>When this function is called as follows:</p>
<eg><![CDATA[<xsl:value-of select="f:wrap('---')"/>]]></eg>
<p>the result is:</p>
<eg><![CDATA[(---)]]></eg>
<p>No additional spaces are inserted, because the calling <elcode>xsl:value-of</elcode> 
instruction merges adjacent text nodes before atomizing the sequence. However, the
result of the instruction:</p>
<eg><![CDATA[<xsl:value-of select="data(f:wrap('---'))"/>]]></eg>
<p>is:</p>
<eg><![CDATA[( --- )]]></eg>
<p>because in this case the three text nodes are atomized to form three strings,
and spaces are inserted between adjacent strings.</p>
</example>

<p diff="chg" at="W">It is possible to construct text nodes whose string value is zero-length.
A zero-length text node, when atomized, produces a zero-length string.
However, zero-length text nodes are ignored when they appear in a sequence 
that is used to form the content of a node, as described in
<specref ref="constructing-complex-content"/> and <specref ref="constructing-simple-content"/>.</p>
 			
				<div3 id="literal-text-nodes">
					<head>Literal Text Nodes</head>
					<p>A <termref def="dt-sequence-constructor">sequence constructor</termref> 
can contain text nodes.  Each text node in a
sequence constructor remaining after 
<termref def="dt-whitespace-text-node">whitespace text nodes</termref> have been stripped as specified in
<specref ref="stylesheet-stripping"/> will construct a new text node with the same
<termref def="dt-string-value">string value</termref>.  
The resulting text node is added to the result of the containing sequence constructor.</p>
					<p>Text is processed at the tree level. 
					Thus, markup of
<code>&amp;lt;</code> in a template will be represented in the
stylesheet tree by a text node that includes the character
<code>&lt;</code>. This will create a text node in the <termref def="dt-result-tree">result tree</termref>
that contains a <code>&lt;</code> character, which will be represented
by the markup <code>&amp;lt;</code> (or an equivalent character
reference) when the result tree is serialized as an XML document,
unless otherwise specified using <termref def="dt-character-map">character maps</termref>
(see <specref ref="character-maps"/>) or <code>disable-output-escaping</code>
 (see <specref ref="disable-output-escaping"/>).</p>
				</div3>
				<div3 id="xsl-text">
					<head>Creating Text Nodes Using <code>xsl:text</code>
					</head>
					<e:element-syntax name="text">
						<e:in-category name="instruction"/>
						<e:attribute name="disable-output-escaping" deprecated="yes">
							<e:constant value="yes"/>
							<e:constant value="no"/>
						</e:attribute>
						<e:text/>
						<e:allowed-parents>
							<e:parent-category name="sequence-constructor"/>
						</e:allowed-parents>
					</e:element-syntax>



					<p>The <elcode>xsl:text</elcode> element is evaluated to contruct a
new text node. The content of the
<elcode>xsl:text</elcode> element is a single text node whose value forms the 
<termref def="dt-string-value">string value</termref> of
the <phrase diff="add" at="R">new</phrase> text node. An <elcode>xsl:text</elcode> element may 
 be empty,
in which case the result of evaluating the instruction is <phrase diff="chg" at="T">a text node whose
string value is the zero-length string</phrase>.</p>
					
					<p>The result of evaluating an
					 <elcode>xsl:text</elcode> instruction is the newly constructed text node.</p>
					<p>A text node that is an immediate child of an <elcode>xsl:text</elcode> instruction
will not be stripped from the stylesheet tree, even if it consists entirely of whitespace 
(see <specref ref="strip"/>).</p>

					<p>For the effect of the <termref def="dt-deprecated">deprecated</termref>
					<code>disable-output-escaping</code> attribute,
see <specref ref="disable-output-escaping"/>
					</p>
					

					<note>
						<p>It is not always necessary to use the <elcode>xsl:text</elcode> instruction
to write text nodes to the <termref def="dt-result-tree">result tree</termref>. Literal text can be written to the result tree by including
it anywhere in a <termref def="dt-sequence-constructor">sequence constructor</termref>, while
computed text can be output using the <elcode>xsl:value-of</elcode> instruction. The principal reason
for using <elcode>xsl:text</elcode> is that it offers improved control over whitespace handling.</p>
					</note>
				</div3>
				
			<div3 id="value-of">
				<head>Generating Text with <elcode>xsl:value-of</elcode>
				</head>
				<p diff="chg" at="ZA">Within a <termref def="dt-sequence-constructor">sequence constructor</termref>, 
the <elcode>xsl:value-of</elcode> instruction can be
used to generate computed text nodes. The
<elcode>xsl:value-of</elcode> instruction computes the text 
using an <termref def="dt-expression">expression</termref> that is specified as the
value of the <code>select</code> attribute, or by means of contained
instructions. This might, for example, extract text from
a <termref def="dt-source-tree">source tree</termref> or insert the value of a variable.  </p>
				
				<e:element-syntax name="value-of" diff="chg" at="R">
					<e:in-category name="instruction"/>
					<e:attribute name="select">
						<e:data-type name="expression"/>
					</e:attribute>
					<e:attribute name="separator">
						<e:attribute-value-template>
							<e:data-type name="string"/>
						</e:attribute-value-template>
					</e:attribute>
					<e:attribute name="disable-output-escaping" deprecated="yes">
						<e:constant value="yes"/>
						<e:constant value="no"/>
					</e:attribute>
					<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				<p>The <elcode>xsl:value-of</elcode> instruction is evaluated to construct a
new text node; the result of the instruction is the newly constructed text node.</p>

<p>The string value of the new text node may be defined either by using the <code>select</code>
attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> 
(see <specref ref="sequence-constructors"/>) that forms the
content of the <elcode>xsl:value-of</elcode> element. These are mutually exclusive, and one of them
must be present. The way in which the
value is constructed is specified in <specref ref="constructing-simple-content"/>.</p>

<p><error spec="XT" type="static" class="SE" code="0870"><p>It is a <termref def="dt-static-error">static error</termref> if
the <code>select</code> attribute of the <elcode>xsl:value-of</elcode> element is present when the
content of the element is non-empty, or if the <code>select</code> attribute is absent when the
content is empty.</p></error></p> 



<p>If the <code>separator</code> attribute is present,
then the <termref def="dt-effective-value">effective value</termref> of 
this attribute is used to separate adjacent items in the result sequence, as described in 
<specref ref="constructing-simple-content"/>. In the absence of this attribute, the default
separator is a single space (#x20) when the content is specified using the <code>select</code>
attribute, or a zero-length string when the content is specified using a 
<termref def="dt-sequence-constructor">sequence constructor</termref>.</p>

<p>Special rules apply when 
<termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref> is enabled for the
instruction. If no <code>separator</code> attribute is present, and if the <code>select</code> attribute
is present, then all items in the <termref def="dt-atomization">atomized</termref>
 result sequence other than the first are ignored.</p>


				<example><head>Generating a List with Separators</head>
					<p>The instruction:</p>
<eg><![CDATA[<x><xsl:value-of select="1 to 4" separator="|"/></x>]]></eg>
<p>produces the output:</p>
<eg><![CDATA[<x>1|2|3|4</x>]]></eg>
				</example>

				<note>
					<p>The <elcode>xsl:copy-of</elcode> element can be used to copy
 a sequence of nodes
 to the <termref def="dt-result-tree">result tree</termref> 
 without <termref def="dt-atomization">atomization</termref>. See <specref ref="copy-of"/>.</p>
				</note>
				

				<p>For the effect of the <termref def="dt-deprecated">deprecated</termref>
				<code>disable-output-escaping</code> attribute,
see <specref ref="disable-output-escaping"/>
				</p>

			</div3>				
				
				
			</div2>
			
			<div2 id="creating-document-nodes">
			<head>Creating Document Nodes</head>
				<e:element-syntax name="document">
					<e:in-category name="instruction"/>
					<e:attribute name="validation">
						<e:constant value="strict"/>
						<e:constant value="lax"/>
						<e:constant value="preserve"/>
						<e:constant value="strip"/>
					</e:attribute>
    				<e:attribute name="type">
    					<e:data-type name="qname"/>
    				</e:attribute>
					<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>	
				
<p>The <elcode>xsl:document</elcode> instruction is used to create a new document node.		
The content of the <elcode>xsl:document</elcode> element is a 
<termref def="dt-sequence-constructor">sequence constructor</termref> 
for the children of the new document node. A document node is created, and 
the sequence obtained by evaluating the sequence constructor is used to construct
the content of the document, as described in <specref ref="constructing-complex-content"/>.
The <termref def="dt-temporary-tree">temporary tree</termref> rooted at this document node forms the 
<termref def="dt-result-tree">result tree</termref>.</p>
			
				<p>Except in error situations, the result of evaluating the
 <elcode>xsl:document</elcode> instruction is a single node, the newly constructed document node.</p>
 
 <note><p>The new document is not serialized. To construct a document that is to form a final result
 rather than an intermediate result, use the <elcode>xsl:result-document</elcode> instruction described
 in <specref ref="creating-result-trees"/>.</p></note>
 
 <p>The optional attributes <code>type</code> and <code>validation</code> may 
be used on the <elcode>xsl:document</elcode>
instruction to validate the contents of the new document, and to
determine the <termref def="dt-annotation">type annotation</termref> that elements and attributes within the 
<termref def="dt-result-tree">result tree</termref> will carry.
The permitted values and their semantics are described in
<specref ref="validating-document-nodes"/>.</p>

<p>The base URI of the new document node is taken from the base URI of the <elcode>xsl:document</elcode>
instruction.</p>

<p diff="add" at="W">The <code>document-uri</code> and <code>unparsed-entities</code> properties 
of the new document node are set to empty.</p>


<example>
<head>Checking Uniqueness Constraints in a Temporary Tree</head>

<p>The following example creates a temporary tree held in a variable. The use of an
enclosed <elcode>xsl:document</elcode> instruction ensures that uniqueness constraints defined
in the schema for the relevant elements are checked.</p>

<eg><![CDATA[<xsl:variable name="tree" as="document-node()">
  <xsl:document validation="strict">
    <xsl:apply-templates/>
  </xsl:document>
</xsl:variable>]]></eg>

</example>

</div2>			
			
			<div2 id="creating-processing-instructions">
				<head>Creating Processing Instructions</head>
				<e:element-syntax name="processing-instruction">
					<e:in-category name="instruction"/>
					<e:attribute name="name" required="yes">
						<e:attribute-value-template>
							<e:data-type name="ncname"/>
						</e:attribute-value-template>
					</e:attribute>
    				<e:attribute name="select">
    					<e:data-type name="expression"/>
    				</e:attribute>	
					<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				<p>The <elcode>xsl:processing-instruction</elcode> element is evaluated
to create a processing instruction node.</p>

<p>The <elcode>xsl:processing-instruction</elcode> element has a <rfc2119>required</rfc2119>
<code>name</code> attribute that specifies the name of the processing
instruction node.  The value of the <code>name</code> attribute is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>.</p>

<p>The string value of the new processing-instruction node may be defined either by using the <code>select</code>
attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the
content of the <elcode>xsl:processing-instruction</elcode> element. These are mutually exclusive. If neither is present,
the string value of the new processing-instruction node will be a zero-length string. The way in which the
value is constructed is specified in <specref ref="constructing-simple-content"/>.</p>

<p><error spec="XT" type="static" class="SE" code="0880"><p>It is a <termref def="dt-static-error">static error</termref> if
the <code>select</code> attribute of the <elcode>xsl:processing-instruction</elcode> element is present unless the
element has empty content.</p></error></p> 

				<p>Except in error situations, the result of evaluating the
 <elcode>xsl:processing-instruction</elcode> instruction is 
  a single node, the newly constructed processing instruction <phrase diff="add" at="R">node</phrase>.</p>
				<example>
				<head>Creating a Processing Instruction</head>
					<p>This instruction:</p>
					<eg><![CDATA[<xsl:processing-instruction name="xml-stylesheet"
  select="('href=&quot;book.css&quot;', 'type=&quot;text/css&quot;)"/>]]></eg>
					<p>creates the processing instruction</p>
					<eg><![CDATA[<?xml-stylesheet href="book.css" type="text/css"?>]]></eg>
					<p>Note that the <code>xml-stylesheet</code> processing instruction
					contains <emph>pseudo-attributes</emph>
					in the form <code>name="value"</code>. Although these have the same textual form
					as attributes in an element start tag, they are not represented as <phrase diff="chg" at="Z">XDM</phrase> 
					attribute nodes, and cannot therefore be constructed using <elcode>xsl:attribute</elcode>
					instructions.</p>
				</example>

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="0890"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
 <termref def="dt-effective-value">effective value</termref> of the
<code>name</code> attribute <error.extra>of the <elcode>xsl:processing-instruction</elcode> 
instruction</error.extra> is not both an <xnt spec="Names" ref="NT-NCName">NCName</xnt> and a
 <xnt spec="XML" ref="PITarget">PITarget</xnt>.</p></error>
				</p>
				<note>
					<p><phrase diff="chg" at="R">Because these rules disallow the name <code>xml</code>,</phrase>
					the <elcode>xsl:processing-instruction</elcode>
cannot be used to output an XML declaration.  The
<elcode>xsl:output</elcode> declaration should be used to control this instead (see <specref ref="serialization"/>).</p>
				</note>

<p diff="chg" at="X">If the result of evaluating the content of the
<elcode>xsl:processing-instruction</elcode> contains the string
<code>?&gt;</code>, this string is modified by inserting a space between the
 <code>?</code> and <code>&gt;</code> characters.</p>

<p diff="add" at="X">The base URI of the new processing-instruction is copied from the base URI of the 
<elcode>xsl:processing-instruction</elcode> element in the stylesheet. 
(Note, however, that this is only relevant when creating a parentless
processing instruction. When the new processing instruction is copied
to form a child of an element or document node, the base URI of the new copy is taken from that 
of its new parent.)</p> 

			</div2>
			<div2 id="creating-namespace-nodes">
				<head>Creating Namespace Nodes</head>
				<e:element-syntax name="namespace">
					<e:in-category name="instruction"/>
					<e:attribute name="name" required="yes">
						<e:attribute-value-template>
							<e:data-type name="ncname"/>
						</e:attribute-value-template>
					</e:attribute>
    				<e:attribute name="select">
    					<e:data-type name="expression"/>
    				</e:attribute>	
					<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				
<p>The <elcode>xsl:namespace</elcode> element is evaluated
to create a namespace node. Except in error situations, the result of evaluating the
 <elcode>xsl:namespace</elcode> instruction is 
  a single node, the newly constructed namespace node.</p>

<p>The <elcode>xsl:namespace</elcode> element has a <rfc2119>required</rfc2119>
<code>name</code> attribute that specifies the name of the namespace node
(that is, the namespace prefix).  The value of the <code>name</code> attribute is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>. If the 
<phrase diff="chg" at="R"><termref def="dt-effective-value">effective value</termref></phrase> 
of the <code>name</code> attribute is a
zero-length string, a namespace node is added for the default namespace.</p>

<p>The string value of the new namespace node (that is, the namespace URI)
may be defined either by using the <code>select</code>
attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the
content of the <elcode>xsl:namespace</elcode> element. These are mutually exclusive. Since the string value
of a namespace node cannot be a zero-length string, one of them must be present. The way in which the
value is constructed is specified in <specref ref="constructing-simple-content"/>.</p>

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="0905"><p>It is a 
<termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
the string value of the new namespace node
<error.extra>created using <elcode>xsl:namespace</elcode></error.extra>
is not valid in the lexical space of the data type <code>xs:anyURI</code>.
<errorref spec="XT" class="DE" code="0835"/></p></error></p> 

<p><error spec="XT" type="static" class="SE" code="0910"><p>It is a <termref def="dt-static-error">static error</termref> if
the <code>select</code> attribute of the <elcode>xsl:namespace</elcode> element is present when the
element has content other than one or more <elcode>xsl:fallback</elcode>
instructions, or if the <code>select</code> attribute is absent when the element
has empty content.</p></error></p> 

<p>Note the restrictions described in <specref ref="constructing-complex-content"/>
  for the position of a namespace node relative to other nodes in the node sequence
  returned by a sequence constructor.</p>
  
<example>
<head>Constructing a QName-Valued Attribute</head>
	<p>This literal result element:</p>
	<eg><![CDATA[<data xsi:type="xs:integer" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <xsl:namespace name="xs" select="'http://www.w3.org/2001/XMLSchema'"/>
  <xsl:text>42</xsl:text>
</data>]]></eg>
	<p>would typically cause the output document to contain the element:</p>
	<eg><![CDATA[<data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">42</data>]]></eg>
     <p>In this case, the element is constructed using a literal result element, and the namespace
     <code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code> could therefore have been added to the 
     <termref def="dt-result-tree">result tree</termref> simply by declaring it as one of the in-scope namespaces in the stylesheet. In practice, the
     <elcode>xsl:namespace</elcode> instruction is more likely to be useful in situations where the element
     is constructed using an <elcode>xsl:element</elcode> instruction, which does not copy all the
     in-scope namespaces from the stylesheet.</p> 
</example>
				
<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="0920"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
<termref def="dt-effective-value">effective value</termref> of the
<code>name</code> attribute <error.extra>of the <elcode>xsl:namespace</elcode> instruction</error.extra>
is neither a zero-length string  nor an <xnt spec="Names" ref="NT-NCName">NCName</xnt>, or
if it is <code>xmlns</code>.  
</p></error></p>

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="0925"><p>It is a
<termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the <elcode>xsl:namespace</elcode>
 instruction generates a namespace node whose name is <code>xml</code> and whose string value is
 not <code>http://www.w3.org/XML/1998/namespace</code>, or a namespace node whose string value is
  <code>http://www.w3.org/XML/1998/namespace</code> and whose name is
 not <code>xml</code>.</p></error></p>

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="0930"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
 evaluating the <phrase diff="chg" at="R"><code>select</code> attribute or the contained
  <termref def="dt-sequence-constructor">sequence constructor</termref> of an
   <elcode>xsl:namespace</elcode> instruction</phrase>
 results in a zero-length string.
</p></error></p>

<p>For details of other error conditions that may arise, see
<specref ref="sequence-constructors"/>.</p>

				<note>
					<p>It is rarely necessary to use <elcode>xsl:namespace</elcode> to create
a namespace node in the <termref def="dt-result-tree">result tree</termref>; in most circumstances, the required
namespace nodes will be created automatically, as a side-effect of writing
elements or attributes that use the namespace. An example where 
<elcode>xsl:namespace</elcode> is needed is a situation where the required namespace
is used only within attribute values in the result document, not in element or
attribute names; especially where the required namespace prefix or 
namespace URI is computed
at run-time and is not present in either the source document or the 
stylesheet.</p>

<p>Adding a namespace node to the <termref def="dt-result-tree">result tree</termref> will never change the
<termref def="dt-expanded-qname">expanded-QName</termref> of any element or attribute
node in the result tree: that is, it will never change the namespace URI
of an element or attribute.
It <phrase diff="chg" at="T">might</phrase>, however, constrain
 the choice of prefixes when namespace fixup is performed.</p>

<p>Namespace prefixes for element and attribute names are effectively established by
the namespace fixup process described in <specref ref="namespace-fixup"/>. The fixup process ensures that an element
has in-scope namespace nodes for the namespace URIs used in the element name and in its attribute names, and the 
serializer will typically use these namespace nodes to determine the prefix to use in the serialized output. The fixup
process cannot generate namespace nodes
that are inconsistent with those already present in the tree. This means that it is
not possible for the processor to decide the prefix to use for an element or for any of its attributes
until all the namespace nodes for the element have been added.</p>

<p>If a namespace prefix is mapped to a particular
namespace URI using the <elcode>xsl:namespace</elcode> instruction, or by using <elcode>xsl:copy</elcode> 
or <elcode>xsl:copy-of</elcode> to copy a namespace node, this prevents the namespace fixup process (and hence
the serializer) from using the same prefix for a different namespace URI on the same element.</p>
</note>

<example diff="chg" at="Y">
<head>Conflicting Namespace Prefixes</head>
<p>Given the instruction:</p>

<eg><![CDATA[<xsl:element name="p:item" xmlns:p="http://www.example.com/p">
  <xsl:namespace name="p">http://www.example.com/q</xsl:namespace>
</xsl:element>]]></eg>

<p>a possible serialization of the <termref def="dt-result-tree">result tree</termref> is:</p>

<eg>&lt;ns0:item xmlns:ns0="http://www.example.com/p" xmlns:p="http://www.example.com/q"/&gt;</eg>

<p>The processor must invent a namespace prefix for the URI <code>p.uri</code>; it cannot use the prefix
<code>p</code> because that prefix has been explicitly associated with a different URI.</p>
</example>

				
<note><p>The <elcode>xsl:namespace</elcode> instruction cannot be used to generate a
<term>namespace undeclaration</term> of the form <code>xmlns=""</code> (nor the new forms of namespace undeclaration
permitted in <bibref ref="xml-names11"/>). Namespace undeclarations
are generated automatically by the serializer if <phrase diff="chg" at="W"><code>undeclare-prefixes="yes"</code></phrase>
is specified on <elcode>xsl:output</elcode>, whenever a parent element has a namespace node
for the default namespace prefix, and a child element has no namespace node for that prefix.</p></note>




			</div2>
			<div2 id="creating-comments">
				<head>Creating Comments</head>
				<e:element-syntax name="comment">
					<e:in-category name="instruction"/>
    				<e:attribute name="select">
    					<e:data-type name="expression"/>
    				</e:attribute>
					<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				
<p>The <elcode>xsl:comment</elcode> element is evaluated to contruct a
new comment node. Except in error cases, the result of evaluating the
 <elcode>xsl:comment</elcode> instruction is a single node, the newly constructed comment node.</p>
 				
<p>The string value of the new comment node may be defined either by using the <code>select</code>
attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the
content of the <elcode>xsl:comment</elcode> element. These are mutually exclusive. If neither is present,
the value of the new comment node will be a zero-length string. The way in which the
value is constructed is specified in <specref ref="constructing-simple-content"/>.</p>

<p><error spec="XT" type="static" class="SE" code="0940"><p>It is a <termref def="dt-static-error">static error</termref> if
the <code>select</code> attribute of the <elcode>xsl:comment</elcode> element is present unless the
element has empty content.</p></error></p> 				
				
				<example><head>Generating a Comment Node</head>
					<p>For example, this</p>
					<eg><![CDATA[<xsl:comment>This file is automatically generated. Do not edit!</xsl:comment>]]></eg>
					<p>would create the comment</p>
					<eg><![CDATA[<!--This file is automatically generated. Do not edit!-->]]></eg>
				</example>
				
        <p diff="chg" at="X">In the generated comment node, the processor
         <rfc2119>must</rfc2119> insert a space after
any occurrence of <code>-</code> that is followed by another
<code>-</code> or that ends the comment.</p>
			</div2>
			<div2 id="copying">
				<head>Copying Nodes</head>
				<div3 id="shallow-copy">
					<head>Shallow Copy</head>
					<e:element-syntax name="copy" diff="chg" at="Q">
						<e:in-category name="instruction"/>
						<e:attribute name="copy-namespaces">
							<e:constant value="yes"/>
							<e:constant value="no"/>
						</e:attribute>
						<e:attribute name="inherit-namespaces">
							<e:constant value="yes"/>
							<e:constant value="no"/>
						</e:attribute>
						<e:attribute name="use-attribute-sets">
							<e:data-type name="qnames"/>
						</e:attribute>
        				<e:attribute name="type">
        					<e:data-type name="qname"/>
        				</e:attribute>
    					<e:attribute name="validation">
    						<e:constant value="strict"/>
    						<e:constant value="lax"/>
    						<e:constant value="preserve"/>
    						<e:constant value="strip"/>
    					</e:attribute>
						<e:model name="sequence-constructor"/>
						<e:allowed-parents>
							<e:parent-category name="sequence-constructor"/>
						</e:allowed-parents>
					</e:element-syntax>
					<p>The <elcode>xsl:copy</elcode> instruction provides a way of copying
the context item. If the
 <termref def="dt-context-item">context item</termref> is a node,
evaluating the <elcode>xsl:copy</elcode> instruction
constructs a copy of the context node, and the result of the
<elcode>xsl:copy</elcode> instruction is this newly constructed node.
<phrase diff="add" at="M">By default, </phrase>the namespace nodes of the
context node are automatically copied as well, but the attributes and
children of the node are not automatically copied.</p>

<p>When the <termref def="dt-context-item">context item</termref> is an atomic value, the
<elcode>xsl:copy</elcode> instruction returns this value. 
<phrase diff="add" at="R">The <termref def="dt-sequence-constructor">sequence constructor</termref>, if
present, is not evaluated.</phrase></p>

<p>When the <termref def="dt-context-item">context item</termref>
 is an attribute node, text node, comment node,
processing instruction node, or namespace node, the <elcode>xsl:copy</elcode> instruction
returns a new node that is a copy of the context node. The new node will have the same
node kind, name, and string value as the context node. <phrase diff="add" at="W">In the case of
an attribute node, it will also have the same values for the <code>is-id</code> and <code>is-idrefs</code>
properties.</phrase>
The <termref def="dt-sequence-constructor">sequence constructor</termref>, if
present, is not evaluated.</p>

<p><phrase diff="chg" at="R">When the context item is a document node or element node,
the <elcode>xsl:copy</elcode> instruction
returns a new node that has the same node kind and name as the context node.
The content of the new node is formed by evaluating the 
<termref def="dt-sequence-constructor">sequence constructor</termref>
contained in the <elcode>xsl:copy</elcode> instruction.</phrase>
The sequence obtained by evaluating this sequence constructor is used (after prepending
any attribute nodes or namespace nodes as described in the following paragraphs) to construct
the content of the document or element node, as described in <specref ref="constructing-complex-content"/>.</p>

<example><head>Identity Transformation</head>

<p>The identity transformation can be written using
<elcode>xsl:copy</elcode> as follows:</p>

<eg><![CDATA[<xsl:template match="@*|node()">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>
  </xsl:copy>
</xsl:template>]]></eg>

<p>This template rule can be used to copy any node in a tree by applying template rules to its
attributes and children. It can be combined with additional template rules that modify selected
nodes, for example if all nodes are to be copied except <code>note</code> elements and their
contents, this can be achieved by using the identity template rule together with the template rule:</p>

<eg><![CDATA[<xsl:template match="note"/>]]></eg>

</example>

<note diff="add" at="M"><p>The <elcode>xsl:copy</elcode> instruction is most useful when copying
element nodes. In other cases, the <elcode>xsl:copy-of</elcode> instruction is
more flexible, because it has a <code>select</code> attribute allowing selection of the
nodes or values to be copied.</p></note>


<p>The <elcode>xsl:copy</elcode> instruction has an optional
<code>use-attribute-sets</code> attribute, whose value is a 
<phrase diff="chg" at="T">whitespace-separated</phrase> list of QNames that identify
<elcode>xsl:attribute-set</elcode> declarations. 
This attribute is used only when copying element nodes. This list is expanded as
described in <specref ref="attribute-sets"/> to produce a sequence of attribute nodes. This sequence is
prepended to the sequence produced as a result of evaluating the 
<termref def="dt-sequence-constructor">sequence constructor</termref>.</p>
					
<p>The <elcode>xsl:copy</elcode> instruction has an optional <code>copy-namespaces</code>
attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>.
The attribute is used only when copying element nodes. If the value is set to <code>yes</code>, or
is omitted, then all the namespace nodes of the source element are copied as namespace nodes for
the result element. These copied namespace nodes are prepended
to the sequence produced as a result of evaluating the 
<termref def="dt-sequence-constructor">sequence constructor</termref> (it is immaterial whether they
come before or after any attribute nodes produced by expanding the <code>use-attribute-sets</code>
attribute).
If the value is set to <code>no</code>, then the namespace nodes are not copied.
However, namespace nodes will still be added to the result element as 
<rfc2119>required</rfc2119> by the namespace
fixup process: see <specref ref="namespace-fixup"/>.</p>

<p diff="add" at="U">The <elcode>xsl:copy</elcode> instruction has an optional <code>inherit-namespaces</code>
attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>.
The attribute is used only when copying element nodes. If the value is set to <code>yes</code>, or
is omitted, then the namespace nodes created for the newly constructed element (whether these were
copied from those of the source node, or generated as a result of namespace fixup) are copied
to the children and descendants of the newly constructed element, as described in 
<specref ref="constructing-complex-content"/>. If the value is set to <code>no</code>, then these
namespace nodes are not automatically copied to the children. This may result in namespace
undeclarations (such as <code>xmlns=""</code> or, in the case of XML Namespaces 1.1, <code>xmlns:p=""</code>)
appearing on the child elements when a
 <termref def="dt-final-result-tree">final result tree</termref> is serialized.</p>

 <p diff="add" at="Y"><error spec="XT" type="static" class="TE" code="0950"><p>It is a 
 <termref def="dt-type-error">type error</termref> to use the <elcode>xsl:copy</elcode> 
or <elcode>xsl:copy-of</elcode> instruction to copy a node that has namespace-sensitive content
if the <code>copy-namespaces</code> attribute has the value
<code>no</code> and its explicit or implicit <code>validation</code> attribute has
the value <code>preserve</code>. 
It is also a type error if either of these instructions (with <code>validation="preserve"</code>)
is used to copy an attribute having
namespace-sensitive content, unless the parent element is also copied.
A node has namespace-sensitive content if its typed value contains an item of type
<code>xs:QName</code> or <code>xs:NOTATION</code> or a type derived therefrom.
The reason this is an error is because the validity of the content depends on the
namespace context being preserved.</p></error></p> 

 <!--<p diff="add" at="Y"><error spec="XT" type="static" class="TE" code="0955"><p>It is a 
 <termref def="dt-type-error">type error</termref> if
an <elcode>xsl:copy</elcode> 
or <code>xsl:copy-of</code> element whose explicit or implicit <code>validation</code> attribute has
the value <code>preserve</code> is used to copy an attribute node whose type is
 namespace-sensitive, that is, a value of type <code>xs:QName</code> or
<code>xs:NOTATION</code> or a type derived or constructed therefrom. 
This is because the data model does not allow such a value to appear
in a parentless attribute. This error does not apply when the attribute is copied as a result of copying 
its containing element.</p></error></p> 	-->

<note diff="add" at="Q"><p>When attribute nodes are copied, whether with
<elcode>xsl:copy</elcode> or with <elcode>xsl:copy-of</elcode>, the processor does not
automatically copy any associated namespace information. The namespace used in the attribute
name itself will be declared by virtue of the namespace fixup process (see <specref ref="namespace-fixup"/>) when
the attribute is added to an element in the <termref def="dt-result-tree">result tree</termref>, 
but if namespace <phrase diff="add" at="T">prefixes</phrase> 
are used in the content
of the attribute (for example, if the value of the attribute is an XPath expression) then it
is the responsibility of the stylesheet author to ensure that suitable namespace nodes
are added to the <termref def="dt-result-tree">result tree</termref>. This can be achieved by copying
 the namespace nodes using
<elcode>xsl:copy</elcode>, or by generating them using <elcode>xsl:namespace</elcode>.</p>

</note>

<p>The optional attributes <code>type</code> and
 <code>validation</code> may be used on the <elcode>xsl:copy</elcode>
instruction to validate the contents of an element, attribute 
or document node against a 
type definition, element declaration, or attribute declaration in a schema,
and thus to determine the <termref def="dt-annotation">type annotation</termref> that the new copy of an element or attribute node will carry.
These attributes are ignored when copying an item that is not an element, attribute 
or document node.
When the node being copied is an element or document node, 
these attributes also affect
 the type annotation carried by any elements and attributes that have
the copied element or document node as an ancestor.
These two attributes are both optional, and if one is specified then the other <rfc2119>must</rfc2119> be omitted.
The permitted values of these attributes and their semantics are described in
 <specref ref="validation"/>.</p>
 
 <note diff="add" at="R"><p>The final <termref def="dt-annotation">type annotation</termref> of the node in the <termref def="dt-result-tree">result tree</termref> also depends on the
 <code>type</code> and <code>validation</code> attributes of the instructions used to create the ancestors
 of the node.</p></note>		 			

<p>The base URI of a node is copied<phrase diff="add" at="ZB">, except in the case of an
element node having an <code>xml:base</code> attribute, in which case the base URI of the new node
is taken as the value of the <code>xml:base</code> attribute, resolved if it is relative
against the base URI of the <elcode>xsl:copy</elcode> instruction</phrase>. If the copied node is
subsequently attached as a child to a new element <phrase diff="chg" at="ZA">or document node</phrase>,
 the final copy of the node inherits
its base URI from its parent node, unless this is overridden using an <code>xml:base</code>
attribute.</p>

<p diff="add" at="ZA">When an <code>xml:id</code> attribute is copied, using either the <elcode>xsl:copy</elcode>
or <elcode>xsl:copy-of</elcode> instruction, it is <termref def="dt-implementation-defined">implementation-defined</termref>
whether the value of the attribute is subjected to attribute value normalization (that is, effectively
applying the <xfunction>normalize-space</xfunction> function).</p>

<note diff="add" at="ZA"><p>In most cases the value will already have been
subjected to attribute value normalization on the source tree, but if this processing has not been
performed on the source tree, it is not an error for it to be performed on the result tree.</p></note>

<imp-def-feature>If an <code>xml:id</code> attribute that has not been subjected to attribute value
normalization is copied from a source tree to a result tree, it is implementation-defined whether
attribute value normalization will be applied during the copy process.</imp-def-feature>


					
					

					
				</div3>
				<div3 id="copy-of">
					<head>Deep Copy</head>
					<e:element-syntax name="copy-of">
						<e:in-category name="instruction"/>
						<e:attribute name="select" required="yes">
							<e:data-type name="expression"/>
						</e:attribute>
						<e:attribute name="copy-namespaces">
							<e:constant value="yes"/>
							<e:constant value="no"/>
						</e:attribute>
        				<e:attribute name="type">
        					<e:data-type name="qname"/>
        				</e:attribute>
    					<e:attribute name="validation">
    						<e:constant value="strict"/>
    						<e:constant value="lax"/>
    						<e:constant value="preserve"/>
    						<e:constant value="strip"/>
    					</e:attribute>
						<e:empty/>
						<e:allowed-parents>
							<e:parent-category name="sequence-constructor"/>
						</e:allowed-parents>
					</e:element-syntax>
					<p>The <elcode>xsl:copy-of</elcode> instruction can be used to 
construct a copy of a sequence of nodes <phrase diff="add" at="Q">and/or atomic values</phrase>, 
with each new node containing
copies of all the children, attributes, and (by default)
namespaces of the original node,
recursively. The result of evaluating the instruction is a sequence
of <phrase diff="add" at="Q">items</phrase> corresponding one-to-one with the 
supplied sequence, and retaining its order.</p>
					
					<p>The <rfc2119>required</rfc2119> <code>select</code>
attribute contains an <termref def="dt-expression">expression</termref>,
<phrase diff="add" at="M">whose value may be any sequence of nodes and atomic values</phrase>. 
The items in this sequence are processed as follows:</p>
					<ulist>
						<item>
							<p>If the item is an element node, a new element is constructed
and appended to the result sequence. The new element will have the
same <termref def="dt-expanded-qname">expanded-QName</termref> as the original, and it will have 
<phrase diff="add" at="R">deep</phrase>
copies of the attribute nodes and children of the element node.</p>
							<p>The new element will also have namespace nodes copied from 
the original element node, unless they are excluded by <phrase diff="add" at="M">specifying
 <code>copy-namespaces="no"</code>. If this attribute is omitted, or takes the value
  <code>yes</code>, then all the namespace nodes of the original element are copied to the
  new element. If it takes the value <code>no</code>, then none of the namespace nodes are
  copied: however, namespace nodes will still be created in the <termref def="dt-result-tree">result tree</termref> 
  as <rfc2119>required</rfc2119>
  by the namespace fixup process: see <specref ref="namespace-fixup"/>. This attribute affects
  all elements copied by this instruction: both elements selected directly by the <code>select</code>
  <termref def="dt-expression">expression</termref>, 
  and elements that are descendants of nodes selected by the <code>select</code> expression.
</phrase></p>
<p diff="add" at="W">The new element will have the same values of the <code>is-id</code>, 
<code>is-idrefs</code>, and <code>nilled</code> properties as the original element.</p>
						</item>
						<item>
							<p>If the item is a document node, the instruction adds a new
							document node to the result sequence; the children of this document node will be one-to-one copies of
							 the children of the original document node (each copied according to the rules for its own node kind).</p>
						</item>
						<item>
							<p>If the item is an attribute or namespace node, or
a text node, a comment, or a processing instruction, the same
rules apply as with <elcode>xsl:copy</elcode> (see <specref ref="shallow-copy"/>).</p>
						</item>
						<item>
							<p>If the item is an atomic
value, the value is appended to the result sequence, as with <elcode>xsl:sequence</elcode>.</p>
						</item>
					</ulist>
					
<p>The optional attributes <code>type</code> and <code>validation</code> may 
be used on the <elcode>xsl:copy-of</elcode>
instruction to validate the contents of an 
element, attribute or document node against a 
type definition, element declaration, or attribute declaration in a schema
and thus to determine the <termref def="dt-annotation">type annotation</termref> that the new copy of an element or attribute node will carry.
These attributes are applied individually to each element, attribute, and document node that is 
selected by the expression in the <code>select</code> attribute. 
These attributes are ignored when copying an item that is not an element, attribute 
or document node.</p>

<p>The specified <code>type</code> and <code>validation</code> apply directly
only to elements, attributes and document nodes created as copies of nodes actually selected by the <code>select</code> expression,
they do not apply to nodes that are implicitly copied because they have selected nodes as an ancestor.
However, these attributes do indirectly affect the <termref def="dt-annotation">type annotation</termref> carried by 
such implicitly copied nodes, as a consequence of the validation process.</p>

<p>These two attributes are both optional, and if one is specified then the other <rfc2119>must</rfc2119> be omitted.
The permitted values of these attributes and their semantics are described in
 <specref ref="validation"/>.</p>
 
<p diff="add" at="Y">Errors may occur when copying namespace-sensitive elements or attributes using 
<code>validation="preserve"</code>. <errorref class="TE" code="0950"/>.</p>

					
<p>The base URI of a node is copied<phrase diff="add" at="ZB">, except in the case of an
element node having an <code>xml:base</code> attribute, in which case the base URI of the new node
is taken as the value of the <code>xml:base</code> attribute, resolved if it is relative
against the base URI of the <elcode>xsl:copy-of</elcode> instruction</phrase>. If the copied node is
subsequently attached as a child to a new element <phrase diff="chg" at="ZA">or document node</phrase>, 
the final copy of the node inherits
its base URI from its parent node, unless this is overridden using an <code>xml:base</code>
attribute.</p>
					
				</div3>
			</div2>
			
			
		<div2 id="constructing-sequences" diff="add" at="Q">
		<head>Constructing Sequences</head>

					<e:element-syntax name="sequence">
						<e:in-category name="instruction"/>
						<e:attribute name="select" required="yes">
							<e:data-type name="expression"/>
						</e:attribute>
        		<!--		<e:attribute name="as">
        					<e:data-type name="sequence-type"/>
        				</e:attribute>-->
					  <e:element name="fallback" repeat="zero-or-more"/>
				   	<!--<e:model name="sequence-constructor"/>-->
						<e:allowed-parents>
							<e:parent-category name="sequence-constructor"/>
						</e:allowed-parents>
					</e:element-syntax>
		
		<p>The <elcode>xsl:sequence</elcode> instruction may be used within a 
		<termref def="dt-sequence-constructor">sequence constructor</termref> to construct a sequence of nodes
		and/or atomic values. This sequence is returned as the result of the instruction. 
		Unlike most other instructions, <elcode>xsl:sequence</elcode>
		can return a sequence containing existing nodes, rather than constructing new nodes.
		When <elcode>xsl:sequence</elcode> is used to add atomic values to a sequence, 
		the effect is very similar to the <elcode>xsl:copy-of</elcode> instruction.</p>
		
		<p diff="chg" at="T">The items comprising the result sequence are selected using the <code>select</code> attribute.</p>

    <p diff="add" at="T">Any contained <elcode>xsl:fallback</elcode> instructions are ignored by an 
    XSLT 2.0 processor, but can be used to define fallback behavior for an XSLT 1.0 processor running
    in forwards compatibility mode.</p>

				
<example><head>Constructing a Sequence of Integers</head>
	<p>For example, the following code:</p>
<eg><![CDATA[<xsl:variable name="values" as="xs:integer*">
    <xsl:sequence select="(1,2,3,4)"/>
    <xsl:sequence select="(8,9,10)"/>
</xsl:variable>
<xsl:value-of select="sum($values)"/>]]></eg>
	<p>produces the output: <code>37</code></p>			
</example>		

		<example><head>Using <code>xsl:for-each</code> to Construct a Sequence</head>
			<p>The following code constructs a sequence containing the value of the
			<code>@price</code> attribute for selected elements (which we assume to be typed as <code>xs:decimal</code>), 
			or a computed price for those
			elements that have no <code>@price</code> attribute. It then returns the average price:</p>
<eg><![CDATA[<xsl:variable name="prices" as="xs:decimal*">
  <xsl:for-each select="//product">
    <xsl:choose>
      <xsl:when test="@price">
        <xsl:sequence select="@price"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="@cost * 1.5"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>
</xsl:variable>
<xsl:value-of select="avg($prices)"/>]]></eg>
			<p>Note that the existing <code>@price</code> attributes could equally have been added to the <code>$prices</code> sequence
			using <elcode>xsl:copy-of</elcode> or <elcode>xsl:value-of</elcode>. However, <elcode>xsl:copy-of</elcode>
			would create a copy of the attribute node, which is not needed in this situation, while <elcode>xsl:value-of</elcode>
			would create a new text node, which then has to be converted to an <code>xs:decimal</code>. Using <elcode>xsl:sequence</elcode>,
			which in this case atomizes the existing attribute node and adds an <code>xs:decimal</code> atomic value to
			the result sequence, is a more direct way of achieving the same result.</p>
			
			<p>This example could alternatively be solved at the XPath level:</p>
			
<eg><![CDATA[<xsl:value-of select="avg(//product/(+@price, @cost*1.5)[1])"/>]]></eg>

<p diff="add" at="V">(The apparently redundant <code>+</code> operator is there to atomize the
attribute value: the expression on the right hand side of the <code>/</code> operator must
not return a mixture of nodes and atomic values.)</p>
						
		</example>					


        </div2>
		</div1>
		<div1 id="number">
			<head>Numbering</head>
			<e:element-syntax name="number" diff="chg" at="R">
				<e:in-category name="instruction"/>
				<e:attribute name="value">
					<e:data-type name="expression"/>
				</e:attribute>
				<e:attribute name="select">
					<e:data-type name="expression"/>
				</e:attribute>
				<e:attribute name="level">
					<e:constant value="single"/>
					<e:constant value="multiple"/>
					<e:constant value="any"/>
				</e:attribute>
				<e:attribute name="count">
					<e:data-type name="pattern"/>
				</e:attribute>
				<e:attribute name="from">
					<e:data-type name="pattern"/>
				</e:attribute>
				<e:attribute name="format">
					<e:attribute-value-template>
						<e:data-type name="string"/>
					</e:attribute-value-template>
				</e:attribute>
				<e:attribute name="lang">
					<e:attribute-value-template>
						<e:data-type name="nmtoken"/>
					</e:attribute-value-template>
				</e:attribute>
				<e:attribute name="letter-value">
					<e:attribute-value-template>
						<e:constant value="alphabetic"/>
						<e:constant value="traditional"/>
					</e:attribute-value-template>
				</e:attribute>
				<e:attribute name="ordinal">
					<e:attribute-value-template>
						<e:data-type name="string"/>
					</e:attribute-value-template>
				</e:attribute>
				<e:attribute name="grouping-separator">
					<e:attribute-value-template>
						<e:data-type name="char"/>
					</e:attribute-value-template>
				</e:attribute>
				<e:attribute name="grouping-size">
					<e:attribute-value-template>
						<e:data-type name="number"/>
					</e:attribute-value-template>
				</e:attribute>
				<e:empty/>
				<e:allowed-parents>
					<e:parent-category name="sequence-constructor"/>
				</e:allowed-parents>
			</e:element-syntax>
			<p>The <elcode>xsl:number</elcode> instruction is used to create a formatted
number. The result of the instruction is a newly constructed
text node containing the formatted number as its <termref def="dt-string-value">string value</termref>.</p>
			<p>
				<termdef id="dt-place-marker" term="place marker">The
 <elcode>xsl:number</elcode> instruction performs
two tasks: firstly, determining a <term>place marker</term> (this is 
a sequence of integers, to allow for hierarchic numbering schemes such as
<code>1.12.2</code> or <code>3(c)ii</code>), and secondly, 
formatting the place marker for output as a text node in the result sequence.</termdef>
 The place marker to be formatted
can either be supplied directly, in the <code>value</code> attribute, or
it can be computed based on the position of <phrase diff="chg">a selected node</phrase> within the tree
that contains it.</p>

<p><error spec="XT" type="static" class="SE" code="0975"><p>It is
 a <termref def="dt-static-error">static error</termref> if the <code>value</code>
attribute of <elcode>xsl:number</elcode> is present unless the <code>select</code>, 
<code>level</code>, <code>count</code>,
and <code>from</code> attributes are all absent.</p></error></p>


			<note>
				<p>The facilities described in this section are specifically designed
to enable the calculation and formatting of section numbers, paragraph numbers, 
and the like.
For formatting of other numeric quantities, the <function>format-number</function>
function may be more suitable: see <specref ref="format-number"/>.</p>
			</note>
			<div2 id="formatting-supplied-number">
				<head>Formatting a Supplied Number</head>
				<p>The <termref def="dt-place-marker">place marker</termref> 
to be formatted may be
specified by an expression. The <code>value</code> attribute contains
the <termref def="dt-expression">expression</termref>.
The value of this expression is <termref def="dt-atomization">atomized</termref> using the procedure defined
in <bibref ref="xpath20"/>, and each value <phrase diff="chg" at="R"> <var>$V</var> in the atomized sequence is then
converted to the integer value returned by the XPath expression
<code>xs:integer(round(number($V)))</code>.</phrase>
 The resulting sequence of integers is used
 as the place marker to be formatted.</p>
 
 <p>If <termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>
 is enabled for the instruction, then:</p>
 
 <ulist>
 <item><p>all items in the <termref def="dt-atomization">atomized</termref> 
 sequence after the first are discarded;</p></item>

 <item diff="add" at="W"><p>If the atomized sequence is empty, it is replaced by
 a sequence containing the <code>xs:double</code> value <code>NaN</code> as its only item;</p></item>

 <item diff="add" at="W"><p>If any value in the sequence cannot be converted to an integer
 (this includes the case where the sequence contains a <code>NaN</code> value) then the string
 <code>NaN</code> is inserted into the formatted result string in its proper position. The error
 described in the following paragraph does not apply in this case.</p></item>
 </ulist>
				<p>
					<error spec="XT" type="dynamic" class="DE" code="0980"><p>It is a
           <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> 
if any undiscarded item in the atomized sequence supplied 
as the value of the <code>value</code> attribute of <elcode>xsl:number</elcode>
 cannot be converted to an integer, or if the resulting integer is less than
  0 (zero). </p></error></p>

        <note><p>The value zero does not arise when numbering nodes in a source
        document, but it can arise in other numbering sequences. It is permitted specifically because
        the rules of the <elcode>xsl:number</elcode> instruction are also invoked by functions such as
        <function>format-time</function>: the minutes and seconds component of a time value
        can legitimately be zero.</p></note>

				<p>The resulting sequence is
formatted as a string using the <termref def="dt-effective-value">effective values</termref>
of the attributes specified in <specref ref="convert"/>; each of these attributes is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>.  After conversion, the <elcode>xsl:number</elcode>
element constructs a new text node containing the resulting string, and returns this node.</p>
				<example><head>Numbering a Sorted List</head>
					<p>The following example numbers a sorted list:</p>
<eg><![CDATA[<xsl:template match="items">
  <xsl:for-each select="item">
    <xsl:sort select="."/>
    <p>
      <xsl:number value="position()" format="1. "/>
      <xsl:value-of select="."/>
    </p>
  </xsl:for-each>
</xsl:template>]]></eg>
				</example>
				
			</div2>
			<div2 id="numbering-based-on-position">
				<head>Numbering based on Position in a Document
				</head>
				<p>If no <code>value</code> attribute is specified, then the
<elcode>xsl:number</elcode> instruction returns a new text
node containing a formatted
 <termref def="dt-place-marker">place marker</termref> that is based on the position
of <phrase diff="chg" at="R">a selected node within 
its containing document. If the <code>select</code> attribute is present, then
the expression contained in the <code>select</code> attribute is evaluated to determine
the selected node. If the <code>select</code> attribute is omitted, then
the selected node is the <termref def="dt-context-node">context node</termref>.</phrase></p>

<p diff="chg" at="X"><error spec="XT" type="type" class="TE" code="0990"><p>It is a
 <termref def="dt-type-error">type error</termref> if the
<elcode>xsl:number</elcode> instruction is evaluated, with no <code>value</code> 
or <code>select</code> attribute,
when the <termref def="dt-context-item">context item</termref> is not a node. 
</p></error></p>
				
<p><error spec="XT" type="type" class="TE" code="1000"><p>It is a <termref def="dt-type-error">type error</termref>
if the result of evaluating the <code>select</code> attribute of the <elcode>xsl:number</elcode>
instruction is anything other than a single node.</p></error></p>
				
				
				
				<p> The following attributes control how the 
				selected node is to be numbered:</p>
				<ulist>
					<item>
						<p>The <code>level</code> attribute specifies rules for
selecting the nodes that are taken into account in allocating a number;
it has the values
<code>single</code>, <code>multiple</code> or <code>any</code>. The
default is <code>single</code>.</p>
					</item>
					<item>
						<p>The <code>count</code> attribute is 
a <termref def="dt-pattern">pattern</termref> that specifies
which nodes are to be counted at those levels.  If <code>count</code>
attribute is not specified, then it defaults to the pattern that
matches any node with the same node <phrase diff="chg" at="P">kind</phrase> as the <phrase diff="chg" at="R">selected</phrase> node and, if
the <phrase diff="chg" at="R">selected</phrase> node has an <termref def="dt-expanded-qname">expanded-QName</termref>, with the same <termref def="dt-expanded-qname">expanded-QName</termref> as
the <phrase diff="chg" at="R">selected</phrase> node.</p>
					</item>
					<item>
						<p>The <code>from</code> attribute is 
a <termref def="dt-pattern">pattern</termref> that specifies
where counting starts.</p>
					</item>
				</ulist>
				<p>In addition, the attributes specified in <specref ref="convert"/>
are used for number to string conversion, as in the case when the
<code>value</code> attribute is specified.</p>
				<p>The <elcode>xsl:number</elcode> element first constructs a sequence of
positive integers using the <code>level</code>, <code>count</code> and
<code>from</code> attributes. Where <code>level</code> is <code>single</code>
or <code>any</code>, this sequence will either be empty or contain a single
number; where <code>level</code> is <code>multiple</code>, the sequence may
be of any length. The sequence is constructed as follows:</p>
				<p>Let <code>matches-count($node)</code> be a function that returns true if and only if the given
node <code>$node</code> matches the pattern given in the <code>count</code> attribute, or the implied
pattern (according to the rules given above) if the <code>count</code> attribute is omitted.</p>
				<p>Let <code>matches-from($node)</code> be a function that returns true if and only if the given
node <code>$node</code> matches the pattern given in the <code>from</code> attribute,
<phrase diff="add" at="Q">or if <code>$node</code> is the root node of a tree.
If the <code>from</code> attribute is omitted, then the function returns true if
and only if <code>$node</code> is the root node of a tree</phrase>.</p>
<p>Let <code>$S</code> be the selected node.</p>
				<p>When <code>level="single"</code>: </p>
				<ulist>
<item>
	<p>Let <code>$A</code> be the node sequence selected by the following expression:</p>
	<p>
		<code>&#xa0;&#xa0;&#xa0;$S/ancestor-or-self::node()[matches-count(.)][1]</code>
	</p>
	<p>(this selects the innermost ancestor-or-self node that matches the <code>count</code> pattern)</p>
</item>
<item>
	<p>Let 
<code>$F</code> be the node sequence selected by the expression</p>

	<p>
		<code>&#xa0;&#xa0;&#xa0;$S/ancestor-or-self::node()[matches-from(.)][1]</code>
	</p>
	<p>(this selects the innermost ancestor-or-self node that matches the <code>from</code> pattern):</p>
</item>
<item>
	<p>Let <code>$AF</code> be the value of:</p>
	<p diff="chg" at="Z">
		<code>&#xa0;&#xa0;&#xa0;$A[ancestor-or-self::node()[. is $F]]</code>
	</p>
<p diff="chg" at="Z">(this selects $A if it is in the subtree rooted at $F, or the empty sequence otherwise)</p>
</item>
<item>
	<p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
	</p>
</item>
<item>
	<p>Otherwise return the value of:</p>
	<p>
		<code>&#xa0;&#xa0;&#xa0;1 + count($AF/preceding-sibling::node()[matches-count(.)])</code>
	</p>
<p>(the number of preceding siblings of the counted node that match the <code>count</code> pattern, plus one).</p>
</item>
				</ulist>
				<p>When <code>level="multiple"</code>: </p>
				<ulist>
<item>
	<p>Let <code>$A</code> be the node sequence selected by the expression</p>
	<p>
		<code>&#xa0;&#xa0;&#xa0;$S/ancestor-or-self::node()[matches-count(.)]</code>
	</p>
<p>(the set of ancestor-or-self nodes that match the <code>count</code> pattern)</p>	
</item>
<item>
	<p>Let <code>$F</code> be the node sequence selected by the expression</p>
	<p>
		<code>&#xa0;&#xa0;&#xa0;$S/ancestor-or-self::node()[matches-from(.)][1]</code>
	</p>
<p>(the innermost ancestor-or-self node that matches the <code>from</code> pattern)</p>	
</item>
<item>
	<p>Let <code>$AF</code> be the value of</p>
	<p diff="chg" at="Z">
		<code>&#xa0;&#xa0;&#xa0;$A[ancestor-or-self::node()[. is $F]]</code>
	</p>
<p diff="chg" at="Z">(the nodes selected in the first step that are in the subtree rooted at the node selected
in the second step)</p>		
</item>
<item>
	<p>Return the result of the expression </p>
	<p>
		<code>&#xa0;&#xa0;&#xa0;for $af in $AF return 1+count($af/preceding-sibling::node()[matches-count(.)])</code>
	</p>
<p>(a sequence of integers containing, for each of these nodes, one plus the number of
preceding siblings that match the <code>count</code> pattern)</p>		
</item>
				</ulist>
				<p>When <code>level="any"</code>: </p>
				
    
				<ulist>


<item>
	<p>Let <code>$A</code> be the node sequence selected by the expression</p>
	<p>
		<code>&#xa0;&#xa0;&#xa0;$S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code>
	</p>
<p diff="add" at="V">(the set of nodes consisting of the selected node together with all nodes, 
other than attributes and namespaces, that precede the 
selected node in document order, provided that they match the <code>count</code> pattern)</p>
</item>
<item>
	<p>Let <code>$F</code> be the node sequence selected by the expression</p>
	<p>
		<code>&#xa0;&#xa0;&#xa0;$S/(preceding::node()|ancestor::node())[matches-from(.)][last()]</code>
	</p>
<p>(the last node in document order that matches the <code>from</code> pattern and that precedes
the selected node, using the same definition)</p>		
</item>	
<item>
	<p>Let <code>$AF</code> be the node sequence <code>$A[. is $F or . &gt;&gt; $F]</code>.</p>
	<p>(the nodes selected in the first step, excluding those that precede the node
	 selected in the second step)</p>	

</item>
<item>
	<p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
	</p>
</item>
<item>
	<p>Otherwise return the value of the expression <code>count($AF)</code>
	</p>
</item>
				</ulist>
				<p>The sequence of numbers 
(the <termref def="dt-place-marker">place marker</termref>)
is then converted into a string using the <termref def="dt-effective-value">effective values</termref>
of the attributes specified in <specref ref="convert"/>; each of these attributes is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>.  After conversion, the resulting string is
<phrase diff="chg" at="U">used to create a text node, which forms the result of the
<elcode>xsl:number</elcode> instruction</phrase>.</p>
				<example><head>Numbering the Items in an Ordered List</head>
					<p>The following will number the items in an ordered list:</p>
<eg><![CDATA[<xsl:template match="ol/item">
  <fo:block>
    <xsl:number/>
    <xsl:text>. </xsl:text>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>
				</example>
				<example><head>Multi-Level Numbering</head>
					<p>The following two rules will number <code>title</code> elements.
This is intended for a document that contains a sequence of chapters
followed by a sequence of appendices, where both chapters and
appendices contain sections, which in turn contain subsections.
Chapters are numbered 1, 2, 3; appendices are numbered A, B, C;
sections in chapters are numbered 1.1, 1.2, 1.3; sections in
appendices are numbered A.1, A.2, A.3. <phrase diff="add" at="R">Subsections within
a chapter are numbered 1.1.1, 1.1.2, 1.1.3; subsections within an appendix are
numbered A.1.1, A.1.2, A.1.3.</phrase></p>
<eg><![CDATA[<xsl:template match="title">
  <fo:block>
     <xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="appendix//title" priority="1">
  <fo:block>
     <xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>
				</example>
				<example><head>Numbering Notes within a Chapter</head>
					<p>This example numbers notes sequentially within a
chapter:</p>
<eg><![CDATA[<xsl:template match="note">
  <fo:block>
     <xsl:number level="any" from="chapter" format="(1) "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>
				</example>
			</div2>
			<div2 id="convert">
				<head>Number to String Conversion Attributes</head>
				<p>The following attributes are used to control conversion of a
sequence of numbers into a string. The numbers are integers greater than 
<phrase diff="add" at="T">or equal to</phrase>
0 (zero). The attributes are all optional.</p>

				<p>The main attribute is <code>format</code>.  The default value for
the <code>format</code> attribute is <code>1</code>.  The
<code>format</code> attribute is split into a sequence of tokens where
each token is a maximal sequence of alphanumeric characters or a
maximal sequence of non-alphanumeric characters.  <emph>Alphanumeric</emph> means
any character that has a Unicode category of Nd, Nl, No, Lu, Ll, Lt,
Lm or Lo.  The alphanumeric tokens (<emph>format tokens</emph>) indicate the format
to be used for each number in the sequence; in most cases the format token
is the same as the required representation of the number 1 (one).</p>
  
<p>Each non-alphanumeric token is either a prefix, a separator,
or a suffix. <phrase diff="add" at="ZB">If there is a non-alphanumeric token
 but no format token, then the single non-alphanumeric token is used as both the prefix and the suffix.</phrase>

The prefix, if it exists, is the non-alphanumeric token that precedes
the first format token: the prefix always appears exactly once in the constructed string,
at the start. The suffix, if it exists, is the non-alphanumeric token that
follows the last format token: the suffix always appears exactly once in the constructed string,
at the end. All other non-alphanumeric tokens 
(those that occur between two format tokens) are <emph>separator tokens</emph> and are
used to separate numbers in the sequence.</p>


<p>The <var>n</var>th format token
is used to format the <var>n</var>th number in the sequence.  If
there are more numbers than format tokens, then the last format token
is used to format remaining numbers.  If there are no format
tokens, then a format token of <code>1</code> is used to format all
numbers.  Each number after the first is separated
from the preceding number by the separator token preceding the format
token used to format that number, or, if <phrase diff="chg" at="Y">that is the 
first format token</phrase>, then by <code>.</code> (dot).</p>

<example><head>Formatting a List of Numbers</head>

<p>Given the sequence of numbers <code>5, 13, 7</code> and the
format token <code>A-001(i)</code>, the output will be the string
<code>E-013(vii)</code></p>
</example>


				<p>Format tokens are interpreted as follows:</p>
				<ulist>
					<item>
						<p>Any token where the last character has a decimal digit value
of 1 (as specified in the Unicode character property database),
and the Unicode value of preceding characters is one less than the
Unicode value of the last character generates a decimal
representation of the number where each number is at least as long as
the format token. <phrase diff="add" at="R">The digits used in the decimal
representation are the set of digits containing the digit character used
in the format token.</phrase> Thus, a format token <code>1</code> generates the
sequence <code diff="chg" at="T">0 1 2 ... 10 11 12 ...</code>, and a format token
<code>01</code> generates the sequence <code diff="chg" at="T">00 01 02 ... 09 10 11 12
... 99 100 101</code>. <phrase diff="add" at="R">A format token of <code>&amp;#x661;</code> 
(Arabic-Indic digit one) generates the sequence <code>&#x0661;</code> then <code>&#x0662;</code> then <code>&#x0663;</code> ...</phrase></p>
					</item>
					<item>
						<p>A format token <code>A</code> generates the sequence <code>A
B C ... Z AA AB AC...</code>.</p>
					</item>
					<item>
						<p>A format token <code>a</code> generates the sequence <code>a
b c ... z aa ab ac...</code>.</p>
					</item>
					<item>
						<p>A format token <code>i</code> generates the sequence <code>i
ii iii iv v vi vii viii ix x ...</code>.</p>
					</item>
					<item>
						<p>A format token <code>I</code> generates the sequence <code>I
II III IV V VI VII VIII IX X ...</code>.</p>
					</item>
					<item>
					<p>A format token <code>w</code> generates numbers written as lower-case words, for
					example in English, <code>one two three four ...</code></p></item>
					<item>
					<p>A format token <code>W</code> generates numbers written as upper-case words, for
					example in English, <code>ONE TWO THREE FOUR ...</code></p></item>
					<item>
					<p>A format token <code>Ww</code> generates numbers written as title-case words, for
					example in English, <code>One Two Three Four ...</code></p></item>										
					<item>
						<p>Any other format token indicates a
						numbering sequence <phrase diff="chg" at="T">in which that token 
            represents the number 1 (one)</phrase> (but see the note below).
						<!-- Where possible (given the constraint that format tokens
						must be alphanumeric, and that they must be distinct) the format token
						used to represent a numbering sequence should be the same as the representation
						of the number 1 (one) in that sequence.-->
						It is <termref def="dt-implementation-defined">implementation-defined</termref> which
						numbering sequences, additional to those listed above, are supported.
If an implementation does not support a
numbering sequence represented by the given token, it <rfc2119>must</rfc2119> use a format
token of <code>1</code>.</p>

<note><p>In some traditional numbering sequences additional signs are
added to denote that the letters should be interpreted as numbers;
these are not included in the format token. An example, see also
the example below, is classical Greek where a <emph>dexia keraia</emph>
and sometimes an <emph>aristeri keraia</emph> is added.</p>
</note>
					</item>
				</ulist>
				<imp-def-feature>The numbering sequences supported by the <elcode>xsl:number</elcode>
instructions, beyond those defined in this specification, are implementation-defined.</imp-def-feature>
				<p>For all format tokens other than the first kind above
(one that consists of decimal digits), there <rfc2119>may</rfc2119> be 
<termref def="dt-implementation-defined">implementation-defined</termref>
<phrase diff="add" at="T">lower and</phrase> upper bounds on the range of numbers that 
can be formatted using this format
token; indeed, for some numbering sequences there may be 
intrinsic limits. <phrase diff="add" at="T">For example, the formatting token <code>&amp;#x2460;</code>
 (circled digit one) has a range of 1 to 20 imposed by the Unicode character repertoire.</phrase>

For the numbering sequences described above 
 <phrase diff="chg" at="T">any upper bound imposed by the implementation <rfc2119>must not</rfc2119> be
less than 1000 (one thousand) and any lower bound must not be greater than 1. 
Numbers that fall outside this range
<rfc2119>must</rfc2119> be formatted using the format token <code>1</code>.
The numbering sequence associated with the format token <code>1</code> 
 has a lower bound of 0 (zero)</phrase>.</p>
				<imp-def-feature>There <rfc2119>may</rfc2119> be implementation-defined upper bounds on the numbers that
can be formatted by <elcode>xsl:number</elcode> using any particular numbering sequence.</imp-def-feature>

<p>The above expansions of numbering sequences for format tokens such as <code>a</code> and
<code>i</code> are indicative but not prescriptive. There are various conventions in use for
how alphabetic sequences continue when the alphabet is exhausted, and differing conventions for how
roman numerals are written (for example, <code>IV</code> versus <code>IIII</code> as the
representation of the number 4). Sometimes alphabetic sequences are used that omit
letters such as <code>i</code> and <code>o</code>. This 
specification does not prescribe the detail of any sequence other than 
those sequences consisting entirely of decimal digits.</p>

<p>Many numbering sequences are language-sensitive.
This applies especially to the sequence selected by the tokens <code>w</code>, 
<code>W</code> and <code>Ww</code>.
It also applies to other sequences,
for example different languages using the Cyrillic alphabet use different
sequences of characters, each starting with the letter #x410 (Cyrillic
capital letter A). In such cases, the <code>lang</code>
attribute specifies which language's conventions are to be used; it has
the same range of values as <code>xml:lang</code>
					(see <bibref ref="REC-xml"/>).
If no <code>lang</code> value is specified, the language that is used is
<termref def="dt-implementation-defined">implementation-defined</termref>.
  The set of languages for which numbering is supported is 
<termref def="dt-implementation-defined">implementation-defined</termref>. 
If a language is requested that is not supported, 
the processor uses the language that it
would use if the <code>lang</code> attribute were omitted.</p>
				<imp-def-feature>The set of
languages for which numbering is supported by <elcode>xsl:number</elcode>, and
the method of choosing a default language, are implementation-defined.</imp-def-feature>

<p>If the optional <code>ordinal</code> attribute is present, and if its value
is not a zero-length string, this indicates a request to output ordinal numbers rather than cardinal
numbers. For example, in English, the value <code>ordinal="yes"</code> when used with
the format token <code>1</code> outputs the sequence
 <code>1st 2nd 3rd 4th ...</code>, and when used with the format token <code>w</code> outputs the sequence
 <code>first second third fourth ...</code>.
In some languages, ordinal numbers vary depending on the grammatical context, for example they
may have different genders and may decline with the noun that they qualify. In such cases the value 
of the <code>ordinal</code> attribute may
be used to indicate the variation of the ordinal number required. 
The way in which the variation is indicated
will depend on the conventions of the language. For inflected languages that vary 
the ending of the word,
the preferred approach is to indicate the required ending, preceded by a hyphen: for example in German,
 appropriate values are <code>-e, -er, -es, -en</code>. 

 <phrase diff="chg" at="T">It is <termref def="dt-implementation-defined">implementation-defined</termref>
 what combinations of values of the format token, the language, and the 
<code>ordinal</code> attribute are supported.</phrase> 
 If ordinal numbering
is not supported for the combination of the format token, the language, and the actual value of the
<code>ordinal</code> attribute, the request is ignored and cardinal numbers are generated instead.</p>

<example><head>Ordinal Numbering in Italian</head>
<p>The specification <code>format="1" ordinal="-" lang="it"</code>, if supported, should
 produce the sequence:</p>
 
<eg>1 2 3 4 ...</eg>

<p>The specification <code>format="Ww" ordinal="-o" lang="it"</code>, if supported, should
produce the sequence:</p>

<eg>Primo Secondo Terzo Quarto Quinto ...</eg>
</example>  

				<p>The <code>letter-value</code> attribute disambiguates between
numbering sequences that use letters.  In many languages there are two
commonly used numbering sequences that use letters.  One numbering
sequence assigns numeric values to letters in alphabetic sequence, and
the other assigns numeric values to each letter in some other manner
traditional in that language.  In English, these would correspond to
the numbering sequences specified by the format tokens <code>a</code>
and <code>i</code>.  In some languages, the first member of each
sequence is the same, and so the format token alone would be
ambiguous.  A value of <code>alphabetic</code> specifies the
alphabetic sequence; a value of <code>traditional</code> specifies the
other sequence.  If the <code>letter-value</code> attribute is not
specified, then it is <termref def="dt-implementation-dependent">implementation-dependent</termref> how any ambiguity is
resolved.</p>
				<note>
					<p>Implementations may use
<phrase diff="chg" at="R"><termref def="dt-extension-attribute">extension attributes</termref></phrase> on
<elcode>xsl:number</elcode> to provide additional control over the way in which numbers are formatted.</p>
				</note>

				<p>The <code>grouping-separator</code> attribute gives the separator
used as a grouping (for example, thousands) separator in decimal numbering
sequences, and the optional <code>grouping-size</code> specifies the
size (normally 3) of the grouping.  For example,
<code>grouping-separator=","</code> and <code>grouping-size="3"</code>
would produce numbers of the form <code>1,000,000</code> while
<code>grouping-separator="."</code> and <code>grouping-size="2"</code> would produce
numbers of the form <code>1.00.00.00</code>. If only one
of the <code>grouping-separator</code> and <code>grouping-size</code>
attributes is specified, then it is ignored.</p>

<example><head>Format Tokens and the Resulting Sequences</head>

<p>These examples use non-Latin characters which might not display
correctly in all browsers, depending on the system configuration.</p>

<table border="1" cellpadding="5">
<thead>
<tr>
  <th align="left">Description</th>
  <th align="left">Format Token</th>
  <th align="left">Sequence</th>
</tr>
</thead>
<tbody>

<tr>
<td>French cardinal words</td>
<td><code diff="chg" at="ZA">format="Ww" lang="fr"</code></td>
<td>Un, Deux, Trois, Quatre</td>
</tr>

<tr>
<td>German ordinal words</td>
<td><code diff="chg" at="ZA">format="w" ordinal="-e" lang="de"</code></td>
<td>erste, zweite, dritte, vierte</td>
</tr>

<tr>
<td>Katakana numbering</td>
<td><code>format="&amp;#x30A2;"</code></td>
<td>&#x30A2;, &#x30A4;, &#x30A6;, &#x30A8;, &#x30AA;, &#x30AB;, &#x30AD;, &#x30AF;, &#x30B1;, &#x30B3;, &#x30B5;,
&#x30B7;, &#x30B9;, &#x30BB;, &#x30BD;, &#x30BF;, &#x30C1;, &#x30C4;, &#x30C6;, &#x30C8;, &#x30CA;, &#x30CB;,
&#x30CC;, &#x30CD;, &#x30CE;, &#x30CF;, &#x30D2;, &#x30D5;, &#x30D8;, &#x30DB;, &#x30DE;, &#x30DF;, &#x30E0;,
&#x30E1;, &#x30E2;, &#x30E4;, &#x30E6;, &#x30E8;, &#x30E9;, &#x30EA;, &#x30EB;, &#x30EC;, &#x30ED;, &#x30EF;,
&#x30F0;, &#x30F1;, &#x30F2;, &#x30F3;</td>
</tr>

<tr>
<td>Katakana numbering in iroha order</td>
<td><code>format="&amp;#x30A4;"</code></td>
<td>&#x30A4;, &#x30ED;, &#x30CF;, &#x30CB;, &#x30DB;, &#x30D8;, &#x30C8;, &#x30C1;, &#x30EA;, &#x30CC;, &#x30EB;,
&#x30F2;, &#x30EF;, &#x30AB;, &#x30E8;, &#x30BF;, &#x30EC;, &#x30BD;, &#x30C4;, &#x30CD;, &#x30CA;, &#x30E9;,
&#x30E0;, &#x30A6;, &#x30F0;, &#x30CE;, &#x30AA;, &#x30AF;, &#x30E4;, &#x30DE;, &#x30B1;, &#x30D5;, &#x30B3;,
&#x30A8;, &#x30C6;, &#x30A2;, &#x30B5;, &#x30AD;, &#x30E6;, &#x30E1;, &#x30DF;, &#x30B7;, &#x30F1;, &#x30D2;,
&#x30E2;, &#x30BB;, &#x30B9;</td>
</tr>

<tr>
<td>Thai numbering</td>
<td><code>format="&amp;#x0E51;"</code></td>
<td>&#x0E51;, &#x0E52;, &#x0E53;, &#x0E54;, &#x0E55;, &#x0E56;, &#x0E57;, &#x0E58;, &#x0E59;, &#x0E51;&#x0E50;,
&#x0E51;&#x0E51;, &#x0E51;&#x0E52;, &#x0E51;&#x0E53;, &#x0E51;&#x0E54;, &#x0E51;&#x0E55;,
&#x0E51;&#x0E56;, &#x0E51;&#x0E57;, &#x0E51;&#x0E58;, &#x0E51;&#x0E59;, &#x0E52;&#x0E50;</td>
</tr>

<tr>
<td>Traditional Hebrew numbering</td>
<td><code>format="&amp;#x05D0;" letter-value="traditional"</code></td>
<td>&#x05D0;,
&#x05D1;,
&#x05D2;,
&#x05D3;,
&#x05D4;,
&#x05D5;,
&#x05D6;,
&#x05D7;,
&#x05D8;,
&#x05D9;, 
&#x05D9;&#x05D0;, 
&#x05D9;&#x05D1;, 
&#x05D9;&#x05D2;, 
&#x05D9;&#x05D3;, 
&#x05D8;&#x05D5;, 
&#x05D8;&#x05D6;, 
&#x05D9;&#x05D6;, 
&#x05D9;&#x05D7;, 
&#x05D9;&#x05D8;, 
&#x05DB;</td>
</tr>

<tr>
<td>Traditional Georgian numbering</td>
<td><code>format="&amp;#x10D0;" letter-value="traditional"</code></td>
<td>&#x10D0;,
&#x10D1;,
&#x10D2;,
&#x10D3;,
&#x10D4;,
&#x10D5;,
&#x10D6;,
&#x10F1;,
&#x10D7;,
&#x10D8;,
&#x10D8;&#x10D0;,
&#x10D8;&#x10D1;,
&#x10D8;&#x10D2;,
&#x10D8;&#x10D3;,
&#x10D8;&#x10D4;,
&#x10D8;&#x10D5;,
&#x10D8;&#x10D6;,
&#x10D8;&#x10F1;,
&#x10D8;&#x10D7;,
&#x10D9;
</td>
</tr>

<tr>
<td>Classical Greek numbering (see note)</td>
<td><code>format="&amp;#x03B1;" letter-value="traditional"</code></td>
<td>
&#x03B1;&#x0374;,
&#x03B2;&#x0374;,
&#x03B3;&#x0374;,
&#x03B4;&#x0374;,
&#x03B5;&#x0374;,
&#x03DB;&#x0374;,
&#x03B6;&#x0374;,
&#x03B7;&#x0374;,
&#x03B8;&#x0374;,
&#x03B9;&#x0374;,
&#x03B9;&#x03B1;&#x0374;,
&#x03B9;&#x03B2;&#x0374;,
&#x03B9;&#x03B3;&#x0374;,
&#x03B9;&#x03B4;&#x0374;,
&#x03B9;&#x03B5;&#x0374;,
&#x03B9;&#x03DB;&#x0374;,
&#x03B9;&#x03B6;&#x0374;,
&#x03B9;&#x03B7;&#x0374;,
&#x03B9;&#x03B8;&#x0374;,
&#x03BA;&#x0374;</td>
</tr>

<tr>
<td>Old Slavic numbering</td>
<td><code>format="&amp;#x0430;" letter-value="traditional"</code></td>
<td>&#x0410;,
&#x0412;,
&#x0413;,
&#x0414;,
&#x0415;,
&#x0405;,
&#x0417;,
&#x0418;,
&#x0472;,
&#x04C0;,
&#x0410;&#x04C0;,
&#x0412;&#x04C0;,
&#x0413;&#x04C0;,
&#x0414;&#x04C0;,
&#x0415;&#x04C0;,
&#x0405;&#x04C0;,
&#x0417;&#x04C0;,
&#x0418;&#x04C0;,
&#x0472;&#x04C0;,
&#x041A;</td>
</tr>
</tbody></table>

<p>Note that Glassical Greek is an example where the format token is not the same as the
representation of the number 1.</p>

</example>

				



				
				
			</div2>
		</div1>
		<div1 id="sorting">
			<head>Sorting</head>
			<p>
				<termdef id="dt-sort-key-specification" term="sort key specification">A 
<term>sort key specification</term>
is a sequence of one or more adjacent <elcode>xsl:sort</elcode> elements which together define rules
for sorting the items in an input sequence to form a sorted sequence.</termdef></p>

<p><termdef id="dt-sort-key-component" term="sort key component">Within a
<termref def="dt-sort-key-specification">sort key specification</termref>, each
<elcode>xsl:sort</elcode> element defines one <term>sort key component</term>.</termdef>
The first <elcode>xsl:sort</elcode>
element specifies the primary component of the sort key specification, the second <elcode>xsl:sort</elcode>
element specifies the secondary component of the sort key specification and so on.</p>
			<p>A sort key specification may occur  
immediately within an <elcode>xsl:apply-templates</elcode>, 
<elcode>xsl:for-each</elcode>, <elcode>xsl:perform-sort</elcode>, 
or <elcode>xsl:for-each-group</elcode> element.</p>
			
				<note><p>When used within <elcode>xsl:for-each</elcode>,
<elcode>xsl:for-each-group</elcode>, or <elcode>xsl:perform-sort</elcode>, 
<elcode>xsl:sort</elcode> elements must occur before any other children.</p></note>
			

			<div2 id="xsl-sort">
				<head>The <elcode>xsl:sort</elcode> Element</head>
				<e:element-syntax name="sort">
					<e:attribute name="select">
						<e:data-type name="expression"/>
					</e:attribute>
					<e:attribute name="lang">
						<e:attribute-value-template>
							<e:data-type name="nmtoken"/>
						</e:attribute-value-template>
					</e:attribute>
					<e:attribute name="order">
						<e:attribute-value-template>
							<e:constant value="ascending"/>
							<e:constant value="descending"/>
						</e:attribute-value-template>
					</e:attribute>
					<e:attribute name="collation">
						<e:attribute-value-template>
							<e:data-type name="uri"/>
						</e:attribute-value-template>
					</e:attribute>
					<e:attribute name="stable">
						<e:attribute-value-template>
							<e:constant value="yes"/>
							<e:constant value="no"/>
						</e:attribute-value-template>
					</e:attribute>					
					<e:attribute name="case-order">
						<e:attribute-value-template>
							<e:constant value="upper-first"/>
							<e:constant value="lower-first"/>
						</e:attribute-value-template>
					</e:attribute>
					<e:attribute name="data-type">
						<e:attribute-value-template>
							<e:constant value="text"/>
							<e:constant value="number"/>
							<e:data-type name="qname-but-not-ncname"/>
						</e:attribute-value-template>
					</e:attribute>
				    <e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent name="apply-templates"/>
						<e:parent name="for-each"/>
						<e:parent name="for-each-group"/>
						<e:parent name="perform-sort"/>						
					</e:allowed-parents>
				</e:element-syntax>
				
<p>The <elcode>xsl:sort</elcode> element defines a
<termref def="dt-sort-key-component">sort key component</termref>. A sort key component
specifies how a <termref def="dt-sort-key-value">sort key value</termref> is to be
computed for each item in the sequence being sorted, and also how two sort key values
are to be compared.</p>

<p>The value of a <termref def="dt-sort-key-component">sort key component</termref>
is determined either by its <code>select</code> attribute, or by the contained
<termref def="dt-sequence-constructor">sequence constructor</termref>. If neither is
present, the default is
 <code>select="."</code>, which has the effect of sorting on the actual value of the item 
 if it is an atomic value, or on the typed-value of the item if it is a node. If a <code>select</code>
 attribute is present, its value <rfc2119>must</rfc2119> be an 
 XPath <termref def="dt-expression">expression</termref>.</p>

<p><error spec="XT" type="static" class="SE" code="1015"><p>It is
 a <termref def="dt-static-error">static error</termref>
if an <elcode>xsl:sort</elcode> element with a <code>select</code> attribute has non-empty content.</p></error></p>

				<p>Those attributes of the <elcode>xsl:sort</elcode> elements whose values
 are <termref def="dt-attribute-value-template">attribute value templates</termref>
are evaluated using the 
same <termref def="dt-focus">focus</termref> as is used to evaluate the
<code>select</code> attribute of the containing instruction
 (specifically, <elcode>xsl:apply-templates</elcode>,
 <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
  or <elcode>xsl:perform-sort</elcode>).</p>


 
<p diff="add" at="T">The <code>stable</code> attribute is permitted only on the first 
<elcode>xsl:sort</elcode> element within a <termref def="dt-sort-key-specification">sort key specification</termref></p>

<p diff="add" at="T"><error spec="XT" type="static" class="SE" code="1017"><p>It is
 a <termref def="dt-static-error">static error</termref>
if an <elcode>xsl:sort</elcode> element other than the first in a sequence of sibling
<elcode>xsl:sort</elcode> elements has a <code>stable</code> attribute.</p></error></p>

<p diff="add" at="T"><termdef id="dt-stable" term="stable">A 
<termref def="dt-sort-key-specification">sort key specification</termref>
is said to be <term>stable</term> if its first <elcode>xsl:sort</elcode> element
has no <code>stable</code> attribute, or has a <code>stable</code> attribute whose
<termref def="dt-effective-value">effective value</termref> is <code>yes</code>.</termdef></p> 
  


<div3 id="sorting-process"><head>The Sorting Process</head>

<p><termdef id="dt-initial-sequence" term="initial sequence">The sequence to be sorted
is referred to as the <term>initial sequence</term>.</termdef></p>

<p><termdef id="dt-sorted-sequence" term="sorted sequence">The sequence after sorting 
as defined by the <elcode>xsl:sort</elcode> elements
is referred to as the <term>sorted sequence</term>.</termdef></p>

<p><termdef id="dt-sort-key-value" term="sort key value">
For each item in the <termref def="dt-initial-sequence">initial sequence</termref>,
a value is computed
for each <termref def="dt-sort-key-component">sort key component</termref>
within the <termref def="dt-sort-key-specification">sort key specification</termref>.
The value computed for an item by using the <var>N</var>th sort key component
is referred to as the <var>N</var>th <term>sort key value</term> of that item.</termdef></p>

				<p>The items in the <termref def="dt-initial-sequence">initial sequence</termref>
 are ordered into a <termref def="dt-sorted-sequence">sorted sequence</termref> by comparing their
<termref def="dt-sort-key-value">sort key values</termref>. 
The relative position of two items <var>A</var> and <var>B</var> in the sorted
 sequence is determined as follows. The first sort key value of <var>A</var> is compared
 with the first sort key value of <var>B</var>, according to the rules of the first
  <termref def="dt-sort-key-component">sort key component</termref>. If, under these rules,
   <var>A</var> is less than <var>B</var>, then <var>A</var> will precede <var>B</var>
 in the sorted sequence, unless the <code>order</code> attribute of this 
 <termref def="dt-sort-key-component">sort key component</termref> specifies
 <code>descending</code>, in which case <var>B</var> will precede <var>A</var>
 in the sorted sequence. If, however, the relevant sort key values compare equal,
 then the second sort key value of <var>A</var> is compared
 with the second sort key value of <var>B</var>, according to the rules of the second 
 <termref def="dt-sort-key-component">sort key component</termref>.
 This continues until two sort key values are found that compare unequal. If all 
 the sort key values compare equal, 
 <phrase diff="add" at="T">and the <termref def="dt-sort-key-specification">sort key specification</termref>
 is <termref def="dt-stable">stable</termref>,</phrase>
  then <var>A</var> will precede <var>B</var> in the
  <termref def="dt-sorted-sequence">sorted sequence</termref> if and only if
 <var>A</var> preceded <var>B</var> in the <termref def="dt-initial-sequence">initial sequence</termref>.
 <phrase diff="add" at="T">If all 
 the sort key values compare equal, 
 and the <termref def="dt-sort-key-specification">sort key specification</termref>
 is not <termref def="dt-stable">stable</termref>, then the relative order of <var>A</var> and
  <var>B</var> in the
  <termref def="dt-sorted-sequence">sorted sequence</termref> is
  <termref def="dt-implementation-dependent">implementation-dependent</termref>.</phrase></p>

  <note><p>If two items have equal <termref def="dt-sort-key-value">sort key values</termref>, 
  <phrase diff="add" at="T">and the sort is <termref def="dt-stable">stable</termref>,</phrase> then their
  order in the <termref def="dt-sorted-sequence">sorted sequence</termref> will be the same
  as their order in the <termref def="dt-initial-sequence">initial sequence</termref>, regardless
  of whether <code>order="descending"</code> was specified on any or all of the 
  <termref def="dt-sort-key-component">sort key components</termref>.</p></note>
  
 
<p>The <var>N</var>th sort key value is computed by evaluating either the
<code>select</code> attribute or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>
of the <var>N</var>th <elcode>xsl:sort</elcode> element, or the expression <code>.</code> (dot) if neither is
present. This evaluation is done with the <termref def="dt-focus">focus</termref> set as follows:</p>
				<ulist>
					<item>
						<p>The <termref def="dt-context-item">context item</termref> is the item in the
 <termref def="dt-initial-sequence">initial sequence</termref> whose 
 <termref def="dt-sort-key-value">sort key value</termref> is
 being computed.</p>
					</item>
					<item>
						<p>The <termref def="dt-context-position">context position</termref>
is the position of that item in the initial sequence.</p>
					</item>
					<item>
						<p>The <termref def="dt-context-size">context size</termref> 
is the size of the initial sequence.</p>
					</item>
				</ulist>

<note><p>As in any other XPath expression, the <function>current</function> function
may be used within the <code>select</code> expression of <elcode>xsl:sort</elcode> to refer to the 
item that is the context item for the expression as a whole; that is, the item whose
 <termref def="dt-sort-key-value">sort key value</termref> is being computed.</p></note>
				
				<p>The <termref def="dt-sort-key-value">sort key values</termref> are 
				<termref def="dt-atomization">atomized</termref>, and are then
				compared. The way they are compared depends on their data type, as
				described in the next section.</p>

</div3>

<div3 id="comparing-sort-keys"><head>Comparing Sort Key Values</head>

<p>It is possible to force the system to compare 
<termref def="dt-sort-key-value">sort key values</termref> using the rules for a particular
data type by including a cast as part of the <termref def="dt-sort-key-component">sort key component</termref>. 
For example, <code>&lt;xsl:sort select="xs:date(@dob)"/&gt;</code>
will force the attributes to be compared as dates. In the absence of such a cast, the sort key values are compared using
the rules appropriate to their data type. Any values of type <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>
are cast to <code>xs:string</code>.</p>
				
				<p>For backwards compatibility with XSLT 1.0, the <code>data-type</code> attribute  
				<phrase diff="chg" at="O">remains available. If 
 this has the <termref def="dt-effective-value">effective value</termref> <code>text</code>, 
 the atomized
 <termref def="dt-sort-key-value">sort key values</termref> are converted to strings before being compared. 
 If it has the effective value <code>number</code>, the atomized
 sort key values are converted to doubles before being compared.
 The conversion is done by using the <xfunction>string</xfunction> or <xfunction>number</xfunction> 
 function as appropriate.</phrase> If the <code>data-type</code> attribute has
 any other <termref def="dt-effective-value">effective value</termref>, 
 then the value <rfc2119>must</rfc2119> be a <phrase diff="chg" at="R"><termref def="dt-lexical-qname">lexical QName</termref> with a non-empty prefix</phrase>, and the effect of the
  attribute is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
				<imp-def-feature>If the <code>data-type</code> attribute of the <elcode>xsl:sort</elcode> element
has a value other than <code>text</code> or <code>number</code>, the effect is 
implementation-defined.</imp-def-feature>

<p><error spec="XT" type="type" class="TE" code="1020"><p>If any <termref def="dt-sort-key-value">sort key value</termref>, after 
<termref def="dt-atomization">atomization</termref> and any type conversion <rfc2119>required</rfc2119> by the
<code>data-type</code> attribute, is a sequence containing
more than one item, then the effect depends on whether the <elcode>xsl:sort</elcode> element 
is evaluated with <termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>.
With backwards compatible behavior, the effective sort key value is the first item in the sequence.
In other cases, this is a <termref def="dt-type-error">type error</termref>.</p></error></p>

<p>The set of <termref def="dt-sort-key-value">sort key values</termref> (after any conversion) 
is first divided into <phrase diff="chg" at="R">two
categories: empty values, and ordinary values. </phrase>
The empty sort key values represent those
items where the sort key value is an empty sequence. These values are considered for sorting
purposes to be equal to each other, but less than any other value. 
 The remaining values are classified as ordinary values.</p>				

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="1030"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if, for any
  <termref def="dt-sort-key-component">sort key component</termref>,
 the set of <termref def="dt-sort-key-value">sort key values</termref> evaluated for all the items in the
 <termref def="dt-initial-sequence">initial sequence</termref>, after any type conversion requested,
 contains a pair of ordinary values for which the result of the
 XPath <code>lt</code> operator is an error.</p></error></p>

<note><p>The above error condition may occur if the values to be sorted
are of a type that does not support ordering (for example, <code>xs:QName</code>) or if the
sequence is heterogeneous (for example, if it contains both strings and numbers). The error
can generally be prevented by invoking a cast or constructor function within the sort key
component.</p>

<p diff="add" at="X">The error condition is subject to the usual caveat that a processor is not required
to evaluate any expression solely in order to determine whether it raises an error. For example, if there
are several sort key components, then a processor is not required to evaluate or compare minor sort key
values unless the corresponding major sort key values are equal.</p>
</note>

		
<p>In general, comparison of two ordinary values is
 performed according to the rules of the
 XPath <code>lt</code> operator. <phrase diff="add" at="Y">To ensure a total ordering, the same 
 implementation of the
 <code>lt</code> operator <rfc2119>must</rfc2119> be used for all the comparisons: the one that is chosen
 is the one appropriate to the most specific type to which all the values can be converted by subtype substitution
 and/or type promotion. For example, if the sequence contains both <code>xs:decimal</code> and <code>xs:double</code>
 values, then the values are compared using <code>xs:double</code> comparison, even when comparing two
 <code>xs:decimal</code> values.</phrase> 
 NaN values, for sorting purposes, are considered to be equal to each other,
 and less than any other numeric value. Special rules
  also apply to the <code>xs:string</code> <phrase diff="chg" at="ZA"> and <code>xs:anyURI</code>
  types, and types derived by restriction therefrom,</phrase>,
  as described in the next section.</p>
  
 
</div3>

<div3 id="collating-sequences"><head>Sorting Using Collations</head>

<p>The rules given in this section apply when comparing 
values whose type is <code>xs:string</code> 
or a type derived by restriction from <code>xs:string</code><phrase diff="chg" at="ZA">,
or whose type is <code>xs:anyURI</code> 
or a type derived by restriction from <code>xs:anyURI</code></phrase>.</p>

				<p><termdef id="dt-collation" term="collation">Facilities in
 XSLT 2.0 and XPath 2.0 that require strings to be ordered rely on the concept of a named
<term>collation</term>. A collation is a set of rules that determine
whether two strings are equal, and if not, which of them is to be sorted before the other.</termdef>
 A collation is
identified by a URI, but the manner in which this URI is associated with an actual rule or algorithm
 is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
 
 <imp-def-feature>The facilities for defining collations and allocating URIs to identify them
 are implementation-defined.</imp-def-feature>
 
<p>The one collation URI that must be recognized by every implementation is
 <code diff="chg" at="X">http://www.w3.org/2005/xpath-functions/collation/codepoint</code>, which provides the ability
 to compare strings based on the Unicode codepoint values of the characters in the string.</p> 
 
 <p>For more information about collations, see <xspecref spec="FO" ref="string-compare"/>
 in <bibref ref="xpath-functions"/>.
 Some specifications, for example <bibref ref="UNICODE-TR10"/>, 
 use the term "collation" to describe rules that can be tailored or parameterized for various 
 purposes. In this specification, a collation URI refers to a collation in which all such 
 parameters have already been fixed. Therefore, if a collation URI is specified, other 
attributes such as <code>case-order</code> and <code>lang</code> are ignored.
 </p>
 
<note><p>The reason XSLT does not provide detailed mechanisms for defining collating sequences
is that many implementations will re-use collating mechanisms available from the underlying
implementation platform (for example, from the operating system or from the run-time library
of a chosen programming language). These will inevitably differ from one XSLT implementation
to another.</p></note>

<p>If the <elcode>xsl:sort</elcode> element has a
<code>collation</code> attribute, then the strings are compared according to the rules for the named
<termref def="dt-collation">collation</termref>: that is, they are compared using the XPath 
function call <code>compare($a, $b, $collation)</code>.</p>

<p diff="add" at="Y">If the <termref def="dt-effective-value">effective value</termref> of
the <code>collation</code> attribute of <elcode>xsl:sort</elcode> is a relative URI, then it
is resolved against the base URI of the <elcode>xsl:sort</elcode> element.</p>

<p diff="chg" at="ZA"><error spec="XT" type="dynamic" class="DE" code="1035"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> 
if the <code>collation</code> attribute of <elcode>xsl:sort</elcode> (after resolving against
the base URI) is not a URI that is recognized
by the implementation as referring to a collation.</p></error></p>

<note><p>It is entirely for the implementation to determine whether it
recognizes a particular collation URI. For example, 
if the implementation allows collation URIs to contain parameters in the query part of the URI, 
it is the implementation that determines whether a URI containing an unknown or invalid parameter 
is or is not a recognized collation URI. <phrase diff="chg" at="X">The fact that this
error is described as non-recoverable thus does not prevent an implementation
applying a fallback collation if it chooses to do so.</phrase></p></note>

<p>The <code>lang</code> and <code>case-order</code> attributes are 
 ignored if a <code>collation</code> attribute
 is present. But in the absence of a <code>collation</code> 
 attribute, these attributes provide input to an 
 <termref def="dt-implementation-defined">implementation-defined</termref>
  algorithm to <phrase diff="chg" at="T">locate</phrase> a suitable collation:</p>
				<imp-def-feature>The algorithm used by <elcode>xsl:sort</elcode> to locate a collation,
 given the values of the <code>lang</code> and <code>case-order</code> attributes,
 is implementation-defined.</imp-def-feature>
				<ulist>
					<item>
						<p>The <code>lang</code> attribute indicates that a collation
 suitable for a particular natural language <rfc2119>should</rfc2119> be used. The 
 <termref def="dt-effective-value">effective value</termref> of
 the attribute <rfc2119>must</rfc2119> be a value that would be valid for the
 <code>xml:lang</code> attribute (see <bibref ref="REC-xml"/>).</p>
					</item>
					<item>
						<p>The <code>case-order</code> attribute indicates whether
 the desired collation <rfc2119>should</rfc2119> sort upper-case letters before 
 lower-case or vice versa. The 
 <termref def="dt-effective-value">effective value</termref> of
 the attribute <rfc2119>must</rfc2119> be either <code>lower-first</code> (indicating
 that lower-case letters precede upper-case letters in the collating
 sequence) or <code>upper-first</code> (indicating that upper-case
 letters precede lower-case).</p>
					</item>
				</ulist>
				
<p>If none of the <code>collation</code>, <code>lang</code> or <code>case-order</code>
attributes is present, the collation is chosen in an <termref def="dt-implementation-defined">implementation-defined</termref>
way. It is not <rfc2119>required</rfc2119> that the default collation for sorting should be the same as
the <termref def="dt-default-collation">default collation</termref> used when evaluating XPath expressions,
as described in <specref ref="static-context"/> and <specref ref="default-collation-attribute"/>.</p>

<note><p>It is usually appropriate, when sorting, to use a strong collation, that is, one
that takes account of secondary differences (accents) and tertiary differences (case) between strings that are
otherwise equal. A weak collation, which ignores such differences, may be more suitable when comparing strings
for equality.</p>

<p>Useful background information on international sorting is provided in
<bibref ref="UNICODE-TR10"/>. The <code>case-order</code> attribute may be interpreted
as described in section 6.6 of <bibref ref="UNICODE-TR10"/>.</p></note>
				 
</div3>


			</div2>
			
<div2 id="creating-sorted-sequence"><head>Creating a Sorted Sequence</head>

					<e:element-syntax name="perform-sort">
						<e:in-category name="instruction"/>
						<e:attribute name="select" required="no">
							<e:data-type name="expression"/>
						</e:attribute>
        				<!--<e:attribute name="as">
        					<e:data-type name="sequence-type"/>
        				</e:attribute>-->
        				<e:sequence>
        					<e:element repeat="one-or-more" name="sort"/>
        					<e:model name="sequence-constructor"/>
        				</e:sequence>
						<e:allowed-parents>
							<e:parent-category name="sequence-constructor"/>
						</e:allowed-parents>
					</e:element-syntax>

<p>The <elcode>xsl:perform-sort</elcode> instruction is used to return a 
<termref def="dt-sorted-sequence">sorted sequence</termref>.</p>

<p>The <termref def="dt-initial-sequence">initial sequence</termref>
 is obtained either by evaluating the <code>select</code> attribute or
by evaluating the contained sequence constructor (but not both). 
If there is no <code>select</code> attribute and no sequence
 constructor then the <termref def="dt-initial-sequence">initial sequence</termref> 
 (and therefore, the <termref def="dt-sorted-sequence">sorted sequence</termref>) is an empty sequence.</p>

<p><error spec="XT" type="static" class="SE" code="1040"><p>It is a <termref def="dt-static-error">static error</termref>
if an <elcode>xsl:perform-sort</elcode> instruction with a <code>select</code> attribute has any content
other than <elcode>xsl:sort</elcode> and <elcode>xsl:fallback</elcode> instructions.</p></error></p>
 
 <p>The result of the <elcode>xsl:perform-sort</elcode> instruction is the result of sorting its 
 <termref def="dt-initial-sequence">initial sequence</termref>
 using its contained <termref def="dt-sort-key-specification">sort key specification</termref>.</p>
 
 <example><head>Sorting a Sequence of Atomic Values</head>
 <p>The following stylesheet function sorts a sequence
 of atomic values using the value itself as the sort key.</p>
 
<eg><![CDATA[<xsl:function name="local:sort" as="xs:anyAtomicType*">
  <xsl:param name="in" as="xs:anyAtomicType*"/>
  <xsl:perform-sort select="$in">
    <xsl:sort select="."/>
  </xsl:perform-sort>
</xsl:function>]]></eg>

</example>

 <example><head>Writing a Function to Perform a Sort</head>
 <p>The following example defines a function that sorts books by price, and
 uses this function to output the 
 five books that have the lowest prices:</p>
<eg><![CDATA[<xsl:function name="bib:books-by-price" as="schema-element(bib:book)*">
  <xsl:param name="in" as="schema-element(bib:book)*"/>
  <xsl:perform-sort select="$in">
    <xsl:sort select="xs:decimal(bib:price)"/>
  </xsl:perform-sort>
</xsl:function>
   ...
   <xsl:copy-of select="bib:books-by-price(//bib:book)[position() = 1 to 5]"/>

 ]]></eg>
 </example>

</div2>
			
			
			<div2 id="sorted-iteration">
				<head>Processing a Sequence in Sorted Order</head>
				<p>When used within <elcode>xsl:for-each</elcode> or
<elcode>xsl:apply-templates</elcode>, a
<termref def="dt-sort-key-specification">sort key specification</termref> indicates that
the sequence of items selected by that instruction is to be processed
in sorted order, not in the order of the supplied sequence.</p>
				<example><head>Processing Elements in Sorted Order</head>
					<p>For example, suppose an employee database has the form</p>
<eg><![CDATA[<employees>
  <employee>
    <name>
      <given>James</given>
      <family>Clark</family>
    </name>
    ...
  </employee>
</employees>
]]></eg>
					<p>Then a list of employees sorted by name could be generated
using:</p>
<eg><![CDATA[<xsl:template match="employees">
  <ul>
    <xsl:apply-templates select="employee">
      <xsl:sort select="name/family"/>
      <xsl:sort select="name/given"/>
    </xsl:apply-templates>
  </ul>
</xsl:template>

<xsl:template match="employee">
  <li>
    <xsl:value-of select="name/given"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="name/family"/>
  </li>
</xsl:template>]]></eg>
				</example>
				<p>When used within <elcode>xsl:for-each-group</elcode>, a
<termref def="dt-sort-key-specification">sort key specification</termref>
indicates the order in which the groups are to be processed.
For the effect of <elcode>xsl:for-each-group</elcode>, see
 <specref ref="grouping"/>.
				</p>
			</div2>
			
		</div1>
		<div1 id="grouping">
			<head>Grouping</head>
			<p>The facilities described in this section are designed to allow
 items in a sequence to be grouped based on common values;
 for example it allows grouping of elements having the same value for a particular attribute,
 or elements with the same name, or elements with
  common values for any other <termref def="dt-expression">expression</termref>. Since
 grouping identifies items with duplicate values, the
 same facilities also allow selection of the distinct values in
 a sequence of items, that is, the elimination of duplicates.</p>
 
 <note><p>Simple elimination of duplicates can also be achieved using the
 function <xfunction>distinct-values</xfunction> in the <termref def="dt-core-function">core function</termref> library: see
 <bibref ref="xpath-functions"/>.</p></note>
 
			<p>In addition these facilities allow grouping based on sequential position, for example
selecting groups of adjacent <code>para</code> elements. The facilities also provide an easy
way to do fixed-size grouping, for example identifying groups of three adjacent nodes, 
which is useful when arranging data in multiple columns.</p>
			<p>For each group of items identified, it is possible to evaluate
 a <termref def="dt-sequence-constructor">sequence constructor</termref>
 for the group.
 Grouping is nestable to multiple levels so that groups of distinct items can be
  identified, then from among the distinct groups selected, further sub-grouping of 
  distinct items in the current group can be done. </p>
  
  <p>It is also possible for one item to participate in more than one group.</p>
  
			<div2 id="current-group">
				<head>The Current Group</head>
				<proto class="xslt" name="current-group" return-type="item()" returnSeq="yes"/>
				<p>
					<termdef id="dt-current-group" term="current group">The evaluation context for 
XPath <termref def="dt-expression">expressions</termref> includes a <phrase diff="chg" at="O">component</phrase> 
called the <term>current group</term>, which is a sequence. The current group is the collection of
related items that are processed collectively in one iteration of the <elcode>xsl:for-each-group</elcode> element.</termdef>
				</p>
				<p>While an <elcode>xsl:for-each-group</elcode> instruction is being evaluated,
the <termref def="dt-current-group">current group</termref> will be non-empty. At other times, it will be an empty sequence.</p>
				<p>The function <function>current-group</function> returns the current group.</p>
				<p>The function takes no arguments.</p>
				<p>
					<error spec="XT" type="static" class="SE" code="1060"><p>It is a <termref def="dt-static-error">static error</termref> if
					the <function>current-group</function> function is used
within a <termref def="dt-pattern">pattern</termref>.</p></error>
				</p>
			</div2>
			<div2 id="current-grouping-key" diff="add" at="Q">
				<head>The Current Grouping Key</head>
				<proto diff="chg" at="R" class="xslt" name="current-grouping-key" return-type="xs:anyAtomicType" returnSeq="no" returnEmptyOk="yes"/>
				<p>
					<termdef id="dt-current-grouping-key" term="current grouping key">The evaluation context for 
XPath <termref def="dt-expression">expressions</termref> includes a component
called the <term>current grouping key</term>, which is an atomic value. The current grouping key is 
<phrase diff="chg" at="ZA">the <termref def="dt-grouping-key">grouping key</termref></phrase>
shared in common by all the items within the <termref def="dt-current-group">current group</termref>.</termdef>
				</p>
				<p>While an <elcode>xsl:for-each-group</elcode> instruction with a <code>group-by</code>
				or <code>group-adjacent</code> attribute is being evaluated,
the <termref def="dt-current-grouping-key">current grouping key</termref> will be 
<phrase diff="chg" at="R">a single atomic value</phrase>. At other times, it will be the empty sequence.</p>
				<p>The function <function>current-grouping-key</function> returns the 
				<termref def="dt-current-grouping-key">current grouping key</termref>.</p>

<p diff="add" at="ZA">Although the <termref def="dt-grouping-key">grouping keys</termref> of all items in a group
 are by definition equal, they are not necessarily identical. For example, one might be an <code>xs:float</code> 
 while another is an <code>xs:decimal</code>. The <function>current-grouping-key</function> function is defined to 
 return the grouping key of the <termref def="dt-initial-item">initial item</termref> in the group, 
 after atomization and casting of <code>xs:untypedAtomic</code> to <code>xs:string</code>.</p>

				<p>The function takes no arguments.</p>
				<p>
					<error spec="XT" type="static" class="SE" code="1070"><p>It is a <termref def="dt-static-error">static error</termref> if
					the <function>current-grouping-key</function> function is used
within a <termref def="dt-pattern">pattern</termref>.</p></error>
				</p>
			</div2>			
			
			<div2 id="xsl-for-each-group">
				<head>The <code>xsl:for-each-group</code> Element</head>
				<e:element-syntax name="for-each-group">
					<e:in-category name="instruction"/>
					<e:attribute name="select" required="yes">
						<e:data-type name="expression"/>
					</e:attribute>
					<e:attribute name="group-by" required="no">
						<e:data-type name="expression"/>
					</e:attribute>
					<e:attribute name="group-adjacent" required="no">
						<e:data-type name="expression"/>
					</e:attribute>
					<e:attribute name="group-starting-with" required="no">
						<e:data-type name="pattern"/>
					</e:attribute>
					<e:attribute name="group-ending-with" required="no">
						<e:data-type name="pattern"/>
					</e:attribute>
					<e:attribute name="collation">
						<e:attribute-value-template>
							<e:data-type name="uri"/>
						</e:attribute-value-template>
					</e:attribute>
					<e:sequence>
						<e:element repeat="zero-or-more" name="sort"/>
						<e:model name="sequence-constructor"/>
					</e:sequence>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>
				<p>This element is an <termref def="dt-instruction">instruction</termref> that
 may be used anywhere within a <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>
				<p>
					<termdef id="dt-group" term="group">The <elcode>xsl:for-each-group</elcode> instruction 
					<phrase diff="chg" at="Q">allocates the items in an input sequence</phrase> into
<term>groups</term> of items (that is, it establishes a collection of sequences) based either on common
values of a grouping key, or on 
a <termref def="dt-pattern">pattern</termref> that the initial or final
node in a group must match.</termdef>
The <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the content of the
<elcode>xsl:for-each-group</elcode> instruction is evaluated once
for each of these groups.</p>
				<p>
					<termdef id="dt-population" term="population">The sequence of items
 to be grouped, which
 is referred to as the <term>population</term>,
is determined by evaluating the XPath <termref def="dt-expression">expression</termref> contained in the
<code>select</code> attribute.</termdef></p>

<p><termdef id="dt-population-order" term="population order">The population is treated as a sequence; 
the order of items in this sequence is referred to as <term>population order</term></termdef>.</p>

<p>A group is never empty. If the
population is empty, the number of groups will be zero. The assignment 
of items to groups depends on the <code>group-by</code>,  
<code>group-adjacent</code>, <code>group-starting-with</code>,
and <code>group-ending-with</code> attributes.</p>

<p><error spec="XT" type="static" class="SE" code="1080"><p>These four attributes 
<error.extra>the <code>group-by</code>,  
<code>group-adjacent</code>, 
<code>group-starting-with</code>, and <code>group-ending-with</code>
 attributes of <elcode>xsl:for-each-group</elcode>
						</error.extra>
are mutually exclusive: it is a <termref def="dt-static-error">static error</termref> if none of these
 four attributes is present, or if more than one of them is present.</p></error>
				</p>

				<p>
					<error spec="XT" type="static" class="SE" code="1090"><p>It is an error to specify the
 <code>collation</code> attribute if neither the
<code>group-by</code> attribute nor <code>group-adjacent</code> attribute is specified.</p></error>
				</p>
				
<p><termdef id="dt-grouping-key" term="grouping key">If either of the
<code>group-by</code> attribute or <code>group-adjacent</code> attributes is present, then
<term>grouping keys</term> are calculated for each item in the <termref def="dt-population">population</termref>.
<phrase diff="chg" at="ZA">The grouping keys are the items in the sequence obtained by evaluating the expression 
contained in the <code>group-by</code> attribute or <code>group-adjacent</code> attribute,
atomizing the result, and then casting an <code>xs:untypedAtomic</code> value to <code>xs:string</code>.</phrase></termdef></p>

<p><phrase diff="add" at="ZB">When calculating grouping keys for an item in the population,</phrase>
the <termref def="dt-expression">expression</termref> contained in the <code>group-by</code> or <code>group-adjacent</code> attribute is
evaluated with that item as the <termref def="dt-context-item">context item</termref>, with its position 
in <termref def="dt-population-order">population order</termref> as the 
<termref def="dt-context-position">context position</termref>, and with the size of the 
population as the <termref def="dt-context-size">context size</termref>. The resulting sequence is
<termref def="dt-atomization">atomized</termref>, and each atomic value in the atomized 
sequence acts as a <termref def="dt-grouping-key">grouping key</termref> for that item in the population.</p>

<p>If the <code>group-by</code> attribute is present, then an item in the population
may have multiple grouping keys: that is, the <code>group-by</code> expression evaluates to a sequence.
The item is included in as many groups as there are distinct grouping keys (which may be zero). If the <code>group-adjacent</code>
attribute is used, then each item in the population <rfc2119>must</rfc2119> have exactly one grouping key value.</p>

<p><error spec="XT" type="type" class="TE" code="1100"><p>It is a <termref def="dt-type-error">type error</termref>
if the <phrase diff="chg" at="T">grouping key evaluated using</phrase>
the <code>group-adjacent</code> attribute is an empty sequence, or a sequence containing
more than one item. </p></error></p>

 
<p><termref def="dt-grouping-key">Grouping keys</termref> are compared using the rules for the
 <code>eq</code> operator appropriate to their dynamic type. <phrase diff="add" at="R">Values of type
 <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase> are cast to <code>xs:string</code> before the comparison. Two items
 that are not comparable using the <code>eq</code> operator are considered to be not equal, that is,
 they are allocated to different groups.</phrase> 
If the values are strings, or untyped atomic values, 
<phrase diff="chg" at="Y">then if there is a <code>collation</code> attribute
the values are compared using the collation specified
as the <termref def="dt-effective-value">effective value</termref> of
 the <code>collation</code> attribute, resolved if relative against the base URI of the
 <elcode>xsl:for-each-group</elcode> element. If there is no <code>collation</code>
 attribute then the 
<termref def="dt-default-collation">default collation</termref> is used.</phrase></p>

<p>For the purposes of grouping, the value <code>NaN</code> is considered equal to itself.</p>

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="1110"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> 
if the collation URI specified to <elcode>xsl:for-each-group</elcode> 
<phrase diff="add" at="Y">(after resolving against the base URI)</phrase>
is a collation that is not recognized
by the implementation. (For notes, <errorref class="DE" code="1035"/>.)</p></error></p>

<p>For more information on collations, see <specref ref="collating-sequences"/>.</p>

<p><error spec="XT" type="type" class="TE" code="1120"><p>When the <code>group-starting-with</code>
or <code>group-ending-with</code> attribute 
<error.extra>of the <elcode>xsl:for-each-group</elcode> instruction</error.extra>
is used, it is a <termref def="dt-type-error">type error</termref> if the
result of evaluating the <code>select</code> expression 
contains an item that is not a node.</p></error></p>

				<ulist>
					<item>
					
<p>If the <code>group-by</code> attribute is present, the 
items in the <termref def="dt-population">population</termref> are examined, in population order. 
For each item <var>J</var>, the expression in the <code>group-by</code> attribute is evaluated to produce
 a sequence of zero or more <termref def="dt-grouping-key">grouping key</termref> values. For each
one of these <termref def="dt-grouping-key">grouping keys</termref>, if there is already a group
created to hold items having that grouping key value, <var>J</var> is added to that group; otherwise
a new group is created for items with that grouping key value, and <var>J</var>
becomes its first member.</p>

<!--</p>					
						<p>If the <code>group-by</code> attribute is present, then  
all items that have the same <termref def="dt-grouping-key">grouping key</termref> are assigned to 
the same group, and the-->
<p>An item in the population may thus be assigned to zero, one, or many groups. 
An item will never be assigned more than once
to the same group; if two or more grouping keys for the same item are equal, then the duplicates are ignored. 
An
<emph>item</emph> here means the item at a particular position within the population&#x2014;<!--em dash-->if the population contains 
the same node at several different positions in the sequence then a group may indeed contain duplicate nodes.</p>

<p>The number of groups will be the same as the number of 
distinct grouping key values present in the <termref def="dt-population">population</termref>.
</p>

					</item>
					<item>
						<p>If the <code>group-adjacent</code> attribute is present, the 
items in the <termref def="dt-population">population</termref> are examined, in population order. 
If an item 
has the same value for the <termref def="dt-grouping-key">grouping key</termref> as its preceding item within 
the <termref def="dt-population">population</termref>
(in <termref def="dt-population-order">population order</termref>), then it is assigned to the same group as its 
preceding item; otherwise a new group is created and the item 
becomes its first member.</p>
					</item>
					<item>
						<p>If the <code>group-starting-with</code> attribute is present, then its value <rfc2119>must</rfc2119> be
a <nt def="NT-Pattern">pattern</nt>. In this case, the items in the population <rfc2119>must</rfc2119> all be nodes.</p>

						<p>The nodes in the <termref def="dt-population">population</termref> are
examined in <termref def="dt-population-order">population order</termref>. If a node matches
the pattern, or is the first node in the population, then a new group is created and the
node becomes its first member. Otherwise, the node is assigned to the same group as its
preceding node within the population.</p>
					</item>
					<item>
						<p>If the <code>group-ending-with</code> attribute is present, then its value <rfc2119>must</rfc2119> be
a <nt def="NT-Pattern">pattern</nt>. In this case, the items in the population <rfc2119>must</rfc2119> all be nodes.</p>

						<p>The nodes in the <termref def="dt-population">population</termref> are
examined in <termref def="dt-population-order">population order</termref>. 
If a node is the first node in the population, or if the previous node in the population matches
the pattern, then a new group is created and the
node becomes its first member. Otherwise, the node is assigned to the same group as its
preceding node within the population.</p>
						
					</item>
				</ulist>

				<p><termdef id="dt-initial-item" term="initial item">For 
				each <termref def="dt-group">group</termref>, the item within the group that is first in
<termref def="dt-population-order">population order</termref> 
is known as the <term>initial item</term> of the group.</termdef></p>
				<p>
					<termdef id="dt-first-appearance" term="order of first appearance">There is an ordering
among <termref def="dt-group">groups</termref> referred to as the <term>order of first
appearance</term>. A group <var>G</var> is defined to precede a group <var>H</var> in order of first
appearance if the <termref def="dt-initial-item">initial item</termref> of <var>G</var> precedes the initial item of <var>H</var> 
in population order. <phrase diff="add" at="Q">If two groups <var>G</var> and <var>H</var> have the same initial item 
(because the item is in both groups) then <var>G</var> precedes <var>H</var> if the <termref def="dt-grouping-key">grouping key</termref>
of <var>G</var> precedes the grouping key of <var>H</var> in the sequence that results from evaluating the
<code>group-by</code> expression of this initial item.</phrase></termdef>
				</p>
				<p><termdef id="dt-processing-order" term="processing order">There 
				is another ordering among groups referred to as <term>processing order</term>.
				<phrase diff="add" at="T">If group <var>R</var> precedes group <var>S</var> in processing
				order, then in the result sequence returned by the <elcode>xsl:for-each-group</elcode> instruction 
				the items generated by processing
				group <var>R</var> will precede the items generated by processing group <var>S</var>.</phrase></termdef></p>
				
				
				<p>If there are no <elcode>xsl:sort</elcode> elements immediately within
the <elcode>xsl:for-each-group</elcode> element, the <termref def="dt-processing-order">processing order</termref> of
the <termref def="dt-group">groups</termref> is the <termref def="dt-first-appearance">order of first appearance</termref>.</p>
				<p>Otherwise, the <elcode>xsl:sort</elcode> elements immediately within
the <elcode>xsl:for-each-group</elcode> element define the processing
order of the <termref def="dt-group">groups</termref> (see <specref ref="sorting"/>). 
They do not affect the order of items within each group. 
Multiple <termref def="dt-sort-key-component">sort key components</termref> are allowed, 
and are evaluated in major-to-minor 
order. If two groups have the same values for all their sort key components, 
they are processed in order of first appearance.</p>
				<p>The <code>select</code> <termref def="dt-expression">expression</termref>
				 of an <elcode>xsl:sort</elcode> element is 
evaluated once for each <termref def="dt-group">group</termref>. During this evaluation, 
the <termref def="dt-context-item">context item</termref> 
is the <termref def="dt-initial-item">initial item</termref> of the group,
the <termref def="dt-context-position">context position</termref> is the position
of this item within the 
set of initial items (that is, one item for each group in the 
<termref def="dt-population">population</termref>) in
<termref def="dt-population-order">population order</termref>, 

the <termref def="dt-context-size">context size</termref>
is the number of groups, the
<termref def="dt-current-group">current group</termref> is the group 
whose <termref def="dt-sort-key-value">sort key value</termref> is being determined,
 <phrase diff="add" at="Q">and the <termref def="dt-current-grouping-key">current grouping key</termref>
 is the grouping key for that group. If the <elcode>xsl:for-each-group</elcode> instruction uses the
 <code>group-starting-with</code> or <code>group-ending-with</code> attributes, then the current grouping
 key is the empty sequence.</phrase></p>
 
				<example><head>Sorting Groups</head>
				<p>For example, this means that if 
the <termref def="dt-grouping-key">grouping key</termref> is 
<code>@category</code>, you can sort the groups in order of 
their grouping key by writing <code diff="chg" at="Q">&lt;xsl:sort select="current-grouping-key()"/&gt;</code>;
or you can sort the groups in order of size by writing 
<code>&lt;xsl:sort select="count(current-group())"/&gt;</code>
					</p></example>
					
				<p>The <termref def="dt-sequence-constructor">sequence constructor</termref> contained 
in the <elcode>xsl:for-each-group</elcode> 
element is evaluated once for each of the <termref def="dt-group">groups</termref>, in 
<termref def="dt-processing-order">processing order</termref>. The sequences that result are concatenated,
in <termref def="dt-processing-order">processing order</termref>, to form the result of the <elcode>xsl:for-each-group</elcode> 
element. Within the <termref def="dt-sequence-constructor">sequence constructor</termref>, the
<termref def="dt-context-item">context item</termref> is 
the <termref def="dt-initial-item">initial item</termref> of the relevant group, the 
<termref def="dt-context-position">context position</termref> is
the position of this item among
the sequence of initial items (one item for each group) 
arranged in <termref def="dt-processing-order">processing order</termref> of the groups, 
the <termref def="dt-context-size">context size</termref> is the number of groups,
the <termref def="dt-current-group">current group</termref>
is the <termref def="dt-group">group</termref> being processed,
 <phrase diff="add" at="Q">and the <termref def="dt-current-grouping-key">current grouping key</termref>
 is the grouping key for that group. If the <elcode>xsl:for-each-group</elcode> instruction uses the
 <code>group-starting-with</code> or <code>group-ending-with</code> attributes, then the current grouping
 key is the empty sequence.</phrase>
This has the effect that 
within the <termref def="dt-sequence-constructor">sequence constructor</termref>, a call on <code>position()</code> takes 
successive values <code>1, 2, ... last()</code>.</p>

<p diff="add" at="ZA">During the evaluation of a 
<termref def="dt-stylesheet-function">stylesheet function</termref>, the 
<termref def="dt-current-group">current group</termref> and 
<termref def="dt-current-grouping-key">current grouping key</termref> are set to the empty sequence, and revert to 
their previous values on completion of evaluation of the stylesheet function.</p>

<p>On completion of the evaluation of the <elcode>xsl:for-each-group</elcode> instruction, the
<termref def="dt-current-group">current group</termref> <phrase diff="add" at="Q"> and 
<termref def="dt-current-grouping-key">current grouping key</termref></phrase> revert to their previous value.</p>

			</div2>
			<div2 id="grouping-examples">
				<head>Examples of Grouping</head>
				
				<example><head>Grouping Nodes based on Common Values</head>
					<p>The following example groups a list of nodes based on common values. The resulting
groups are numbered but unsorted, and a total is calculated for each group. </p>
					<p>Source XML document:</p>
					<eg><![CDATA[<cities>
  <city name="Milano"  country="Italia"      pop="5"/>
  <city name="Paris"   country="France"      pop="7"/>
  <city name="Mnchen" country="Deutschland" pop="4"/>
  <city name="Lyon"    country="France"      pop="2"/>
  <city name="Venezia" country="Italia"      pop="1"/>
</cities>]]></eg>
					<p>More specifically, the aim is to produce a four-column table,
    containing one row for each distinct country. The four columns are to contain
    first, a sequence number giving the number of the row;
    second, the name of the country, third, a comma-separated 
    alphabetical list of the city names within that
    country, and fourth, the sum of the <code>pop</code> attribute for
    the cities in that country.</p>
					<p>Desired output:</p>
					<eg><![CDATA[<table>
  <tr>
    <th>Position</th>
    <th>Country</th>
    <th>List of Cities</th>
    <th>Population</th>
  </tr>
  <tr>
    <td>1</td>
    <td>Italia</td>
    <td>Milano, Venezia</td>
    <td>6</td>
  </tr>
  <tr>
    <td>2</td>
    <td>France</td>
    <td>Lyon, Paris</td>
    <td>9</td>
  </tr>  
  <tr>
    <td>3</td>
    <td>Deutschland</td>
    <td>Mnchen</td>
    <td>4</td>
  </tr>  
</table>]]></eg>
					<p>Solution:</p>
					<eg><![CDATA[<table xsl:version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <tr>
    <th>Position</th>
    <th>Country</th>
    <th>City List</th>
    <th>Population</th>
  </tr>
  <xsl:for-each-group select="cities/city" group-by="@country">
    <tr>
      <td><xsl:value-of select="position()"/></td>
      <td><xsl:value-of select="@country"/></td>
      <td>
        <xsl:value-of select="current-group()/@name" separator=", "/>
      </td>
      <td><xsl:value-of select="sum(current-group()/@pop)"/></td>
    </tr>
  </xsl:for-each-group>
</table>]]></eg>
				</example>
<!--
				<example>
					<p>The following example uses the same source document, this time
	 grouping the cities according to the initial letter of the city name. The groups
	 are sorted, and the result includes a count of the nodes within the group.
	 The heading contains a count of the number of groups:</p>
					<p>Desired output:</p>
					<eg><![CDATA[<html>
  <body>
    <h2>L (1)</h2><p>Lyon</p>
    <h2>M (2)</h2><p>Milano</p><p>Mnchen</p>
    <h2>P (1)</h2><p>Paris</p>
    <h2>V (1)</h2><p>Venezia</p>
  </body>
    </html>]]></eg>
					<p>Solution:</p>
					<eg><![CDATA[<html xsl:version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <body>
    <xsl:for-each-group select="cities/city" group-by="substring(@name,1,1)">
      <xsl:sort select="current-grouping-key()"/>
      <h2>
        <xsl:value-of select="upper-case(current-grouping-key())"/>
        <xsl:text> (</xsl:text>
        <xsl:value-of select="count(current-group())"/>
        <xsl:text>)</xsl:text>
      </h2>
      <xsl:for-each select="current-group()">
        <p><xsl:value-of select="@name"/></p>
      </xsl:for-each>
    </xsl:for-each-group>
  </body>
</html>]]></eg>
				</example>
-->	


				<example>
				<head>A Composite Grouping Key</head>
				<p>Sometimes it is necessary to use a composite grouping key: for example, suppose the source document 
				is similar to the one used in the previous examples, but allows multiple entries for the same country 
				and city, such as:</p>
				
<eg><![CDATA[<cities>
  <city name="Milano"  country="Italia"  year="1950"   pop="5.23"/>
  <city name="Milano"  country="Italia"  year="1960"   pop="5.29"/>  
  <city name="Padova"  country="Italia"  year="1950"   pop="0.69"/>
  <city name="Padova"  country="Italia"  year="1960"   pop="0.93"/>    
  <city name="Paris"   country="France"  year="1951"   pop="7.2"/>
  <city name="Paris"   country="France"  year="1961"   pop="7.6"/>
</cities>]]></eg>

<p>Now suppose we want to list the average value of <code>@pop</code> for each (country, name) combination.
One way to handle this is to concatenate the parts of the key, for example 
<code>&lt;xsl:for-each-group select="concat(@country, '/', @name)"&gt;</code>. A more flexible solution
is to nest one <elcode>xsl:for-each-group</elcode> element directly inside another:</p>

<eg><![CDATA[<xsl:for-each-group select="cities/city" group-by="@country">
  <xsl:for-each-group select="current-group()" group-by="@name">
    <p><xsl:value-of select="@name"/>, <xsl:value-of select="@country"/>:
        <xsl:value-of select="avg(current-group()/@pop)"/></p>
  </xsl:for-each-group>
</xsl:for-each-group>]]></eg>

<p>The two approaches are not precisely equivalent. If the code were changed to output the
value of <code>position()</code> alongside <code>@name</code> then the first approach (a single <elcode>xsl:for-each-group</elcode>
element with a compound key) would number the groups (1, 2, 3), while the second approach (two nested
<elcode>xsl:for-each-group</elcode> elements) would number them (1, 2, 1).</p>

</example>

			
				<example><head>Identifying a Group by its Initial Element</head>
					<p>The next example identifies a group not by the presence of a common value, but rather 
 by adjacency in document order. A group consists of an <code>h2</code> element,
 followed by all the <code>p</code> elements up to the next <code>h2</code> element.</p>
					<p>Source XML document:</p>
					<eg><![CDATA[<body>
  <h2>Introduction</h2>
  <p>XSLT is used to write stylesheets.</p>
  <p>XQuery is used to query XML databases.</p>
  <h2>What is a stylesheet?</h2>
  <p>A stylesheet is an XML document used to define a transformation.</p>
  <p>Stylesheets may be written in XSLT.</p>
  <p>XSLT 2.0 introduces new grouping constructs.</p>
</body>]]></eg>
					<p>Desired output:</p>
					<eg><![CDATA[<chapter>
  <section title="Introduction">
    <para>XSLT is used to write stylesheets.</para>
    <para>XQuery is used to query XML databases.</para>
  </section> 
  <section title="What is a stylesheet?">
    <para>A stylesheet is an XML document used to define a transformation.</para>
    <para>Stylesheets may be written in XSLT.</para>
    <para>XSLT 2.0 introduces new grouping constructs.</para>
  </section>
</chapter>]]></eg>
					<p>Solution:</p>
					<eg><![CDATA[<xsl:template match="body">
  <chapter>
	<xsl:for-each-group select="*" group-starting-with="h2"	>
	  <section title="{self::h2}">
	    <xsl:for-each select="current-group()[self::p]">
	      <para><xsl:value-of select="."/></para>
	    </xsl:for-each> 
	  </section>
	</xsl:for-each-group>
  </chapter>
</xsl:template>]]></eg>
					<p>The use of <code>title="{self::h2}"</code> rather than <code>title="{.}"</code> is
 to handle the case where the first element is not an <code>h2</code> element.</p>
				</example>
 
				<example><head>Identifying a Group by its Final Element</head>
					<p>The next example illustrates how a group of related elements can be identified
by the last element in the group, rather than the first. Here the absence of the attribute
<code>continued="yes"</code> indicates the end of the group.</p>
					<p>Source XML document:</p>
					<eg><![CDATA[<doc>
  <page continued="yes">Some text</page>
  <page continued="yes">More text</page>    
  <page>Yet more text</page>
  <page continued="yes">Some words</page>
  <page continued="yes">More words</page>    
  <page>Yet more words</page>        
</doc>]]></eg>
					<p>Desired output:</p>
					<eg><![CDATA[<doc>
  <pageset>
    <page>Some text</page>
    <page>More text</page>    
    <page>Yet more text</page>
  </pageset>
  <pageset>
    <page>Some words</page>
    <page>More words</page>    
    <page>Yet more words</page>
  </pageset>
</doc>]]></eg>
					<p>Solution:</p>
					<eg><![CDATA[<xsl:template match="doc">
<doc>
  <xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]">
    <pageset>
      <xsl:for-each select="current-group()">
        <page><xsl:value-of select="."/></page>
      </xsl:for-each> 
    </pageset>
  </xsl:for-each-group>
</doc>
</xsl:template>]]></eg>
				</example>
				
				<example><head>Adding an Element to Several Groups</head>
				<p>The next example shows how an item can be added to multiple groups. Book titles
				will be added to one group for each indexing term marked up within the title.</p>
				
				<p>Source XML document:</p>
<eg><![CDATA[<titles>
    <title>A Beginner's Guide to <ix>Java</ix></title>
    <title>Learning <ix>XML</ix></title>
    <title>Using <ix>XML</ix> with <ix>Java</ix></title>
</titles>]]></eg>

<p>Desired output:</p>
<eg><![CDATA[<h2>Java</h2>
    <p>A Beginner's Guide to Java</p>
    <p>Using XML with Java</p>
<h2>XML</h2>
    <p>Learning XML</p>
    <p>Using XML with Java</p>]]></eg>
    
<p>Solution:</p>

<eg><![CDATA[<xsl:template match="titles">
    <xsl:for-each-group select="title" group-by="ix">
      <h2><xsl:value-of select="current-grouping-key()"/></h2>
      <xsl:for-each select="current-group()">
        <p><xsl:value-of select="."/></p>
      </xsl:for-each>
    </xsl:for-each-group>
</xsl:template>]]></eg>
    
</example>
    
				<example><head>Grouping Alternating Sequences of Elements</head>
					<p>In the final example, the membership of a node within a group is based both on adjacency
 of the nodes in document order, and on common values. In this case, the grouping key
  is a boolean condition, true or false, so the effect is that a grouping
 establishes a maximal sequence of nodes for which the condition is true, followed by a maximal
 sequence for which it is false, and so on.</p>
					<p>Source XML document:</p>
					<eg><![CDATA[<p>Do <em>not</em>:
    <ul>
    <li>talk,</li>
    <li>eat, or</li>
    <li>use your mobile telephone</li>
    </ul>
    while you are in the cinema.</p>]]></eg>
					<p>Desired output:</p>
					<eg><![CDATA[<p>Do <em>not</em>:</p>
    <ul>
    <li>talk,</li>
    <li>eat, or</li>
    <li>use your mobile telephone</li>
    </ul>
    <p>while you are in the cinema.</p>]]></eg>
					<p>Solution:</p>
					<p>This requires creating a <code>p</code> element around the maximal sequence
    of sibling nodes that does not include a <code>ul</code> or <code>ol</code> element.</p>
					<p>This can be done by using <code>group-adjacent</code>, with a grouping key that is true
    if the element is a <code>ul</code> or <code>ol</code> element, and false otherwise:</p>
					<eg><![CDATA[<xsl:template match="p">
    <xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol">
        <xsl:choose>
            <xsl:when test="current-grouping-key()">
                <xsl:copy-of select="current-group()"/>  
            </xsl:when>
            <xsl:otherwise>
                <p>
                    <xsl:copy-of select="current-group()"/>
                </p>
            </xsl:otherwise>  
        </xsl:choose>
    </xsl:for-each-group>
</xsl:template>]]></eg>
				</example>
			</div2>
		</div1>
		<div1 id="regular-expressions">
			<head>Regular Expressions</head>
			<p>The <termref def="dt-core-function">core function</termref> library for XPath 2.0 defines three functions that make use of
regular expressions:</p>
			<ulist>
				<item>
					<p>
						<xfunction>matches</xfunction> returns a boolean result that indicates whether or not a
string matches a given regular expression.</p>
				</item>
				<item>
					<p>
						<xfunction>replace</xfunction> takes a string as input and returns a string obtained by 
replacing all substrings that match a given regular expression with a replacement string.</p>
				</item>
				<item>
					<p>
						<xfunction>tokenize</xfunction> returns a sequence of strings formed by breaking a supplied
input string at any separator that matches a given regular expression.</p>
				</item>
			</ulist>
			<p>These functions are described in <bibref ref="xpath-functions"/>.</p>
			<p>For more complex string processing than is possible using these functions, XSLT provides an
instruction <elcode>xsl:analyze-string</elcode>, which is defined in this section.</p>
			<p>The regular expressions used by this instruction, and the flags that control the interpretation
of these regular expressions, <rfc2119>must</rfc2119> conform to the syntax defined in <bibref ref="xpath-functions"/> 
(see <xspecref spec="FO" ref="regex-syntax"/>), which is itself
based on the syntax defined in <bibref ref="xmlschema-2"/>.</p>

<div2 id="analyze-string"><head>The <code>xsl:analyze-string</code> instruction</head>

			<e:element-syntax name="analyze-string">
				<e:in-category name="instruction"/>
				<e:attribute name="select" required="yes">
					<e:data-type name="expression"/>
				</e:attribute>
				<e:attribute name="regex" required="yes">
					<e:attribute-value-template>
						<e:data-type name="string"/>
					</e:attribute-value-template>
				</e:attribute>
				<e:attribute name="flags" required="no">
					<e:attribute-value-template>
						<e:data-type name="string"/>
					</e:attribute-value-template>
				</e:attribute>
				<e:sequence>
					<e:element repeat="zero-or-one" name="matching-substring"/>
					<e:element repeat="zero-or-one" name="non-matching-substring"/>
					<e:element repeat="zero-or-more" name="fallback"/>
				</e:sequence>
				<e:allowed-parents>
					<e:parent-category name="sequence-constructor"/>
				</e:allowed-parents>
			</e:element-syntax>
			<e:element-syntax name="matching-substring">
				<e:model name="sequence-constructor"/>
				<e:allowed-parents>
					<e:parent name="analyze-string"/>
				</e:allowed-parents>
			</e:element-syntax>
			<e:element-syntax name="non-matching-substring">
				<e:model name="sequence-constructor"/>
				<e:allowed-parents>
					<e:parent name="analyze-string"/>
				</e:allowed-parents>
			</e:element-syntax>
			<p>The <elcode>xsl:analyze-string</elcode> instruction takes as input a string (the result of evaluating
			the expression in the <code>select</code>
attribute) and a regular expression (the effective value of the <code>regex</code> attribute).</p>

<p diff="add" at="T">If the result of evaluating the <code>select</code> expression is not a string, it is converted
 to a string by applying the <termref def="dt-function-conversion-rules">function conversion rules</termref>.</p>

			<p>The <code>flags</code> attribute may be used to control the interpretation of the regular expression.
If the attribute is omitted, the effect is the same as supplying a zero-length string. 
This is interpreted in the same
way as the <code>$flags</code> attribute of the functions <xfunction>matches</xfunction>, <xfunction>replace</xfunction>,
and <xfunction>tokenize</xfunction>. <phrase diff="chg" at="P">Specifically, if it contains the letter <code>m</code>, 
the match operates in multiline mode. If it contains the letter <code>s</code>, it operates in dot-all mode.
If it contains the letter <code>i</code>,
it operates in case-insensitive mode. If it contains the letter <code>x</code>, then whitespace
within the regular expression is ignored. For more detailed specifications
of these modes, see <bibref ref="xpath-functions"/> (<xspecref ref="flags" spec="FO"/>).</phrase></p>

<note><p>Because the <code>regex</code> attribute is an attribute value template,
curly brackets within the regular expression must be doubled. For example, to match a sequence of one to
five characters, write <code>regex=".{{1,5}}"</code>. <phrase diff="add" at="Z">For regular expressions
containing many curly brackets it may be more convenient to use a notation such as 
<code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or to use a variable.</phrase></p></note>

<p diff="del" at="ZC">The <elcode>xsl:analyze-string</elcode> instruction may have two child elements: <elcode>xsl:matching-substring</elcode>
and <elcode>xsl:non-matching-substring</elcode>. 
Both elements are optional, and neither may appear more than once. At least one
of them must be present. If both are present, the <elcode>xsl:matching-substring</elcode>
element must come first.</p>

<change diff="add" at="ZC">

<p>The content of the <elcode>xsl:analyze-string</elcode> instruction must take one of the following forms:</p>

<olist>
<item><p>A single <elcode>xsl:matching-substring</elcode> instruction, followed by zero or more
<elcode>xsl:fallback</elcode> instructions</p></item>
<item><p>A single <elcode>xsl:non-matching-substring</elcode> instruction, followed by zero or more
<elcode>xsl:fallback</elcode> instructions</p></item>
<item><p>A single <elcode>xsl:matching-substring</elcode> instruction, 
followed by a single <elcode>xsl:non-matching-substring</elcode> instruction,
followed by zero or more <elcode>xsl:fallback</elcode> instructions</p></item>
</olist>

</change>

<p><error spec="XT" type="static" class="SE" code="1130"><p>It is a 
<termref def="dt-static-error">static error</termref> if the <elcode>xsl:analyze-string</elcode> instruction
contains neither an <elcode>xsl:matching-substring</elcode> nor an
 <elcode>xsl:non-matching-substring</elcode> element.</p></error></p>

<p><phrase diff="chg" at="ZC">Any <elcode>xsl:fallback</elcode> elements among the children of the
 <elcode>xsl:analyze-string</elcode> instruction</phrase>
 are ignored by an XSLT 2.0 processor, but allow fallback behavior to be defined when the stylesheet
is used with an XSLT 1.0 processor operating in forwards-compatible mode.</p>

			<p>This instruction is designed to process all the non-overlapping substrings of the input string that
match the regular expression supplied.</p>

<p><error spec="XT" type="dynamic" class="DE" code="1140"><p>It is a 
<termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the 
<termref def="dt-effective-value">effective value</termref> of the <code>regex</code> attribute 
<error.extra>of the <elcode>xsl:analyze-string</elcode> instruction</error.extra>
does not conform to the <rfc2119>required</rfc2119> syntax for
regular expressions, as specified in <bibref ref="xpath-functions"/>.
If the regular expression is known
statically (for example, if the attribute does not contain any <termref def="dt-expression">expressions</termref> enclosed in curly brackets)
then the processor <rfc2119>may</rfc2119> signal the error as a <termref def="dt-static-error">static error</termref>.
				</p></error>
			</p>
			
<p><error spec="XT" type="dynamic" class="DE" code="1145"><p>It is a 
<termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the 
<termref def="dt-effective-value">effective value</termref> of the <code>flags</code> attribute 
<error.extra>of the <elcode>xsl:analyze-string</elcode> instruction</error.extra>
has a value other than the values defined in <bibref ref="xpath-functions"/>.
If the value of the attribute is known
statically (for example, if the attribute does not contain any <termref def="dt-expression">expressions</termref> enclosed in curly brackets)
then the processor <rfc2119>may</rfc2119> signal the error as a <termref def="dt-static-error">static error</termref>.
				</p></error>
			</p>			
			
			<p>
				<error spec="XT" type="dynamic" class="DE" code="1150"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the 
<termref def="dt-effective-value">effective value</termref> of the <code>regex</code> attribute 
<error.extra>of the <elcode>xsl:analyze-string</elcode> instruction</error.extra>
is a regular expression that matches a zero-length string: or more specifically, if the regular expression <code>$r</code>
and flags <code>$f</code> are such that <code>matches("", $r, $f)</code> returns true.
If the regular expression is known
statically (for example, if the attribute does not contain any <termref def="dt-expression">expressions</termref> enclosed in curly brackets)
then the processor <rfc2119>may</rfc2119> signal the error as a <termref def="dt-static-error">static error</termref>.
				</p></error>
			</p>
			
			
			<p>The <elcode>xsl:analyze-string</elcode> instruction
 starts at the beginning of the input string and attempts to find
the first substring that matches the regular expression. If there are
several matches, the first match is defined to be the one whose starting
position comes first in the string. 
If several alternatives within the regular expression 
both match at the same position in the input string, then the match that is
 chosen is the first alternative that matches. For example, if the
 input string is <code>The quick brown fox jumps</code> and the regular expression
 is <code>jump|jumps</code>, then the match that is chosen is <code>jump</code>. 
 </p>

<p>Having found the first match, the instruction proceeds to find the
second and subsequent matches by repeating the search, starting at the first
character that was not included in the previous match.</p>
			<p>The input string is thus partitioned into a sequence of substrings, some of which 
match the regular expression, others which do not match it. 
Each substring will contain at least one character. 
This sequence of substrings is
processed using the <elcode>xsl:matching-substring</elcode>
and <elcode>xsl:non-matching-substring</elcode> child instructions. A matching substring is
processed using the <elcode>xsl:matching-substring</elcode> element, a non-matching substring
using the <elcode>xsl:non-matching-substring</elcode> element. Each of these elements
takes a sequence constructor as its content. If the element is absent, the effect is the same 
as if it were present with empty content. In processing each substring, the contents of the substring 
will be the <termref def="dt-context-item">context item</termref>
 (as a value of type <code>xs:string</code>); the position of the substring within the
sequence of matching and non-matching substrings will be the <termref def="dt-context-position">context position</termref>; 
and the number of
matching and non-matching substrings will be the <termref def="dt-context-size">context size</termref>.</p>
			<p>If the input is a zero-length string, the number of substrings will be zero,
			so neither the <elcode>xsl:matching-substring</elcode>
nor <elcode>xsl:non-matching-substring</elcode> elements will be evaluated.</p>

</div2>

<div2 id="regex-group"><head>Captured Substrings</head>
			<proto class="xslt" name="regex-group" return-type="xs:string">
				<arg name="group-number" type="xs:integer"/>
			</proto>
			<p><termdef id="dt-current-captured-substrings" term="current captured substrings">While the <elcode>xsl:matching-substring</elcode> instruction is active, a set of 
			<term>current captured substrings</term> is
available, corresponding to the parenthesized sub-expressions of the regular expression.</termdef> These captured
substrings are accessible using the function <function>regex-group</function>. This function takes an
integer argument to identify the group, and returns a string representing the captured substring.</p>

<p>The <var>N</var>th captured substring (where <var>N</var> &gt; 0) is the string matched by the
subexpression contained by the <var>N</var>th left parenthesis in the regex. The zeroeth captured substring
is the string that matches the entire regex. 
This means that the value of <code>regex-group(0)</code> is initially the same as the 
value of <code>.</code> (dot).</p>

<p>The function returns the zero-length string if there is no 
captured substring with the relevant number. This can occur for a number of reasons:</p>
<olist>
<item><p>The number is negative.</p></item>
<item><p>The regular expression does not contain a parenthesized sub-expression with the given number.</p></item>
<item><p>The parenthesized sub-expression exists, and did not match any part of the input string.</p></item>
<item><p>The parenthesized sub-expression exists, and matched a zero-length substring of the input string.</p></item>
</olist>

<p>The set of captured substrings is a context variable with dynamic scope. It is initially an empty sequence.
During the evaluation of an <elcode>xsl:matching-substring</elcode> instruction it is set to the sequence of matched substrings
for that regex match. During the evaluation of an <elcode>xsl:non-matching-substring</elcode> instruction or a 
<termref def="dt-pattern">pattern</termref> or
a <termref def="dt-stylesheet-function">stylesheet function</termref> it is set to an empty sequence. 
On completion of an instruction that changes the value, the variable reverts to its previous value.</p>
			
<p>The value of the <termref def="dt-current-captured-substrings">current captured substrings</termref>
is unaffected through calls of <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>, 
<elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>, or by expansion of named
<termref def="dt-attribute-set">attribute sets</termref>.</p>

</div2>
			<div2 id="regex-examples">
				<head>Examples of Regular Expression Matching</head>
				
				<example><head>Replacing Characters by Elements</head>
					<p>Problem: replace all newline characters in the <code>abstract</code> element
					 by empty <code>br</code> elements:</p>
					<p>Solution:</p>
					<eg><![CDATA[<xsl:analyze-string select="abstract" regex="\n">
  <xsl:matching-substring>
    <br/>
  </xsl:matching-substring>
  <xsl:non-matching-substring>
    <xsl:value-of select="."/>
  </xsl:non-matching-substring>
</xsl:analyze-string>]]></eg>
				</example>
				
				<example><head>Recognizing non-XML Markup Structure</head>
					<p>Problem: replace all occurrences of <code>[...]</code> in the 
					<code>body</code> by <code>cite</code> elements, retaining the content
					between the square brackets as the content of the new element.</p>

					<p>Solution:</p>
					<eg><![CDATA[<xsl:analyze-string select="body" regex="\[(.*?)\]">
  <xsl:matching-substring>
    <cite><xsl:value-of select="regex-group(1)"/></cite>
  </xsl:matching-substring>
  <xsl:non-matching-substring>
    <xsl:value-of select="."/>
  </xsl:non-matching-substring>
</xsl:analyze-string>]]></eg>

<p>Note that this simple approach fails if the <code>body</code> element contains
markup that needs to be retained. In this case it is necessary to apply the regular expression
processing to each text node individually. If the <code>[...]</code> constructs span multiple
text nodes (for example, because there are elements within the square brackets) then it probably
becomes necessary to make two or more passes over the data.</p>
				</example>
				
				<example><head>Parsing a Date</head>
					<p>Problem: the input string contains a date such as <code>23 March 2002</code>.
Convert it to the form <code>2002-03-23</code>.</p>
					<p>Solution (with no error handling if the input format is incorrect):</p>
					<eg><![CDATA[<xsl:variable name="months" select="'January', 'February', 'March', ..."/>

<xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})">
    <xsl:matching-substring>
        <xsl:number value="regex-group(3)" format="0001"/>          
        <xsl:text>-</xsl:text>
        <xsl:number value="index-of($months, regex-group(2))" format="01"/>
        <xsl:text>-</xsl:text>
        <xsl:number value="regex-group(1)" format="01"/>
    </xsl:matching-substring>
</xsl:analyze-string>]]></eg>

<p>Note the use of <code>normalize-space</code> to simplify the work done by the regular expression,
and the use of doubled curly brackets because the <code>regex</code> attribute is an attribute value
template.</p>
				</example>
			</div2>
		</div1>
		<div1 id="add-func">
			<head>Additional Functions</head>
			<p>This section describes XSLT-specific additions to the 
      <termref def="dt-core-function">core function</termref> library.  
      Some of these additional functions also make use of
information specified by <termref def="dt-declaration">declarations</termref>
in the stylesheet; this section also describes these
declarations.</p>
			
			<div2 id="document" diff="add" at="P">
				<head>Multiple Source Documents</head>
				
							
				<proto class="xslt" name="document" return-type="node()" returnSeq="yes">
					<arg name="uri-sequence" type="item()" seq="yes" emptyOk="yes"/>
				</proto>
				<proto class="xslt" name="document" return-type="node()" returnSeq="yes">
					<arg name="uri-sequence" type="item()" seq="yes" emptyOk="yes"/>
					<arg name="base-node" type="node()"/>
				</proto>

<p>The <function>document</function> function allows
access to XML documents identified by a URI.</p>

<p>The first argument contains a sequence of URI references. The second argument, if present, is
a node whose base URI is used to resolve any relative URI references contained in the first argument.</p>

<p>A sequence of absolute URI references is obtained as follows.</p>

<ulist>
<item><p>For an item in <code>$uri-sequence</code> that is an instance of <code>xs:string</code>,
<code>xs:anyURI</code>, or <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>, the value is cast to <code>xs:anyURI</code>. 
If the resulting URI reference is an absolute URI reference then it is used <emph>as is</emph>.
If it is a relative URI reference, then it is resolved against the base URI of <code>$base-node</code>
if supplied, or against the base URI from the static context otherwise 
(this will usually be the base URI of the stylesheet module).
A relative URI is resolved against a base URI using
the rules defined in <bibref ref="RFC3986"/>.</p></item>

<item><p>For an item in <code>$uri-sequence</code> that is a node, 
the node is <termref def="dt-atomization">atomized</termref>. 
The result <rfc2119>must</rfc2119> be a sequence whose
items are all instances of <code>xs:string</code>, <code>xs:anyURI</code>, or 
<phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>. Each of these
values is cast to <code>xs:anyURI</code>, and
if the resulting URI reference is an absolute URI reference then it is used <emph>as is</emph>. 
If it is a relative URI reference, then it is resolved against the base URI of <code>$base-node</code>
if supplied, or against the base URI of the node that contained it otherwise.</p></item>

</ulist>

<note><p>The XPath rules for function calling ensure that it is a type error if the supplied value
of the second argument is anything other than a single node. If 
<termref def="dt-compatibility-mode">XPath 1.0 compatibility mode</termref> is enabled, then
a sequence of nodes may be supplied, and the first node in the sequence will be used.</p></note>

<p>Each of these absolute URI references is then processed as follows. Any
fragment identifier that is present in the URI reference is removed, and the resulting absolute URI 
is cast to a string and then
passed to the <xfunction>doc</xfunction> function defined in <bibref ref="xpath-functions"/>. This returns
a document node. If an error occurs during evaluation of the <xfunction>doc</xfunction> function,
the processor <rfc2119>may</rfc2119> either signal this error in the normal way, or <rfc2119>may</rfc2119> recover by ignoring the failure,
in which case the failing URI will not contribute any nodes to the result of the
<function diff="add" at="R">document</function> function.</p>

<p>If the URI reference contained no fragment identifier, then this document node is included in
the sequence of nodes returned by the <function>document</function> function.</p>

<p>If the URI reference contained a fragment identifier, then the fragment identifier is interpreted
according to the rules for the media type of the resource <phrase diff="add" at="U">representation</phrase>
identified by the URI, and is used to select 
zero or more nodes that are descendant-or-self nodes of the returned document node. 
As described in <specref ref="initiating"/>, the media type is available
as part of the evaluation context for a transformation.</p>
 
<p><error spec="XT" type="dynamic" class="RE" code="1160"><p>When a URI reference
<error.extra>supplied to the <function>document</function> function</error.extra>
contains a fragment identifier,
it is a <termref def="dt-recoverable-error">recoverable dynamic error</termref> if the media type is not one that is recognized by the
processor, or if the fragment identifier does not conform to the rules for fragment identifiers
for that media type, or if the fragment identifier selects something other than a sequence of
nodes (for example, if it selects a range of characters within a text node).
<error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to ignore the fragment
identifier and return the document node.</error.action></p></error> The set of media types recognized
by a processor is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>

<imp-def-feature>The set of media types recognized by the processor, for the purpose of
interpreting fragment identifiers in URI references passed to the <function>document</function>
function, is implementation-defined.</imp-def-feature>

<note><p>The recovery action here is different from XSLT 1.0</p></note>

<p>The sequence of nodes returned by the function is in document order, with no duplicates.
This order has no necessary relationship to the order in which URIs were supplied
 in the <code>$uri-sequence</code> argument.</p>



<note><p>One effect of these rules is that unless XML entities or <code>xml:base</code> are used,
and provided that the base URI of the stylesheet module is known,
<code>document("")</code> refers to the document node of the containing stylesheet module
(the definitive rules are in <phrase diff="chg" at="X"><bibref ref="RFC3986"/></phrase>).
The XML resource containing the stylesheet module is processed exactly as if
it were any other XML document, for example there is no special recognition 
of <elcode>xsl:text</elcode> elements, and no special treatment of comments 
and processing instructions.</p></note>

			</div2>
			
			
			<div2 id="unparsed-text">
				<head>Reading Text Files</head>
				<proto class="xslt" name="unparsed-text" return-type="xs:string" returnEmptyOk="yes">
					<arg name="href" type="xs:string" emptyOk="yes"/>
				</proto>
				<proto class="xslt" name="unparsed-text" return-type="xs:string" returnEmptyOk="yes">
					<arg name="href" type="xs:string" emptyOk="yes"/>
					<arg name="encoding" type="xs:string"/>
				</proto>
				<p diff="chg" at="O">The <function>unparsed-text</function>
					function reads an external 
					resource (for example, a file) and returns
                    its contents as a string.</p>
				<p>The <code>$href</code> argument <rfc2119>must</rfc2119> be
				 <phrase diff="chg" at="Q">a string in the form of a URI</phrase>. The URI <rfc2119>must</rfc2119> contain no fragment identifier, and <rfc2119>must</rfc2119>
identify a resource that can be read as text. If the URI is a relative URI, then
it is resolved relative to the base URI from the static context.</p>

<p>If the value of the <code>$href</code> argument is an empty sequence, 
the function returns an empty sequence.</p>

<note><p>If a different
base URI is appropriate (for example, when resolving a relative URI read from a source document) then
the relative URI should be resolved using the <xfunction>resolve-uri</xfunction> function
before passing it to the <function>unparsed-text</function> function.</p></note>

				<p>The <code>$encoding</code> argument, if present, is the name of an encoding. 
 The values for this attribute follow
the same rules as for the <code>encoding</code> attribute in an XML declaration. The only values which
every <termref def="dt-implementation">implementation</termref> is <rfc2119>required</rfc2119> to recognize are
 <code>utf-8</code> and <code>utf-16</code>.</p>

 <imp-def-feature>The set of encodings recognized by the <function>unparsed-text</function> function,
other than <code>utf-8</code> and <code>utf-16</code>, is
 <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>

<p>The encoding of the external resource is determined as follows:</p>

<olist>
<item><p>external encoding information is used if available, otherwise</p></item>
<item><p>if the media type of the resource is <code>text/xml</code> or <code>application/xml</code>
(see <bibref ref="RFC2376"/>),
 or if it matches the conventions <code>text/*+xml</code> or <code>application/*+xml</code>  
(see <bibref ref="RFC3023"/> <phrase diff="add" at="ZA">and/or its successors</phrase>), 
then the encoding is recognized as specified in <bibref ref="REC-xml"/>, otherwise</p></item>
<item><p>the value of the <code>$encoding</code> argument is used if present, otherwise</p></item>
<item><p diff="add" at="ZB">the processor <rfc2119>may</rfc2119> use <termref def="dt-implementation-defined">implementation-defined</termref>
heuristics to determine the likely encoding, otherwise</p></item>
<item><p>UTF-8 is assumed.</p></item>
</olist>

<imp-def-feature>If no encoding is specified on a call to the <function>unparsed-text</function> function,
the processor <rfc2119>may</rfc2119> use <termref def="dt-implementation-defined">implementation-defined</termref>
heuristics to determine the likely encoding.</imp-def-feature>

<note><p>The above rules are chosen for consistency with <bibref ref="xinclude"/>. 
Files with an XML media type are treated specially because there
are use cases for this function where the retrieved text is to be included as unparsed XML within
a CDATA section of a containing document, and because processors are likely to be able to reuse
the code that performs encoding detection for XML external entities.</p></note>



<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="1170"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if a URI 
<error.extra>supplied in the first argument to the <function>unparsed-text</function> function</error.extra>
<phrase diff="add" at="ZA">contains a fragment identifier,</phrase> or if it cannot be used to retrieve a resource 
containing text.</p></error>
				</p>


				<p diff="chg" at="Y">
					<error spec="XT" type="dynamic" class="DE" code="1190"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if a resource 
<error.extra>retrieved using the <function>unparsed-text</function> function</error.extra>
contains octets that cannot be decoded into Unicode characters
using the specified encoding, or if the resulting characters are not permitted XML characters.
 This includes the case where the
 <termref def="dt-processor">processor</termref> does not support
the requested encoding.</p></error>
				</p>
				<p>
					<error spec="XT" type="dynamic" class="DE" code="1200"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if the second argument of the <function>unparsed-text</function> function is omitted and the
 <termref def="dt-processor">processor</termref> cannot infer the encoding using
external information and the encoding is not UTF-8.</p></error>

				</p>
				<p>The result is a string containing the text of the resource
retrieved using the URI.</p>
				<note>
					<p>If the text file contains characters such as <code>&lt;</code> and <code>&amp;</code>, 
these will typically be output as <code>&amp;lt;</code> and <code>&amp;amp;</code> when the string is
written to a <termref def="dt-final-result-tree">final result tree</termref> and 
serialized as XML or HTML. If these characters actually
represent markup (for example, if the text file contains HTML), then the stylesheet can 
attempt to write them as markup to the output file using the <code>disable-output-escaping</code>
attribute of the <elcode>xsl:value-of</elcode> instruction (see <specref ref="disable-output-escaping"/>). 
Note, however, that implementations are not required to support this feature.</p>
				</note>
				<example><head>Copying Unparsed HTML Boilerplate</head>
					<p>This example attempts to read an HTML file and copy it, as HTML, to the serialized
output file:</p>
					<eg><![CDATA[<xsl:output method="html"/>

<xsl:template match="/">
  <xsl:value-of select="unparsed-text('header.html', 'iso-8859-1')"
                disable-output-escaping="yes"/>
  <xsl:apply-templates/>
  <xsl:value-of select="unparsed-text('footer.html', 'iso-8859-1')"
                disable-output-escaping="yes"/>
</xsl:template>
]]></eg>
				</example>
				<example><head>Splitting an Input File into a Sequence of Lines</head>
				<p>Often it is necessary to split a text file into a sequence of lines, representing each line
				as a string. This can be achieved by using the <function>unparsed-text</function> function
				in conjunction with the XPath <xfunction>tokenize</xfunction> function. For example:</p>
<eg><![CDATA[<xsl:for-each select="tokenize(unparsed-text($in), '\r?\n')">
 ...
</xsl:for-each>]]></eg>
 <p>Note that the <function>unparsed-text</function> function does not normalize line endings. This
 example has therefore been written to recognize both Unix and Windows conventions for end-of-line,
 namely a single newline (#x0A) character or a carriage return / line feed pair (#x0D #x0A).</p>
 </example>



 <p>Because errors in evaluating the <function>unparsed-text</function> function are 
 non-recoverable, two functions are provided to allow a stylesheet to determine whether a call
 with particular arguments would succeed:</p>

<change diff="chg" at="Z">

				<proto class="xslt" name="unparsed-text-available" return-type="xs:boolean">
					<arg name="href" type="xs:string" emptyOk="yes"/>
				</proto>
				<proto class="xslt" name="unparsed-text-available" return-type="xs:boolean">
					<arg name="href" type="xs:string" emptyOk="yes"/>
					<arg name="encoding" type="xs:string" emptyOk="yes"/>
				</proto>
</change>

<p>The <function>unparsed-text-available</function> function determines whether a call on 
the <function>unparsed-text</function> function with identical arguments would 
<phrase diff="add" at="Z">return a string</phrase>.</p>

<p diff="add" at="Z">If the first argument is an empty sequence, the function returns false.
If the second argument is an empty sequence, the function behaves as if the second argument
were omitted.</p>

<p>In other cases, the function returns true if a call on <function>unparsed-text</function> with the same
arguments would succeed, and false if a call on <function>unparsed-text</function> with
the same arguments would fail with a non-recoverable dynamic error.</p>

<note><p>This requires that the <function>unparsed-text-available</function> function 
should actually attempt to read the resource identified by the URI, and check that it is correctly
encoded and contains no characters that are invalid in XML. Implementations may avoid the cost
of repeating these checks for example by caching the validated contents of the resource, to 
anticipate a subsequent call on the <function>unparsed-text</function> function.
Alternatively, implementations may be able to rewrite an expression such as
<code>if (unparsed-text-available(A)) then unparsed-text(A) else ...</code> to
generate a single call internally.</p></note>

<p diff="add" at="ZA">The functions <function>unparsed-text</function> and 
<function>unparsed-text-available</function> have the same requirement for stability
as the functions <xfunction>doc</xfunction> and <xfunction>doc-available</xfunction> defined
in <bibref ref="xpath-functions"/>. This means that unless the user has explicitly stated a requirement
for a reduced level of stability, either of these functions if called twice with the same
arguments during the course of a transformation <rfc2119>must</rfc2119> return the same results
each time; moreover, the results
of a call on <function>unparsed-text-available</function> <rfc2119>must</rfc2119> be consistent with the results of
a subsequent call on <function>unparsed-text</function> with the same arguments.</p>


			</div2>
			<div2 id="key">
				<head>Keys</head>
				<p>Keys provide a way to work with documents that contain an implicit
cross-reference structure. They make it easier to locate the nodes within a document
that have a given value for a given attribute or child element, and they provide
a hint to the implementation that certain access paths in the document need to
be efficient.</p>
				<div3 id="xsl-key">
					<head>The <elcode>xsl:key</elcode> Declaration</head>
					<e:element-syntax name="key">
						<e:in-category name="declaration"/>
						<e:attribute name="name" required="yes">
							<e:data-type name="qname"/>
						</e:attribute>
						<e:attribute name="match" required="yes">
							<e:data-type name="pattern"/>
						</e:attribute>
						<e:attribute name="use">
							<e:data-type name="expression"/>
						</e:attribute>
						<e:attribute name="collation" required="no">
							<e:data-type name="uri"/>
						</e:attribute>
				        <e:model name="sequence-constructor"/>
						<e:allowed-parents>
							<e:parent name="stylesheet"/>
							<e:parent name="transform"/>
						</e:allowed-parents>
					</e:element-syntax>


<p>The <elcode>xsl:key</elcode>	<termref def="dt-declaration">declaration</termref> 
is used to declare <termref def="dt-key">keys</termref>.  The
<code>name</code> attribute specifies the name of the key.  The value
of the <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, which is expanded as described
in <specref ref="qname"/>. The <code>match</code> attribute is a <nt def="NT-Pattern">Pattern</nt>; an <elcode>xsl:key</elcode> element 
applies to all nodes that match the pattern
specified in the <code>match</code> attribute.</p>

<p><termdef id="dt-key" term="key">A <term>key</term> is defined as
a set of <elcode>xsl:key</elcode> declarations in the <termref def="dt-stylesheet">stylesheet</termref>
 that share the same name.</termdef></p>

<p>The value of the key may be specified either using the <code>use</code> attribute or
by means of the contained <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>

<p><error spec="XT" type="static" class="SE" code="1205"><p>It is 
a <termref def="dt-static-error">static error</termref>
if an <elcode>xsl:key</elcode> declaration has a <code>use</code> attribute and has non-empty content, or
if it has empty content and no <code>use</code> attribute.</p></error></p>

<p>If the <code>use</code> attribute is present, its value is
an <termref def="dt-expression">expression</termref> specifying the
values of the key. The expression will be evaluated with the node that
matches the pattern as the context node. 
<!-- TODO: what about context position and size? Use the concept of "singleton focus" -->
The result of evaluating the
expression is <termref def="dt-atomization">atomized</termref>.</p>

<p>Similarly, if a <termref def="dt-sequence-constructor">sequence constructor</termref>
is present, it is used to determine the values of the key. The sequence constructor will be evaluated
with the node that matches the pattern as the context node. <phrase diff="add" at="U">The result of evaluating the
sequence constructor is <termref def="dt-atomization">atomized</termref>.</phrase></p>

<p><termdef id="dt-key-specifier" term="key specifier">The expression in
 the <code>use</code> attribute and the 
<termref def="dt-sequence-constructor">sequence constructor</termref> within
an <elcode>xsl:key</elcode> declaration are
referred to collectively as the <term>key specifier</term>. The key specifier determines
the values that may be used to find a node using this <termref def="dt-key">key</termref>.</termdef></p> 

 <note><p>There is no requirement that all the values of a key should
 have the same type.</p></note>

<p>The presence of an <elcode>xsl:key</elcode> declaration makes it
easy to find a node that matches the <code>match</code> pattern if any of the values
of the <phrase diff="chg" at="R"><termref def="dt-key-specifier">key specifier</termref></phrase> 
(when applied to that node) are known. It also provides
a hint to the implementation that access to the nodes by means of these values needs
to be efficient (many implementations are likely to
construct an index or hash table to achieve this).
Note that the <phrase diff="chg" at="R"><termref def="dt-key-specifier">key specifier</termref></phrase> 
in general returns a sequence of values, and any one
of these may be used to locate the node.</p>

<note diff="add" at="Z"><p>An <elcode>xsl:key</elcode> declaration is not bound to a specific source
document. The source document to which it applies is determined only when the <function>key</function>
function is used to locate nodes using the key. Keys can be used to locate nodes within any source document
(including temporary trees), but each use of the <function>key</function> function searches one document 
only.</p></note> 

<p>The optional <code>collation</code> attribute is used only when 
 deciding
 whether two strings are equal for the purposes of key matching. Specifically, two values <code>$a</code>
 and <code>$b</code> are considered equal if the result of the function call
  <code>compare($a, $b, $collation)</code> is zero. 
  The effective collation for an <elcode>xsl:key</elcode> declaration is the 
  collation specified in its <code>collation</code> attribute if present,
  <phrase diff="add" at="Y">resolved against the base URI of the <elcode>xsl:key</elcode> element</phrase>,
  or the
   <termref def="dt-default-collation">default collation</termref> that is in scope for the
   <elcode>xsl:key</elcode> declaration otherwise; the effective collation must be the same for all the 
   <elcode>xsl:key</elcode> declarations making up a <termref def="dt-key">key</termref>.</p>

<p diff="add" at="V">
						<error spec="XT" type="static" class="SE" code="1210"><p>It is a static error if 
            the <elcode>xsl:key</elcode> declaration
has a <code>collation</code> attribute whose value
 <phrase diff="add" at="Y">(after resolving against the base URI)</phrase> 
 is not a URI recognized by the implementation
as referring to a collation.</p></error></p>  
  
	<p diff="chg" at="U">
						<error spec="XT" type="static" class="SE" code="1220"><p>It is a static error if there are 
            several <elcode>xsl:key</elcode> declarations
in the <termref def="dt-stylesheet">stylesheet</termref> with the same key name and different 
effective collations. Two collations are the same if their URIs are equal under the rules
for comparing <code>xs:anyURI</code> values, or if the implementation can determine that they
are different URIs referring to the same collation.</p></error></p>  
  

					<p>It is possible to have:</p>
					<ulist>
						<item>
							<p>multiple <elcode>xsl:key</elcode> declarations with the same name;</p>
						</item>
						<item>
							<p>a node that matches the <code>match</code> patterns of several different
							 <elcode>xsl:key</elcode> declarations<phrase diff="add" at="M">, whether these have the
							 same key name or different key names;</phrase></p>
						</item>
						<item>
							<p>a node that returns more than one value from its <phrase diff="chg" at="R"><termref def="dt-key-specifier">key specifier</termref></phrase>;</p>
						</item>
						<item>
							<p>a key value that identifies more than one node (the key values for different nodes do not need
to be unique).</p>
						</item>
					</ulist>
					

 
<p>An <elcode>xsl:key</elcode> declaration with higher 
<termref def="dt-import-precedence">import precedence</termref> does
not override another of lower import precedence; all the <elcode>xsl:key</elcode> declarations
in the stylesheet are effective regardless of their import precedence.</p>
							
				</div3>
				<div3 id="keys">
					<head>The <function>key</function> Function</head>
					<proto class="xslt" name="key" return-type="node()" returnSeq="yes">
						<arg name="key-name" type="xs:string"/>
						<arg name="key-value" type="xs:anyAtomicType" seq="yes" emptyOk="yes"/>
					</proto>
          <proto class="xslt" name="key" return-type="node()" returnSeq="yes">
						<arg name="key-name" type="xs:string"/>
						<arg name="key-value" type="xs:anyAtomicType" seq="yes" emptyOk="yes"/>
            <arg name="top" type="node()"/>
					</proto>
					<p>The <function>key</function> function does for keys what the
<xfunction>id</xfunction> function does for IDs.</p>
					<p>The <code>$key-name</code> argument
specifies the name of the <termref def="dt-key">key</termref>. The value of the argument <rfc2119>must</rfc2119> be a
<termref def="dt-lexical-qname">lexical QName</termref>, which is expanded as
described in <specref ref="qname"/>.</p>

<p><error spec="XT" type="dynamic" class="DE" code="1260"><p>It is a 
<termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the value 
<error.extra>of the first argument to the <function>key</function> function</error.extra> is
not a valid QName, or if there is no
 namespace declaration in scope for the prefix of the QName, or if the
 name obtained by expanding the QName is not the same as the expanded
 name of any <elcode>xsl:key</elcode> declaration in the <termref def="dt-stylesheet">stylesheet</termref>.
  If the processor is able to detect the error statically (for example, when the argument is
 supplied as a string literal), then the processor <rfc2119>may</rfc2119> optionally signal this 
 as a <termref def="dt-static-error">static error</termref>.</p></error>
					</p>
					
					<p>The <code>$key-value</code> argument to the
<function>key</function> function is considered as a sequence. The set of requested
key values is formed by atomizing the supplied
value of the argument, using the standard 
<termref def="dt-function-conversion-rules">function conversion rules</termref>. 
Each of the resulting atomic values is considered as a requested key value.
The result of the function is
a sequence of nodes, in document order and with duplicates removed, 
comprising those nodes in the selected <phrase diff="chg" at="W">subtree</phrase> (see below) that
are matched by an <elcode>xsl:key</elcode> declaration whose name is the same as the
supplied key name, where the result of evaluating the <termref def="dt-key-specifier">key specifier</termref> contains
a value that is equal to one of these requested key values,
under the rules appropriate to the XPath <code>eq</code> operator for the two
values in question, using the <code>collation</code>
attributes of the <elcode>xsl:key</elcode> declaration when comparing strings. 
No error is reported if two values are encountered that are
not comparable; they are regarded for the purposes of this function as being not equal.
</p>

<note diff="add" at="T"><p>Under the rules for the <code>eq</code> operator, untyped atomic values
are converted to strings, not to the type of the other operand. This means, for example, that if the
expression in the <code>use</code> attribute returns a date, supplying an untyped atomic value
in the call to the <function>key</function> function will return an empty sequence.</p></note>

<p>If the second argument is an empty sequence, the result of the
function will be an empty sequence.</p>
					
<p diff="add" at="W">Different rules apply when <termref def="dt-backwards-compatible-behavior">backwards compatible</termref>
behavior is enabled. Specifically, if any of the <elcode>xsl:key</elcode> elements in the definition of the
<termref def="dt-key">key</termref> enables backwards compatible behavior, then the value of the
<termref def="dt-key-specifier">key specifier</termref> and the value of the second argument of the
<function>key</function> function are both converted after atomization to a sequence of strings, by
applying a cast to each item in the sequence, before performing the comparison.</p>

<p diff="chg" at="W">The third argument is used to identify the selected subtree. 
If the argument
is present, the selected subtree is the set of nodes that have <var>$top</var> as an ancestor-or-self node. 
If the argument
is omitted, the selected subtree is the document containing the context node. This means that the third argument
effectively defaults to <code>/</code>.</p>

<p diff="chg" at="T"><error spec="XT" type="dynamic" class="DE" code="1270"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
to call the <function>key</function> function with two arguments if there is no <termref def="dt-context-node">context node</termref>,
<phrase diff="add" at="Q">or if the root of the tree containing the context node is not a document node</phrase>; or to call
the function with three arguments if the root of the tree containing the node supplied in the third
argument is not a document node.</p></error></p>


<p>The result of the <function>key</function> function can be described more specifically as follows.
 The result is a sequence containing
 every node <var>$N</var> that satisfies the following conditions:</p>

<ulist>
<item><p diff="chg" at="W"><code>$N/ancestor-or-self::node() intersect $top</code> is non-empty. (If the third
argument is omitted, <code>$top</code> defaults to <code>/</code>)</p></item>

<item><p><var>$N</var> matches the pattern specified in the <code>match</code> attribute of 
an <elcode>xsl:key</elcode> declaration whose <code>name</code> attribute matches 
 the name specified in the <code>$key-name</code> argument.</p></item>

<item><p>When the <termref def="dt-key-specifier">key specifier</termref> of that
 <elcode>xsl:key</elcode> declaration is evaluated with
 a <termref def="dt-singleton-focus">singleton focus</termref> based on <var>$N</var>, 
 the <termref def="dt-atomization">atomized</termref> value of the resulting sequence includes a
  value that compares equal to at least one item in the atomized value of the sequence
   supplied as <code>$key-value</code>, under the rules of the <code>eq</code> operator
   with the collation selected as described above.</p></item>
</ulist>

<p>The sequence returned by the <function>key</function> function will be in document order, with duplicates 
(that is, nodes having the same identity) removed. </p>





					<example><head>Using a Key to Follow Cross-References</head>
						<p>For example, given a declaration</p>
						<eg><![CDATA[<xsl:key name="idkey" match="div" use="@id"/>]]></eg>
						<p>an expression <code>key("idkey",@ref)</code> will return the same
nodes as <code>id(@ref)</code>, assuming that the only ID attribute
declared in the XML source document is:</p>
						<eg><![CDATA[<!ATTLIST div id ID #IMPLIED>]]></eg>
						<p>and that the <code>ref</code> attribute of the context node
contains no whitespace.</p>
						<p>Suppose a document describing a function library uses a
<code>prototype</code> element to define functions</p>
						<eg><![CDATA[<prototype name="sqrt" return-type="xs:double">
  <arg type="xs:double"/>
</prototype>]]></eg>
						<p>and a <code>function</code> element to refer to function names</p>
						<eg><![CDATA[<function>sqrt</function>]]></eg>
						<p>Then the stylesheet could generate hyperlinks between the
references and definitions as follows:</p>
						<eg><![CDATA[<xsl:key name="func" match="prototype" use="@name"/>

<xsl:template match="function">
<b>
  <a href="#{generate-id(key('func',.))}">
    <xsl:apply-templates/>
  </a>
</b>
</xsl:template>

<xsl:template match="prototype">
  <p>
    <a name="{generate-id()}">
      <b>Function: </b>
      ...
    </a>
  </p>
</xsl:template>]]></eg>
					</example>
					
<p>When called with two arguments, the <function>key</function> function always
returns nodes that are in the same document as the context node. To
retrieve a node from any other document, it is necessary 
 either to change the context node, or to supply a third argument.</p>
					<example><head>Using Keys to Reference other Documents</head>
						<p>For example, suppose a document contains bibliographic references in the
form <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a
separate XML document <code>bib.xml</code> containing a bibliographic
database with entries in the form:</p>
						<eg><![CDATA[<entry name="XSLT">...</entry>]]></eg>
						<p>Then the stylesheet could use the following to transform the
<code>bibref</code> elements:</p>
						<eg><![CDATA[<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:variable name="name" select="."/>
  <xsl:apply-templates select="document('bib.xml')/key('bib',$name)"/>
</xsl:template>]]></eg>
						<note>
							<p>This relies on the ability in XPath 2.0 to have a function call
on the right-hand side of the <code>/</code> operator in a path expression.</p>
						</note>

<p diff="add" at="Z">The following code would also work:</p>
						
<eg diff="add" at="Z"><![CDATA[<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:apply-templates select="key('bib', ., document('bib.xml'))"/>
</xsl:template>]]></eg>


					</example>
					

				</div3>
			</div2>
			<div2 id="format-number">
				<head>Number Formatting</head>
				<proto class="xslt" name="format-number" return-type="xs:string">
					<arg name="value" type="numeric" emptyOk="yes"/>
					<arg name="picture" type="xs:string"/>
				</proto>
				<proto class="xslt" name="format-number" return-type="xs:string">
					<arg name="value" type="numeric" emptyOk="yes"/>
					<arg name="picture" type="xs:string"/>
					<arg name="decimal-format-name" type="xs:string"/>
				</proto>				
				<p>The <function>format-number</function> function formats
<code>$value</code> as a string using the <termref def="dt-picture-string">picture string</termref>
 specified by the
<code>$picture</code> argument and the decimal-format named by the <code>$decimal-format-name</code> argument, or
the default decimal-format, if there is no <code>$decimal-format-name</code> argument.
<phrase diff="add" at="X">The syntax of the picture string is described in 
<specref ref="processing-picture-string"/>.</phrase></p>

<p diff="add" at="U">The <code>$value</code> argument may be of any numeric data type (<code>xs:double</code>,
<code>xs:float</code>, <code>xs:decimal</code>, or their subtypes including <code>xs:integer</code>).
Note that if an <code>xs:decimal</code> is supplied, it is not automatically promoted to an <code>xs:double</code>,
as such promotion can involve a loss of precision.</p>

<p diff="add" at="V">If the supplied value of the <code>$value</code> argument is an empty sequence, the function
behaves as if the supplied value were the <code>xs:double</code> value <code>NaN</code>.</p>

<p>The value of <code>$decimal-format-name</code> <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical QName</termref>, which is expanded as
described in <specref ref="qname"/>. The result of the function is the formatted string
representation of the supplied number.</p>
				<p diff="chg" at="X">
					<error spec="XT" type="dynamic" class="DE" code="1280"><p>It is a 
<termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> 
if the name specified as the
<code>$decimal-format-name</code> argument<error.extra> to the <function>format-number</function> function</error.extra>
<phrase diff="add" at="O">is not a valid <termref def="dt-qname">QName</termref>, or
if its prefix has not been declared in an in-scope namespace declaration</phrase>, or
if the <termref def="dt-stylesheet">stylesheet</termref> does not contain a declaration of a decimal-format with a matching 
<termref def="dt-expanded-qname">expanded-QName</termref>.
 If the processor is able to detect the error statically (for example, when the argument is
 supplied as a string literal), then the processor <rfc2119>may</rfc2119> optionally signal this 
 as a <termref def="dt-static-error">static error</termref>.
					</p></error>
				</p>

				<div3 id="defining-decimal-format">
					<head>Defining a Decimal Format</head>
					<e:element-syntax name="decimal-format">
						<e:in-category name="declaration"/>
						<e:attribute name="name">
							<e:data-type name="qname"/>
						</e:attribute>
						<e:attribute name="decimal-separator">
							<e:data-type name="char"/>
						</e:attribute>
						<e:attribute name="grouping-separator">
							<e:data-type name="char"/>
						</e:attribute>
						<e:attribute name="infinity">
							<e:data-type name="string"/>
						</e:attribute>
						<e:attribute name="minus-sign">
							<e:data-type name="char"/>
						</e:attribute>
						<e:attribute name="NaN">
							<e:data-type name="string"/>
						</e:attribute>
						<e:attribute name="percent">
							<e:data-type name="char"/>
						</e:attribute>
						<e:attribute name="per-mille">
							<e:data-type name="char"/>
						</e:attribute>
						<e:attribute name="zero-digit">
							<e:data-type name="char"/>
						</e:attribute>
						<e:attribute name="digit">
							<e:data-type name="char"/>
						</e:attribute>
						<e:attribute name="pattern-separator">
							<e:data-type name="char"/>
						</e:attribute>
						<e:empty/>
						<e:allowed-parents>
							<e:parent name="stylesheet"/>
							<e:parent name="transform"/>
						</e:allowed-parents>
					</e:element-syntax>

<p>The <elcode>xsl:decimal-format</elcode> 
element controls the interpretation of a <termref def="dt-picture-string">picture string</termref>
used by the <function>format-number</function> function.</p>

			<p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
       <elcode>xsl:decimal-format</elcode> declarations
and may include or import <termref def="dt-stylesheet-module">stylesheet modules</termref> that also contain
<elcode>xsl:decimal-format</elcode> declarations. The name of an <elcode>xsl:decimal-format</elcode> declaration
is the value of its <code>name</code> attribute, if any.</p>

<p><termdef id="dt-decimal-format" term="decimal format">All 
the <elcode>xsl:decimal-format</elcode> declarations in a stylesheet
 that share the same name are grouped into a named <term>decimal format</term>;
 those that have no name are grouped into a single unnamed decimal format.</termdef>
			</p>


 

<p>If a <termref def="dt-stylesheet">stylesheet</termref> does not contain a declaration of
the unnamed decimal format, a declaration equivalent to
an <elcode>xsl:decimal-format</elcode> element with no attributes
is implied.</p>
					<p>The attributes of the <elcode>xsl:decimal-format</elcode>
declaration establish values for a number of variables used as input to
the algorithm followed by the <function>format-number</function> function.
An outline of the purpose of each attribute is given below; however, the definitive
explanations are given later, as part of the description of this algorithm.</p>

<p>For any named <termref def="dt-decimal-format">decimal format</termref>,
the effective value of each attribute is taken from an <elcode>xsl:decimal-format</elcode> declaration
that has that name, and that specifies an explicit value
for the required attribute. If there is no such declaration, the default value of the attribute
is used. If there is more than one such declaration, the one with highest
<termref def="dt-import-precedence">import precedence</termref> is used.</p>

<p>For any unnamed <termref def="dt-decimal-format">decimal format</termref>,
the effective value of each attribute is taken from an <elcode>xsl:decimal-format</elcode> declaration
that is unnamed, and that specifies an explicit value
for the required attribute. If there is no such declaration, the default value of the attribute
is used. If there is more than one such declaration, the one with highest
<termref def="dt-import-precedence">import precedence</termref> is used.</p>

<p><error spec="XT" type="static" class="SE" code="1290"><p>It 
is a <termref def="dt-static-error">static error</termref>
if a named or unnamed
<termref def="dt-decimal-format">decimal format</termref> contains two conflicting 
values for the same attribute in different
<elcode>xsl:decimal-format</elcode> declarations having the same 
<termref def="dt-import-precedence">import precedence</termref>, unless there is another definition
of the same attribute with higher import precedence.</p></error></p>

					<p>The following attributes control the interpretation of
characters in the <termref def="dt-picture-string">picture string</termref> supplied to the <function>format-number</function>
function, and also specify characters that may
appear in the result of formatting the number. In each case the value <rfc2119>must</rfc2119>
be a single character <phrase diff="add" at="Z"><errorref class="SE" code="0020"/></phrase>.</p>
					<ulist>
						<item>
							<p>
								<code>decimal-separator</code> specifies the character used
for the <var>decimal-separator-sign</var>; the default value is the period character
(<code>.</code>)</p>
						</item>
						<item>
							<p>
								<code>grouping-separator</code> specifies the character used
for the <var>grouping-sign</var>, which is typically used as a thousands
 separator; the default value is the
comma character (<code>,</code>)</p>
						</item>
						<item>
							<p>
								<code>percent</code> specifies the character used for the
<var>percent-sign</var>; the default value is the percent character
(<code>%</code>)</p>
						</item>
						<item>
							<p>
								<code>per-mille</code> specifies the character used for the
<var>per-mille-sign</var>; the default value is the Unicode per-mille character
(#x2030)</p>
						</item>
						<item>
							<p>
								<code>zero-digit</code> specifies the character used for the
<var>digit-zero-sign</var>; the default value is the digit zero
(<code>0</code>). This character <rfc2119>must</rfc2119> be a digit (category Nd in 
the Unicode property database), and it <rfc2119>must</rfc2119> have the numeric value zero.
<phrase diff="chg" at="P">This attribute implicitly defines the Unicode
character that is used to represent each of the values 0 to 9 in the final
result string: Unicode is organized so that each set of decimal digits forms 
a contiguous block of characters in numerical sequence.</phrase></p>
						</item>
					</ulist>

<p><error spec="XT" type="static" class="SE" code="1295" diff="add" at="Z"><p>It 
is a <termref def="dt-static-error">static error</termref> if the character specified
in the <code>zero-digit</code> attribute is not a digit or is a digit that does not have
the numeric value zero.
</p></error></p>

					<p>The following attributes control the interpretation of characters
in the <termref def="dt-picture-string">picture string</termref> supplied to the <function>format-number</function>
function. In each case the value <rfc2119>must</rfc2119> be a single character
 <phrase diff="add" at="Z"><errorref class="SE" code="0020"/></phrase>.</p>
					<ulist>
						<item>
							<p>
								<code>digit</code> specifies the character used for the <var>digit-sign</var>
in the <termref def="dt-picture-string">picture string</termref>; the default value is the number sign character
(<code>#</code>)</p>
						</item>
						<item>
							<p>
								<code>pattern-separator</code> specifies the character used
for the <var>pattern-separator-sign</var>, which
separates positive and negative sub-pictures in a <termref def="dt-picture-string">picture string</termref>; the
default value is the semi-colon character (<code>;</code>)</p>
						</item>
					</ulist>
					<p>The following attributes specify characters or strings that may
appear in the result of formatting the number:</p>
					<ulist>
						<item>
							<p>
								<code>infinity</code> specifies the string used for the
<var>infinity-symbol</var>; the default value is the string
<code>Infinity</code>
							</p>
						</item>
						<item>
							<p>
								<code>NaN</code> specifies the string used for the
<var>NaN-symbol</var>, which is used to represent the value NaN (not-a-number);
the default value is the string <code>NaN</code>
							</p>
						</item>
						<item>
							<p>
								<code>minus-sign</code> specifies the character used for the
<var>minus-symbol</var>; the default value is the hyphen-minus character
(<code>-</code>, #x2D). The value <rfc2119>must</rfc2119> be a single character.</p>
						</item>
					</ulist>
					<p>
<error spec="XT" type="static" class="SE" code="1300"><p>It is a <termref def="dt-static-error">static error</termref> if,
for any named or unnamed decimal format, the variables
representing characters used in a <termref def="dt-picture-string">picture string</termref>
do not each have distinct values. These variables are <var>decimal-separator-sign</var>,
<var>grouping-sign</var>, <var>percent-sign</var>, <var>per-mille-sign</var>,
<var>digit-zero-sign</var>, <var>digit-sign</var>, and <var>pattern-separator-sign</var>.
</p></error>


					</p>
				</div3>
				<div3 id="processing-picture-string">
					<head>Processing the Picture String</head>
					
<p><termdef id="dt-picture-string" term="picture string">The formatting of a 
number is controlled by a <term>picture string</term>. The
picture string is a sequence of characters, in which the characters
assigned to the variables <var>decimal-separator-sign</var>, <var>grouping-sign</var>,
<var>zero-digit-sign</var>,
<var>digit-sign</var> and <var>pattern-separator-sign</var> are classified as
active characters, and all other characters (including the <var>percent-sign</var> and 
<var>per-mille-sign</var>) are classified as passive characters.</termdef></p>

<p>The <var>integer part</var> of the sub-picture is defined as the part that
appears to the left of the <var>decimal-separator-sign</var> if there is one, or the entire
sub-picture otherwise. The <var>fractional part</var> of the sub-picture is defined as the part that
appears to the right of the <var>decimal-separator-sign</var> if there is one; it is a zero-length
string otherwise.</p> 



<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="1310"><p>The
 <termref def="dt-picture-string">picture string</termref>
<error.extra>supplied to the <function>format-number</function> function</error.extra>
<rfc2119>must</rfc2119> conform to the following rules. <error.extra> See full specification.</error.extra>
It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the picture string
does not satisfy these rules.</p></error></p>

<p>Note that in these
rules the words "preceded" and "followed" refer to characters anywhere in the string, they
are not to be read as "immediately preceded" and "immediately followed".</p>

<ulist>
	<item>
		<p>A picture-string consists either of a sub-picture, or of
        two sub-pictures separated by a <var>pattern-separator-sign</var>. A picture-string
        <rfc2119>must not</rfc2119> contain more than one <var>pattern-separator-sign</var>. If the picture-string contains two
        sub-pictures, the first is used for positive values and the second for negative values.</p>
	</item>
	<item>
		<p>A sub-picture <rfc2119>must not</rfc2119> contain more than one <var>decimal-separator-sign</var>.</p>
	</item>
	<item>
		<p>A sub-picture <rfc2119>must not</rfc2119> contain more than one <var>percent-sign</var> or
        <var>per-mille-sign</var>, and it <rfc2119>must not</rfc2119> contain one of each.</p>
	</item>
	<item>
		<p>A sub-picture <rfc2119>must</rfc2119> contain at least one <var>digit-sign</var> or <var>zero-digit-sign</var>.</p>
	</item>
	<item>
		<p>A sub-picture <rfc2119>must not</rfc2119> contain a passive character that is preceded by
        an active character and that is followed by another active character.</p>
	</item>
	<item>
		<p>A sub-picture <rfc2119>must not</rfc2119> contain a <var>grouping-separator-sign</var> adjacent to a
        <var>decimal-separator-sign</var>.</p>
	</item>
	<item>
		<p>The integer part of a sub-picture <rfc2119>must not</rfc2119> contain a <var>zero-digit-sign</var> that is followed by
        a <var>digit-sign</var>. The fractional part of a sub-picture <rfc2119>must not</rfc2119> contain a <var>digit-sign</var>
        that is followed by a <var>zero-digit-sign</var>.</p>
	</item>
</ulist>


<p>The evaluation of the <function>format-number</function> function
is described below in two phases, an analysis phase and a formatting
phase. The analysis phase takes as its inputs the <termref def="dt-picture-string">picture string</termref>
and the variables derived from the relevant <elcode>xsl:decimal-format</elcode> declaration,
and produces as its output a number of variables with defined values.
The formatting phase takes as its inputs the number to be formatted
and the variables produced by the analysis phase, and produces as
its output a string containing a formatted representation of the number.</p>

				
<note><p>Numbers will always be formatted with the most significant
 digit on the left.</p></note>
 
				</div3>
				
				<div3 id="analysing-picture-string" diff="chg" at="P">
					<head>Analysing the Picture String</head>
					
					<p>This phase of the algorithm analyses 
the <termref def="dt-picture-string">picture string</termref> and the attribute settings of
the <elcode>xsl:decimal-format</elcode> declaration, and has the effect
of setting the values of various variables, which are used in the
subsequent formatting phase. These variables are listed below.
Each is shown with its initial setting and its data type.
					</p>
				

					


					<p>Several variables are associated with each sub-picture. If there are
two sub-pictures, then these rules are applied to one sub-picture to obtain the values
that apply to positive numbers, and to the other to obtain the values that apply
to negative numbers. If there is only one sub-picture, then the values for both cases
are derived from this sub-picture.</p>

<p>The variables are as follows:</p>


					<ulist>

<item><p>The <var>integer-part-grouping-positions</var> is a sequence of integers
representing the positions of grouping separators within the integer part of the
sub-picture. For each <var>grouping-separator-sign</var> that appears within the
integer part of the sub-picture, this sequence contains an integer that is equal
to the total number of <var>digit-sign</var> and <var>zero-digit-sign</var> 
characters that appear within the integer part of the sub-picture and to the right of the 
<var>grouping-separator-sign</var>. In addition, if these
<var>integer-part-grouping-positions</var> are at regular intervals (that is, if they 
<phrase diff="chg" at="ZA">form a sequence <var>N</var>, <var>2N</var>, <var>3N</var>, ... 
for some integer value <var>N</var>, </phrase>
including the case where there is only one
number in the list), then the sequence contains all
integer multiples of <var>N</var> as far as necessary to accommodate the largest 
possible number.</p></item>
						

 <item>
 <p>The <var>minimum-integer-part-size</var> is an integer indicating the minimum number of digits that will
 appear to the left of the <var>decimal-separator-sign</var>. It is normally set to 
 the number of <var>zero-digit-sign</var> characters found in the integer part of the sub-picture.
 But if the sub-picture contains no <var>zero-digit-sign</var> and no <var>decimal-separator-sign</var>,
 it is set to one.</p>
 <note diff="add" at="Y"><p>There is no maximum integer part size. All significant digits in the integer part of the
 number will be displayed, even if this exceeds the number of <var>digit-sign</var> and
 <var>zero-digit-sign</var> characters in the subpicture.</p></note>
 </item>
 
 
						<item>
							<p>The <var>prefix</var> is set to contain all passive characters
in the sub-picture to the left of the leftmost active character.
<phrase diff="chg" at="P">If the picture string contains only one sub-picture</phrase>, 
the <var>prefix</var> 
for the negative sub-picture is set by concatenating the <var>minus-sign</var> 
character and the <var>prefix</var> for the positive sub-picture (if any),
in that order.</p>

						</item>
						
<item><p>The <var>fractional-part-grouping-positions</var> is a sequence of integers
representing the positions of grouping separators within the fractional part of the
sub-picture. For each <var>grouping-separator-sign</var> that appears within the
fractional part of the sub-picture, this sequence contains an integer that is equal
to the total number of <var>digit-sign</var> and <var>zero-digit-sign</var> 
characters that appear within the fractional part of the sub-picture and to the left of the 
<var>grouping-separator-sign</var>.</p></item>						

						<item>
<p>The <var>minimum-fractional-part-size</var> is set to the number of 
<var>zero-digit-sign</var> characters found in the fractional part of the sub-picture.</p>
</item>
<item>
<p>The <var>maximum-fractional-part-size</var> is set to the total number of 
<var>digit-sign</var> and <var>zero-digit-sign</var> characters found 
in the fractional part of the sub-picture.</p>
</item>					
						
						<item>
<p>The <var>suffix</var> is set to contain all passive characters to the right of the rightmost
active character in the fractional part of the sub-picture.</p>
						
						</item>
					</ulist>
					<note>
						<p>If there is only one sub-picture, then all variables
for positive numbers and negative numbers will be the same, except for  
<var>prefix</var>: the prefix for negative numbers will <phrase diff="chg" at="Q">
be preceded by the <var>minus-sign</var> character</phrase>.</p>
					</note>
				</div3>
				<div3 id="formatting-the-number">
					<head>Formatting the Number</head>
					<p>This section describes the second phase of processing of the
<function>format-number</function> function. This phase takes as input a number to be formatted
(referred to as the <emph>input number</emph>), and the variables set up by
analysing the <elcode>xsl:decimal-format</elcode> declaration and the
<termref def="dt-picture-string">picture string</termref>, as described above.
 The result of this phase is a string, which forms the return value of 
the <function>format-number</function> function.</p>
					<p>The algorithm for this second stage of processing is as follows:</p>
					<olist>
						<item>
							<p diff="chg" at="ZA">If the input number is NaN (not a number), the result is the 
							 specified <var>NaN-symbol</var> (with no
<var>prefix</var> or <var>suffix</var>).</p>
						</item>
						<item>
							<p>In the rules below, the positive sub-picture and its associated variables are used 
							 if the input number is positive, and the negative sub-picture and its associated
variables are used otherwise. Negative zero is taken as negative, positive zero as positive.</p>
						</item>
						<item>
							<p>If the input number is positive or negative infinity, the result is the 
concatenation of the appropriate <var>prefix</var>, the <var>infinity-symbol</var>,
 and the appropriate <var>suffix</var>.</p>
						</item>
						<item>
							<p>If the sub-picture contains a <var>percent-sign</var>, the number is multiplied 
by 100. If the sub-picture contains a <var>per-mille-sign</var>, the number is multiplied by 1000.
The resulting number is referred to below as the <var>adjusted number</var>.</p>
							
						</item>
						
<item><p>The <var>adjusted number</var> is converted (if necessary) to
 an <code>xs:decimal</code> value,
using an implementation of <code>xs:decimal</code> that imposes no limits on the
<code>totalDigits</code> or <code>fractionDigits</code> facets. If there are several 
such values that
are numerically equal to the <var>adjusted number</var> (bearing in mind that if the
<var>adjusted number</var> is an <code>xs:double</code> or <code>xs:float</code>, the comparison will be done by
converting the decimal value back to an <code>xs:double</code> or <code>xs:float</code>), the one that
is chosen <rfc2119>should</rfc2119> be one with the smallest possible number of digits
not counting leading or trailing zeroes <phrase diff="add" at="Y">(whether significant or insignificant)</phrase>. 
For example, 1.0 is preferred to
0.9999999999, and 100000000 is preferred to 100000001. This value is then
rounded so that it uses no more than <code>maximum-fractional-part-size</code> digits in
its fractional part. The <var>rounded number</var> is defined to be the result of
converting the <var>adjusted number</var> to an <code>xs:decimal</code> value, as described above,
and then calling the function <xfunction>round-half-to-even</xfunction> with this converted number
as the first argument and the <code>maximum-fractional-part-size</code> as the second
argument, again with no limits on the <code>totalDigits</code> or <code>fractionDigits</code> in the
result.</p></item>

<item><p>The absolute value of the <var>rounded number</var> is converted to a string in decimal notation, 
with no insignificant leading or trailing zeroes, using the
characters implied by the choice of <var>zero-digit-sign</var> to represent the ten decimal digits,
and the <var>decimal-separator-sign</var> to separate the integer part and the fractional part.
(The value zero will at this stage be represented by a <var>decimal-separator-sign</var> on its own.)</p></item>

<item><p>If the number of digits to the left of the <var>decimal-separator-sign</var> is less than
<var>minimum-integer-part-size</var>, leading <var>zero-digit-sign</var> 
characters are added to pad out to that size.</p></item>

<item><p>If the number of digits to the right of the <var>decimal-separator-sign</var> is less than
<var>minimum-fractional-part-size</var>, trailing <var>zero-digit-sign</var> 
characters are added to pad out to that size.</p></item>

<item><p>For each integer <var>N</var> in the <var>integer-part-grouping-positions</var> list,  
a <var>grouping-separator-sign</var> character is inserted into the string immediately
after that digit that appears in the integer part of the number and has <var>N</var> digits
between it and the <var>decimal-separator-sign</var>, if there is such a digit.</p></item>

<item><p>For each integer <var>N</var> in the <var>fractional-part-grouping-positions</var> list,  
a <var>grouping-separator-sign</var> character is inserted into the string immediately
before that digit that appears in the fractional part of the number and has <var>N</var> digits
between it and the <var>decimal-separator-sign</var>, if there is such a digit.</p></item>

<item><p>If there is no <var>decimal-separator-sign</var> in the sub-picture, 
<phrase diff="add" at="W">or if there are no digits to the right of the 
<var>decimal-separator-sign</var> character in the string, then</phrase> the
<var>decimal-separator-sign</var> character is removed from the string (it will be the rightmost 
character in the string).</p></item>

<item><p>The result of the function is the concatenation of the appropriate <var>prefix</var>, the 
string conversion of the number as obtained above, and the appropriate <var>suffix</var>.</p></item>
					
					</olist>

				</div3>
			</div2>

<div2 id="format-date">
  <head>Formatting Dates and Times</head>
  
<p>Three functions are provided to represent dates and times as a string, using the conventions of a selected calendar,
 language, and country. Each has two variants.</p>

<proto class="xslt" name="format-dateTime" return-type="xs:string" returnEmptyOk="yes">
	<arg name="value" type="xs:dateTime" emptyOk="yes"/>
	<arg name="picture" type="xs:string"/>
	<arg name="language" type="xs:string" emptyOk="yes"/>
	<arg name="calendar" type="xs:string" emptyOk="yes"/>
	<arg name="country" type="xs:string" emptyOk="yes"/>
</proto>

<proto class="xslt" name="format-dateTime" return-type="xs:string" returnEmptyOk="yes">
	<arg name="value" type="xs:dateTime" emptyOk="yes"/>
	<arg name="picture" type="xs:string"/>
</proto>

<proto class="xslt" name="format-date" return-type="xs:string" returnEmptyOk="yes">
	<arg name="value" type="xs:date" emptyOk="yes"/>
	<arg name="picture" type="xs:string"/>
	<arg name="language" type="xs:string" emptyOk="yes"/>
	<arg name="calendar" type="xs:string" emptyOk="yes"/>
	<arg name="country" type="xs:string" emptyOk="yes"/>
</proto>

<proto class="xslt" name="format-date" return-type="xs:string" returnEmptyOk="yes">
	<arg name="value" type="xs:date" emptyOk="yes"/>
	<arg name="picture" type="xs:string"/>
</proto>

<proto class="xslt" name="format-time" return-type="xs:string" returnEmptyOk="yes">
	<arg name="value" type="xs:time" emptyOk="yes"/>
	<arg name="picture" type="xs:string"/>
	<arg name="language" type="xs:string" emptyOk="yes"/>
	<arg name="calendar" type="xs:string" emptyOk="yes"/>
	<arg name="country" type="xs:string" emptyOk="yes"/>
</proto>

<proto class="xslt" name="format-time" return-type="xs:string" returnEmptyOk="yes">
	<arg name="value" type="xs:time" emptyOk="yes"/>
	<arg name="picture" type="xs:string"/>
</proto>
  

<p>The <function>format-dateTime</function>, <function>format-date</function>, 
and <function>format-time</function> 
functions format <code>$value</code> as a string using 
the picture string specified by the <code>$picture</code> argument,
the calendar specified by the <code>$calendar</code> argument,
the language specified by the <code>$language</code> argument, 
and the country specified by the <code>$country</code> argument.
The result of the function is the formatted string representation of the supplied
  <code>dateTime</code>, <code>date</code>, or <code>time</code> value.</p>
  
<p><termdef id="dt-date-formatting-function" term="date formatting function">The three 
functions <function>format-date</function>, <function>format-time</function>, and
<function>format-dateTime</function> are referred to collectively as the
 <term>date formatting functions</term>.</termdef></p>

<p>If <code>$value</code> is the empty sequence, the empty sequence is returned.</p>

<p>Calling the two-argument form of each of the three functions is equivalent
to calling the five-argument form with each of the last three arguments set to an empty sequence.</p>

<p>For details of the <code>language</code>, <code>calendar</code>, and
<code>country</code> arguments, see <specref ref="lang-cal-country"/>.</p>
 
<p>In general, the use of an invalid <code>picture</code>, 
<code>language</code>, <code>calendar</code>, or
<code>country</code> argument is classified as a <phrase diff="chg" at="Z"><termref def="dt-nonrec-dynamic-error">non-recoverable
dynamic error</termref>. By contrast,</phrase>
use of an option in any of these arguments that is valid but not supported by the implementation is
not an error, and in these cases the implementation is required to output the value in a fallback
representation.</p>

<div3 id="date-picture-string"><head>The Picture String</head>

<p>The picture consists of a sequence of variable markers and literal substrings.
A substring enclosed in square brackets is interpreted as a variable marker; substrings
not enclosed in square brackets are taken as literal substrings. 
The literal substrings are optional and if present are rendered unchanged, including any whitespace. 
If an opening or closing square bracket 
is required within a literal substring, it <rfc2119>must</rfc2119> be doubled.
The variable markers are replaced in the result by strings representing 
aspects of the date and/or time to be formatted. These are described in detail below.</p>

<p>A variable marker consists of a component specifier followed optionally 
by one or two presentation modifiers and/or optionally by a width modifier.
Whitespace within a variable marker is ignored.</p>

<p>The <emph>component specifier</emph> indicates the component of the date or
time that is required, and takes the following values:</p>

<table border="1" cellpadding="5">
<thead>
<tr>
<th align="left">Specifier</th>
<th align="left">Meaning</th>
<th align="left">Default Presentation Modifier</th>
</tr>
</thead>
<tbody>
<tr><td valign="top">Y</td><td>year <phrase diff="add" at="ZA">(absolute value)</phrase></td><td valign="top">1</td></tr>
<tr><td valign="top">M</td><td>month in year</td><td valign="top">1</td></tr>
<tr><td valign="top">D</td><td>day in month</td><td valign="top">1</td></tr>
<tr><td valign="top">d</td><td>day in year</td><td valign="top">1</td></tr>
<tr><td valign="top">F</td><td>day of week</td><td valign="top">n</td></tr>
<tr><td valign="top">W</td><td>week in year</td><td valign="top">1</td></tr>
<tr><td valign="top">w</td><td>week in month</td><td valign="top">1</td></tr>
<tr><td valign="top">H</td><td>hour in day (24 hours)</td><td valign="top">1</td></tr>
<tr><td valign="top">h</td><td>hour in half-day (12 hours)</td><td valign="top">1</td></tr>
<tr><td valign="top">P</td><td>am/pm marker</td><td valign="top">n</td></tr>
<tr><td valign="top">m</td><td>minute in hour</td><td valign="top"><phrase diff="chg" at="U">01</phrase></td></tr>
<tr><td valign="top">s</td><td>second in minute</td><td valign="top"><phrase diff="chg" at="U">01</phrase></td></tr>
<tr><td valign="top">f</td><td>fractional seconds</td><td valign="top">1</td></tr>
<tr><td valign="top">Z</td><td>timezone as a time offset from UTC, or if an alphabetic
      modifier is present the conventional name of a timezone (such as PST)</td><td valign="top">1</td></tr>
<tr><td valign="top">z</td><td>timezone as a time offset using GMT, for example GMT+1</td><td valign="top">1</td></tr>
<tr><td valign="top">C</td><td>calendar: the name or abbreviation of a calendar name</td><td valign="top">n</td></tr>
<tr><td valign="top">E</td><td>era: the name of a baseline for the numbering of years, for example
                  the reign of a monarch</td><td valign="top">n</td></tr>
</tbody>
</table>

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="1340"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
 if the syntax of the picture <error.extra>used for date/time formatting</error.extra>
 is incorrect.</p></error></p>

<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="1350"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
 if a component specifier within the picture <error.extra>used for date/time formatting</error.extra>
 refers to components that are not available in the given type of <code>$value</code>,
 for example if the picture supplied to the <function>format-time</function> refers
 to the year, month, or day component.</p></error></p>

 <p diff="add" at="X">It is not an error to include a timezone component when the supplied
 value has no timezone. In these circumstances the timezone component will be ignored.</p>

<p>The first <emph>presentation modifier</emph> indicates the style in which the
value of a component is to be represented. Its value may be
either:</p>

<ulist>
<item><p>any format token permitted in the <code>format</code> string
of the <elcode>xsl:number</elcode> instruction (see <specref ref="number"/>), indicating
that the value of the component is to be output numerically using the specified number format (for example,
<code>1</code>, <code>01</code>, <code>i</code>, <code>I</code>, <code>w</code>, <code>W</code>,
or <code>Ww</code>) or </p></item>
<item><p>the format token <code>n</code>, <code>N</code>,
or <code>Nn</code>, indicating that the value of the component is to be output by name,
in lower-case, upper-case, or title-case respectively. Components that can be output by name
include (but are not limited to) months, days of the week, timezones, and eras. 
If the processor cannot output these components by name for the chosen calendar and language 
then it must use an implementation-defined fallback representation.</p></item>
</ulist>

<p>If the implementation does not support the use of the requested format token, it <rfc2119>must</rfc2119>
use the default presentation modifier for that component.</p>

<p>If the first presentation modifier is present, then it may optionally be followed by
a second presentation modifier as follows:</p>

<table border="1" cellpadding="5">
<thead>
<tr>
<th align="left">Modifier</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr><td valign="top">t</td><td valign="top">traditional numbering. This has the same meaning as
<code>letter-value="traditional"</code> in <elcode>xsl:number</elcode>.</td></tr>
<tr><td valign="top">o</td><td valign="top">ordinal form of a number, for example <code>8th</code> or <code>8</code>. 
The actual representation of the ordinal form of a number
may depend not only on the language, but also on the grammatical context (for example,
in some languages it must agree in gender).</td></tr>
</tbody>
</table>

<note><p>Although the formatting rules are expressed in terms of the rules
for format tokens in <elcode>xsl:number</elcode>, the formats actually used may be specialized
to the numbering of date components where appropriate. For example, in Italian, it is conventional to
use an ordinal number (<code>primo</code>) for the first day of the month, and cardinal numbers
(<code>due, tre, quattro ...</code>) for the remaining days. A processor may therefore use
this convention to number days of the month, ignoring the presence or absence of the ordinal
presentation modifier.</p></note> 

<p>Whether or not a presentation modifier is included, a width modifier may be supplied. This
indicates the number of characters or digits to be included in the representation of the value.</p>

<p>The width modifier, if present, is introduced by a comma. It takes the form:</p>

<p><code>,min-width ("-" max-width)?</code></p>

<p>where <code>min-width</code> is either an unsigned integer indicating the minimum number of characters to
be output, or <code>*</code> indicating that there is no explicit minimum, and 
<code>max-width</code> is either an unsigned integer indicating the maximum number of characters to
be output, or <code>*</code> indicating that there is no explicit maximum; if <code>max-width</code>
is omitted then <code>*</code> is assumed. Both integers, if present, <rfc2119>must</rfc2119> be greater than zero.</p>

<p>A format token containing leading zeroes, such as <code>001</code>, sets the
minimum and maximum width to the number of digits appearing in the format token; if a width
modifier is also present, then the width modifier takes precedence.</p>

<note diff="add" at="ZA"><p>A format token consisting of a one-digit on its own,
 such as <code>1</code>, does not constrain the number of digits in the output. 
 In the case of fractional seconds in particular, <code>[f001]</code> requests three decimal digits,
  <code>[f01]</code> requests two digits, but <code>[f1]</code> will produce an 
  implementation-defined number of digits. 
If exactly one digit is required, this can be achieved using the component specifier 
<code>[f1,1-1]</code>.</p></note>

<p>If the minumum and maximum width are unspecified, then the output uses as 
many characters as are required to
represent the value of the component without truncation and without padding: this is referred to below
as the <emph>full representation</emph> of the value.</p>

<p>If the full representation of the value exceeds the specified maximum width, then the processor
<rfc2119>should</rfc2119> attempt to use an alternative shorter representation that fits within 
the maximum width. Where the
presentation modifier is <code>N</code>, <code>n</code>, or <code>Nn</code>, 
this is done by abbreviating the name,
using either conventional abbreviations if available, or crude right-truncation if not. For example,
setting <code>max-width</code> to <code>4</code> indicates that four-letter abbreviations
 <rfc2119>should</rfc2119> be
used, though it would be acceptable to use a three-letter abbreviation if this is in conventional use.
(For example, "Tuesday" might be abbreviated to "Tues", and "Friday" to "Fri".) 
In the case of the year component, setting <code>max-width</code> requests omission of high-order
digits from the year, for example, if <code>max-width</code> is set to <code>2</code> then the year 2003
will be output as <code>03</code>. <phrase diff="add" at="ZA">In the case of the fractional seconds 
component, the value is rounded to the specified size as if by applying the function
<code>round-half-to-even(fractional-seconds, max-width)</code>.</phrase>
If no mechanism is available for fitting the value within the specified
maximum width (for example, when roman numerals are used), then the value <rfc2119>should</rfc2119> be 
output in its full representation.</p>

<p>If the full representation of the value is shorter than the specified minimum width, then the processor
<rfc2119>should</rfc2119> pad the value to the specified width. For decimal representations of 
numbers, this <rfc2119>should</rfc2119> be done by
prepending zero digits from the appropriate set of digit characters,
or appending zero digits in the case of the fractional
seconds component. In other cases, 
it <rfc2119>should</rfc2119> be done by appending spaces.</p>
</div3>


<div3 id="lang-cal-country">
<head>The Language, Calendar, and Country Arguments</head>



<p>The set of languages, calendars, and countries that are supported in the 
<termref def="dt-date-formatting-function">date formatting functions</termref> is
<termref def="dt-implementation-defined">implementation-defined</termref>. When
any of these arguments is omitted or is an empty sequence, an <termref def="dt-implementation-defined">implementation-defined</termref>
default value is used.</p>

<imp-def-feature>The set of languages, calendars, and countries that are supported in the 
<termref def="dt-date-formatting-function">date formatting functions</termref> is
implementation-defined. If any of these arguments is omitted or set to an empty sequence, 
the default is implementation-defined.</imp-def-feature>

<p>If the fallback representation uses a different calendar 
from that requested, the output string <rfc2119>must</rfc2119> be prefixed 
with <code>[Calendar: X]</code> where <code>X</code>
identifies the calendar actually used. The string <code>Calendar</code> 
<rfc2119>should</rfc2119> be localized using the requested
language if available. If the fallback representation uses a different language from 
that requested, the output string should be prefixed with <code>[Language: Y]</code> where <code>Y</code>
identifies the language actually used. The string <code>Language</code> 
<rfc2119>may</rfc2119> be localized in an 
<termref def="dt-implementation-dependent">implementation-dependent</termref> way.
If a particular component of the value cannot be output in the
requested format, it <rfc2119>should</rfc2119> be output in the default format for that component.</p>







<p>The <code>language</code> argument specifies the language to be used for the result string 
of the function. The value of the argument <rfc2119>must</rfc2119> be either the empty sequence
or a value that would be valid for the <code>xml:lang</code> attribute (see [XML]).
Note that this permits the identification of sublanguages
based on country codes (from <bibref ref="ISO3166"/>) as well as identification of dialects
and of regions within a country.</p>

<p>If the <code>language</code> 
argument is omitted or is set to an empty sequence, or if it is set to an invalid value or a
value that the implementation does not recognize, 
then the processor uses an <termref def="dt-implementation-defined">implementation-defined</termref>
language.</p>

<p>The language is used to select the appropriate language-dependent forms of:</p>

<slist>
<sitem>names (for example, of months)</sitem>
<sitem>numbers expressed as words or as ordinals (<code>twenty, 20th, twentieth</code>)</sitem>
<sitem>hour convention (0-23 vs 1-24, 0-11 vs 1-12)</sitem>
<sitem>first day of week, first week of year</sitem>
</slist>

<p>Where appropriate this choice may also take into account the value of the
<code>country</code> argument, though this <rfc2119>should</rfc2119> not be used to override the
language or any sublanguage that is specified as part of the <code>language</code>
argument.</p>

<p>The choice of the names and abbreviations used in any given language is 
<termref def="dt-implementation-defined">implementation-defined</termref>. For example,
one implementation might abbreviate July as <code>Jul</code> while another uses <code>Jly</code>. In German,
one implementation might represent Saturday as <code>Samstag</code> while another
uses <code>Sonnabend</code>. Implementations <rfc2119>may</rfc2119> provide mechanisms allowing users to
control such choices.</p>

<imp-def-feature>The choice of the names and abbreviations used in any given language for
calendar units such as days of the week and months of the year is 
<termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>

<p>Where ordinal numbers are used, the selection of the correct representation of the 
ordinal (for example, the linguistic gender) <rfc2119>may</rfc2119> depend on the component being formatted and on its
textual context in the picture string.</p>

<p>The <code>calendar</code> attribute specifies that the <code>dateTime</code>, <code>date</code>,
or <code>time</code> supplied in the <code>$value</code> argument <rfc2119>must</rfc2119> be 
converted to a value in the specified calendar and then converted to a string using the 
conventions of that calendar.</p>

<p>A calendar value <rfc2119>must</rfc2119> be a valid <termref def="dt-qname">QName</termref>. 
If the QName does not have a prefix, 
then it identifies a calendar with the designator specified below. 
If the QName has a prefix, then the QName is expanded into an expanded-QName 
as described in <specref ref="qname"/>; the expanded-QName identifies the calendar; 
the behavior in this case is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>

<p>If the calendar attribute is omitted an
 <termref def="dt-implementation-defined">implementation-defined</termref> value is used.</p>



<note><p>The calendars listed below were known to be in use during the 
last hundred years. Many other calendars have been used in the past.</p>

<p>This specification does not define any of these calendars, nor the way that they
map to the value space of the <code>xs:date</code> data type in <bibref ref="xmlschema-2"/>.
There may be ambiguities when dates are recorded using different calendars. 
For example, the start of a new day is not simultaneous in different calendars, 
and may also vary geographically (for example, based on the time of sunrise or sunset).
Translation of dates is therefore more reliable when the time of day is also known, and
when the geographic location is known. 
When translating dates between
one calendar and another, the processor may take account of the values
of the <code>country</code> and/or <code>language</code> arguments, with the <code>country</code>
argument taking precedence.</p>

<p>Information about some of these calendars, and algorithms for converting between them, may
be found in <bibref ref="CALCALC"/>.</p>
</note>

<table border="1" cellpadding="5">
<thead>
<tr>
<th valign="top" align="left">Designator</th>
<th valign="top" align="left">Calendar</th>
</tr>
</thead>
<tbody>
<tr><td>AD</td><td>Anno Domini (Christian Era)</td></tr>
<tr><td>AH</td><td>Anno Hegirae (Muhammedan Era)</td></tr>
<tr><td>AME</td><td>Mauludi Era (solar years since Mohammed's birth)</td></tr>
<tr><td>AM</td><td>Anno Mundi (Jewish Calendar)</td></tr>
<tr><td>AP</td><td>Anno Persici</td></tr>
<tr><td>AS</td><td>Aji Saka Era (Java)</td></tr>
<tr><td>BE</td><td>Buddhist Era</td></tr>
<tr><td>CB</td><td>Cooch Behar Era</td></tr>
<tr><td>CE</td><td>Common Era</td></tr>
<tr><td>CL</td><td>Chinese Lunar Era</td></tr>
<tr><td>CS</td><td>Chula Sakarat Era</td></tr>
<tr><td>EE</td><td>Ethiopian Era</td></tr>
<tr><td>FE</td><td>Fasli Era</td></tr>
<tr><td>ISO</td><td>ISO 8601 calendar</td></tr>
<tr><td>JE</td><td>Japanese Calendar</td></tr>
<tr><td>KE</td><td>Khalsa Era (Sikh calendar)</td></tr>
<tr><td>KY</td><td>Kali Yuga</td></tr>
<tr><td>ME</td><td>Malabar Era</td></tr>
<tr><td>MS</td><td>Monarchic Solar Era</td></tr>
<tr><td>NS</td><td>Nepal Samwat Era</td></tr>
<tr><td>OS</td><td>Old Style (Julian Calendar)</td></tr>
<tr><td>RS</td><td>Rattanakosin (Bangkok) Era</td></tr>
<tr><td>SE</td><td>Saka Era</td></tr>
<tr><td>SH</td><td>Mohammedan Solar Era (Iran)</td></tr>
<tr><td>SS</td><td>Saka Samvat</td></tr>
<tr><td>TE</td><td>Tripurabda Era</td></tr>
<tr><td>VE</td><td>Vikrama Era</td></tr>
<tr><td>VS</td><td>Vikrama Samvat Era</td></tr>
</tbody>
</table>

<p>At least one of the above calendars <rfc2119>must</rfc2119> be supported. It is 
<termref def="dt-implementation-defined">implementation-defined</termref> which
calendars are supported.</p>


<p diff="chg" at="ZA">The ISO 8601 calendar (<bibref ref="ISO8601"/>), 
which is included in the above list and designated <code>ISO</code>, 
is very similar to the Gregorian calendar designated <code>AD</code>, but it
differs in several ways. The ISO calendar
    is intended to ensure that date and time formats can be read
    easily by other software, as well as being legible for human
    users. The ISO calendar
prescribes the use of particular numbering conventions as defined in
ISO 8601, rather than allowing these to be localized on a per-language basis. 
In particular it
    provides a numeric 'week date' format which identifies dates by
    year, week of the year, and day in the week; 
in the ISO calendar the days of the week are numbered from 1 (Monday) to 7 (Sunday), and
week 1 in any calendar year is the week (from Monday to Sunday) that includes the first Thursday
of that year. The numeric values of the components year, month, day, hour, minute, and second
are the same in the ISO calendar as the values used in the lexical representation of the date and
time as defined in <bibref ref="xmlschema-2"/>. The era ("E" component)
with this calendar is either a minus sign (for negative years) or a zero-length string (for positive years).
For dates before 1 January, AD 1, year numbers in
    the ISO and AD calendars are off by one from each other: ISO year
    0000 is 1 BC, -0001 is 2 BC, etc.</p>

<note><p>The value space of the date and time data types, as defined in XML Schema, is based on
absolute points in time. The lexical space of these data types defines a 
representation of these absolute points in time using the proleptic Gregorian calendar,
that is, the modern Western calendar extrapolated into the past and the future; but the value space
is calendar-neutral. The
<termref def="dt-date-formatting-function">date formatting functions</termref> produce a representation
of this absolute point in time, but denoted in a possibly different calendar. So,
for example, the date whose lexical representation in XML Schema is <code>1502-01-11</code> 
(the day on which Pope Gregory XIII was born) might be
formatted using the Old Style (Julian) calendar as <code>1 January 1502</code>. This reflects the fact
that there was at that time a ten-day difference between the two calendars. It would be
incorrect, and would produce incorrect results, to represent this date in an element or attribute 
of type <code>xs:date</code> as <code>1502-01-01</code>, even though this might reflect the way 
the date was recorded in contemporary documents.</p>

<p diff="add" at="ZA">When referring to years occurring in antiquity, modern historians generally
use a numbering system in which there is no year zero (the year before 1 CE
is thus 1 BCE). This is the convention that <rfc2119>should</rfc2119> be used when the
requested calendar is OS (Julian) or AD (Gregorian). When the requested
calendar is ISO, however, the conventions of ISO 8601 <rfc2119>should</rfc2119> be followed:
here the year before +0001 is numbered zero. In <bibref ref="xmlschema-2"/> (version 1.0), 
the value space for <code>xs:date</code> and <code>xs:dateTime</code>
does not include a year zero: however, a future edition is
expected to endorse the ISO 8601 convention. This means that the date on
which Julius Caesar was assassinated has the ISO 8601 lexical representation
-0043-03-13, but will be formatted as 15 March 44 BCE in the Julian calendar
or 13 March 44 BCE in the Gregorian calendar (dependant on the chosen
localization of the names of months and eras).</p></note>



<p>The intended use of the <code>country</code> argument is to identify
 the place where an event
represented by the <code>dateTime</code>, <code>date</code>,
or <code>time</code> supplied in the <code>$value</code> argument took place or will take place.
If the value is supplied, and is not the empty sequence, then it <rfc2119>should</rfc2119> be a country code
defined in <bibref ref="ISO3166"/>. Implementations <rfc2119>may</rfc2119> also allow the use
of codes representing subdivisions of a country from ISO 3166-2, or codes representing formerly used names of
countries from ISO 3166-3.
This argument is not intended to identify the location of the user 
for whom the date or time is being formatted;
that should be done by means of the <code>language</code> attribute. 
This information 
<rfc2119>may</rfc2119> be used to provide additional information when converting dates between
calendars or when deciding how individual components of the date and time are to be formatted. 
For example, different countries using the Old Style (Julian) calendar started the new year on different
days, and some countries used variants of the calendar that were out of synchronization as a result of
differences in calculating leap years. <phrase diff="add" at="T">The geographical area identified by a country code is defined by the
  boundaries as they existed at the time of the date to be formatted,
  or the present-day boundaries for dates in the future.</phrase></p>


</div3>


<div3 id="date-time-examples">
<head>Examples of Date and Time Formatting</head>

<example><head>Gregorian Calendar</head>

<p>The following examples show a selection of dates and times and the way they might
be formatted. These examples assume the use of the Gregorian calendar as the default calendar.</p>

<table border="1" cellpadding="5">
<thead>
<tr><th align="left">Required Output</th><th align="left">Expression</th></tr>
</thead>
<tbody>

<tr><td><code>2002-12-31</code></td><td><code>format-date($d, "[Y0001]-[M01]-[D01]")</code></td></tr>
<tr><td><code>12-31-2002</code></td><td><code>format-date($d, "[M]-[D]-[Y]")</code></td></tr>
<tr><td><code>31-12-2002</code></td><td><code>format-date($d, "[D]-[M]-[Y]")</code></td></tr>
<tr><td><code>31 XII 2002</code></td><td><code>format-date($d, "[D1] [MI] [Y]")</code></td></tr>
<tr><td><code>31st December, 2002</code></td><td><code>format-date($d, "[D1o] [MNn], [Y]", "en", (), ())</code></td></tr>
<tr><td><code>31 DEC 2002</code></td><td><code>format-date($d, "[D01] [MN,*-3] [Y0001]", "en", (), ())</code></td></tr>
<tr><td><code>December 31, 2002</code></td><td><code>format-date($d, "[MNn] [D], [Y]", "en", (), ())</code></td></tr>
<tr><td><code>31 Dezember, 2002</code></td><td><code>format-date($d, "[D] [MNn], [Y]", "de", (), ())</code></td></tr>
<tr><td><code>Tisdag 31 December 2002</code></td><td><code>format-date($d, "[FNn] [D] [MNn] [Y]", "sv", (), ())</code></td></tr>
<tr><td><code>[2002-12-31]</code></td><td><code>format-date($d, "[[[Y0001]-[M01]-[D01]]]")</code></td></tr>
<tr><td><code>Two Thousand and Three</code></td><td><code>format-date($d, "[YWw]", "en", (), ())</code></td></tr>
<tr><td><code>einunddreiigste Dezember</code></td><td><code>format-date($d, "[Dwo] [MNn]", "de", (), ())</code></td></tr>
<tr><td><code>3:58 PM</code></td><td><code>format-time($t, "[h]:[m01] [PN]", "en", (), ())</code></td></tr>
<tr><td><code>3:58:45 pm</code></td><td><code>format-time($t, "[h]:[m01]:[s01] [Pn]", "en", (), ())</code></td></tr>
<tr><td><code>3:58:45 PM PDT</code></td><td><code>format-time($t, "[h]:[m01]:[s01] [PN] [ZN,*-3]", "en", (), ())</code></td></tr>
<tr><td><code>3:58:45 o'clock PM PDT</code></td><td><code>format-time($t, "[h]:[m01]:[s01] o'clock [PN] [ZN,*-3]",
"en")</code></td></tr>
<tr><td><code>15:58</code></td><td><code>format-time($t,"[H01]:[m01]")</code></td></tr>
<tr><td><code>15:58:45.762</code></td><td><code>format-time($t,"[H01]:[m01]:[s01].[f001]")</code></td></tr>
<tr><td><code>15:58:45 GMT+02:00</code></td><td><code>format-time($t,"[H01]:[m01]:[s01] [z]", "en", (), ())</code></td></tr>
<tr><td><code>15.58 Uhr GMT+02:00</code></td><td><code>format-time($t,"[H01]:[m01] Uhr [z]", "de", (), ())</code></td></tr>
<tr><td><code>3.58pm on Tuesday, 31st December</code></td><td><code>format-dateTime($dt, "[h].[m01][Pn] on [FNn], [D1o] [MNn]")</code></td></tr>
<tr><td><phrase diff="chg" at="Z"><code>12/31/2002 at 15:58:45</code></phrase></td><td><code>format-dateTime($dt, "[M01]/[D01]/[Y0001] at [H01]:[m01]:[s01]")</code></td></tr>
</tbody>
</table>

</example>

<example><head>Non-Gregorian Calendars</head>
<p>The following examples use calendars other than the Gregorian calendar.</p>

<p>These examples use non-Latin characters which might not display
correctly in all browsers, depending on the system configuration.</p>

<table border="1" cellpadding="5">
<thead>
<tr>
  <th align="left">Description</th>
  <th align="left">Request</th>
  <th align="left">Result</th>
</tr>
</thead>
<tbody>

<tr> 
<td valign="top">Islamic</td> 
<td valign="top"><code>format-date($d, "[D&amp;#x0661;] [Mn] [Y&amp;#x0661;]", "Islamic", "ar", "AH", ())</code></td> 
<td valign="top">&#x0662;&#x0666; &#xFEB8;&#xFEED;&#x0651;&#xFE8D;&#xFEDD; &#x0661;&#x0664;&#x0662;&#x0663;</td>
</tr>

<tr>
<td valign="top">Jewish (with Western numbering)</td> 
<td valign="top"><code>format-date($d, "[D] [Mn] [Y]", "he", "AM", ())</code></td> 
<td valign="top">&#x200F;26 &#x05D8;&#x05D1;&#x05EA; 5763</td>
</tr>

<tr>
<td valign="top">Jewish (with traditional numbering)</td> 
<td valign="top"><code>format-date($d, "[D&amp;#x05D0;t] [Mn] [Y&amp;#x05D0;t]", "he", "AM", ())</code></td> 
<td valign="top">&#x05DB;&#x05F4;&#x05D5; &#x05D8;&#x05D1;&#x05EA; &#x05EA;&#x05E9;&#x05E1;&#x05F4;&#x05D2;</td>
</tr>

<tr>
<td valign="top">Julian (Old Style)</td> 
<td valign="top"><code>format-date($d, "[D] [MNn] [Y]", "en", "OS", ())</code></td>
<td valign="top">18 December 2002</td> 
</tr>

<tr>
<td valign="top">Thai</td>
<td valign="top"><code>format-date($d, "[D&amp;#x0E51;] [Mn] [Y&amp;#x0E51;]", "th", "BE", ())</code></td>
<td valign="top">&#x0E53;&#x0E51; &#x0E18;&#x0E31;&#x0E19;&#x0E27;&#x0E32;&#x0E04;&#x0E21; 
&#x0E52;&#x0E55;&#x0E54;&#x0E55;</td>
</tr>


</tbody>
</table>
</example>

  
 </div3>

  </div2>
  
  
  


			<div2 id="misc-func">
				<head>Miscellaneous Additional Functions</head>
				

				<div3 id="current-function">
					<head>current</head>
					<proto class="xslt" name="current" return-type="item()"/>
					<p>The <function>current</function> function, used within
an XPath <termref def="dt-expression">expression</termref>, returns the item that was the <termref def="dt-context-item">context
item</termref> at the point where the expression was invoked from the XSLT <termref def="dt-stylesheet">stylesheet</termref>.
This is referred to as the current item.  
 For an outermost expression (an expression not occurring
within another expression), the current item is always the same as the
context item.  Thus,</p>
					<eg><![CDATA[<xsl:value-of select="current()"/>]]></eg>
					<p>means the same as</p>
					<eg><![CDATA[<xsl:value-of select="."/>]]></eg>
					<p>However, within square brackets, or on the
 right-hand side of the <code>/</code> operator, 
 the current item is generally
different from the context item.</p>
					<example><head>Using the <code>current</code> Function</head>
						<p>For example,</p>
						<eg><![CDATA[<xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/>]]></eg>
						<p>will process all <code>entry</code> elements that have a
<code>glossary</code> parent element and that have a <code>name</code>
attribute with value equal to the value of the current item's
<code>ref</code> attribute. This is different from</p>
						<eg><![CDATA[<xsl:apply-templates select="//glossary/entry[@name=./@ref]"/>]]></eg>
						<p>which means the same as</p>
						<eg><![CDATA[<xsl:apply-templates select="//glossary/entry[@name=@ref]"/>]]></eg>
						<p>and so would process all <code>entry</code> elements that have a
<code>glossary</code> parent element and that have a <code>name</code>
attribute and a <code>ref</code> attribute with the same value.</p>
					</example>
					<p>If the <function>current</function> function is used within a 
<termref def="dt-pattern">pattern</termref>, its value is the node that is being matched 
against the pattern.</p>
					
<p><error spec="XT" type="dynamic" class="DE" code="1360"><p>If the <function>current</function> function is evaluated
within an expression that is evaluated when the context item is undefined, a 
<termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> occurs.</p></error></p>
				</div3>
				<div3 id="unparsed-entity-uri">
					<head>unparsed-entity-uri</head>
					<proto class="xslt" name="unparsed-entity-uri" return-type="xs:anyURI" diff="chg" at="W">
						<arg name="entity-name" type="xs:string"/>
					</proto>
					<p>The <function>unparsed-entity-uri</function> function returns the URI of the
unparsed entity whose name is given by the value of the <code>$entity-name</code> argument, in the 
document containing the <termref def="dt-context-node">context node</termref>.  It returns the
zero-length <phrase diff="chg" at="W"><code>xs:anyURI</code></phrase>  if there is no such entity. 
<phrase diff="add" at="P">This function maps to the <code>dm:unparsed-entity-system-id</code>
accessor defined in <bibref ref="xpath-datamodel"/>.</phrase></p>

<p><error spec="XT" type="dynamic" class="DE" code="1370"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if the <function>unparsed-entity-uri</function> function is called when there is no <termref def="dt-context-node">context node</termref>,
or when the root of the tree containing the context node is not a document node.</p></error></p>
				</div3>
				<div3 id="unparsed-entity-public-id">
					<head>unparsed-entity-public-id</head>
					<proto class="xslt" name="unparsed-entity-public-id" return-type="xs:string">
						<arg name="entity-name" type="xs:string"/>
					</proto>
					<p>The <function>unparsed-entity-public-id</function> function returns the public identifier of the
unparsed entity whose name is given by the value of the <code>$entity-name</code> argument, in the 
document containing the <termref def="dt-context-node">context node</termref>.  It returns the
zero-length string if there is no such entity<phrase diff="add" at="O">, or if the entity
has no public identifier</phrase>. <phrase diff="add" at="P">This function maps to the <code>dm:unparsed-entity-public-id</code>
accessor defined in <bibref ref="xpath-datamodel"/>.</phrase></p>

<p><error spec="XT" type="dynamic" class="DE" code="1380"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if the <function>unparsed-entity-public-id</function> function is called
 when there is no <termref def="dt-context-node">context node</termref>,
 or when the root of the tree containing the context node is not a document node.</p></error></p>
				</div3>
				<div3 id="generate-id">
					<head>generate-id</head>
					<proto class="xslt" name="generate-id" return-type="xs:string"/>
					<proto class="xslt" name="generate-id" return-type="xs:string">
						<arg name="node" type="node()" emptyOk="yes"/>
					</proto>

					<p>The <function>generate-id</function> function returns a string that
uniquely identifies a given node.  The unique identifier <rfc2119>must</rfc2119> consist of ASCII
alphanumeric characters and <rfc2119>must</rfc2119> start with an alphabetic character.
Thus, the string is syntactically an XML name.  An implementation is
free to generate an identifier in any convenient way provided that it
always generates the same identifier for the same node and that
different identifiers are always generated from different nodes. An
implementation is under no obligation to generate the same identifiers
each time a document is transformed.  There is no guarantee that a
generated unique identifier will be distinct from any unique IDs
specified in the source document.  If the argument 
is the empty sequence, the result is the <phrase diff="chg" at="M">zero-length string</phrase>. 
If the argument is omitted, it defaults
to the <termref def="dt-context-node">context node</termref>.</p>


				</div3>
				<div3 id="system-property">
					<head>system-property</head>
					<proto class="xslt" name="system-property" return-type="xs:string">
						<arg name="property-name" type="xs:string"/>
					</proto>
					<p>The <code>$property-name</code> argument <rfc2119>must</rfc2119> evaluate to a 
					<termref def="dt-lexical-qname">lexical QName</termref>.
  The <termref def="dt-lexical-qname">lexical QName</termref> is expanded as described in
  <specref ref="qname"/>.</p>

<p><error spec="XT" type="dynamic" class="DE" code="1390"><p>It is a 
<termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the value 
<error.extra>supplied as the <code>$property-name</code> argument to the
 <function>system-property</function> function</error.extra> is
not a valid QName, or if there is no
 namespace declaration in scope for the prefix of the QName. 
 If the processor is able to detect the error statically (for example, when the argument is
 supplied as a string literal), then the processor <rfc2119>may</rfc2119> optionally signal this 
 as a <termref def="dt-static-error">static error</termref>.
						</p></error>
					</p>
					<p>The <function>system-property</function> function returns a string
representing the value of the system property identified by the name.
If there is no such system property, the zero-length string <phrase diff="chg" at="M">is</phrase>
returned.</p>
					<p>Implementations <rfc2119>must</rfc2119> provide the following system properties, which
are all in the <termref def="dt-xslt-namespace">XSLT namespace</termref>:</p>
					<ulist>
					
<item><p><code>xsl:version</code>, a number giving the version of XSLT
implemented by the <termref def="dt-processor">processor</termref>; for implementations conforming to the
version of XSLT specified by this document, this is the string
<code>"2.0"</code>. The value will always be a string in the lexical
space of the decimal data type defined in XML Schema (see <bibref ref="xmlschema-2"/>).
This allows the value to be converted to a number for the purpose
of magnitude comparisons.</p></item>

<item><p><code>xsl:vendor</code>, a string identifying the implementer of the
<termref def="dt-processor">processor</termref></p>
</item>

<item><p>
<code>xsl:vendor-url</code>, a string containing a URL
identifying the implementer of the <termref def="dt-processor">processor</termref>; typically this is the
host page (home page) of the implementer's Web site.</p></item>

<item><p><code>xsl:product-name</code>, a string containing the name
of the implementation, as defined by the implementer. This <rfc2119>should</rfc2119> normally
remain constant from one release of the product to the next. It <rfc2119>should</rfc2119> also be 
constant across platforms in cases where the same source code is used to produce
compatible products for multiple execution platforms.</p>
</item>

<item><p><code>xsl:product-version</code>, a string identifying the version 
of the implementation, as defined by the implementer. This <rfc2119>should</rfc2119> normally
vary from one release of the product to the next, and at the discretion
of the implementer it <rfc2119>may</rfc2119> also vary across different execution platforms.</p></item>

<item><p><code>xsl:is-schema-aware</code>, returns the string <code>"yes"</code> in
the case of a processor that claims conformance as a <termref def="dt-schema-aware-xslt-processor">schema-aware
XSLT processor</termref>, or <code>"no"</code> in the case of a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>.</p></item>

<item><p><code>xsl:supports-serialization</code>, returns the string <code>"yes"</code> in
the case of a processor that offers the <termref def="dt-serialization-feature">serialization feature</termref>, 
or <code>"no"</code> otherwise.</p></item>

<item><p><code>xsl:supports-backwards-compatibility</code>, returns the string <code>"yes"</code> in
the case of a processor that offers the
 <termref def="dt-backwards-compatibility-feature">backwards compatibility feature</termref>, 
or <code>"no"</code> otherwise.</p></item>

<!--
<item><p diff="add" at="U"><code>xsl:short-date-format</code>,
<code>xsl:medium-date-format</code>,
<code>xsl:long-date-format</code>,
<code>xsl:full-date-format</code>,
<code>xsl:short-dateTime-format</code>,
<code>xsl:medium-dateTime-format</code>,
<code>xsl:long-dateTime-format</code>,
<code>xsl:full-dateTime-format</code>,
<code>xsl:short-time-format</code>,
<code>xsl:medium-time-format</code>,
<code>xsl:long-time-format</code>, and
<code>xsl:full-time-format</code>. These system properties return picture strings that can be
used in the second argument of the <termref def="dt-date-formatting-function">date formatting functions</termref>
(see <specref ref="localized-date-formats"/>) to achieve date and time formatting according to
the locale appropriate to the user for whom the stylesheet output is intended.</p></item>
-->
					</ulist>
					
					<p>Some of these properties relate to the conformance levels and features
					offered by the <termref def="dt-processor">processor</termref>: 
					these options are described in <specref ref="conformance"/>.</p>
					<p>The actual values returned for the above properties
are <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
					<p>The set of system properties that are supported, in addition
to those listed above, is also <termref def="dt-implementation-defined">implementation-defined</termref>.
Implementations <rfc2119>must not</rfc2119> define additional system
properties in the XSLT namespace.</p>
					<imp-def-feature>The values returned by the <function>system-property</function>
function, and the names of the additional properties that are recognized, are implementation-defined.</imp-def-feature>
					<note>
						<p>An implementation must not return the value <code>2.0</code>
as the value of the <code>xsl:version</code> system property unless it is
conformant to XSLT 2.0.</p>
						<p>It is recognized that vendors who are enhancing XSLT 1.0 processors may
wish to release interim implementations before all the mandatory features of this
specification are implemented. Since such products are not conformant to XSLT 2.0, this
specification cannot define their behavior. However, implementers of such products are
encouraged to return a value for the <code>xsl:version</code> system property that
is intermediate between 1.0 and 2.0, and to provide the <function>element-available</function> and
<function>function-available</function> functions to allow users to test which features have
been fully implemented.</p>
					</note>
					
				</div3>
			</div2>
		</div1>
		<div1 id="message">
			<head>Messages</head>
			<e:element-syntax name="message">
				<e:in-category name="instruction"/>
    			<e:attribute name="select">
    				<e:data-type name="expression"/>
    		    </e:attribute>
				<e:attribute name="terminate">
					<e:attribute-value-template>
						<e:constant value="yes"/>
						<e:constant value="no"/>
					</e:attribute-value-template>
				</e:attribute>
				<e:model name="sequence-constructor"/>
				<e:allowed-parents>
					<e:parent-category name="sequence-constructor"/>
					<e:parent name="function"/>
				</e:allowed-parents>
			</e:element-syntax>
			
		
			<p>The <elcode>xsl:message</elcode> instruction sends a message in 
an <termref def="dt-implementation-defined">implementation-defined</termref> way. 
The <elcode>xsl:message</elcode> instruction causes the creation of a new
document, which is typically serialized and output to an
 <termref def="dt-implementation-defined">implementation-defined</termref>
destination. The result of the <elcode>xsl:message</elcode> instruction is an empty
sequence.</p>

<p>The content of the message may be specified by using either or both of the
optional <code>select</code> attribute and the 
<termref def="dt-sequence-constructor">sequence constructor</termref>
that forms the content of the <elcode>xsl:message</elcode> instruction.</p>

<p>If the <elcode>xsl:message</elcode> instruction contains a 
<termref def="dt-sequence-constructor">sequence constructor</termref>, then the sequence 
obtained by evaluating this sequence constructor is used to construct
the content of the new document node, as described in <specref ref="constructing-complex-content"/>.</p>

<p>If the <elcode>xsl:message</elcode> instruction has a <code>select</code>
attribute, then the value of the attribute <rfc2119>must</rfc2119> be an XPath expression.
The effect of the <elcode>xsl:message</elcode> instruction is then the same as if
a single <elcode>xsl:copy-of</elcode> instruction with this <code>select</code> attribute
were added to the start of the <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>

<p>If the <elcode>xsl:message</elcode> instruction has no content
and no <code>select</code> attribute, then an empty message is produced.</p>


			<imp-def-feature>The destination and formatting of messages written using the
<elcode>xsl:message</elcode> instruction are implementation-defined.</imp-def-feature>

<p>The tree produced by the <elcode>xsl:message</elcode> instruction is not technically
a <termref def="dt-final-result-tree">final result tree</termref>. 
The tree has no URI and processors are not <rfc2119>required</rfc2119> to make the tree 
accessible to applications.</p>

			
			<note>
				<p>In many cases, the XML document produced using <elcode>xsl:message</elcode> will
consist of a document node owning a single text node. However, it may contain a more complex
structure.</p>
			</note>
			<note>
				<p>An implementation might implement <elcode>xsl:message</elcode> by
popping up an alert box or by writing to a log file. <phrase diff="add" at="P">Because the order
of execution of instructions is implementation-defined, the order in which such messages appear
is not predictable.</phrase></p>
			</note>
			<p>The <code>terminate</code> attribute is interpreted as
an <termref def="dt-attribute-value-template">attribute value
template</termref>.</p>
			<p>If the <termref def="dt-effective-value">effective value</termref>
of the <code>terminate</code> attribute is
				<code>yes</code>, then the <termref def="dt-processor">processor</termref> <rfc2119>must</rfc2119>
 terminate processing after sending the message.  The default value is <code>no</code>.
 Note that because the order of evaluation of instructions is
 <termref def="dt-implementation-dependent">implementation-dependent</termref>, 
 this gives no guarantee that any particular instruction will or
 will not be evaluated before processing terminates.</p>

<p diff="add" at="ZB"><error spec="XT" type="dynamic" class="MM" code="9000"><p>When
a transformation is terminated by use of <code>xsl:message terminate="yes"</code>, the effect
is the same as when a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> occurs 
during the transformation.</p></error></p>

			<example><head>Localizing Messages</head>
				<p>One convenient way to do localization is to put the localized
information (message text, etc.) in an XML document, which becomes an
additional input file to the <termref def="dt-stylesheet">stylesheet</termref>.  For example, suppose
messages for a language <code>
						<var>L</var>
					</code> are stored in an XML
file <code>resources/<var>L</var>.xml</code> in the form:</p>
				<eg><![CDATA[<messages>
  <message name="problem">A problem was detected.</message>
  <message name="error">An error was detected.</message>
</messages>
]]></eg>
				<p>Then a stylesheet could use the following approach to localize
messages:</p>
				<eg><![CDATA[<xsl:param name="lang" select="'en'"/>
<xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/>

<xsl:template name="localized-message">
  <xsl:param name="name"/>
  <xsl:message select="string($messages/message[@name=$name])"/>
</xsl:template>

<xsl:template name="problem">
  <xsl:call-template name="localized-message">
    <xsl:with-param name="name">problem</xsl:with-param>
  </xsl:call-template>
</xsl:template>]]></eg>
			</example>
			
		</div1>
		<div1 id="extension">
			<head>Extensibility and Fallback</head>
			<p>XSLT allows two kinds of extension, extension instructions and
extension functions.</p>

<p><termdef id="dt-extension-instruction" term="extension instruction">An
<term>extension instruction</term> is an element within a
 <termref def="dt-sequence-constructor">sequence constructor</termref> that is in
 a namespace (not the <termref def="dt-xslt-namespace">XSLT namespace</termref>)
 designated as an extension namespace.</termdef></p>

<p><termdef id="dt-extension-function" term="extension function">An
<term>extension function</term> is a function that is available for
use within an XPath <termref def="dt-expression">expression</termref>, other than a
 <termref def="dt-core-function">core function</termref> defined
in <bibref ref="xpath-functions"/>, an additional function defined in this
XSLT specification, <phrase diff="add" at="T">a constructor function named after an 
atomic type,</phrase> or a <termref def="dt-stylesheet-function">stylesheet
function</termref> defined using an <elcode>xsl:function</elcode> declaration.</termdef>. 
</p>
			<p>This specification does not define any mechanism for creating or binding
implementations of <termref def="dt-extension-instruction">extension instructions</termref>
or <termref def="dt-extension-function">extension functions</termref>, and
it is not <rfc2119>required</rfc2119> that implementations support any such mechanism.
Such mechanisms, if they exist, are
<termref def="dt-implementation-defined">implementation-defined</termref>.
Therefore, an XSLT stylesheet that <rfc2119>must</rfc2119>
be portable between XSLT implementations cannot rely on particular
extensions being available.  XSLT provides mechanisms that allow an
XSLT stylesheet to determine whether the implementation makes particular extensions
available, and to specify what happens if those extensions are
not available.  If an XSLT stylesheet is careful to make use of these
mechanisms, it is possible for it to take advantage of extensions and
still retain portability.</p>
			<div2 id="extension-functions">
				<head>Extension Functions</head>
				
        <p diff="add" at="T">The set of functions that can be called from 
        a <xnt spec="XP" ref="FunctionCall">FunctionCall</xnt> 
within an XPath <termref def="dt-expression">expression</termref> may include
one or more <termref def="dt-extension-function">extension functions</termref>.
The <termref def="dt-expanded-qname">expanded-QName</termref> of an extension function 
always has a non-null namespace URI.</p>

				
				<div3 id="testing-function-availability">
					<head>Testing Availability of Functions</head>
					<p>The <function>function-available</function> function 
can be used with the
<code>[xsl:]use-when</code> attribute (see <specref ref="conditional-inclusion"/>) to
explicitly control how a stylesheet behaves if a particular
extension function is not available.</p>
					<proto class="xslt" name="function-available" return-type="xs:boolean">
						<arg name="function-name" type="xs:string"/>
					</proto>
					<proto class="xslt" name="function-available" return-type="xs:boolean" diff="add" at="T">
						<arg name="function-name" type="xs:string"/>
						<arg name="arity" type="xs:integer"/>
					</proto>					
					
<p>A function is said to be available within an XPath expression if it is present in the
<xtermref spec="XP" ref="dt-function-signature">in-scope functions</xtermref> for that expression 
(see <specref ref="static-context"/>). Functions in the static context are uniquely identified
by the name of the function (a QName) in combination with its <termref def="dt-arity">arity</termref>.</p> 


					<p>The value of the <code>$function-name</code> argument <rfc2119>must</rfc2119> be a string containing 
					a <termref def="dt-lexical-qname">lexical QName</termref>. 
The lexical QName is expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> using the
namespace declarations in scope for the <termref def="dt-expression">expression</termref>. 
If the lexical QName is unprefixed, then the 
<termref def="dt-standard-function-namespace">standard function namespace</termref>
is used in the expanded QName.</p>

					<p>The two-argument version of the 
					<function>function-available</function> function
returns true if and only if there is an available function whose name matches the value of the <code>$function-name</code> argument
and whose <termref def="dt-arity">arity</termref> matches the value of the <code>$arity</code> argument. </p>
					<p>The single-argument version of the 
					<function>function-available</function> function
returns true if and only if there is at least one available function (with some arity) 
whose name matches the value of the <code>$function-name</code> argument. </p>


<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="1400"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> 
if the argument 
<error.extra>passed to the <function>function-available</function> function</error.extra>
does not evaluate to a string that is a valid <termref def="dt-qname">QName</termref>,
or if there is no namespace declaration in scope for the prefix of the <termref def="dt-qname">QName</termref>.
 If the processor is able to detect the error statically (for example, when the argument is
 supplied as a string literal), then the processor <rfc2119>may</rfc2119> optionally signal this 
 as a <termref def="dt-static-error">static error</termref>.</p></error>
					</p>

<p diff="add" at="ZB">When <termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>
 is enabled, the <function>function-available</function> function
  returns false in respect of a function name and arity for which no implementation is available
  (other than the fallback error function that raises a
dynamic error whenever it is called). This means that it is possible (as in XSLT
1.0) to use logic such as the following to test whether a function is
available before calling it:</p>

<example diff="add" at="ZB">
<head>Calling an extension function with backwards-compatibility enabled</head>
<eg><![CDATA[
<summary xsl:version="1.0">
  <xsl:choose>
    <xsl:when test="function-available('my:summary')">
      <xsl:value-of select="my:summary()"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>Summary not available</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</summary>]]></eg></example>

					<note>
						<p>The fact that a function with a given name is available
gives no guarantee that any particular call on the function will be successful. For example,
it is not possible to determine the types of the arguments expected.</p>
					</note>
          <note><p>In XSLT 2.0 <phrase diff="chg" at="ZB">(without backwards compatibility enabled)</phrase> 
		  a static error occurs when an XPath expression
          references a function that is not available. This is true even in a part of the stylesheet
          that uses <termref def="dt-forwards-compatible-behavior">forwards-compatible behavior</termref>.
		  Therefore, the conditional logic to test whether a function is
          available before calling it should normally be written in a <code>use-when</code> attribute (see
          <specref ref="conditional-inclusion"/>).</p>
          </note>

          <example>
          <head>Stylesheet portable between XSLT 1.0 and XSLT 2.0</head>
          <p>A stylesheet that is designed to use XSLT 2.0 facilities when they are available, but to fall back
          to XSLT 1.0 capabilities when not, might be written using the code:</p>
          <eg><![CDATA[
<out xsl:version="2.0">
  <xsl:choose>
    <xsl:when test="function-available('matches')">
      <xsl:value-of select="matches($input, '[a-z]*')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="string-length(
	                  translate($in, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/>
    </xsl:otherwise>
  </xsl:choose>
</out>]]></eg>
          <p>Here an XSLT 2.0 processor will always take the <elcode>xsl:when</elcode> branch, 
		  while a 1.0 processor will follow the <elcode>xsl:otherwise</elcode> branch.
		  The single-argument version of the <function>function-available</function> function is used
          here, because that is the only version available in XSLT 1.0. Under the rules of XSLT 1.0, the call on 
		  the <code>matches</code> function is not an error, because it is never evaluated.</p>
          </example>
          
          <example diff="add" at="Y">
          <head>Stylesheet portable between XSLT 2.0 and a future version of XSLT</head>
          <p>A stylesheet that is designed to use facilities in some future XSLT version when they are available, but to fall back
          to XSLT 2.0 capabilities when not, might be written using code such as the following. This hypothesizes the availability
          in some future version of a function <code>pad</code> which pads a string to a fixed
          length with spaces:</p>
<eg><![CDATA[
 <xsl:value-of select="pad($input, 10)" 
               use-when="function-available('pad', 2)"/>
 <xsl:value-of select="concat($input, string-join(
                          for $i in 1 to 10 - string-length($input) 
						  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/>
 ]]></eg>
         <p>In this case the two-argument version of <function>function-available</function> is used, because there
         is no requirement for this code to run under XSLT 1.0.</p>
         </example>           

					
				</div3>
				<div3 id="calling-extension-functions">
					<head>Calling Extension Functions</head>
					<p>If the function name used in a 
					<xnt spec="XP" ref="FunctionCall">FunctionCall</xnt> 
within an XPath <termref def="dt-expression">expression</termref> identifies an
extension function, then to evaluate the <xnt spec="XP" ref="FunctionCall">FunctionCall</xnt>, the processor
will first evaluate each of the arguments in the <xnt spec="XP" ref="FunctionCall">FunctionCall</xnt>. If the
processor has information about the data types expected by the extension function,
then it <rfc2119>may</rfc2119> perform any necessary type conversions between the XPath data types and
those defined by the implementation language. If multiple extension functions are
available with the same name, the processor <rfc2119>may</rfc2119> decide which one to invoke based on
the number of arguments, the types of the arguments, or any other criteria.
The result returned by the implementation
is returned as the result of the function call, again after any necessary conversions
between the data types of the implementation language and those of XPath. The details
of such type conversions are outside the scope of this specification.</p>

<p><error spec="XT" type="dynamic" class="DE" code="1420"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
error</termref> if the arguments supplied to a call on an extension function do
not satisfy the rules defined for that particular extension function, or if the
extension function reports an error, or if the result of the extension function
cannot be converted to an XPath value.</p></error></p>
          <note diff="add" at="U"><p>Implementations may also provide mechanisms allowing extension
functions to report
recoverable dynamic errors, or to execute within an environment that treats some or all 
of the errors listed above as recoverable.</p></note>

<p><error spec="XT" type="dynamic" class="DE" code="1425"><p>When
<termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>
is enabled, 
it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
error</termref> to evaluate an extension function call if no implementation
of the extension function is available.</p></error></p>

<note diff="add" at="ZB"><p>When backwards-compatible behavior is not enabled,
this is a static error <!--<xerrorref spec="XP" class="ST" code="0017"/>-->[XPST0017].</p></note> 

					<note>
						<p>There is no prohibition on calling extension functions that
have side-effects (for example, an extension function that writes data to a file). However,
the order of execution of XSLT instructions is not defined in this specification, so the
effects of such functions are unpredictable.</p>
					</note>
					<p>Implementations are not <rfc2119>required</rfc2119> to perform full validation
of values returned by extension functions. It is an error for
an extension function to return a string containing characters that are not permitted
in XML, but the consequences of this error are 
<termref def="dt-implementation-defined">implementation-defined</termref>. The implementation
<rfc2119>may</rfc2119> raise an error, <rfc2119>may</rfc2119> convert the string to a string containing valid characters only, or <rfc2119>may</rfc2119>
treat the invalid characters as if they were permitted characters.</p>

<!-- TODO: this seems inconsistent with the serialization spec -->

<imp-def-feature>The effect of an extension function returning a string containing
characters that are not legal in XML is implementation-defined.</imp-def-feature>
					<note>
						<p>The ability to execute extension functions represents a
potential security weakness, since untrusted stylesheets may invoke code that has
privileged access to resources on the machine where the
 <termref def="dt-processor">processor</termref> executes. 
Implementations may therefore provide mechanisms that restrict the use of
extension functions by untrusted stylesheets.</p>
					</note>
<p diff="add" at="U">All observations in this section regarding the errors that can occur
when invoking extension functions apply equally when invoking 
<termref def="dt-extension-instruction">extension instructions</termref>.</p>					
				</div3>
				<div3 id="external-objects">
					<head>External Objects</head>
					
					<p>An implementation <rfc2119>may</rfc2119> allow an extension function to return
an object that does not have any natural representation in the <phrase diff="chg" at="Z">XDM</phrase> data model,
either as an atomic value or as a node. For example, an extension function <code>sql:connect</code> might
return an object that represents a connection to a relational database; the resulting
connection object might be passed as an argument to calls on other extension functions
such as <code>sql:insert</code> and <code>sql:select</code>.</p>
					<p>The way in which such objects are represented in the type
system is <termref def="dt-implementation-defined">implementation-defined</termref>.
They might be represented by a completely new data type, or they might be mapped to existing
data types such as <code>integer</code>, <code>string</code>, or <code>anyURI</code>.</p>
					<imp-def-feature>The way in which external objects are represented in the type
system is implementation-defined.</imp-def-feature>
					

				</div3>


			<div3 id="testing-type-availability" diff="add" at="ZB">
					<head>Testing Availability of Types</head>
					<p>The <function>type-available</function> function 
can be used, for example with the
<code>[xsl:]use-when</code> attribute (see <specref ref="conditional-inclusion"/>), to
explicitly control how a stylesheet behaves if a particular
schema type is not available in the static context.</p>
					<proto class="xslt" name="type-available" return-type="xs:boolean">
						<arg name="type-name" type="xs:string"/>
					</proto>		

<p>A schema type (that is, a simple type or a complex type) is said to be
available within an XPath expression if it is a type definition that is present
in the <xtermref spec="XP" ref="dt-is-types">in-scope schema types</xtermref>
 for that expression (see <specref ref="static-context"/>). This includes built-in types, types imported using
<elcode>xsl:import-schema</elcode>, and extension types defined by the
implementation.</p>
					

<p>The value of the <code>$type-name</code> argument <rfc2119>must</rfc2119> be a string containing 
a <termref def="dt-lexical-qname">lexical QName</termref>. 
The lexical QName is expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> using the
namespace declarations in scope for the <termref def="dt-expression">expression</termref>. 
If the lexical QName is unprefixed, then the 
default namespace is used in the expanded QName.</p>

					<p>The function
returns true if and only if there is an available type whose name matches the value of the 
<code>$type-name</code> argument. </p>


<p><error spec="XT" type="dynamic" class="DE" code="1428"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> 
if the argument 
<error.extra>passed to the <function>type-available</function> function</error.extra>
does not evaluate to a string that is a valid <termref def="dt-qname">QName</termref>,
or if there is no namespace declaration in scope for the prefix of the <termref def="dt-qname">QName</termref>.
 If the processor is able to detect the error statically (for example, when the argument is
 supplied as a string literal), then the processor <rfc2119>may</rfc2119> optionally signal this 
 as a <termref def="dt-static-error">static error</termref>.</p></error>
					</p>

					</div3>




			</div2>
			<div2 id="extension-instruction">
				<head>Extension Instructions</head>
				<p>
					<termdef id="dt-extension-namespace" term="extension namespace">The
<termref def="dt-extension-instruction">extension instruction</termref> mechanism allows namespaces to be designated as
<term>extension namespaces</term>. When a namespace is designated as
an extension namespace and an element with a name from that namespace
occurs in a <termref def="dt-sequence-constructor">sequence constructor</termref>,
 then the element is treated as an <termref def="dt-instruction">instruction</termref>
rather than as a <termref def="dt-literal-result-element">literal result element</termref>.</termdef> The namespace
determines the semantics of the instruction.</p>
				<note>
					<p>Since an element that is a child of an
<elcode>xsl:stylesheet</elcode> element is not occurring <emph>in a
<termref def="dt-sequence-constructor">sequence constructor</termref></emph>, 
 <termref def="dt-data-element">user-defined data elements</termref>
(see <specref ref="user-defined-top-level"/>) are not extension
elements as defined here, and nothing in this section applies to
them.</p>
				</note>
				<div3 id="designating-extension-namespace">
					<head>Designating an Extension Namespace</head>
					<p>A namespace is designated as an extension namespace by using an
<code>[xsl:]extension-element-prefixes</code> attribute on an
element in the stylesheet (see <specref ref="standard-attributes"/>). 
The attribute <rfc2119>must</rfc2119> be in the XSLT namespace
only if its parent element is <emph>not</emph> in the XSLT namespace.
The value of the attribute is a
whitespace-separated list of namespace prefixes. The namespace bound
to each of the prefixes is designated as an extension namespace.</p>

<p>The default namespace (as declared by <code>xmlns</code>) may be designated as an
extension namespace by including <code>#default</code> in the list of
namespace prefixes.</p>

<!-- TODO: should clarify whether "default namespace" here includes the null namespace -->

<p><error spec="XT" type="static" class="SE" code="1430"><p>It
is a <termref def="dt-static-error">static error</termref>
 if there is no namespace bound to the prefix on the
element bearing the <code>[xsl:]extension-element-prefixes</code> attribute
<phrase diff="add" at="ZB">or, when <code>#default</code> is specified,
if there is no default namespace</phrase>.</p></error></p>  

<p>The designation of a namespace as an extension
namespace is effective for
the element bearing the <code>[xsl:]extension-element-prefixes</code> attribute
and for all descendants of that element within the same stylesheet module.</p>
				</div3>
				<div3 id="testing-instruction-available">
					<head>Testing Availability of Instructions</head>
					<p>The <function>element-available</function> function can be used with the
<elcode>xsl:choose</elcode> and <elcode>xsl:if</elcode> instructions<phrase diff="add" at="T">, or with the
<code>[xsl:]use-when</code> attribute (see <specref ref="conditional-inclusion"/>) to
explicitly control how a stylesheet behaves when a particular
XSLT instruction or extension instruction is (or is not) available.</phrase></p>
					<proto class="xslt" name="element-available" return-type="xs:boolean">
						<arg name="element-name" type="xs:string"/>
					</proto>
					<p>The value of the <code>$element-name</code> argument <rfc2119>must</rfc2119> be a string containing a <termref def="dt-qname">QName</termref>.
The <termref def="dt-qname">QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> using the
namespace declarations in scope for the <termref def="dt-expression">expression</termref>. If there is a default namespace in scope,
then it is used to expand an unprefixed <termref def="dt-qname">QName</termref>. The
<function>element-available</function> function returns true if and
only if the <termref def="dt-expanded-qname">expanded-QName</termref> is the name of an <termref def="dt-instruction">instruction</termref>.  If the
<termref def="dt-expanded-qname">expanded-QName</termref> has a namespace URI equal to 
the <termref def="dt-xslt-namespace">XSLT namespace</termref> URI,
then it refers to an element defined by XSLT.  Otherwise, it refers to
an <termref def="dt-extension-instruction">extension instruction</termref>. If the <termref def="dt-expanded-qname">expanded-QName</termref> has a null namespace URI,
the <function>element-available</function> function will return
false.</p>
<p diff="chg" at="X"><error spec="XT" type="dynamic" class="DE" code="1440"><p>It is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
 argument 
<error.extra>passed to the <function>element-available</function> function</error.extra>
does not evaluate to a string that is a valid <termref def="dt-qname">QName</termref>,
or if there is no namespace declaration in scope for the prefix of the <termref def="dt-qname">QName</termref>. 
 If the processor is able to detect the error statically (for example, when the argument is
 supplied as a string literal), then the processor <rfc2119>may</rfc2119> optionally signal this 
 as a <termref def="dt-static-error">static error</termref>.</p></error>
					</p>
					
<p diff="add" at="ZA">If the <termref def="dt-expanded-qname">expanded-QName</termref> 
is in the <termref def="dt-xslt-namespace">XSLT namespace</termref>, the function returns true if
and only if the expanded QName is the name of an <termref def="dt-xslt-instruction">XSLT instruction</termref>, 
that is,
an <termref def="dt-xslt-element">XSLT element</termref> whose syntax summary in this specification 
classifies it as
an <termref def="dt-instruction">instruction</termref>.</p>

<note diff="add" at="ZA"><p>Although the result of applying this function to a name in the
XSLT namespace when using a conformant
XSLT 2.0 processor is entirely predictable, the function is useful in cases
where the stylesheet might be executing under a processor that implements some
other version of XSLT with different rules.</p></note>

<p diff="add" at="ZA">If the <termref def="dt-expanded-qname">expanded-QName</termref> 
is not in the <termref def="dt-xslt-namespace">XSLT namespace</termref>, the function returns true
if and only if the processor has an implementation available of an 
<termref def="dt-extension-instruction">extension instruction</termref>
 with the given expanded QName. This applies whether or not the
namespace has been designated as an <termref def="dt-extension-namespace">extension namespace</termref>.</p>

<p diff="add" at="ZA">If the processor does not have an implementation of a particular extension
instruction available, and such an extension instruction is evaluated, then the
processor <rfc2119>must</rfc2119> perform fallback for the element as specified in <specref ref="fallback"/>. 
An implementation <rfc2119>must not</rfc2119> signal an error merely because the
stylesheet contains an extension instruction for which no implementation is
available.</p>

<!-- TODO: clarify that the result of element-available() does not depend on designating the namespace as
an extension element namespace -->

				</div3>
				<div3 id="fallback">
					<head>Fallback</head>
					<e:element-syntax name="fallback">
						<e:in-category name="instruction"/>
						<e:model name="sequence-constructor"/>
						<e:allowed-parents>
							<e:parent-category name="sequence-constructor"/>
						</e:allowed-parents>
					</e:element-syntax>
	
					<p>The content of an <elcode>xsl:fallback</elcode> element is a
 <termref def="dt-sequence-constructor">sequence constructor</termref>,
  and when performing fallback, the value
 returned by the <elcode>xsl:fallback</elcode> element
is the result of evaluating this sequence constructor.</p>
					<p>When not performing fallback, evaluating an <elcode>xsl:fallback</elcode> element returns
an empty sequence: the content of the <elcode>xsl:fallback</elcode> element is ignored.</p>
					<p>There are two situations where a
 <termref def="dt-processor">processor</termref> performs fallback: when an
 extension instruction that is not available is evaluated, and when an instruction
 in the XSLT namespace, that is not defined in XSLT 2.0, is evaluated within a 
 region of the stylesheet for which <termref def="dt-forwards-compatible-behavior">forwards
 compatible behavior</termref> is enabled.</p>
 
 <note><p>Fallback processing is not invoked in other situations, for example
 it is not invoked when an XPath expression uses unrecognized syntax or
 contains a call to an unknown function. To handle such situations dynamically, the stylesheet should 
 call functions such as
  <function>system-property</function> and <function>function-available</function> to decide what
  capabilities are available.</p></note>

 <p diff="chg" at="ZA"><error spec="XT" type="dynamic" class="DE" code="1450"><p>When a
  <termref def="dt-processor">processor</termref> performs fallback for an
<termref def="dt-extension-instruction">extension instruction</termref> that is not recognized, 
if the instruction element has one or more
<elcode>xsl:fallback</elcode> children, then the content of each of the
<elcode>xsl:fallback</elcode> children <rfc2119>must</rfc2119> be evaluated; it is a
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if it has no <elcode>xsl:fallback</elcode> children.</p></error>
					</p>

<note diff="add" at="ZA"><p>This is different from the situation with unrecognized 
<termref def="dt-xslt-element">XSLT elements</termref>. As explained
in <specref ref="forwards"/>, an unrecognized XSLT element appearing within a 
<termref def="dt-sequence-constructor">sequence constructor</termref> is a static
error unless (a) <termref def="dt-forwards-compatible-behavior">forwards-compatible behavior</termref>
is enabled, and (b) the instruction has an <elcode>xsl:fallback</elcode> child.</p></note>
					
				</div3>
			</div2>
		</div1>
		<div1 id="result-trees">
			<head>Final Result Trees</head>
			<p>The output of a transformation is a set of <phrase diff="chg" at="ZC">one</phrase> or more 
      <termref def="dt-final-result-tree">final result trees</termref>.</p>
			
			<p>A <termref def="dt-final-result-tree">final result tree</termref> 
      can be created explicitly, by evaluating an
<elcode>xsl:result-document</elcode> instruction. 
<phrase diff="add" at="ZC">As explained in <specref ref="executing-a-transformation"/>,</phrase> 
a final result tree is also created implicitly if no
<elcode>xsl:result-document</elcode> instruction is evaluated, or if the
result of evaluating the <termref def="dt-initial-template">initial template</termref> is a non-empty sequence. 
</p>

			<p>The way in which a <termref def="dt-final-result-tree">final result tree</termref> is delivered to an application
is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
			<imp-def-feature>The way in which a final result tree is delivered to an
application is implementation-defined.</imp-def-feature>

			<p>Serialization of <termref def="dt-final-result-tree">final result trees</termref> 
      is described further in <specref ref="serialization"/>
			</p>
			
			<div2 id="creating-result-trees">
				<head>Creating Final Result Trees</head>
				<e:element-syntax name="result-document" diff="chg" at="Z">
					<e:in-category name="instruction"/>
					<e:attribute name="format">
					  <e:attribute-value-template>
						<e:data-type name="qname"/>   
					  </e:attribute-value-template> 
					</e:attribute>
					<e:attribute name="href">
						<e:attribute-value-template>
							<e:data-type name="uri-reference"/>
						</e:attribute-value-template>
					</e:attribute>
					<e:attribute name="validation">
						<e:constant value="strict"/>
						<e:constant value="lax"/>
						<e:constant value="preserve"/>
						<e:constant value="strip"/>
					</e:attribute>
    			<e:attribute name="type">
    				<e:data-type name="qname"/>
    			</e:attribute>
  			  <e:attribute name="method">
            <e:attribute-value-template>
    					<e:constant value="xml"/>
    					<e:constant value="html"/>
    					<e:constant value="xhtml"/>
    					<e:constant value="text"/>
    					<e:data-type name="qname-but-not-ncname"/>
            </e:attribute-value-template>
  				</e:attribute>
				<e:attribute name="byte-order-mark">
				  <e:attribute-value-template>
						<e:constant value="yes"/>
						<e:constant value="no"/>
					</e:attribute-value-template>
				</e:attribute>
  				<e:attribute name="cdata-section-elements">
            <e:attribute-value-template>
  					  <e:data-type name="qnames"/>
            </e:attribute-value-template>
  				</e:attribute>
  				<e:attribute name="doctype-public">
            <e:attribute-value-template>
    					<e:data-type name="string"/>
            </e:attribute-value-template>
  				</e:attribute>
  				<e:attribute name="doctype-system">
            <e:attribute-value-template>
    					<e:data-type name="string"/>
  	        </e:attribute-value-template>
    			</e:attribute>
  				<e:attribute name="encoding">
            <e:attribute-value-template>
    					<e:data-type name="string"/>
            </e:attribute-value-template>
  				</e:attribute>
  				<e:attribute name="escape-uri-attributes">
            <e:attribute-value-template> 
    					<e:constant value="yes"/>
  	  				<e:constant value="no"/>
            </e:attribute-value-template>
  				</e:attribute>
  				<e:attribute name="include-content-type">
            <e:attribute-value-template>
  					  <e:constant value="yes"/>
  					  <e:constant value="no"/>
            </e:attribute-value-template>
  				</e:attribute>
  				<e:attribute name="indent">
            <e:attribute-value-template>
    					<e:constant value="yes"/>
  	  				<e:constant value="no"/>
  		      </e:attribute-value-template>
      		</e:attribute>
  				<e:attribute name="media-type">
            <e:attribute-value-template>
  					  <e:data-type name="string"/>
            </e:attribute-value-template>
  				</e:attribute>
  				<e:attribute name="normalization-form">
            <e:attribute-value-template>
    					<e:constant value="NFC"/>
  	  				<e:constant value="NFD"/>
  		  			<e:constant value="NFKC"/>
  			  		<e:constant value="NFKD"/>
  				  	<e:constant value="fully-normalized"/>
  					  <e:constant value="none"/>
  					  <e:data-type name="nmtoken"/>
            </e:attribute-value-template>
  				</e:attribute>
  				<e:attribute name="omit-xml-declaration">
            <e:attribute-value-template>
    					<e:constant value="yes"/>
  	  				<e:constant value="no"/>
  		      </e:attribute-value-template>
      		</e:attribute>
  				<e:attribute name="standalone">
            <e:attribute-value-template>
    					<e:constant value="yes"/>
  	  				<e:constant value="no"/>
  	  				<e:constant value="omit"/>
  		      </e:attribute-value-template>
  				</e:attribute>
  				<e:attribute name="undeclare-prefixes">
            <e:attribute-value-template>
    					<e:constant value="yes"/>
  	  				<e:constant value="no"/>
  		      </e:attribute-value-template>
  				</e:attribute>				
  				<e:attribute name="use-character-maps">
  				  <e:data-type name="qnames"/>
  				</e:attribute>
  				<e:attribute name="output-version">
            <e:attribute-value-template>
  					  <e:data-type name="nmtoken"/>
            </e:attribute-value-template>
  				</e:attribute>	  
  				<e:model name="sequence-constructor"/>
					<e:allowed-parents>
						<e:parent-category name="sequence-constructor"/>
					</e:allowed-parents>
				</e:element-syntax>

				<p>The <elcode>xsl:result-document</elcode> instruction is used to create a
 <termref def="dt-final-result-tree">final result tree</termref>. The content of the
<elcode>xsl:result-document</elcode> element is a 
<termref def="dt-sequence-constructor">sequence constructor</termref> 
for the children of the document node of the tree.
A document node is created, and 
the sequence obtained by evaluating the sequence constructor is used to construct
the content of the document, as described in <specref ref="constructing-complex-content"/>.
The tree rooted at this document node forms the final result tree.</p>

				<p>The <elcode>xsl:result-document</elcode> instruction defines the URI
 of the result
tree, and may optionally specify the output format to be used for serializing this tree.</p>
<p>The <phrase diff="chg" at="Z"><termref def="dt-effective-value">effective value</termref></phrase>
 of the <code>format</code> attribute, if specified, <rfc2119>must</rfc2119> be a 
 <termref def="dt-lexical-qname">lexical QName</termref>.
The QName is expanded using the namespace declarations in scope for the 
<elcode>xsl:result-document</elcode> element. 
The <termref def="dt-expanded-qname">expanded-QName</termref> <rfc2119>must</rfc2119> match the expanded
QName of a named <termref def="dt-output-definition">output definition</termref> in the <termref def="dt-stylesheet">stylesheet</termref>. 
This identifies
the <elcode>xsl:output</elcode> declaration that will control the serialization of the
<termref def="dt-final-result-tree">final result tree</termref>
 (see <specref ref="serialization"/>), if the result tree is serialized. If the
<code>format</code> attribute is omitted, the unnamed
 <termref def="dt-output-definition">output definition</termref>
is used to control serialization of the result tree.</p>
				
<p><error spec="XT" type="dynamic" class="DE" code="1460" diff="chg" at="Z"><p>It is
 a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
error</termref> if the <termref def="dt-effective-value">effective value</termref>
 of the <code>format</code> attribute 
<error.extra>of an <elcode>xsl:result-document</elcode> element</error.extra>
is not a valid <termref def="dt-lexical-qname">lexical QName</termref>, 
or if it does not match the <termref def="dt-expanded-qname">expanded-QName</termref> of an 
<termref def="dt-output-definition">output definition</termref> in the
 <termref def="dt-stylesheet">stylesheet</termref>.
 If the processor is able to detect the error statically (for example, when the <code>format</code> attribute 
 contains no curly brackets), then the processor <rfc2119>may</rfc2119> optionally signal this 
 as a <termref def="dt-static-error">static error</termref>.</p></error>
</p>

<note diff="add" at="Z"><p>The only way to select the unnamed <termref def="dt-output-definition">output definition</termref>
is to omit the <code>format</code> attribute.</p></note>

<p>The attributes <code>method</code>, 
<code>byte-order-mark</code>
<code>cdata-section-elements</code>, 
<code>doctype-public</code>, 
<code>doctype-system</code>, 
<code>encoding</code>, 
<code>escape-uri-attributes</code>, 
<code>indent</code>, 
<code>media-type</code>, 
<code>normalization-form</code>, 
<code>omit-xml-declaration</code>, 
<code>standalone</code>, 
<code>undeclare-prefixes</code>, 
<code>use-character-maps</code>, and
<code>output-version</code> may be used to override attributes defined in the selected
<termref def="dt-output-definition">output definition</termref>.</p>

<p>With the exception of <code>use-character-maps</code>, these attributes
are all defined as <termref def="dt-attribute-value-template">attribute value templates</termref>,
so their values may be set dynamically. For any of these attributes
that is present on the <elcode>xsl:result-document</elcode> instruction, the 
<termref def="dt-effective-value">effective value</termref> of the attribute overrides 
or supplements the corresponding value from the output definition. This works in the same way
as when one <elcode>xsl:output</elcode> declaration overrides another:</p>

<ulist>
<item><p>In the case of <code>cdata-section-elements</code>, the value of the
serialization parameter is the union of the expanded names of the elements named in this instruction and the
elements named in the selected output definition;</p></item>
<item><p>In the case of <code>use-character-maps</code>, the character maps referenced in
this instruction supplement and take precedence over those defined in the selected output
 definition;</p></item>
<item><p>In all other cases, the effective value of an attribute actually present on this 
instruction takes precedence over the value defined in the selected output definition.</p></item>
</ulist>

<note><p>In the case of the attributes <code>method</code>, <code>cdata-section-elements</code>,
<phrase diff="add" at="Z">and <code>use-character-maps</code>,</phrase>
the <termref def="dt-effective-value">effective value</termref> of the attribute contains 
one or more lexical QNames. The prefix in such a QName is expanded using the
in-scope namespaces for the <code>xsl:result-document</code> element. In the case of  
<code>cdata-section-elements</code>, an unprefixed element name is expanded using the default
namespace.</p></note>

<p>The <code>output-version</code> attribute
on the <elcode>xsl:result-document</elcode> instruction overrides the <code>version</code>
attribute on <elcode>xsl:output</elcode> (it has been renamed because <code>version</code>
is available with a different meaning as a standard attribute: 
see <specref ref="standard-attributes"/>). In all other cases, attributes correspond if
they have the same name.</p>

<p diff="add" at="ZA">There are some serialization parameters that apply to some output methods but not to 
others. For example, the <code>indent</code> attribute has no effect on the <code>text</code> output method.
If a value is supplied for an attribute that is inapplicable to the output method, its value is 
<phrase diff="chg" at="ZB">not passed to the serializer</phrase>.
The processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not <rfc2119>required</rfc2119>
to do so.</p>



				
<p>The <code>href</code> attribute is 
optional. The default value is the zero-length string. 
The <termref def="dt-effective-value">effective value</termref> of the attribute <rfc2119>must</rfc2119> be a
<termref def="dt-uri-reference">URI Reference</termref>, which may be absolute or relative. 
There <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined">implementation-defined</termref>
restrictions on the form of absolute URI
that may be used, but the implementation is not <rfc2119>required</rfc2119> to enforce any restrictions.
Any legal relative URI <rfc2119>must</rfc2119> be accepted. Note that the zero-length string
is a legal relative URI.</p>
 
			<p diff="chg" at="X">The base URI of the document node at the root of the
       <termref def="dt-final-result-tree">final result tree</termref>
       is based on the
      <termref def="dt-effective-value">effective value</termref> of the <code>href</code> attribute. 
      If the <termref def="dt-effective-value">effective value</termref> is a relative URI, then
it is resolved relative to the <termref def="dt-base-output-uri">base output URI</termref>.
      If the implementation provides an API to access final result
trees, then it <rfc2119>must</rfc2119> allow a final result tree to be identified by means of this base URI.</p>
			<note>
				<p>The base URI of the
<termref def="dt-final-result-tree">final result tree</termref> is not 
<phrase diff="add" at="T">necessarily</phrase> the same thing as the URI of its serialized representation on disk, if any.
For example, a server (or browser client) might store final result trees only in memory, or
in an internal disk cache. 
As long as <phrase diff="chg" at="T">the processor</phrase>
 satisfies requests for those URIs, it is irrelevant where they are actually written
on disk, if at all.</p>
			</note>
			
			<note>
				<p>It will often be the case that one <termref def="dt-final-result-tree">final result tree</termref> 
        contains links to another final result tree produced
during the same transformation, in the form of a relative URI. The mechanism of associating a URI with
a final result tree has been chosen to allow the integrity of such links to be preserved when the
trees are serialized.</p>
      <p diff="add" at="X">As well as being potentially significant in any API that provides access to final
      result trees, the base URI of the new document node is relevant if the final result tree, rather than
      being serialized, is supplied as input to a further transformation.</p>
			</note>


<p>The optional attributes <code>type</code> and <code>validation</code> may 
be used on the <elcode>xsl:result-document</elcode>
instruction to validate the contents of the new document, and to
determine the <termref def="dt-annotation">type annotation</termref> that elements and attributes within the
 <termref def="dt-final-result-tree">final result tree</termref> will carry.
The permitted values and their semantics are described in
<specref ref="validating-document-nodes"/>.</p>
 
		

 
<p>A <termref def="dt-processor">processor</termref> <rfc2119>may</rfc2119> allow a
 <termref def="dt-final-result-tree">final result tree</termref> to be serialized.
Serialization is described in <specref ref="serialization"/>.
However, an implementation (for example,
a <termref def="dt-processor">processor</termref> running in an environment with no access
to writable filestore) is not <rfc2119>required</rfc2119> to 
support the serialization of <termref def="dt-final-result-tree">final result trees</termref>. 
An implementation that does not support
the serialization of final result trees <rfc2119>may</rfc2119> ignore the <code>format</code> attribute
<phrase diff="add" at="T">and the serialization attributes</phrase>. 
Such an implementation
<rfc2119>must</rfc2119> provide the application with some means of access to the (un-serialized) result tree,
using its URI to identify it.</p>

<p>Implementations may provide additional mechanisms, outside the scope
of this specification, for defining the way in which 
<termref def="dt-final-result-tree">final result trees</termref> are processed. Such mechanisms
<rfc2119>may</rfc2119> make use of the XSLT-defined attributes on the <elcode>xsl:result-document</elcode> and/or 
<elcode>xsl:output</elcode> elements, or they <rfc2119>may</rfc2119> use additional elements or attributes in
an <termref def="dt-implementation-defined">implementation-defined</termref> namespace.</p>

<imp-def-feature>Implementations <rfc2119>may</rfc2119> provide additional mechanisms allowing users to define the way in which
<termref def="dt-final-result-tree">final result trees</termref> are processed.</imp-def-feature>
 
				<example><head>Multiple Result Documents</head>
					<p>
					The following example takes an XHTML document as input, and breaks it up so that the text
					following each &lt;h1&gt; element is included in a separate document. A new document <code>toc.html</code>
					is constructed to act as an index:</p>

					<eg><![CDATA[<xsl:stylesheet
	version="2.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xhtml="http://www.w3.org/1999/xhtml">
	
<xsl:output name="toc-format" method="xhtml" indent="yes"
            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
            doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/>
            
<xsl:output name="section-format" method="xhtml" indent="no"
            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
            doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/>	
	 
<xsl:template match="/">
  <xsl:result-document href="toc.html" format="toc-format" validation="strict">
    <html xmlns="http://www.w3.org/1999/xhtml">
      <head><title>Table of Contents</title></head>
      <body>
        <h1>Table of Contents</h1>
        <xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)">
          <p><a href="section{position()}.html"><xsl:value-of select="."/></a></p>
        </xsl:for-each>
      </body>
    </html>
  </xsl:result-document>
  <xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1">
    <xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip">  	
      <html xmlns="http://www.w3.org/1999/xhtml">
        <head><title><xsl:value-of select="."/></title></head>
        <body>
          <xsl:copy-of select="current-group()"/>
        </body>
      </html>
    </xsl:result-document>
  </xsl:for-each-group>
</xsl:template>

</xsl:stylesheet>]]></eg>
				</example>
				
				
<p>There are restrictions on the use of the <elcode>xsl:result-document</elcode>
instruction, designed to ensure that the results are fully interoperable even when processors
optimize the sequence in which instructions are evaluated. Informally, the restriction is that 
the <elcode>xsl:result-document</elcode> instruction can only be used while writing a final result
tree, not while writing to a temporary tree or a sequence. This restriction is defined formally as follows.</p>

<p><termdef id="dt-output-state" term="output state">Each instruction
in the <termref def="dt-stylesheet">stylesheet</termref> is evaluated in one of two possible <term>output states</term>:
<termref def="dt-final-output-state">final output state</termref> or 
<termref def="dt-temporary-output-state">temporary output state</termref></termdef>.</p>

<p><termdef id="dt-final-output-state" term="final output state">The first of the two 
<termref def="dt-output-state">output states</termref>
is called <term>final output</term> state. This state applies when 
instructions are writing to a 
<termref def="dt-final-result-tree">final result tree</termref>.</termdef></p>

<p><termdef id="dt-temporary-output-state" term="temporary output state">The second of the two 
<termref def="dt-output-state">output states</termref>
is called <term>temporary output</term> state. This state applies when 
instructions are writing to a <termref def="dt-temporary-tree">temporary tree</termref>
or any other non-final destination.</termdef></p>

<p>The instructions in the <termref def="dt-initial-template">initial template</termref>
are evaluated in <termref def="dt-final-output-state">final output state</termref>. 
An instruction is evaluated in the same <termref def="dt-output-state">output state</termref>
as its calling instruction, except that <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>,
<elcode>xsl:with-param</elcode>, <elcode>xsl:attribute</elcode>,
<elcode>xsl:comment</elcode>, <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:namespace</elcode>,
<elcode>xsl:value-of</elcode>, 
<elcode>xsl:function</elcode>, <elcode>xsl:key</elcode>, <elcode>xsl:sort</elcode>,
and <elcode>xsl:message</elcode> always evaluate the instructions in their contained 
<termref def="dt-sequence-constructor">sequence constructor</termref> in
 <termref def="dt-temporary-output-state">temporary output state</termref>.</p>

<p><error spec="XT" type="dynamic" class="DE" code="1480"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
error</termref> to evaluate the <elcode>xsl:result-document</elcode> instruction in 
<termref def="dt-temporary-output-state">temporary output state</termref>.</p></error></p>

<p><error spec="XT" type="dynamic" class="DE" code="1490"><p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
error</termref> for a transformation to generate two or more 
<termref def="dt-final-result-tree">final result trees</termref> with the same URI.</p></error>
</p>
				<note diff="chg" at="Q">
					<p>Note, this means that it is an error to evaluate more than one <elcode>xsl:result-document</elcode>
instruction that omits the <code>href</code> attribute, or to evaluate any <elcode>xsl:result-document</elcode>
instruction that omits the <code>href</code> attribute if an initial
 <termref def="dt-final-result-tree">final result tree</termref> is created implicitly.</p>
				</note>
				<p>Technically, the result of evaluating the <elcode>xsl:result-document</elcode>
instruction is an empty sequence. This means it does not contribute any nodes to
the result of the <phrase diff="chg" at="Q">sequence</phrase> constructor it is part of.</p>
				

<p diff="add" at="U"><error spec="XT" type="dynamic" class="RE" code="1495"><p>It 
is a <termref def="dt-recoverable-error">recoverable dynamic
error</termref> for a transformation to generate two or more 
<termref def="dt-final-result-tree">final result trees</termref>  
with URIs that identify the same physical resource. The 
<termref def="dt-optional-recovery-action">optional recovery action</termref>
is <termref def="dt-implementation-dependent">implementation-dependent</termref>,
since it may be impossible for the processor to detect the error.</p></error>
</p>
				<p>
					<error spec="XT" type="dynamic" class="RE" code="1500"><p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
for a <termref def="dt-stylesheet">stylesheet</termref> to write to an external resource and read from the same resource during a single
transformation, whether or not the same URI is used to access the resource in both cases. <error.action>The
<termref def="dt-optional-recovery-action">optional recovery action</termref> is <termref def="dt-implementation-dependent">implementation-dependent</termref>: 
implementations are not <rfc2119 diff="chg" at="T">required</rfc2119> to detect the error condition.
<phrase diff="add" at="X">Note that if the error is not detected, it is undefined whether the document that is read from the resource 
reflects its state before or after the result tree is written.</phrase></error.action>
					</p></error>
				</p>

			</div2>
			
			<div2 id="validation">
			<head>Validation</head>
			
<p>It is possible to control the <termref def="dt-annotation">type annotation</termref> applied to individual element and
 attribute nodes as they are constructed. 
This is done using the <code>type</code> and <code>validation</code> attributes of 
the <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>,
<elcode>xsl:copy-of</elcode>, <phrase diff="add" at="Y"><elcode>xsl:document</elcode></phrase>, and <elcode>xsl:result-document</elcode> instructions, 
or the <code>xsl:type</code> and <code>xsl:validation</code> attributes of a 
<termref def="dt-literal-result-element">literal result element</termref>.</p>

<p diff="add" at="T">The <code>[xsl:]type</code> attribute is used to request validation
of an element or attribute against a specific simple or complex type defined in a schema. 
The <code>[xsl:]validation</code>
attribute is used to request validation against the global element or attribute declaration 
whose name matches the name of the element or attribute being validated.</p>

<p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are mutually
exclusive. Both are optional, but if one is present then the other <rfc2119>must</rfc2119> be omitted. If both
attributes are omitted, the effect is the same as specifying the <code>validation</code> attribute
with the value specified in the <code>default-validation</code> attribute of the containing
<elcode>xsl:stylesheet</elcode> element; if this is not specified, the effect is the same as
specifying <code>validation="strip"</code>.</p>

<p><error spec="XT" type="static" class="SE" code="1505"><p>It is a
 <termref def="dt-static-error">static error</termref> if both the 
<code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are present on 
the <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>,
<elcode>xsl:copy-of</elcode>, <phrase diff="add" at="Y"><elcode>xsl:document</elcode></phrase>, or <elcode>xsl:result-document</elcode>
 instructions, 
or on a <termref def="dt-literal-result-element">literal result element</termref>.</p></error></p>

<p>The detailed rules for validation vary depending on the kind of node being
validated. The rules for element and attribute nodes are given in <specref ref="validating-constructed-nodes"/>,
while those for document nodes are given in <specref ref="validating-document-nodes"/>.</p>

<div3 id="validating-constructed-nodes">
<head>Validating Constructed Elements and Attributes</head>

<div4 id="validating-using-validation-attribute">
<head>Validation using the <code>[xsl:]validation</code> Attribute</head>		

<p>The <code>[xsl:]validation</code> attribute defines the validation action to be taken. It determines not only 
the <termref def="dt-annotation">type annotation</termref> of the node that is constructed by the relevant instruction
itself, but also the type annotations of all element and attribute nodes that have the constructed
node as an ancestor. Conceptually, the validation requested for a child element or attribute node is
applied before the validation requested for its parent element. For example, if the instruction that
constructs a child element specifies <code>validation="strict"</code>, this will cause the 
 child element to be checked against an element declaration,
but if the instruction that constructs its parent element specifies <code>validation="strip"</code>,
then the final effect will be that the child node is annotated as 
<phrase diff="chg" at="ZA"><code>xs:untyped</code></phrase>.</p>

<p>In the paragraphs below, the term <emph>contained nodes</emph> means the elements and attributes
that have the newly constructed node as an ancestor.</p>

<ulist>
<item><p>The value <code>strip</code> indicates that the new node and each of the contained nodes
will have the <termref def="dt-annotation">type annotation</termref> 
<phrase diff="chg" at="ZA"><code>xs:untyped</code></phrase>
 if it is an element, or <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>
if it is an attribute. Any previous type annotation present on a contained element or attribute node 
(for example, a type annotation that is present on an element copied from a source document) 
is also replaced by <phrase diff="chg" at="ZA"><code>xs:untyped</code></phrase>
or <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase> as appropriate. 
<phrase diff="add" at="ZA">The typed value of the node is changed to be the same as its string value,
as an instance of <code>xs:untypedAtomic</code>. In the case of elements the <code>nilled</code> property
is set to <code>false</code>. The values of the <code>is-id</code> and <code>is-idrefs</code> properties
are unchanged.</phrase> Schema validation is not invoked.</p></item>

<item><p>The value <code>preserve</code> indicates that nodes that are copied will
retain their <termref def="dt-annotation">type annotations</termref>, but nodes whose content is newly constructed will be 
annotated as <code>xs:anyType</code> in the case of 
elements, or <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>
in the case of attributes. Schema validation is not invoked.
The detailed effect depends on the instruction:</p>

  <ulist>
  <item><p>In the case of <elcode>xsl:element</elcode> and literal result elements,
  the new element has a <termref def="dt-annotation">type annotation</termref>
   of <code>xs:anyType</code>,  and the type
  annotations of contained nodes are retained unchanged.</p></item>
  <item><p>In the case of <elcode>xsl:attribute</elcode>, the effect is exactly the
  same as specifying <code>validation="strip"</code>: that is, the new attribute will 
  have the type annotation <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>.</p></item>
  <item><p>In the case of <elcode>xsl:copy-of</elcode>, all the nodes that are copied
  will retain their type annotations unchanged.</p></item>
  <item><p>In the case of <elcode>xsl:copy</elcode>, the effect depends on the kind of 
  node being copied.</p> 
     <olist>
     <item><p>Where the node being copied is an attribute, the copied attribute will retain its
  <termref def="dt-annotation">type annotation</termref>.</p></item>
     <item><p>Where the node being copied is an element, the copied element will have a 
  <termref def="dt-annotation">type annotation</termref> of <phrase diff="chg" at="T"><code>xs:anyType</code></phrase>
   (because this instruction does not copy the
  content of the element, it would be wrong to assume that the type is unchanged);
  but any contained nodes will have their type annotations retained
  in the same way as with <elcode>xsl:element</elcode>.</p></item>
     </olist>
  </item>
  </ulist>
</item>

<item><p>The value <code>strict</code> indicates that <termref def="dt-annotation">type annotations</termref> are
     established by performing strict schema validity assessment on the element or attribute 
     node created by this instruction as follows:</p>
     
     <ulist>
     <item><p>In the case of an element, <phrase diff="add" at="X">a top-level</phrase>
      element declaration is identified
     whose local name and namespace (if any) match the name of the element,
     and schema-validity assessment is carried out
     according to the rules defined in <bibref ref="xmlschema-1"/> 
     (section 3.3.4 <quote>Element Declaration Validation Rules</quote>, validation rule 
     <quote>Schema-Validity Assessment (Element)</quote>, clauses 1.1 and 2<phrase diff="add" at="X">,
     using the top-level element declaration as the "declaration stipulated by the processor", which is mentioned
     in clause 1.1.1.1</phrase>). 
     The element is considered valid if the result of the
     schema validity assessment is a PSVI in which the relevant element node has a <code>validity</code>
     property whose value is <code>valid</code>. If <phrase diff="add" at="X">there is no matching
     element declaration, or if </phrase>the element is not considered
     valid, the transformation fails <errorref class="TE" code="1510"/>, <errorref class="TE" code="1512"/>. 
     In effect this means that the element 
     being validated <rfc2119>must</rfc2119> be declared using a top-level declaration in the schema, and
     <rfc2119>must</rfc2119> conform to its declaration. The process of validation
     applies recursively to contained elements and attributes to the extent 
     required by the schema definition.</p>
     
	 <note diff="add" at="ZA"><p>It is not an error if the identified type definition is a simple type,
	 although <bibref ref="xmlschema-1"/> does not define explicitly that this case is permitted.</p></note>
     </item>

	 
     
     <item><p>In the case of an attribute, <phrase diff="add">a top-level</phrase>
      attribute declaration is identified
     whose local name and namespace (if any) match the name of the attribute,
     and schema-validity assessment is carried out
     according to the rules defined in <bibref ref="xmlschema-1"/> 
     (section
     3.2.4 <quote>Attribute Declaration Validation Rules</quote>, validation rule 
     <quote>Schema-Validity Assessment (Attribute)</quote>). 
     The attribute is considered valid if the result of the
     schema validity assessment is a PSVI in which the relevant attribute node has a <code>validity</code>
     property whose value is <code>valid</code>. If the attribute is not considered
     valid, the transformation fails <phrase diff="add" at="T"><errorref class="TE" code="1510"/></phrase>. 
     In effect this means that the attribute 
     being validated <rfc2119>must</rfc2119> be declared using a top-level declaration in the schema, and
     <rfc2119>must</rfc2119> conform to its declaration.</p>
     </item>       
     
     <item><p>The schema components used to validate an element or attribute may
     be located in any way <phrase diff="chg" at="T">described</phrase> by <bibref ref="xmlschema-1"/> (see section 4.3.2, 
     <emph>How schema documents are located on the Web</emph>). The components in the schema
     constructed from the synthetic schema document (see <specref ref="import-schema"/>) will
     always be available for validating constructed nodes; if additional schema components are 
     needed, they <rfc2119>may</rfc2119> <phrase diff="chg" at="T">be located in other ways,
     for example implicitly from knowledge
     of the namespace in which the elements and attributes appear, 
     or using the <code>xsi:schemaLocation</code> attribute of elements within the
     tree being validated.</phrase></p></item>
     
     <item><p>If no validation is performed for a node, which can happen when the schema 
     specifies <code>lax</code> or
     <code>skip</code> validation for that node or for a subtree, then the node is annotated as
      <phrase diff="chg" at="X"><code>xs:anyType</code></phrase> in the case
     of an element, and <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase> in the case of an attribute.</p></item>
     </ulist>
</item>

<item><p>The value <code>lax</code> has the same effect as the value
     <code>strict</code>, except that whereas <code>strict</code> validation fails 
     <phrase diff="add" at="X">if there is no matching top-level element declaration or</phrase>
     if the outcome of validity assessment is a <code>validity</code> property of <code>invalid</code>
     or <code>notKnown</code>,
     <code>lax</code> validation fails only if 
    the outcome of validity assessment is a <code>validity</code> property of <code>invalid</code>.
    That is, <code>lax</code> validation does not cause a type error when the outcome is
    <code>notKnown</code>.</p>
    
    <p>In practice this means that the element or
     attribute being validated <rfc2119>must</rfc2119> conform to its declaration if a top-level declaration
     is available. If no such declaration is available, then
     the element or attribute is not validated, but its attributes and children are validated, again
     with lax validation. Any nodes whose validation outcome is a <code>validity</code> property
     of <code>notKnown</code> are annotated as <phrase diff="chg" at="X"><code>xs:anyType</code></phrase>
      in the case
     of an element, and <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase> in the case of an attribute.</p>

<note diff="add" at="X"><p>When the parent element lacks a declaration, the XML Schema 
specification defines the recursive checking of children and attributes as optional. 
For this specification, this recursive checking is required.</p></note> 

<note diff="add" at="X"><p>If an element that is being validated has an <code>xsi:type</code> attribute,
then the value of the <code>xsi:type</code> attribute will be taken into account when performing the
validation. However, the presence of an <code>xsi:type</code> attribute will not of itself cause an element
to be validated: if validation against a named type is required, as distinct from validation against a top-level
element declaration, then it must be requested using the XSLT <code>[xsl:]type</code> attribute on
the instruction that invokes the validation, as described in section <specref ref="validation-xsl-type"/></p></note>
</item>

</ulist>

<p><error spec="XT" type="type" class="TE" code="1510"><p>If the <code>validation</code> attribute
of an <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>, 
<elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or <elcode>xsl:result-document</elcode>
 instruction, or the <code>xsl:validation</code> attribute
of a literal result element,
has the effective value <code>strict</code>, and  
schema validity assessment concludes that the validity of 
the element or attribute is invalid or unknown, a type
error occurs. As with other type
errors, the error <rfc2119>may</rfc2119> be signaled statically if it can be detected statically.
</p></error>
</p>

<p diff="add" at="X"><error spec="XT" type="type" class="TE" code="1512"><p>If the <code>validation</code> attribute
of an <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>, 
<elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or <elcode>xsl:result-document</elcode>
 instruction, or the <code>xsl:validation</code> attribute
of a literal result element,
has the effective value <code>strict</code>, and  
there is no matching top-level declaration in the schema, then a type
error occurs. As with other type
errors, the error <rfc2119>may</rfc2119> be signaled statically if it can be detected statically.
</p></error>
</p>

<p><error spec="XT" type="type" class="TE" code="1515"><p>If the <code>validation</code> attribute
of an <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>, 
<elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or <elcode>xsl:result-document</elcode>
 instruction, or the <code>xsl:validation</code> attribute
of a literal result element,
has the effective value <code>lax</code>, and  
schema validity assessment concludes that the element or attribute is invalid, a type
error occurs. As with other type
errors, the error <rfc2119>may</rfc2119> be signaled statically if it can be detected statically.
</p></error>
</p>


<note><p>No mechanism is provided to validate an element or attribute against a local declaration
in a schema. Such validation can usually be achieved by applying validation to a containing element
for which a top-level element declaration exists.</p></note>

</div4>
<div4 id="validation-xsl-type">
<head>Validation using the <code>[xsl:]type</code> Attribute</head>

<p>The <code>[xsl:]type</code> attribute takes as its value a <code>QName</code>. This <rfc2119>must</rfc2119> 
<phrase diff="chg" at="R">be the name of a type definition included in the 
<termref def="dt-in-scope-schema-component">in-scope schema components</termref> for the stylesheet.</phrase>
If the QName
has no prefix, it is expanded using the default namespace established using the effective 
<code>[xsl:]xpath-default-namespace</code> attribute if there is one; otherwise, it is taken as being a name
in no namespace.</p>

<p>If the <code>[xsl:]type</code> attribute is present, then the newly constructed 
element or attribute is
validated against the type definition identified by this attribute.</p>

   <ulist>
   <item><p>In the case of an element, schema-validity assessment is carried out
     according to the rules defined in <bibref ref="xmlschema-1"/> 
     (section 3.3.4 <quote>Element Declaration Validation Rules</quote>, validation rule 
     <quote>Schema-Validity Assessment (Element)</quote>, clauses 1.2 and 2),
     using this type definition as the <quote>processor-stipulated type definition</quote>. 
     The element is considered valid if the result of the
     schema validity assessment is a PSVI in which the relevant element node has a <code>validity</code>
     property whose value is <code>valid</code>. </p>
     </item>
   <item><p>In the case of an attribute, the attribute is considered valid if
   (in the terminology of XML Schema) the attribute's normalized value is locally valid
    with respect to that type definition according to the rules for <quote>String Valid</quote>
    (<bibref ref="xmlschema-1"/>, section 3.14.4). (Normalization here refers to the process
    of normalizing whitespace according to the rules of the <code>whiteSpace</code> facet for the
    data type).</p></item>
    <item><p>If the element or attribute is not considered
     valid, <phrase diff="add" at="T">as defined above</phrase>,
     the transformation fails <phrase diff="add" at="T"><errorref class="TE" code="1540"/></phrase>.</p></item>
   </ulist>

<p><error spec="XT" type="static" class="SE" code="1520"><p>It is a <termref def="dt-static-error">static error</termref>
 if the value of the <code>type</code> attribute 
of an <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, 
 <elcode>xsl:copy-of</elcode>, <phrase diff="add" at="ZA"><elcode>xsl:document</elcode>, </phrase> or <elcode>xsl:result-document</elcode>
 instruction, or the <code>xsl:type</code> attribute
of a literal result element, is not a valid <code>QName</code>, or if it uses a prefix that is not defined in an
in-scope namespace declaration, or if the QName is not the name of a type definition
included in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref>
for the stylesheet.</p></error></p>

<p><error spec="XT" type="static" class="SE" code="1530"><p>It is a <termref def="dt-static-error">static error</termref>
 if the value of the <code>type</code> attribute 
of an <elcode>xsl:attribute</elcode> instruction refers to a complex type definition</p></error>.</p>


<p><error spec="XT" type="type" class="TE" code="1540"><p>It is a <termref def="dt-type-error">type error</termref> if an <code>[xsl:]type</code>
attribute is defined for a constructed element or attribute, and the 
outcome of schema validity assessment against that type is that the <code>validity</code> property
of that element or attribute information item is other than <code>valid</code>.</p></error></p>

<note><p>Like other type errors, this error may be signaled statically 
if it can be detected statically. For example,
the instruction <code>&lt;xsl:attribute name="dob" type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code> 
may result
in a static error being signaled. If the error is not signaled statically, 
it will be signaled when the instruction is evaluated.</p></note>

</div4>
<div4 id="validation-process">
<head>The Validation Process</head>

<p>As well as checking for validity against the schema, the validity assessment process
causes <termref def="dt-annotation">type annotations</termref> to be associated with element and attribute nodes.
If default values for elements or attributes are defined in the schema, the validation
process will where necessary create new nodes 
containing these default values.</p>

<p>Validation of an element or attribute node only takes into account constraints on the content
of the element or attribute. Validation rules affecting the document as a whole are not applied.
Specifically, this means:</p>

<ulist>
     <item><p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is not
     applied. This means that validation will not fail if there are non-unique ID
     values or dangling IDREF values in the subtree being validated.</p></item>
     
     <item><p>The validation rule <quote>Validation Rule: Identity-constraint Satisfied</quote>
     is not applied.</p></item>

     <item><p>There is no check that the document contains unparsed entities whose names match the values of
nodes of type <code>xs:ENTITY</code> or <code>xs:ENTITIES</code>. (XSLT 2.0 provides no facility
to construct unparsed entities within a tree.)</p></item>

     <item><p>There is no check that the document contains notations whose names match the values of
nodes of type <code>xs:NOTATION</code>. (The <phrase diff="chg" at="Z">XDM</phrase> data model makes no provision
 for notations to be represented in the tree.)</p></item>
</ulist>

<p>With these caveats, validating a newly constructed element, using strict or lax validation,
 is equivalent to the following steps:</p>

<olist>
    
   <item><p>The element is serialized to textual XML form, according to the
   rules defined in <bibref ref="xslt-xquery-serialization"/> using the XML output method,
   with all parameters defaulted. Note that this process discards
      any existing <termref def="dt-annotation">type annotations</termref>.</p></item>
   
   <item><p>The resulting XML document is parsed to create
   an XML Information Set (see <bibref ref="xml-infoset"/>.)</p></item>

   <item><p>The Information Set produced in the previous step is validated
      according to the rules in <bibref ref="xmlschema-1"/>. The result of this step is a
      Post-Schema Validation Infoset (PSVI). If the validation process
      is not successful (as defined above), a type error is raised.</p></item>

   <item><p>The PSVI produced in the previous step is converted back into the
      <phrase diff="chg" at="Z">XDM</phrase> data model by the mapping described in <bibref ref="xpath-datamodel"/>
      (<xspecref spec="DM" ref="PSVI2Types"/>).
      This process creates nodes with simple or complex <termref def="dt-annotation">type annotations</termref> based on the types established
      during schema validation.</p></item></olist>
      
<p>Validating an attribute using strict or lax validation requires a modified version
of this procedure. A copy of the attribute is first added to an element node that is created for the purpose,
and namespace fixup (see <specref ref="namespace-fixup"/>) is performed on this element node.
The name of this element is of no consequence, but it must be the same as the name of a 
synthesized element declaration of the form:</p>

<eg><![CDATA[<xs:element name="E">
  <xs:complexType>
    <xs:sequence/>
    <xs:attribute ref="A"/>
  </xs:complexType>
</xs:element>]]></eg>

<p>where A is the name of the attribute being validated.</p>

<p>This synthetic element is then validated using the procedure given above for validating elements, and if it
is found to be valid, a copy of the validated attribute is made, retaining its <termref def="dt-annotation">type annotation</termref>, but detaching it
from the containing element (and thus, from any namespace nodes).</p>

<p diff="add" at="Y">The <phrase diff="chg" at="Z">XDM</phrase> data model does not permit an attribute node with no parent to have a typed value
that includes a namespace-qualified name, that is, a value whose type is derived from <code>xs:QName</code>
or <code>xs:NOTATION</code>. This restriction is imposed because these types rely on the namespace nodes
of a containing element to resolve namespace prefixes. Therefore, it is an error to validate a parentless
 attribute against such a type.
This affects the instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and 
<elcode>xsl:copy-of</elcode>.</p>

<p diff="add" at="Y"><error spec="XT" type="type" class="TE" code="1545"><p>A 
<termref def="dt-type-error">type error</termref> occurs if a <code>type</code> or <code>validation</code>
attribute is defined (explicitly or implicitly) for an instruction that constructs a new attribute node, if the 
effect of this is to cause the attribute value to be validated against a type that is derived from,
or constructed by list or union from, the primitive types <code>xs:QName</code> or
<code>xs:NOTATION</code>.</p></error></p>

</div4>

</div3>
<div3 id="validating-document-nodes"><head>Validating Document Nodes</head>

<p>It is possible to apply validation to a document node. 
<phrase diff="add" at="ZA">This happens when a
new document node is constructed by one of the instructions <elcode>xsl:document</elcode>,
<elcode>xsl:result-document</elcode>, <elcode>xsl:copy</elcode>, or 
<elcode>xsl:copy-of</elcode>, and this instruction has a
<code>type</code> attribute, or a <code>validation</code> attribute
 with the value <code>strict</code> or <code>lax</code></phrase>.</p>



<p diff="chg" at="ZA">Document-level validation is not applied to
the document node that is created implicitly when a variable-binding element has no
<code>select</code> attribute and no <code>as</code> attribute (see <specref ref="temporary-trees"/>). 
This is equivalent to using
<code>validation="preserve"</code> on <elcode>xsl:document</elcode>: nodes within such
trees retain their <termref def="dt-annotation">type annotation</termref>.
Similarly, validation is not applied to document nodes created using
<elcode>xsl:message</elcode>.
</p>

<p>The values <code>validation="preserve"</code> and <code>validation="strip"</code>
do not request validation. In the first case, all element and attribute nodes within the tree rooted
at the new document node retain their <termref def="dt-annotation">type annotations</termref>. In the second case, elements within the tree
have their type annotation set to <phrase diff="chg" at="ZA"><code>xs:untyped</code></phrase>,
 while attributes have their type
annotation set to <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>.</p>

<p>When validation is requested for a document node (that is, when <code>validation</code>
is set to <code>strict</code> or <code>lax</code>, or when a <code>type</code> attribute
is present), the following processing takes place:</p>

<ulist>

<item><p><error spec="XT" type="type" class="TE" code="1550"><p>A 
<termref def="dt-type-error">type error</termref> occurs 
<error.extra>when a document node is validated</error.extra> 
unless the children of the document node comprise
exactly one element node, no text nodes, and zero or more comment and processing instruction nodes,
in any order.</p></error></p></item>

<item><p>The single element node child is validated, using the supplied values of the <code>validation</code>
and <code>type</code> attributes, as described in <specref ref="validating-constructed-nodes"/>.</p>

<note><p>The <code>type</code> attribute on 
<phrase diff="add" at="Z"><elcode>xsl:document</elcode> and </phrase>
<elcode>xsl:result-document</elcode>, and
on <elcode>xsl:copy</elcode> and <elcode>xsl:copy-of</elcode> when copying a document node, thus refers
to the required type of the element node that is the only element child of the 
document node. It does not refer to the type of the document node itself.</p></note> 
</item>

<item><p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is 
     applied to the single element node child of the document node. 
     This means that validation will fail if there are non-unique ID
     values or dangling IDREF values in the document tree.</p></item>

<item><p>Identity constraints, as defined in section 3.11 of
<bibref ref="xmlschema-1"/>, are checked. (This refers to constraints defined using
<code>xs:unique</code>, <code>xs:key</code>, and <code>xs:keyref</code>.)</p></item>

<item><p>There is no check that the tree contains unparsed entities whose names match the values of
nodes of type <code>xs:ENTITY</code> or <code>xs:ENTITIES</code>. This is because there is
no facility in XSLT 2.0 to create unparsed entities in a <termref def="dt-result-tree">result tree</termref>. It is possible to add unparsed
entity declarations to the result document by referencing a suitable DOCTYPE during serialization.</p></item>

<item><p>There is no check that the document contains notations whose names match the values of
nodes of type <code>xs:NOTATION</code>. This is because notations are
not part of the <phrase diff="chg" at="Z">XDM</phrase> data model. It is possible to add notations to the result document by referencing a
 suitable DOCTYPE during serialization.</p></item>

<item><p>All other children of the document node (comments and processing instructions) 
are copied unchanged.</p></item>

</ulist>

<p><error spec="XT" type="type" class="TE" code="1555"><p>It is a
 <termref def="dt-type-error">type error</termref> if, when validating a document
 node, document-level constraints are not satisfied. These constraints include
 identity constraints (<code>xs:unique</code>, <code>xs:key</code>, 
 and <code>xs:keyref</code>) and ID/IDREF constraints.</p></error></p>


</div3>
</div2>
			
		</div1>
		
		<div1 id="serialization">
			<head>Serialization</head>
			<p>A <termref def="dt-processor">processor</termref> <rfc2119>may</rfc2119> output a 
      <termref def="dt-final-result-tree">final result tree</termref> as a sequence of
octets, although it is not <rfc2119>required</rfc2119> to be able to do so (see <specref ref="conformance"/>). 
<phrase diff="chg" at="ZA">Stylesheet authors can use <elcode>xsl:output</elcode> declarations 
to specify how they wish result trees to be serialized. 
If a processor serializes a final result tree, it <rfc2119>must</rfc2119> do so
as specified by these declarations.</phrase></p>

<p>The rules governing the output of the serializer are defined in <bibref ref="xslt-xquery-serialization"/>.
The serialization is controlled using a number of serialization parameters. The values of these
serialization parameters may be set within the <termref def="dt-stylesheet">stylesheet</termref>,
 using the <elcode>xsl:output</elcode>, <elcode>xsl:result-document</elcode>, and
<elcode>xsl:character-map</elcode> declarations.</p>

			<e:element-syntax name="output">
				<e:in-category name="declaration"/>
				<e:attribute name="name">
					<e:data-type name="qname"/>
				</e:attribute>
				<e:attribute name="method">
					<e:constant value="xml"/>
					<e:constant value="html"/>
					<e:constant value="xhtml"/>
					<e:constant value="text"/>
					<e:data-type name="qname-but-not-ncname"/>
				</e:attribute>
				<e:attribute name="byte-order-mark">
					<e:constant value="yes"/>
					<e:constant value="no"/>
				</e:attribute>
				<e:attribute name="cdata-section-elements">
					<e:data-type name="qnames"/>
				</e:attribute>
				<e:attribute name="doctype-public">
					<e:data-type name="string"/>
				</e:attribute>
				<e:attribute name="doctype-system">
					<e:data-type name="string"/>
				</e:attribute>
				<e:attribute name="encoding">
					<e:data-type name="string"/>
				</e:attribute>
				<e:attribute name="escape-uri-attributes">
					<e:constant value="yes"/>
					<e:constant value="no"/>
				</e:attribute>
				<e:attribute name="include-content-type">
					<e:constant value="yes"/>
					<e:constant value="no"/>
				</e:attribute>
				<e:attribute name="indent">
					<e:constant value="yes"/>
					<e:constant value="no"/>
				</e:attribute>
				<e:attribute name="media-type">
					<e:data-type name="string"/>
				</e:attribute>
				<e:attribute name="normalization-form">
					<e:constant value="NFC"/>
					<e:constant value="NFD"/>
					<e:constant value="NFKC"/>
					<e:constant value="NFKD"/>
					<e:constant value="fully-normalized"/>
					<e:constant value="none"/>
					<e:data-type name="nmtoken"/>
				</e:attribute>
				<e:attribute name="omit-xml-declaration">
					<e:constant value="yes"/>
					<e:constant value="no"/>
				</e:attribute>
				<e:attribute name="standalone">
					<e:constant value="yes"/>
					<e:constant value="no"/>
					<e:constant value="omit"/>
				</e:attribute>
				<e:attribute name="undeclare-prefixes">
					<e:constant value="yes"/>
					<e:constant value="no"/>
				</e:attribute>				
				<e:attribute name="use-character-maps">
				    <e:data-type name="qnames"/>
				</e:attribute>
				<e:attribute name="version">
					<e:data-type name="nmtoken"/>
				</e:attribute>
				<e:empty/>
				<e:allowed-parents>
					<e:parent name="stylesheet"/>
					<e:parent name="transform"/>
				</e:allowed-parents>
			</e:element-syntax>
			
			<p>The <elcode>xsl:output</elcode> declaration is optional; if used, it <rfc2119>must</rfc2119> always
 appear as a <termref def="dt-top-level">top-level</termref> element within a <phrase diff="chg" at="R">stylesheet module</phrase>.</p>
			
			
            
			
			<p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple <elcode>xsl:output</elcode> declarations
and may include or import stylesheet modules that also contain
<elcode>xsl:output</elcode> declarations. The name of an <elcode>xsl:output</elcode> declaration
is the value of its <code>name</code> attribute, if any.</p>

<p><termdef id="dt-output-definition" term="output definition">All 
the <elcode>xsl:output</elcode> declarations in a stylesheet
 that share the same name are grouped into a named <term>output definition</term>;
 those that have no name are grouped into a single unnamed output definition.</termdef>
			</p>
			
<p diff="add" at="T">A stylesheet always includes an unnamed <termref def="dt-output-definition">output definition</termref>;
in the absence of an unnamed <elcode>xsl:output</elcode> declaration, the unnamed output
definition is equivalent to the one that would be used if the stylesheet contained an
<elcode>xsl:output</elcode> declaration having no attributes.</p>
			
			<p>A named <termref def="dt-output-definition">output definition</termref> is used when its name matches the <code>format</code> attribute
used in an <elcode>xsl:result-document</elcode> element. The unnamed output definition is used
when an <elcode>xsl:result-document</elcode> element omits the <code>format</code> attribute.
It is also used when serializing the <termref def="dt-final-result-tree">final result tree</termref> that is created
implicitly in the absence of an <elcode>xsl:result-document</elcode> element.</p>

<p>All the <elcode>xsl:output</elcode>
elements making up an <termref def="dt-output-definition">output definition</termref> are effectively merged.
<phrase diff="add" at="Z">For those attributes whose values are namespace-sensitive, the merging is done
after <termref def="dt-lexical-qname">lexical QNames</termref> have been converted into
<termref def="dt-expanded-qname">expanded QNames</termref>.</phrase>
For the <code>cdata-section-elements</code> attribute,
 the output definition uses
the union of the values from all the constituent <elcode>xsl:output</elcode> declarations.
<phrase diff="chg" at="Z">For the <code>use-character-maps</code> attribute, the output definition uses 
the concatenation of the sequences of <termref def="dt-expanded-qname">expanded QNames</termref> values
 from all the constituent <elcode>xsl:output</elcode> declarations,
  taking them in order of increasing <termref def="dt-import-precedence">import precedence</termref>, or where several have the
   same import precedence, in <termref def="dt-declaration-order">declaration order</termref>.</phrase>
For other attributes, the <termref def="dt-output-definition">output definition</termref> uses the value
 of that attribute from the <elcode>xsl:output</elcode> declaration with the 
highest <termref def="dt-import-precedence">import precedence</termref>.</p>

<p><error spec="XT" type="static" class="SE" code="1560"><p>It is a 
<termref def="dt-static-error">static error</termref>
if two <elcode>xsl:output</elcode> declarations within an
<termref def="dt-output-definition">output definition</termref> specify
explicit values for the same attribute (other than <code>cdata-section-elements</code> 
and <code>use-character-maps</code>), 
with the values of the attributes being not equal, 
unless there is another <elcode>xsl:output</elcode> declaration within the same
<termref def="dt-output-definition">output definition</termref> that has higher import precedence 
and that specifies an explicit value for the same attribute.
				</p></error>
			</p>
			
<p>If none of the <elcode>xsl:output</elcode> declarations within
an <termref def="dt-output-definition">output definition</termref> specifies a value
for a particular attribute, then the corresponding serialization parameter takes a default value. The default
value depends on the chosen output method.</p>

<p diff="add" at="ZA">There are some serialization parameters that apply to some output methods but not to 
others. For example, the <code>indent</code> attribute has no effect on the <code>text</code> output method.
If a value is supplied for an attribute that is inapplicable to the output method, its value is <phrase diff="chg" at="ZB">not passed to the serializer</phrase>.
The processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not <rfc2119>required</rfc2119>
to do so.</p>

<p>An implementation <rfc2119>may</rfc2119> allow the attributes of the <elcode>xsl:output</elcode> declaration
to be overridden, or the default values to be changed, using the API that controls the transformation.</p>
			
<p>The location to which <termref def="dt-final-result-tree">final result trees</termref> 
are serialized (whether in filestore
or elsewhere) is <termref def="dt-implementation-defined">implementation-defined</termref>
(which in practice
<rfc2119>may</rfc2119> mean that it is controlled using an implementation-defined API). 
However, these locations <rfc2119>must</rfc2119> satisfy the constraint that
when two <termref def="dt-final-result-tree">final result trees</termref> are both created (implicitly or explicitly) using
relative URIs in the <code>href</code> attribute of the <elcode>xsl:result-document</elcode> instruction, then
these relative URIs may be used to construct references from one tree to the other, and such references <rfc2119>must</rfc2119> remain
valid when both result trees are serialized.				
			</p>
			<imp-def-feature>If serialization is supported, then the location to which a 
      <termref def="dt-final-result-tree">final result tree</termref>
is serialized is implementation-defined, subject to the constraint that relative URIs used to reference
one tree from another remain valid.</imp-def-feature>
			<p>The <code>method</code> attribute on the <elcode>xsl:output</elcode> element
identifies the overall method that is to be used for outputting the
<termref def="dt-final-result-tree">final result tree</termref>.</p>

<p><error spec="XT" type="static" class="SE" code="1570"><p>The value 
<error.extra>of the <code>method</code> attribute on
 <elcode>xsl:output</elcode>
					</error.extra>
<rfc2119>must</rfc2119> <phrase diff="add" at="W">(if present)</phrase> 
be a valid <termref def="dt-qname">QName</termref>.  
If the <termref def="dt-qname">QName</termref> does not have a prefix, then it
identifies a method specified in <bibref ref="xslt-xquery-serialization"/> and <rfc2119>must</rfc2119> be one of
<code>xml</code>, <code>html</code>, <code>xhtml</code>, 
 or <code>text</code>.</p></error>  If the <termref def="dt-qname">QName</termref> has a prefix, then the <termref def="dt-qname">QName</termref> 
 is expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> as described
in <specref ref="qname"/>; the <termref def="dt-expanded-qname">expanded-QName</termref> identifies the output
method; the behavior in this case is not specified by this
document.</p>
			<p>The default for the <code>method</code> attribute 
			<phrase diff="add" at="T">depends on the contents of the tree being serialized, and</phrase>
			is chosen as
follows.  If the document node of the <termref def="dt-final-result-tree">final result tree</termref> has an element
child, and any text nodes preceding the first element child of the document
node of the result tree contain only whitespace characters, then:</p>
			<ulist>
				<item>
					<p>If the <termref def="dt-expanded-qname">expanded-QName</termref> of this first element child has local part
 <code>html</code> (in lower case), and namespace URI <code>http://www.w3.org/1999/xhtml</code>,
 then the default output method is <phrase diff="add" at="W">normally</phrase> <code>xhtml</code>. 
 <phrase diff="add" at="W">However, if the <code>version</code> attribute of the <elcode>xsl:stylesheet</elcode>
 element of the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref> has the
 value <code>1.0</code>, and if the result tree is generated implicitly (rather than by an explicit
 <elcode>xsl:result-document</elcode> instruction), then the default output method
  in this situation is <code>xml</code>.</phrase></p>
				</item>
				<item>
					<p>If the <termref def="dt-expanded-qname">expanded-QName</termref> of this first element child has local part
<code>html</code> (in any combination of upper and lower case) and a
null namespace URI, then the default output method is <code>html</code>.</p>
				</item>
			</ulist>
			<p>In all other cases, the default output method
 is <code>xml</code>.</p>
			<p diff="chg" at="T">The default output method is used
 if the selected <termref def="dt-output-definition">output definition</termref> does not include a 
<code>method</code> attribute.</p>
			<p>The other attributes on <elcode>xsl:output</elcode> provide parameters
for the output method.  The following attributes are allowed:</p>
			<ulist>
				<item>
					<p>
						The value of the <code>encoding</code> attribute provides the
						value of the <code>encoding</code> parameter to the serialization method.
						The default value is <termref def="dt-implementation-defined">implementation-defined</termref>, 
						but in the case of the <code>xml</code>
						and <code>xhtml</code> methods it <rfc2119>must</rfc2119> be either <code>UTF-8</code> or <code>UTF-16</code>.
					</p>
					<imp-def-feature>The default value of the <code>encoding</code> attribute of the
					<elcode>xsl:output</elcode> element is implementation-defined.</imp-def-feature>
				</item>
				<item>
				 <p diff="add" at="V">The <code>byte-order-mark</code> attribute defines whether a byte order mark
				 is written at the start of the file. If the value <code>yes</code> is specified, a byte order mark
				 is written; if <code>no</code> is specified, no byte order mark is written. The default value
				 depends on the encoding used. If the encoding is <code>UTF-16</code>, the default is <code>yes</code>;
				 for <code>UTF-8</code> it is <termref def="dt-implementation-defined">implementation-defined</termref>,
				 and for all other encodings it is <code>no</code>. The value of the byte order mark indicates whether
				 high order bytes are written before or after low order bytes; the actual byte order used is
				 <termref def="dt-implementation-dependent">implementation-dependent</termref><phrase diff="add" at="W">,
         unless it is defined by the selected encoding</phrase>.
				 </p>
				 </item>

				<item>
					<p>
						The <code>cdata-section-elements</code> attribute is a 
						whitespace-separated list
						of QNames. The default value is an empty list.
            After expansion of these names using the in-scope namespace declarations
						for the <elcode>xsl:output</elcode> declaration in which they appear, this list of
						names provides the value of the <code>cdata-section-elements</code> parameter
						to the serialization method. <phrase diff="add" at="Y">In the case of an unprefixed name,
            the default namespace (that is, the namespace declared using <code>xmlns="uri"</code>)
            is used.</phrase> </p>
            <note diff="add" at="Y"><p>This differs from the rule for most other QNames used in a stylesheet. The reason
            is that these names refer to elements in the result document, and therefore follow the same
            convention as the name of a literal result element or the <code>name</code> attribute
	          of <elcode>xsl:element</elcode>.</p></note>
  			</item>

				<item>
					<p>
						The value of the <code>doctype-system</code> attribute provides the
						value of the <code>doctype-system</code> parameter to the serialization method.
						By default, the parameter is not supplied.
				    </p>
				</item>
				<item>
					<p>
						The value of the <code>doctype-public</code> attribute provides the
						value of the <code>doctype-public</code> parameter to the serialization method.
						By default, the parameter is not supplied.
				    </p>
				</item>
				<item>
					<p>
						The value of the <code>escape-uri-attributes</code> attribute provides the
						value of the <code>escape-uri-attributes</code> parameter to the serialization method.
						The default value is <code>yes</code>.
				    </p>				
				</item>
				<item>
					<p>
						The value of the <code>include-content-type</code> attribute provides the
						value of the <code>include-content-type</code> parameter to the serialization method.
						The default value is <code>yes</code>.
				    </p>	
				</item>
				<item>
					<p>
						The value of the <code>indent</code> attribute provides the
						value of the <code>indent</code> parameter to the serialization method.
						The default value is <code>yes</code> in the case of the <code>html</code> and <code>xhtml</code>
						output methods, <code>no</code> in the case of the <code>xml</code> output method.
				    </p>					
				</item>
				<item>
					<p>
						The value of the <code>media-type</code> attribute provides the
						value of the <code>media-type</code> parameter to the serialization method.
						The default value is <code>text/xml</code> in the case of the <code>xml</code> output method,
						<code>text/html</code> in the case of the <code>html</code> and <code>xhtml</code>
						output methods, and <code>text/plain</code> in the case of the <code>text</code>
						output method. 
				    </p>				
				</item>
				<item>
					<p diff="chg" at="T">
The value of the <code>normalization-form</code> attribute provides the value of the 
<code>normalization-form</code> parameter to the serialization method.  A value that is 
an <code>NMTOKEN</code> other than one of those enumerated for the <code>normalization-form</code> 
attribute specifes an implementation-defined normalization form; the 
behavior in this case is not specified by this document. The default 
value is <code>none</code>.
				    </p>	

				</item>
				<item>
					<p>
						The value of the <code>omit-xml-declaration</code> attribute provides the
						value of the <code>omit-xml-declaration</code> parameter to the serialization method.
						The default value is <code>no</code>.
				    </p>	
				</item>
				<item>
					<p>
						The value of the <code>standalone</code> attribute provides the
						value of the <code>standalone</code> parameter to the serialization method.
						<phrase diff="add" at="T">The default value is <code>omit</code>; 
            this means that no <code>standalone</code> attribute is to be included in the XML declaration.</phrase>
				    </p>	
				</item>
				<item>
				    <p>The <code diff="chg" at="W">undeclare-prefixes</code> attribute is
				    relevant only when producing output with <code>method="xml"</code> and <code>version="1.1"</code> 
            <phrase diff="add" at="T">(or later)</phrase>.
				    It defines whether namespace undeclarations (of the form <code>xmlns:foo=""</code>) <rfc2119>should</rfc2119> be output
				    when a child element has no namespace node with the same name (that is, namespace prefix) as a
				    namespace node of its parent element. The default value is <code>no</code>: this means that
				    namespace undeclarations are not output, which has the effect that when the resulting XML is
				    reparsed, the new tree may contain namespace nodes on the child element that were not there
				    in the original tree before serialization.</p>
				</item>				
				<item>
				    <p>The <code>use-character-maps</code> attribute provides
				    a list of named character maps that
				     are used in conjunction with this <termref def="dt-output-definition">output definition</termref>. The way this attribute
				     is used is described in <specref ref="character-maps"/>.
             <phrase diff="add" at="W">The default value is an empty list.</phrase></p>
				</item>
				<item>
					<p>
						The value of the <code>version</code> attribute provides the
						value of the <code>version</code> parameter to the serialization method.
            <phrase diff="chg" at="U">The set of permitted values, and the default value,
            are <termref def="dt-implementation-defined">implementation-defined</termref>.
            A <termref def="dt-serialization-error">serialization error</termref> will be reported
            if the requested version is not supported by the implementation.</phrase>
						<!--The default value depends on the output method: it is <code>1.0</code> for <code>xml</code>,
						<code>4.01</code> for <code>html</code>, and <code>1.0</code> for <code>xhtml</code>. The 
						parameter is not used by the text output method.-->
				    </p>
           	
				</item>
			</ulist>

				<imp-def-feature>It is implementation-defined which versions of XML, HTML, and XHTML
        are supported in the <code>version</code> attribute of the 
        <elcode>xsl:output</elcode> declaration.</imp-def-feature>

				<imp-def-feature>The default value of the <code>byte-order-mark</code> serialization
				parameter is implementation-defined in the case of UTF-8 encoding.</imp-def-feature>

<p diff="add" at="ZA">If the processor performs serialization, then it must signal any
non-recoverable serialization
errors that occur. These have the same effect as
 <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic errors</termref>:
that is, the processor must signal the error and must not finish as if the
transformation had been successful.</p>


			<div2 id="character-maps">
			<head>Character Maps</head>
			
			<p><termdef id="dt-character-map" term="character map">A <term>character map</term> allows 
			a specific character appearing in a text or attribute node
			in the <termref def="dt-final-result-tree">final result tree</termref>
       to be substituted by a specified string of characters during serialization.</termdef>
			The effect of character maps is defined in <bibref ref="xslt-xquery-serialization"/>.</p>

            <p>The character map that is supplied as a parameter to the serializer is determined from the
            <elcode>xsl:character-map</elcode> elements referenced from the <elcode>xsl:output</elcode>
            declaration for the selected <termref def="dt-output-definition">output definition</termref>.</p>
			
<p>The <elcode>xsl:character-map</elcode> element is a declaration that may appear as a child
of the <elcode>xsl:stylesheet</elcode> element.</p>

                    <e:element-syntax name="character-map">
						<e:in-category name="declaration"/>
						<e:attribute name="name" required="yes">
							<e:data-type name="qname"/>
						</e:attribute>
						<e:attribute name="use-character-maps">
							<e:data-type name="qnames"/>
						</e:attribute>
    					<e:sequence>
    						<e:element repeat="zero-or-more" name="output-character"/>
    					</e:sequence>
						<e:allowed-parents>
							<e:parent name="stylesheet"/>
							<e:parent name="transform"/>
						</e:allowed-parents>
					</e:element-syntax>



<p>The <elcode>xsl:character-map</elcode> declaration declares a character map with a
name and a set of character mappings. The character mappings are
specified by means of <elcode>xsl:output-character</elcode> elements contained either directly 
within the <elcode>xsl:character-map</elcode> element, or in further character maps referenced
in the <code>use-character-maps</code> attribute.</p>
  
<p>The <rfc2119>required</rfc2119> <code>name</code> attribute provides a name for the character map.
When a character map is used by an <termref def="dt-output-definition">output definition</termref> or another
character map, the character map with the highest <termref def="dt-import-precedence">import precedence</termref> is
used.</p>
<p><error spec="XT" type="static" class="SE" code="1580"><p>It is a <termref def="dt-static-error">static error</termref> 
if the <termref def="dt-stylesheet">stylesheet</termref> contains two or more character maps 
with the same name and the same <termref def="dt-import-precedence">import
precedence</termref><phrase diff="add" at="R">, unless it also contains another character
map with the same name and higher import precedence.</phrase></p></error></p>

<p>The optional <code>use-character-maps</code> attribute lists the names of further character
maps that are included into this character map.</p>

<p><error spec="XT" type="static" class="SE" code="1590"><p>It is a <termref def="dt-static-error">static error</termref> if a name in 
the <code>use-character-maps</code> attribute <phrase diff="add" at="W">of the <elcode>xsl:output</elcode> or
 <elcode>xsl:character-map</elcode> elements</phrase> does not
match the <code>name</code> attribute of any <elcode>xsl:character-map</elcode> in the <termref def="dt-stylesheet">stylesheet</termref>.</p></error></p>

<p><error spec="XT" type="static" class="SE" code="1600"><p>It is a <termref def="dt-static-error">static error</termref> if 
a character map references itself, directly or indirectly, via a name in 
the <code>use-character-maps</code> attribute.</p></error></p>

<p>It is not an error if the same character map is referenced more than once, directly or indirectly.</p>

<p>An <termref def="dt-output-definition">output definition</termref>, after recursive expansion of character maps referenced via its
<code>use-character-maps</code> attribute, may contain several mappings for the same character.
In this situation, the last character mapping takes precedence. To establish the ordering, the following
rules are used:</p>

<ulist>
<item><p>Within a single <elcode>xsl:character-map</elcode> element, the characters defined in character maps
referenced in the <code>use-character-maps</code> attribute are considered before the characters defined in
the child <elcode>xsl:output-character</elcode> elements.</p></item>
<item><p>The character maps referenced in a single <code>use-character-maps</code> attribute are considered
in the order in which they are listed in that attribute. The expansion is depth-first: each referenced
character map is fully expanded before the next one is considered.</p></item>
<item><p>Two <elcode>xsl:output-character</elcode> elements appearing as children of the same 
<elcode>xsl:character-map</elcode> element are considered in document order.</p></item>
</ulist>

<p>The <elcode>xsl:output-character</elcode> element is defined as follows:</p>

                    <e:element-syntax name="output-character">
						<e:attribute name="character" required="yes">
							<e:data-type name="char"/>
						</e:attribute>
						<e:attribute name="string" required="yes">
							<e:data-type name="string"/>
						</e:attribute>
    					<e:empty/>
						<e:allowed-parents>
							<e:parent name="character-map"/>
						</e:allowed-parents>
					</e:element-syntax>

<p>The character map that is passed as a parameter to the serializer contains a mapping
for the character specified in the
<code>character</code> attribute to the string specified in the <code>string</code> attribute. </p>


<p>Character mapping is not applied to characters for which output escaping has
been disabled as described in <specref ref="disable-output-escaping"/>.</p> 

<p>If a character is mapped, then it is not subjected to XML or HTML escaping.</p>

<example><head>Using Character Maps to Generate Non-XML Output</head>
	<p>Character maps can be useful when producing serialized output in a format that resembles,
	but is not strictly conformant to, HTML or XML. For example, when the output is a JSP page,
	there might be a need to generate the output:</p>
	
    <eg>&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;</eg>
		
    <p>Although this output is not well-formed XML or HTML, it is valid in Java Server Pages.
    This can be achieved by allocating three Unicode characters (which are not needed for any other purpose)
    to represent the strings <code>&lt;%</code>, <code>%&gt;</code>, and <code>"</code>, for example:</p>
    
    <eg><![CDATA[<xsl:character-map name="jsp">
  <xsl:output-character character="" string="&lt;%"/>   
  <xsl:output-character character="" string="%&gt;"/>
  <xsl:output-character character="" string='"'/>
</xsl:character-map>]]></eg>

    <p>When this character map is referenced in the <elcode>xsl:output</elcode> declaration,
    the required output can be produced by writing the following in the stylesheet:</p>     
    
    <eg><![CDATA[<jsp:setProperty name="user" property="id" value='= id + idValue '/>]]></eg>

    <p>This works <phrase diff="chg" at="Z">on the assumption that</phrase> when an apostrophe or quotation
    mark is generated as part of an attribute value by the use of character maps, the serializer will
    (where possible) use the other choice of delimiter around the attribute value.</p>
</example>

<example><head>Constructing a Composite Character Map</head>

<p>The following example illustrates a composite character map constructed in
a modular fashion:</p>

<eg><![CDATA[
<xsl:output name="htmlDoc" use-character-maps="htmlDoc" />

<xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" />
  
<xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." />

<xsl:character-map name="latin1">
  <xsl:output-character character="&#160;" string="&amp;nbsp;" />
  <xsl:output-character character="&#161;" string="&amp;iexcl;" />
  ...
</xsl:character-map>

<xsl:character-map name="doc-entities">
  <xsl:output-character character="&#xE400;" string="&amp;t-and-c;" />
  <xsl:output-character character="&#xE401;" string="&amp;chap1;" />
  <xsl:output-character character="&#xE402;" string="&amp;chap2;" />
  ...
</xsl:character-map>

<xsl:character-map name="windows-format">
  <!-- newlines as CRLF -->
  <xsl:output-character character="&#xA;" string="&#xD;&#xA;" />

  <!-- tabs as three spaces -->
  <xsl:output-character character="&#x9;" string="   " />

  <!-- images for special characters -->
  <xsl:output-character character="&#xF001;"
    string="&lt;img src='special1.gif' /&gt;" />
  <xsl:output-character character="&#xF002;"
    string="&lt;img src='special2.gif' /&gt;" />
  ...
</xsl:character-map>]]></eg></example>




          </div2>			


			<div2 id="disable-output-escaping">
				<head>Disabling Output Escaping</head>
				<p>Normally, when using the XML, HTML, or XHTML output method, 
				the serializer will escape special
characters such as <code>&amp;</code> and <code>&lt;</code>
when outputting text nodes. This
ensures that the output is well-formed. However, it is sometimes
convenient to be able to produce output that is almost, but not quite
well-formed XML; for example, the output may include ill-formed
sections which are intended to be transformed into well-formed XML by
a subsequent non-XML-aware process.  For this reason, XSLT defines a
mechanism for disabling output escaping.</p>

<p diff="add" at="T">This feature is <termref def="dt-deprecated">deprecated</termref>.</p>

<p>This is an optional feature: it is not <rfc2119>required</rfc2119> that a XSLT processor that
implements the serialization option <rfc2119>should</rfc2119> offer the ability to disable output escaping,
and there is no conformance level that requires this feature.</p>

<p>This feature requires an extension to the serializer described in <bibref ref="xslt-xquery-serialization"/>.
Conceptually, the <termref def="dt-final-result-tree">final result tree</termref>
 provides an additional boolean property <code>disable-escaping</code>
associated with every character in a text node. When this property
is set, the normal action of the serializer to escape special characters such as <code>&amp;</code>
and <code>&lt;</code> is suppressed.</p>

				<p>An <elcode>xsl:value-of</elcode>
or <elcode>xsl:text</elcode> element may have a
<code>disable-output-escaping</code> attribute; the allowed values are
<code>yes</code> or <code>no</code>. The default is <code>no</code>;
if the value is <code>yes</code>, then every character in the text node generated by
evaluating the <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode>
element <rfc2119>should</rfc2119> have the <code>disable-output</code> property set.</p>

				<example><head>Disable Output Escaping</head>
					<p>For example,</p>
					<eg><![CDATA[<xsl:text disable-output-escaping="yes">&lt;</xsl:text>]]></eg>
					<p>should generate the single character <code>&lt;</code>.</p>
				</example>

					<p diff="chg" at="X">If
 output escaping is disabled for an <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> instruction
evaluated when  <termref def="dt-temporary-output-state">temporary output state</termref> is in effect,
the request to disable output escaping is ignored.</p>

				

<p>If output escaping is disabled for text within an element that would
normally be output using a CDATA section, because the element is listed in the 
<code>cdata-section-elements</code>, then the relevant text will not be included in a
CDATA section. In effect, CDATA is treated as an alternative escaping mechanism, which
is disabled by the <code>disable-output-escaping</code> option.</p>


				<example><head>Interaction of Output Escaping and CDATA</head>
					<p>For example, if <code>&lt;xsl:output cdata-section-elements="title"/&gt;</code>
					is specified, then the following instructions:</p>
<eg><![CDATA[<title>
  <xsl:text disable-output-escaping="yes">This is not &lt;hr/&gt; good coding practice</xsl:text>
</title>]]></eg>
					<p>should generate the output:</p>
<eg diff="chg" at="T">&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;</eg>
				</example>


				<p>The <code>disable-output-escaping</code> attribute may be used with
the <code>html</code> output method as well as with the
<code>xml</code> output method.  The <code>text</code> output method
ignores the <code>disable-output-escaping</code> attribute, since it
does not perform any output escaping.</p>

				<p>A <termref def="dt-processor">processor</termref> will only be able to disable output escaping if
it controls how the <termref def="dt-final-result-tree">final result tree</termref> is output. This might not always be the
case.  For example, the result tree might be used as a <termref def="dt-source-tree">source tree</termref> for
another XSLT transformation instead of being output.  
It is <termref def="dt-implementation-defined">implementation-defined</termref>
whether (and under what circumstances) disabling output escaping is supported.</p>

<p><error spec="XT" type="dynamic" class="RE" code="1620"><p>It is 
 a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
 if an
<elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> instruction specifies that
output escaping is to be disabled and the implementation does not
support this. 
<error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to ignore the 
<code>disable-output-escaping</code> attribute.</error.action></p></error></p>

<p><error spec="XT" type="dynamic" class="RE" code="1630"><p>It is 
 a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
 if an
<elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> instruction specifies that
output escaping is to be disabled when writing to a 
<termref def="dt-final-result-tree">final result tree</termref> that is
not being serialized. 
<error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to ignore the 
<code>disable-output-escaping</code> attribute.</error.action></p></error></p>
				
				<imp-def-feature>It is implementation-defined whether, and under what circumstances,
disabling output escaping is supported.</imp-def-feature>

<p diff="chg" at="X">If output escaping is disabled for a character that is not
representable in the encoding that the <termref def="dt-processor">processor</termref> is using for
output, the request to disable output escaping is ignored in respect of that character.</p>

				<p>Since disabling output escaping might not work with all implementations
 and can result in XML that is not well-formed, it <rfc2119>should</rfc2119> be
used only when there is no alternative.</p>

<note><p>The facility to define character maps for use during serialization,
as described in <specref ref="character-maps"/>, has been produced as an alternative mechanism that can be used
in many situations where disabling of output escaping was previously necessary, without the same
difficulties.</p></note>
			</div2>

		</div1>
				
		
        <div1 id="conformance">


        
        <head>Conformance</head>

<p>A <termref def="dt-processor">processor</termref> that claims conformance with this
specification <rfc2119>must</rfc2119> claim conformance either as a <termref def="dt-basic-xslt-processor">basic
XSLT processor</termref> or as a <termref def="dt-schema-aware-xslt-processor">schema-aware
XSLT processor</termref>. The rules for these two conformance levels are defined in
the following sections.</p>

<p>A processor that claims conformance at either of these two levels <rfc2119>may</rfc2119> additionally
claim conformance with either or both of the following optional features: the
serialization feature, defined in <specref ref="serialization-feature"/>, and the
backwards compatibility feature, defined in <specref ref="backwards-compatibility-feature"/>.</p>

<note><p>There is no conformance level or feature defined in this specification
that requires implementation of the static typing features described in <bibref ref="xpath20"/>.
An XSLT processor may provide a user option to invoke static typing, 
but to be conformant with this specification it must
allow a stylesheet to be processed with static typing disabled. The interaction of XSLT
stylesheets with the static typing feature of XPath 2.0 has not been specified, so the results
of using static typing, if available, are implementation-defined.</p></note>

<p>An XSLT processor takes as its inputs a stylesheet and one or more <phrase diff="chg" at="Z">XDM trees 
conforming to</phrase> the data model defined in <bibref ref="xpath-datamodel"/>. It is 
not <rfc2119>required</rfc2119> that the processor supports any particular method of constructing 
<phrase diff="chg" at="Z">XDM trees</phrase>, but conformance can only be tested if it provides a mechanism that enables 
<phrase diff="chg" at="Z">XDM trees</phrase> representing the stylesheet and primary source document to be constructed
and supplied as input to the processor.</p>

<p>The output of the XSLT processor consists of <phrase diff="chg" at="U">zero</phrase> or more 
<termref def="dt-final-result-tree">final result trees</termref>.  It is 
not <rfc2119>required</rfc2119> that the processor supports any particular method of accessing 
a final result tree, but if it does not support the serialization module, conformance can 
only be tested if it provides some alternative mechanism that enables access to the 
results of the transformation.</p>
			
<p>Certain facilities in this specification are described as producing 
<termref def="dt-implementation-defined">implementation-defined</termref> results. A
claim that asserts conformance with this specification <rfc2119>must</rfc2119> be accompanied by documentation
stating the effect of each implementation-defined feature. For convenience, a non-normative
checklist of implementation-defined features is provided at 
<specref ref="implementation-defined-features"/>.</p>
			
<p>A conforming <termref def="dt-processor">processor</termref> <rfc2119>must</rfc2119> signal
any <termref def="dt-static-error">static error</termref> occurring in the stylesheet,
or in any XPath <termref def="dt-expression">expression</termref>, except where specified
otherwise either for individual error conditions or under the general provisions for
<termref def="dt-forwards-compatible-behavior">forwards compatible behavior</termref> 
(see <specref ref="forwards"/>). After signaling such an error, the processor <rfc2119>may</rfc2119> continue for the
purpose of signaling additional errors, but <rfc2119>must</rfc2119> terminate abnormally without performing
any transformation.</p>

<p>When a <termref def="dt-dynamic-error">dynamic error</termref>
occurs during the course of a transformation, the action depends on whether the error is classified as a
<termref def="dt-recoverable-error">recoverable error</termref>.
If a non-recoverable error occurs, the processor <rfc2119>must</rfc2119> 
signal it and <rfc2119>must</rfc2119> eventually terminate abnormally. If a recoverable 
error occurs, the processor <rfc2119>must</rfc2119> either signal it and terminate 
abnormally, or it <rfc2119>must</rfc2119> take the defined recovery action and continue processing.</p>

<p>Some errors, notably <termref def="dt-type-error">type errors</termref>,
<rfc2119>may</rfc2119> be treated as <termref def="dt-static-error">static errors</termref> or
<termref def="dt-dynamic-error">dynamic errors</termref> at the discretion of the
processor.</p>
            
<p>A conforming processor <rfc2119>may</rfc2119> impose limits on the processing
resources consumed by the processing of a stylesheet.</p>

			
<div2 id="basic-conformance">
<head>Basic XSLT Processor</head>

<p><termdef id="dt-basic-xslt-processor" term="basic XSLT processor">A <term>basic XSLT processor</term> is an XSLT
processor that implements all the mandatory requirements of this specification with the exception
of certain explicitly-identified constructs related to schema processing.</termdef>
These constructs are listed below.</p>

<p>The mandatory requirements of this specification are taken
to include the mandatory requirements of XPath 2.0, as described in <bibref ref="xpath20"/>.
A requirement is mandatory unless the specification includes wording (such as the use of the
words <rfc2119>should</rfc2119> or <rfc2119>may</rfc2119>) that clearly indicates that it is optional.</p>

<p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> <rfc2119>must</rfc2119> 
enforce the following restrictions. It <rfc2119>must</rfc2119> signal a static
or dynamic error when the restriction is violated, as described below.</p>

<p><error spec="XT" type="static" class="SE" code="1650"><p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> 
<rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static error</termref> if the <termref def="dt-stylesheet">stylesheet</termref> includes an
<elcode>xsl:import-schema</elcode> declaration.</p></error></p>

<note><p>A processor that rejects
an <elcode>xsl:import-schema</elcode> declaration will also reject any reference to a user-defined
type defined in a schema, or to a user-defined element or attribute declaration; it will not, 
however, reject references to the built-in types listed in <specref ref="built-in-types"/>.</p></note>

<p><error spec="XT" type="static" class="SE" code="1660"><p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> 
<rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static error</termref> if the <termref def="dt-stylesheet">stylesheet</termref> includes an
<code>[xsl:]type</code> attribute, or an
<code>[xsl:]validation</code> or <code>default-validation</code> 
attribute with a value other than <code>strip</code>.</p></error></p>

<p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>
constrains the data model as follows:</p>

<ulist diff="chg" at="V">
<item><p>Atomic values <rfc2119>must</rfc2119> belong to one of the atomic types listed in 
<specref ref="built-in-types"/> (except as noted below).</p>

<p>An atomic value may also belong to an implementation-defined type that has been added to
the context for use with <termref def="dt-extension-function">extension functions</termref>
or <termref def="dt-extension-instruction">extension instructions</termref>.</p>

<p>The set of constructor functions available are limited to those that construct values
of the above atomic types.</p>

<p>The static context, which defines the full set of type names recognized by an XSLT
processor and also by the XPath processor, includes these atomic types, plus <code>xs:anyType</code>,
<code>xs:anySimpleType</code>, <phrase diff="chg" at="ZA"><code>xs:untyped</code></phrase>, 
and <phrase diff="chg" at="ZA"><code>xs:anyAtomicType</code></phrase>.</p>



</item>

<item><p>Element nodes <rfc2119>must</rfc2119> be annotated with the <termref def="dt-annotation">type annotation</termref>
 <phrase diff="chg" at="ZA"><code>xs:untyped</code></phrase>, 
 and attribute nodes with the type annotation
<code diff="chg" at="Z">xs:untypedAtomic</code>.</p>
</item>

</ulist>

<p><error spec="XT" type="dynamic" class="DE" code="1665"><p>A 
<termref def="dt-basic-xslt-processor">basic XSLT processor</termref>
 <rfc2119>must</rfc2119> raise a 
<termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
if the input to the processor includes a node with a <termref def="dt-annotation">type annotation</termref> other than
<phrase diff="chg" at="ZA"><code>xs:untyped</code></phrase> or <phrase diff="chg" at="ZA"><code>xs:untypedAtomic</code></phrase>, or an atomic value
of a type other than those which a basic XSLT processor supports.</p></error>
<phrase diff="add" at="U">This error will not arise if the <code>input-type-annotations</code> attribute is set
to <code>strip</code>.</phrase></p>


<note>
<p>Although this is expressed in terms of a requirement to detect invalid input, an alternative
approach is for a basic XSLT processor to prevent this error condition occurring, by not providing
any interfaces that would allow the situation to arise. 
A processor might, for example, implement a mapping from the PSVI to the data model that loses
all non-trivial <termref def="dt-annotation">type annotations</termref>; or it might not accept input from a PSVI at all.</p>

<p>The phrase <emph>input to the processor</emph> is deliberately wide: it includes
the tree containing the <termref def="dt-initial-context-node">initial context node</termref>,
trees passed as <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>,
trees accessed using the <function>document</function>, <xfunction>doc</xfunction>, and
<xfunction>collection</xfunction> functions, and trees returned by 
<termref def="dt-extension-function">extension functions</termref> and
<termref def="dt-extension-instruction">extension instructions</termref>.</p></note>

</div2>
			
			<div2 id="schema-aware-conformance">
			<head>Schema-Aware XSLT Processor</head>

            <p><termdef id="dt-schema-aware-xslt-processor" term="schema-aware XSLT processor">A <term>schema-aware XSLT processor</term>
            is an XSLT processor that implements all the mandatory requirements of this specification,
            including those features that a <termref def="dt-basic-xslt-processor">basic XSLT 
            processor</termref> signals as an error. The mandatory requirements of this specification are taken
			to include the mandatory requirements of XPath 2.0, as described in <bibref ref="xpath20"/>.
			A requirement is mandatory unless the specification includes wording (such as the use of the
			words <rfc2119>should</rfc2119> or <rfc2119>may</rfc2119>) that clearly indicates that it is optional.</termdef></p> 

            </div2>
            
            <div2 id="serialization-feature">
            <head>Serialization Feature</head>
            
            <p><termdef id="dt-serialization-feature" term="serialization feature">A processor that 
            claims conformance with the <term>serialization feature</term> <rfc2119>must</rfc2119> support the conversion
            of a <termref def="dt-final-result-tree">final result tree</termref> 
            to a sequence of <phrase diff="chg" at="Q">octets</phrase> following the rules defined in <specref ref="serialization"/>.</termdef>
            It <rfc2119>must</rfc2119> respect all the attributes of the <elcode>xsl:output</elcode> and <elcode>xsl:character-map</elcode>
            declarations, and <rfc2119>must</rfc2119> provide all four output methods, <code>xml</code>, <code>xhtml</code>,
            <code>html</code>, and <code>text</code>. Where the specification uses words such as <rfc2119>must</rfc2119>
            and <rfc2119>required</rfc2119>, then it <rfc2119>must</rfc2119> serialize the result tree in precisely the way described; in 
            other cases it <rfc2119>may</rfc2119> use an alternative, equivalent representation.</p>
            
            <p>A processor may claim conformance with the serialization feature whether or not it supports
            the setting <code>disable-output-escaping="yes"</code> on <elcode>xsl:text</elcode>, or <elcode>xsl:value-of</elcode>.
            </p>
            
            <p>A processor that does not claim conformance with the serialization feature <rfc2119>must not</rfc2119> signal
            an error merely because the <termref def="dt-stylesheet">stylesheet</termref> contains <elcode>xsl:output</elcode> or <elcode>xsl:character-map</elcode>
            declarations, <phrase diff="chg" at="T">or serialization attributes on the <elcode>xsl:result-document</elcode> instruction.
            Such a processor <rfc2119>may</rfc2119> check that these 
            declarations and attributes have valid values, but is not <rfc2119>required</rfc2119> to do so. 
            Apart from optional validation,</phrase> these declarations <rfc2119>should</rfc2119> be ignored.</p>
            
			
			</div2>
			
			<div2 id="backwards-compatibility-feature">
			<head>Backwards Compatibility Feature</head>
			
			<p><termdef id="dt-backwards-compatibility-feature" term="backwards compatibility feature">A 
			processor that claims conformance with the <term>backwards compatibility feature</term> <rfc2119>must</rfc2119> support
			the processing of stylesheet instructions and XPath expressions with 
			<termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>, as
			defined in <specref ref="backwards"/>.</termdef></p>
			
			<p diff="chg" at="W">Note that a processor that does not claim conformance with the backwards 
			compatibility feature <rfc2119>must</rfc2119> raise a 
			<termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
			if an instruction is evaluated containing an <code>[xsl:]version</code> attribute that invokes
			backwards compatible behavior <errorref spec="XT" class="DE" code="0160"/>.</p>
			
			<note><p>The reason this is a dynamic error rather than a static error is to allow stylesheets
			to contain conditional logic, following different paths depending on whether the XSLT processor
			implements XSLT 1.0 or XSLT 2.0. The selection of which path to use can be controlled by 
			using the <function>system-property</function> function to test
			the <code>xsl:version</code> system property.</p></note>
			
			<p>A processor that claims conformance with the backwards compatibility 
			feature <rfc2119>must</rfc2119> permit the use of the namespace axis in XPath expressions when backwards
			compatible behavior is enabled. In all other circumstances, support for the namespace axis
			is optional.</p>
			
			</div2>
			
		</div1>
	</body>
	<back>
		<div1 id="references">
			<head>References</head>
			<div2 id="normative-references">
				<head>Normative References</head>
				<blist>

<bibl id="xpath-datamodel" key="Data Model"/>

<bibl id="xpath-functions" key="Functions and Operators"/>

<!--World Wide Web Consortium. 
<emph>XQuery 1.0 and XPath 2.0 Functions and Operators.</emph>
W3C Working Draft. 
See <loc href="http://www.w3.org/TR/xpath-functions/"/>
					</bibl>-->

					<bibl id="xml-infoset" key="XML Information Set"/>
					<!--World Wide Web Consortium. 
					<emph>XML Information Set.</emph> W3C Recommendation. 
					See <loc href="http://www.w3.org/TR/xml-infoset/"/>
                    </bibl>-->
					<bibl id="ISO3166" key="ISO 3166-1">ISO (International Organization for Standardization)
					<emph>Codes for the representation of names of countries
					 and their subdivisions - Part 1: Country codes</emph> ISO 3166-1:1997.
                    </bibl>     
					<bibl id="ISO8601" key="ISO 8601">ISO (International Organization for Standardization)
					<emph>Data elements and interchange formats - Information interchange -
					Representation of dates and times.</emph> ISO 8601:2000(E), Second edition, 2000-12-15.
                    </bibl>                    

<bibl id="xslt-xquery-serialization" key="XSLT and XQuery Serialization"/>

					<!--<bibl id="UNICODE-NORMALIZATION" key="Unicode Normalization">Unicode Consortium.
					<emph>Unicode Normalization Forms</emph>. Unicode Standard Annex #15.
					See <loc href="http://www.unicode.org/unicode/reports/tr15/"/>
					</bibl>-->
<!--					<bibl id="XHTML10" key="XHTML 1.0">World Wide Web Consortium. <emph>XHTML
1.0: The Extensible HyperText Markup Language.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xhtml1/"/>. Note: a second edition of this
specification is in preparation.</bibl>-->
<!--					<bibl id="XHTML11" key="XHTML 1.1">World Wide Web Consortium. <emph>XHTML
1.1: Module-Based XHTML.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xhtml11/"/>
					</bibl>-->
<bibl id="REC-xml" key="XML 1.0"/>
					<!--World Wide Web Consortium. <emph>Extensible
Markup Language (XML) 1.0 (Second Edition)</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/2000/REC-xml-20001006"/>
					</bibl>-->
<bibl id="xml11" key="XML 1.1"/>
<bibl id="xmlbase" key="XML Base"/>
					<!--World Wide Web
Consortium. <emph>XML Base.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/xmlbase/"/>
					</bibl>-->
<bibl id="xml-id" key="xml:id"/>
<!--World Wide Web Consortium. <emph>xml:id 1.0</emph> W3C Proposed Recommendation. 
See <loc href="http://www.w3.org/TR/xml-id/"/>
					</bibl>-->
					<bibl id="REC-xml-names" key="Namespaces in XML 1.0"/>
					<!--World Wide Web
Consortium. <emph>Namespaces in XML.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/REC-xml-names/"/>. 
<emph>This specification carries no version number, but is referenced herein
as</emph> XML Namespaces 1.0<emph>, to avoid confusion with later versions.</emph>
					</bibl>-->
					<bibl id="xml-names11" key="Namespaces in XML 1.1"/>
					<!--World Wide Web
Consortium. <emph>Namespaces in XML 1.1.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/xml-names11/"/>
					</bibl>-->
					<bibl id="xmlschema-1" key="XML Schema Part 1"/>	
					<bibl id="xmlschema-2" key="XML Schema Part 2"/>					
					<!--<bibl id="XMLSCHEMA" key="XML Schema">World Wide Web Consortium. 
<emph>XML Schema Part 1: Structures</emph> and 
and <emph>XML Schema Part 2: Data Types</emph>. W3C Recommendation.
See <loc href="http://www.w3.org/TR/xmlschema-1/"/> and
<loc href="http://www.w3.org/TR/xmlschema-2/"/>
					</bibl>-->
					<bibl id="xpath20" key="XPath 2.0"/>
					<!--World Wide Web Consortium. <emph>XML Path
Language Version 2.0</emph> W3C Working Draft.
See <loc href="http://www.w3.org/TR/xpath20/"/>
					</bibl>-->
				</blist>
			</div2>
			<div2 id="other-references">
				<head>Other References</head>
				<blist>
                    <bibl id="CALCALC" key="Calendrical Calculations">Edward M. Reingold and Nachum Dershowitz.
<emph>Calendrical Calculations Millennium edition (2nd Edition)</emph>. Cambridge University Press, 
ISBN 0 521 77752 6</bibl>
					<bibl id="DOM-Level-2-Core" key="DOM Level 2"/>
					<!--World Wide Web Consortium. <emph>Document
Object Model (DOM) Level 2 Core Specification.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/DOM-Level-2-Core/"/>
					</bibl>-->
<!--					<bibl id="HTML" key="HTML">World Wide Web Consortium. <emph>HTML 4.01
specification</emph>. W3C Recommendation. 
See <loc href="http://www.w3.org/TR/html4/"/>
					</bibl>-->
<!--					<bibl id="IANA" key="IANA">Internet Assigned Numbers
Authority. <emph>Character Sets</emph>. 
See <loc href="http://www.iana.org/assignments/character-sets"/>.</bibl>-->
					<bibl id="RFC2119" key="RFC2119">S. Bradner.  <emph>Key 
words for use in RFCs to Indicate Requirement Levels</emph>.  IETF RFC 2119. 
See <loc href="http://www.ietf.org/rfc/rfc2119.txt"/>.</bibl>
<!--					<bibl id="RFC2278" key="RFC2278">N. Freed, J. Postel.  <emph>IANA
Charset Registration Procedures</emph>.  IETF RFC 2278. 
See <loc href="http://www.ietf.org/rfc/rfc2278.txt"/>.</bibl>-->
					<bibl id="RFC2376" key="RFC2376">E. Whitehead, M. Murata.  <emph>XML
Media Types</emph>. IETF RFC 2376. 
See <loc href="http://www.ietf.org/rfc/rfc2376.txt"/>.</bibl>

					<bibl id="RFC3023" key="RFC3023">M. Murata, S. St.Laurent, and D. Cohn. 
<emph>XML Media Types</emph>. IETF RFC 3023. 
See <loc href="http://www.ietf.org/rfc/rfc3023.txt"/>. 
<phrase diff="add" at="ZA">References to RFC 3023 should be taken to refer to any document
that supersedes RFC 3023.</phrase></bibl>

					<bibl id="RFC3986" key="RFC3986">
T. Berners-Lee, R. Fielding, and
L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
Syntax</emph>. IETF RFC 3986. 
See <loc href="http://www.ietf.org/rfc/rfc3986.txt"/>.</bibl>

<bibl id="RFC3987" key="RFC3987">M. Duerst, M. Suignard.  
					<emph>Internationalized Resource Identifiers (IRIs)</emph>. 
					IETF RFC 3987. 
See <loc href="http://www.ietf.org/rfc/rfc3987.txt"/>.</bibl>
<!--					<bibl id="RFC3236" key="RFC3236">M. Baker, P. Stark. 
<emph>The 'application/xhtml+xml' Media Type</emph>.  IETF RFC 3236. 
See <loc href="http://www.ietf.org/rfc/rfc3236.txt"/>.</bibl>-->
					<bibl id="UNICODE-TR10" key="UNICODE TR10">Unicode Consortium.
<emph>Unicode Technical Standard #10. Unicode Collation
Algorithm</emph>.  Unicode Technical Report.  
See <loc href="http://www.unicode.org/unicode/reports/tr10/"/>.</bibl>

					<bibl id="xinclude" key="XInclude"/>
					<!--World Wide Web
Consortium. <emph>XML Inclusions (XInclude) Version 1.0</emph>
W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xinclude/"/></bibl>-->

					<bibl id="xlink" key="XLink"/>
					<!--World Wide Web
Consortium. <emph>XML Linking Language (XLink) Version 1.0</emph>.
W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xlink/"/></bibl>-->

<bibl id="SCHEMA-AND-XML-1.1" key="XML Schema 1.0 and XML 1.1">World Wide Web
Consortium. <emph>Processing XML 1.1 documents with XML Schema 1.0 processors</emph>.
W3C Working Group Note 11 May 2005. See <loc href="http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/"/></bibl>

					<bibl id="xml-stylesheet" key="XML Stylesheet"/>
					<!--World Wide Web
Consortium. <emph>Associating Style Sheets with XML documents.</emph>
W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xml-stylesheet/"/>
					</bibl>-->
					<bibl id="xptr-framework" key="XPointer Framework"/>
					<!--World Wide Web Consortium. <emph>XPointer
Framework.</emph> W3C Recommendation, 25 March 2003.
See <loc href="http://www.w3.org/TR/xptr-framework/"/>
					</bibl>-->
					<bibl id="xsl" key="Extensible Stylesheet Language (XSL)"/>
					<!--World Wide Web Consortium.  
<emph>Extensible Stylesheet Language (XSL).</emph>  W3C Recommendation.  
See <loc href="http://www.w3.org/TR/xsl/"/>
					</bibl>-->
					<bibl id="xslt" key="XSLT 1.0"/>
					<!--World Wide Web Consortium. 
<emph>XSL Transformations (XSLT) Version 1.0</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xslt"/>
					</bibl>-->
					<bibl id="xslt20req" key="XSLT 2.0 Requirements"/>
					<!--World Wide Web
Consortium. <emph>XSLT Requirements Version 2.0</emph>
W3C Working Draft. See <loc href="http://www.w3.org/TR/xslt20req"/>
					</bibl>-->
				</blist>
			</div2>
		</div1>
		<div1 id="xslt-mime-definition">

<head>The XSLT Media Type</head>

<p>This appendix registers a new MIME media type,
<quote><code>application/xslt+xml</code></quote>.</p>

<p diff="add" at="Z">This information is being submitted to the IESG (Internet Engineering Steering Group) 
for review, approval, and registration with IANA (the Internet Assigned Numbers Authority).</p>

<div2 id="media-type-registration">
<head>Registration of MIME Media Type application/xslt+xml</head>

<glist>
<gitem>
<label>MIME media type name:</label>

<def>
<p><code>application</code>
</p>
</def>
</gitem>
<gitem>
<label>MIME subtype name:</label>
<def>
<p><code>xslt+xml</code>
</p>
</def>
</gitem>
<gitem>
<label>Required parameters:</label>

<def>
<p>None.
</p>
</def>
</gitem>
<gitem>
<label>Optional parameters:</label>
<def>
  <glist>
  <gitem>
  <label><code>charset</code></label>
  <def>

  <p>This parameter has identical semantics to the <code>charset</code>
     parameter of the <code>application/xml</code> media type as
     specified in <bibref ref="RFC3023"/>.
  </p>
  </def>
  </gitem>
  </glist>
</def>
</gitem>

<gitem>
<label>Encoding considerations:</label>
<def>
<p>By virtue of XSLT content being XML, it has the same
considerations when sent as <quote><code>application/xslt+xml</code></quote>
as does XML. See RFC 3023, section 3.2.
</p>
</def>
</gitem>
<gitem>
<label>Security considerations:</label>
<def>
<p>Several XSLT instructions may cause arbitrary URIs to be
dereferenced. In this case, the security issues of 
<phrase diff="chg" at="X"><bibref ref="RFC3986"/>, section 7,</phrase>
should be considered.</p>

<p>In addition, because of the extensibility features for XSLT,
it is possible that <quote><code>application/xslt+xml</code></quote>
may describe content that has security implications beyond those
described here. However, if the processor follows only the normative semantics
of this specification, this content will be ignored. Only in
the case where the processor recognizes and processes the additional
content, or where further processing of that content is dispatched to
other processors, would security issues potentially arise. And in that
case, they would fall outside the domain of this registration
document.</p>
</def>
</gitem>
<gitem>
<label>Interoperability considerations:</label>
<def>
<p>This specification describes processing semantics that dictate
behavior that must be followed when dealing with, among other things,
unrecognized elements.</p>

<p>Because XSLT is extensible, conformant
<quote><code>application/xslt+xml</code></quote> processors can expect
that content received is well-formed XML, but it cannot be guaranteed
that the content is valid XSLT or that the processor will recognize all
of the elements and attributes in the document.</p>

</def>
</gitem>
<gitem>
<label>Published specification:</label>
<def>
<p>This media type registration is for XSLT stylesheet modules as described by
the XSLT 2.0 specification, <phrase diff="add" at="Z">which is located at
<loc href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</loc>.</phrase> 
It is also appropriate to use this media
type with earlier and later versions of the XSLT language.
</p>
</def>
</gitem>
<gitem>
<label>Applications which use this media type:</label>
<def>
<p>Existing XSLT 1.0 stylesheets are most often described using the
unregistered media type
<quote><code diff="chg" at="V">text/xsl</code></quote>.</p>

<p>There is no experimental, vendor specific, or personal tree
predecessor to <quote><code>application/xslt+xml</code></quote>,
reflecting the fact that no applications currently recognize it. This
new type is being registered in order to allow for the expected
deployment of XSLT 2.0 on the World Wide Web, as a first class XML
application.
</p>
</def>
</gitem>
<gitem>
<label>Additional information:</label>
<def>
  <glist>
  <gitem>
  <label>Magic number(s):</label>

  <def>
  <p>There is no single initial octet sequence that is always present in
XSLT documents.
  </p>
  </def>
  </gitem>
  <gitem>
  <label>File extension(s):</label>
  <def>
  <p>XSLT documents are most often identified with the extensions

<quote><code>.xsl</code></quote> or <quote><code>.xslt</code></quote>.
  </p>
  </def>
  </gitem>
  <gitem>
  <label>Macintosh File Type Code(s):</label>
  <def>

  <p>TEXT</p>
  </def>
  </gitem>
  </glist>
</def>
</gitem>
<gitem>
<label>Person &amp; email address to contact for further information:</label>
<def>

<p>Norman Walsh, <code>&lt;<loc href="mailto:Norman.Walsh@Sun.COM">Norman.Walsh@Sun.COM</loc>&gt;</code>.</p>
</def>
</gitem>
<gitem>
<label>Intended usage:</label>
<def>
<p>COMMON</p>
</def>
</gitem>
<gitem>
<label>Author/Change controller:</label>

<def>
<p>The XSLT specification is a work product of the World
Wide Web Consortium's XSL Working Group.  The W3C has change
control over these specifications.</p>
</def>
</gitem>
</glist>
</div2>
<div2 id="media-type-fragid">
<head>Fragment Identifiers</head>

<p>For documents labeled as
<quote><code>application/xslt+xml</code></quote>,
the fragment
identifier notation is exactly that for
<quote><code>application/xml</code></quote>,
as specified in RFC 3023.</p>

</div2>


		</div1>
		
		<inform-div1 id="glossary">
			<head>Glossary</head>
			<?glossary?>			
		</inform-div1>
		<inform-div1 id="element-syntax-summary">
			<head>Element Syntax Summary</head>
			<?element-syntax-summary?>			
		</inform-div1>
		<inform-div1 id="error-summary">
			<head>Summary of Error Conditions</head>
			<p>This appendix provides a summary of error conditions that a processor
may signal. This list is not exhaustive or definitive. The errors are numbered
for ease of reference, but there is no implication that an implementation <rfc2119>must</rfc2119>
signal errors using these error codes, or that applications can test for these codes.
Moreover, implementations are not <rfc2119>required</rfc2119> to signal errors using the descriptive
text used here.</p>

<?error-summary?>
			
		</inform-div1>
		<inform-div1 id="implementation-defined-features">
			<head>Checklist of Implementation-Defined Features</head>
			<p>This appendix provides a summary of XSLT language features whose effect is
explicitly <termref def="dt-implementation-defined">implementation-defined</termref>.
The conformance rules (see <specref ref="conformance"/>) require vendors to provide documentation 
that explains how these choices have been exercised.</p>

			<?implementation-defined-features?>			

		</inform-div1>
		<inform-div1 id="schema-for-xslt">
			<head>Schema for XSLT Stylesheets</head>
			<p>The following schema describes the structure of an XSLT stylesheet module. It does
not define all the constraints that apply to a stylesheet (for example, it does not attempt
to define a data type that precisely represents attributes containing XPath
 <termref def="dt-expression">expressions</termref>).
<phrase diff="chg" at="X">However, every valid stylesheet module conforms to this schema, 
unless it contains elements that invoke 
<termref def="dt-forwards-compatible-behavior">forwards-compatible-behavior</termref>.</phrase></p>

<p>A copy of this schema is available at 
<loc href="http://www.w3.org/2007/schema-for-xslt20.xsd">http://www.w3.org/2007/schema-for-xslt20.xsd</loc></p>

			<?schema-for-xslt?>
			
		</inform-div1>

		<inform-div1 id="acknowledgements">
			<head>Acknowledgements</head>
			<p>This specification was developed and approved for publication by the
W3C XSL Working Group (WG). WG approval of this specification does not
necessarily imply that all WG members voted for its approval.</p>
			<p>The chair of the XSL WG is Sharon Adler, IBM. The XSL Working Group
			includes two overlapping teams working on XSLT and XSL Formatting Objects. The
members of the XSL WG currently engaged in XSLT activities are:</p>
			<table border="1" cellpadding="5">
				<thead>
					<tr>
						<th>Participant</th>
						<th>Affiliation</th>
					</tr>
				</thead>
				<tbody>
				    <tr>
						<td>Colin Paul Adams</td>
						<td>Invited Expert</td>
					</tr>
					<tr>
						<td>Anders Berglund</td>
						<td>IBM</td>
					</tr>
					<tr>
						<td>Scott Boag</td>
						<td>IBM</td>
					</tr>			
					<tr>
						<td>Michael Kay</td>
						<td>Invited Expert</td>
					</tr>				
					<tr>
						<td>Alex Milowski</td>
						<td>Invited Expert</td>
					</tr>				
					<tr>					
						<td>William Peterson</td>
						<td>Novell, Inc</td>
					</tr>
                    <tr>
						<td>Michael Sperberg-McQueen</td>
						<td>W3C</td>
					</tr>											
					<tr>					
						<td>Zarella Rendon</td>
						<td>Invited Expert</td>
					</tr>														
					<tr>
						<td>Jeni Tennison</td>
						<td>Invited Expert</td>
					</tr>				
					<tr>
						<td>Joanne Tong</td>
						<td>IBM</td>
					</tr>
					<tr>
						<td>Norm Walsh</td>
						<td>Sun Microsystems Inc.</td>
					</tr>
                    <tr>
						<td>Mohamed Zergaoui</td>
						<td>Innovimax SARL</td>
					</tr>
					<tr>						
						<td>(vacancy)</td>
						<td>Oracle</td>
					</tr>																
				</tbody>
			</table>
			<p>Alternates are listed only where they have taken an active part in working group discussions.
			 However,
			the group acknowledges the support that many members receive from colleagues in their 
			organizations, whether or not they are officially appointed as alternates.</p>
	
			<p>The W3C representative on the XSL Working Group is Michael Sperberg-McQueen.</p>
			<p>The following individuals made significant contributions to XSLT 2.0 while they were members
 of the Working Group, and in some cases afterwards:</p>
			<slist>
				<sitem>James Clark, Invited Expert</sitem>
				<sitem>Jonathan Marsh, Microsoft</sitem>
				<sitem>Steve Muench, Oracle</sitem>
				<sitem>Steve Zilles, Adobe</sitem>
				<sitem>Evan Lenz, XYZFind</sitem>
                <sitem>Mark Scardina, Oracle</sitem>
				<sitem>Kristoffer Rose, IBM</sitem>
				<sitem>Henry Zongaro, IBM</sitem>
				<sitem>Henry Thompson, University of Edinburgh</sitem>
				<sitem>K Karun, Oracle</sitem>
			</slist>
			<p>The working group wishes to acknowledge the contribution made by David Marston
			of IBM especially to the new specification of the <function>format-number</function> function.</p>
			<p>This specification builds on the success of the XSLT 1.0 Recommendation. 
For a list of contributors to XSLT 1.0, see <bibref ref="xslt"/>.</p>
		</inform-div1>
		<inform-div1 id="requirements-checklist">
			<head>Checklist of Requirements</head>
			<p>This section provides a checklist of progress against the published
XSLT 2.0 Requirements document (see <bibref ref="xslt20req"/>).</p>
			<requirements>
				<req>
					<req-text>
						<p><rfc2119>must</rfc2119>Maintain Backwards Compatibility with XSLT 1.1 
         [Read this as "with XSLT 1.0"]</p>
						<p>Any stylesheet whose behavior is fully defined in XSLT
1.0 and which generates no errors will produce the same result tree under
XSLT 2.0</p>
					</req-text>
					<req-response>
						<p>See <specref ref="incompatibilities"/>
						</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>must</rfc2119> Match Elements with Null Values</p>
						<p>A stylesheet should be able to match elements and attributes whose value
          is explicitly null. </p>
					</req-text>
					<req-response>
						<p>This has been handled as an XPath 2.0 requirement. <phrase diff="add" at="Y">A new function 
            <xfunction>nilled</xfunction> is available to test whether an element has been marked
            as nil after schema validation.</phrase></p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>should</rfc2119>Allow Included Documents to "Encapsulate"  Local Stylesheets</p>
						<p>XSLT 2.0 <rfc2119>should</rfc2119> define a mechanism to allow the templates in  a stylesheet
          associated with a secondary source document, to be imported and used
           to format the included fragment, taking precedence over any applicable
            templates in the current stylesheet.</p>
					</req-text>
					<req-response>
						<p>The facility to define modes has been generalized, making it easier
      to define a distinct set of template rules for processing a particular document.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldSupport Accessing Infoset Items for XML Declaration</p>
						<p>A stylesheet COULD be able to access information like the version and
          encoding from the XML declaration of a document.</p>
					</req-text>
					<req-response>
						<p>No new facilities have been provided in this area, because
						this information is not available in the data model.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldProvide QName Aware String Functions</p>
						<p>Users manipulating documents (for example stylesheets, schemas) that have
          QName-valued element or attribute content need functions that take a
string containing a QName as their argument, convert it to an <termref def="dt-expanded-qname">expanded-QName</termref>
using either the namespace declarations in scope at that point in the
stylesheet, or the namespace declarations in scope for a specific source
node, and return properties of the <termref def="dt-expanded-qname">expanded-QName</termref> such as its namespace URI
and local name.</p>
					</req-text>
					<req-response>
						<p>Functions operating on QNames are included in the XPath 2.0 
      Functions and Operators document: see <bibref ref="xpath-functions"/>.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldEnable Constructing a Namespace with Computed Name</p>
						<p>Provide an <elcode>xsl:namespace</elcode> analog to
          <elcode>xsl:element</elcode> for constructing
          a namespace node with a computed prefix and URI.</p>
					</req-text>
					<req-response>
						<p>An <elcode>xsl:namespace</elcode> instruction has been added: see
         <specref ref="creating-namespace-nodes"/>.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldSimplify Resolving Prefix Conflicts in QName-Valued Attributes</p>
						<p>XSLT 2.0 could simplify the renaming of conflicting namespace prefixes in
          result tree fragments, particularly for attributes declared in a schema
           as being QNames. Once the processor knows an attribute value
is a QName, an XSLT processor <rfc2119>should</rfc2119> be able to rename prefixes and
generate namespace declarations to preserve the semantics of that
attribute value, just as it does for attribute names.  </p>
					</req-text>
					<req-response>
						<p>If an attribute is typed as a QName in the schema, the
      new XPath 2.0 functions can be used to manipulate it as required at
      application level. This <phrase diff="chg" at="Y">is considered</phrase> sufficient to meet the requirement.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldSupport XHTML Output Method</p>
						<p>Complementing the existing output methods for html, xml, and text, an
          xhtml output method could be provided to simplify transformations which
           target XHTML output.</p>
					</req-text>
					<req-response>
						<p>An XHTML output method is now provided: see <bibref ref="xslt-xquery-serialization"/></p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>must</rfc2119>Allow Matching on Default Namespace Without Explicit Prefix</p>
						<p>Many users stumble trying to match an element with a default namespace.</p>
					</req-text>
					<req-response>
						<p>A new <code>[xsl:]xpath-default-namespace</code> attribute 
      is provided for this purpose: see <specref ref="unprefixed-qnames"/></p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>must</rfc2119>Add Date Formatting Functions</p>
						<p>One of the more frequent requests from XSLT 1.0 users is the ability
          to format date information with similar control  to XSLT's
           format-number. XML Schema introduces several kinds of date
            and time datatypes which will further increase the demand
             for date formatting during transformations. Functionality
              similar to that provided by java.text.SimpleDateFormat.
               A date analog of XSLT's named  xsl:decimal-format may
                be required to handle locale-specific date formatting issues. </p>
					</req-text>
					<req-response>
						<p>A set of date formatting functions has been specified:
						see <specref ref="format-date"/></p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>must</rfc2119>Simplify Accessing Id's and Key's in Other Documents</p>
						<p>Currently it is cumbersome to lookup nodes by id() or key() in documents
          other than the source document. Users <rfc2119>must</rfc2119> first use an xsl:for-each
           instruction, selecting the desired document() to make it the current
            node, then relative XPath expressions within the scope of the
             xsl:for-each can refer to id() or key()  as desired.</p>
					</req-text>
					<req-response>
						<p>The requirement is met by the generalization of path syntax in XPath 2.0. It is
						now possible to use a path expression such as <code>document('a.xml')/id('A001')</code>.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>should</rfc2119>Provide Function to Absolutize Relative URIs</p>
						<p>There <rfc2119>should</rfc2119> be a way in XSLT 2.0 to create an absolute URI. The 
         functionality <rfc2119>should</rfc2119> allow passing a node-set and return a <termref def="dt-string-value">string value</termref> 
         representing the absolute URI resolved with respect to the base URI of 
         the current node. </p>
					</req-text>
					<req-response>
						<p>A function <xfunction>resolve-uri</xfunction> is now defined in 
      <bibref ref="xpath-functions"/>.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>should</rfc2119>Include Unparsed Text from an External Resource</p>
						<p>Frequently stylesheets <rfc2119>must</rfc2119> import text from external resources. 
         Today users have to resort to
          <termref def="dt-extension-function">extension functions</termref> to accomplish
           this because XSLT 1.0 only provides the document() function which, while useful,
            can only read external resources that are well-formed XML documents.</p>
					</req-text>
					<req-response>
						<p>A function <function>unparsed-text</function> has been added: see
						<specref ref="unparsed-text"/></p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>should</rfc2119>Allow Authoring Extension Functions in XSLT</p>
						<p>As part of the XSLT 1.1 work done on
          <termref def="dt-extension-function">extension functions</termref>, a proposal to 
         author XSLT extension functions in XSLT itself was deferred for reconsideration
          in XSLT 2.0. This would allow the functions in an extension namespace to be
           implemented in "pure" XSLT, without resulting to external programming languages.</p>
					</req-text>
					<req-response>
						<p>A solution to this requirement, the <elcode>xsl:function</elcode> element,
      is included in this specification. See <specref ref="stylesheet-functions"/>.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>should</rfc2119>Output Character Entity References Instead of Numeric Character Entities</p>
						<p>Users have frequently requested the ability to have the output of their transformation
          use (named) character references  instead of the numeric character entity. 
          The ability to control this preference as the level of the whole document 
          is sufficient. For example, rather than seeing &amp;#160; in the output, 
          the user could request to see the equivalent &amp;nbsp; instead.</p>
					</req-text>
					<req-response>
						<p>The serialization specification
						gives the implementation discretion on how special characters are output.
						A user who wishes to force the use of named character references can
						achieve this using the new <elcode>xsl:character-map</elcode> declaration.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>should</rfc2119>Construct Entity Reference by Name</p>
						<p>Analogous to the ability to create elements and attributes, users
          have expressed a desire to construct named entity references.  </p>
					</req-text>
					<req-response>
						<p>No solution has been provided to this requirement;
						it is difficult, because entity references are not defined in the data model.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>should</rfc2119>Support for Unicode String Normalization</p>
						<p>For reliable string comparison of Unicode strings, users need the ability to 
         apply Unicode normalization before comparing the strings.</p>
					</req-text>
					<req-response>
						<p>This requirement has been addressed by the provision of the
						<xfunction>normalize-unicode</xfunction> function described in
						<bibref ref="xpath-functions"/>. In addition, a serialization parameter
						<code diff="chg" at="Y">normalization-form</code> has been added.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>should</rfc2119>Standardize Extension Element Language Bindings</p>
						<p>XSLT 1.1 undertook the standardization of language bindings for XSLT 
         <termref def="dt-extension-function">extension functions</termref>. 
         For XSLT 2.0, analogous bindings <rfc2119>should</rfc2119> be provided 
         for extension elements [now 
         renamed <termref def="dt-extension-instruction">extension instructions</termref>].</p>
					</req-text>
					<req-response>
						<p>The XSL Working Group has decided not to pursue this requirement,
      and the attempt to standardize language bindings for extension functions that
      appeared in the XSLT 1.1 Working Draft has now been withdrawn. The Working Group
      decided that language bindings would be better published separately from the
      core XSLT specification.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldImprove Efficiency of Transformations on Large Documents</p>
						<p>Many useful transformations take place on large documents consisting of thousands of repeating "sub-documents". Today 
						transformations over these documents are impractical due to the need to have the entire source tree in memory.  
            Enabling "progressive" transformations, where the processor is able to produce
progressively more output as more input is received,  is tantamount to avoiding the need for XSLT processors to have random access to the entire
source document. This might be accomplished by: </p>
						<p>Identifying a core subset of XPath that does not require random access to the source tree, or</p>
						<p>Consider a "transform all subtrees" mode where the stylesheet
says, "Apply the transformation implied by this stylesheet to each node that
matches XXX, considered as the root of a separate tree, and copy all the
results of these mini-transformations as separate subtrees on to the final
result tree."</p>
					</req-text>
					<req-response>
						<p diff="chg" at="Y">The Working Group observes that implementation techniques for XSLT processing
            have advanced considerably since this requirement was written, and that further research developing
            new approaches continues both in industry and academia. In the light of
            these developments, the Working Group has decided that it would be inappropriate at this stage to identify
            language features or subsets designed specifically to enable progressive transformations.
            </p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldSupport Reverse IDREF attributes</p>
						<p>Given a particular value of an ID, produce a list of all elements that have an IDREF or IDREFS attribute which refers to this ID.</p>
						<p>This functionality can be accomplished using the current &lt;xsl:key&gt; and key() mechanism.</p>
					</req-text>
					<req-response>
						<p>The <xfunction>idref</xfunction> function defined in <bibref ref="xpath-functions"/> has been
						introduced in response to this requirement.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldSupport Case-Insensitive Comparisons</p>
						<p> XSLT 2.0 could expand its comparison functionality  to include support for case-insensitive string comparison.</p>
					</req-text>
					<req-response>
						<p>This is an XPath 2.0 requirement. XPath 2.0 includes
      functions to convert strings to uppercase or lowercase, it also includes functions to compare
      strings using a named collating sequence, which provides the option of using a collating
      sequence that treats uppercase and lowercase as equal.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldSupport Lexigraphic String Comparisons</p>
						<p>We don't let users compare strings like $x &gt; 'a'. </p>
					</req-text>
					<req-response>
						<p>This requirement has been addressed in XPath 2.0.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldAllow Comparing  Nodes Based on Document Order</p>
						<p>Support the ability to test whether one node comes before another in document order.</p>
					</req-text>
					<req-response>
						<p>This requirement has been addressed in XPath 2.0, using the operators
						<code>&lt;&lt;</code> and <code>&gt;&gt;</code>.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldImprove Support for Unparsed Entities</p>
						<p>In XSLT 1.0 there is an asymmetry in support for unparsed entities. 
         They can be handled on input but not on output. In particular, there 
         is no way to do an identity transformation that preserves them. 
         At a minimum we need the ability to retrieve the Public ID of an unparsed entity.</p>
					</req-text>
					<req-response>
						<p>A function to retrieve the public identifier of an unparsed
      entity has been added. However, no facilities have been provided to include unparsed entities
      in a result document.
						</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldAllow Processing a Node with the "Next Best Matching" Template</p>
						<p>In the construction of large stylesheets for complex documents, it is often 
         necessary to construct templates that implement special behavior for a particular 
         instance of an element, and then apply the normal styling for that element. 
         Currently this is not possible because <elcode>xsl:apply-templates</elcode> specifies 
         that for any given node only a single template will be selected and instantiated.</p>
						<p>Currently the processor determines a list of matching templates and then 
         discards all but the one with the highest priority. In order to support this 
         requirement, the processor would retain the list of matching templates sorted 
         in priority order. A new instruction, for example <elcode>xsl:next-match</elcode>, 
         in a template would simply trigger the next template in the list of matching 
         templates. This "next best match"  recursion naturally bottoms out at the
          builtin template which can be seen as the lowest priority matching template
           for every match pattern.
</p>
					</req-text>
					<req-response>
						<p>An <elcode>xsl:next-match</elcode> instruction has been added.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldMake Coercions Symmetric By Allowing Scalar to Nodeset Conversion</p>
						<p>Presently, no datatype can be coerced or cast to a node-set. By 
         allowing a <termref def="dt-string-value">string value</termref> to convert to a node-set, some user "gotchas" 
         could be avoided. </p>
					</req-text>
					<req-response>
						<p>The availability of sequences of strings or numbers probably
      meets most of the use-cases envisaged by this requirement.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>must</rfc2119>Simplify Constructing and Copying Typed Content</p>
						<p>It <rfc2119>must</rfc2119> be possible to construct XML Schema-typed elements and
          attributes. In addition, when copying an element or an attribute to
           the result, it <rfc2119>should</rfc2119> be possible to preserve the type during the process.</p>
					</req-text>
					<req-response>
						<p diff="chg" at="Y">Facilities to validate constructed and copied
      element and attribute nodes are defined in this specification; these elements and attributes will
      carry a type annotation indicating their XML Schema type. In addition, it is possible to specify when
      copying nodes whether type annotations should be preserved or removed.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>must</rfc2119>Support Sorting Nodes Based on XML Schema Type</p>
						<p>XSLT 1.0 supports  sorting based on string-valued and number-valued expressions.
          XML Schema: Datatypes introduces new scalar types (for example, date)
           with well-known sort orders. It <rfc2119>must</rfc2119> be possible to sort based on these
            extended set of scalar data types. Since XML Schema: Datatypes does not
             define an ordering for complex types, this sorting support <rfc2119>should</rfc2119> only
              be considered for simple types.</p>
						<p><rfc2119>should</rfc2119> be consistent with whatever we define for the matrix of conversion and comparisons.</p>
					</req-text>
					<req-response>
						<p>Sorting based on any schema-defined primitive data type with
						a total ordering is included
      in this specification. </p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldSupport Scientific Notation in Number Formatting</p>
						<p>Several users have requested the ability to have the existing
          format-number() function extended to format numbers using
           Scientific Notation.</p>
					</req-text>
					<req-response>
						<p diff="chg" at="Y">Simple scientific formatting is now
      available through support for the schema-defined <code>xs:float</code> and <code>xs:double</code> data types;
      casting a large or small value of these types to a string produces a representation of the value in 
      scientific notation. The Working Group believes that this will meet the requirement in most cases, and
      has therefore decided not to enhance the <function>format-number</function> further to introduce scientific notation. 
      Users with more specialized requirements can write their own functions.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p>CouldProvide Ability to Detect Whether "Rich" Schema Information
          is Available</p>
						<p>A stylesheet that requires XML Schema type-related functionality
          could be able to test whether a "rich" Post-Schema-Validated
           Infoset is available from the XML Schema processor, so that
            the stylesheet can provide fallback behavior or choose to exit
             with <code>xsl:message abort="yes"</code>.</p>
					</req-text>
					<req-response>
						<p diff="chg" at="Y">This requirement is satisified through the <code>instance of</code> operator in XPath 2.0,
            which allows expressions to determine the type of element and
      attribute nodes, using information from the schema. The details of
      how these expressions behave when there is no schema are defined in the XPath
      specifications.</p>
					</req-response>
				</req>
				<req>
					<req-text>
						<p><rfc2119>must</rfc2119>Simplify Grouping</p>
						<p>Grouping is complicated in XSLT 1.0. It <rfc2119>must</rfc2119> be possible for users to group
          nodes in a document based on common string-values, common names, or
          common values for any other expression</p>
						<p>In addition XSLT <rfc2119>must</rfc2119>  allow grouping based on sequential position, for example
selecting groups of adjacent &lt;P&gt; elements. Ideally it <rfc2119>should</rfc2119> also make it
easier to do fixed-size grouping as well, for example groups of three adjacent nodes, for
laying out data in multiple columns.
For each group of nodes identified, it <rfc2119>must</rfc2119> be possible to instantiate a template for the group. Grouping <rfc2119>must</rfc2119> be "nestable" to multiple levels so that groups of distinct nodes can be identified, then from among the distinct groups selected, 
further sub-grouping of distinct node in the current group can be done. </p>
					</req-text>
					<req-response>
						<p>A new <elcode>xsl:for-each-group</elcode> instruction is provided: see
       <specref ref="grouping"/>. In addition, many of the new functions and operators provided
       in XPath 2.0 make these algorithms easier to write.</p>
					</req-response>
				</req>
			</requirements>
		</inform-div1>
		<!--	<inform-div1 id="issues-list">
		<head>Summary of Issues</head>
			<div2 id="open-issues">
				<head>Open Issues</head>
				<?issues-list-open?>				
			</div2>
			<div2 id="decided-issues">
				<head>Decided Issues</head>
				<p>These are issues where the working group has made a decision, but the decision is not yet reflected
in this draft.</p>
				<?issues-list-decided?>				
			</div2>
			<div2 id="closed-issues">
				<head>Closed Issues</head>
				
				<p>The only issues listed in this section are those whose status has changed since the date of the
				previous working draft, 2 May 2003.</p>
				<?issues-list-closed?>				
				
			</div2>
		</inform-div1>-->
		<inform-div1 id="changes">
			<head>Changes from XSLT 1.0</head>
			<div2 id="incompatibilities">
				<head>Incompatible Changes</head>


				<p>This section lists all known cases where a stylesheet that was valid (produced no errors)
under XSLT 1.0, and whose behavior was fully specified by XSLT 1.0,
will produce different results under XSLT 2.0.</p>

				<p>Most of the discussion is concerned with compatibility
in the absence of a schema: that is, it is assumed that the source document
being transformed has no schema when processed using XSLT 1.0, and that no
schema is added when moving to XSLT 2.0. Some additional factors that come into
play when a schema is added are noted at the end of the section.</p>



<div3 id="incompatibility-stripping" diff="add" at="Z"><head>Tree construction: whitespace stripping</head>

<p>Both in XSLT 1.0 and in XSLT 2.0, the XSLT specification places no constraints on the
way in which source trees are constructed. For XSLT 2.0, however, the <bibref ref="xpath-datamodel"/>
specification describes explicit processes for constructing a tree
from an Infoset or a PSVI, while also permitting other processes to be used.
The process described in <bibref ref="xpath-datamodel"/> has the effect of stripping 
<termref def="dt-whitespace-text-node">whitespace text nodes</termref>
from elements declared to have element-only content. Although the
XSLT 1.0 specification did not preclude such behavior, it differs from the
way that most existing XSLT 1.0 implementations work. It is <rfc2119>recommended</rfc2119> that
an XSLT 2.0 implementation wishing to provide maximum interoperability and
backwards compatibility should offer the user the option either to construct
source trees using the processes described in <bibref ref="xpath-datamodel"/>, or alternatively
to retain or remove whitespace according to the common practice of previous
XSLT 1.0 implementations.</p>

<p>To write transformations that give the same result regardless of the
whitespace stripping applied during tree construction, stylesheet authors
can:</p>

<ulist>
<item><p>use the <elcode>xsl:strip-space</elcode> declaration to remove 
<termref def="dt-whitespace-text-node">whitespace text nodes</termref> from
elements having element-only content (this has no effect if the whitespace
has already been stripped)</p></item>

<item><p>use instructions such as <code>&lt;xsl:apply-templates select="*"/&gt;</code> that cause only
the element children of the context node to be processed, and not its text
nodes.</p></item>
</ulist> 

</div3>

<div3 id="incompatibility-serialization" diff="add" at="Z">
<head>Changes in Serialization Behavior</head>

<p>The specification of the output of <termref def="dt-serialization">serialization</termref> 
is more prescriptive than
in XSLT 1.0. For example, the <code>html</code> output method is
 <rfc2119>required</rfc2119> to detect invalid HTML characters. Also, certain
 combinations of serialization parameters are now defined to be errors.
Furthermore, XSLT 1.0 implementations were allowed to add
additional <elcode>xsl:output</elcode> attributes that modified the behavior of the
serializer. Some such extensions might be non-conformant
under the stricter rules of XSLT 2.0. For example, some XSLT 1.0 processors
provided an extension attribute to switch off the creation of <code>meta</code> elements
by the <code>html</code> output method (a facility that is now provided as standard). A
conformant XSLT 2.0 processor is not allowed to provide such extensions.</p>

<p>Where necessary, implementations <rfc2119>may</rfc2119> provide additional serialization methods
designed to mimic more closely the behavior of specific XSLT 1.0 serializers.</p>

</div3>

<div3 id="backwards-compatibility-behavior"><head>Backwards Compatibility Behavior</head>
<p>Some XSLT constructs behave differently under XSLT 2.0 depending on whether
 <termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref> is enabled.
 In these cases, the behavior may be made compatible with XSLT 1.0 by ensuring that 
 <termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref> is enabled
 (which is done using the <code>[xsl:]version</code> attribute).</p>
 
 <p>These constructs are as follows:</p>
 
 <olist>
 <item><p>If the <elcode>xsl:value-of</elcode> instruction has no <code>separator</code> attribute, and the
 value of the <code>select</code> expression is a sequence of more than one item, then under XSLT 2.0
 all items in the sequence will be output, space separated, while in XSLT 1.0, all items after the first
 will be discarded.</p></item>
 
 <item><p>If the <termref def="dt-effective-value">effective value</termref> of an
 <termref def="dt-attribute-value-template">attribute value template</termref>
  is a sequence of more than one item, then under XSLT 2.0
 all items in the sequence will be output, space separated, while in XSLT 1.0, all items after the first
 will be discarded.</p></item>
  
 <item><p diff="chg" at="ZA">If the expression in the <code>value</code> attribute of the 
 <elcode>xsl:number</elcode> instruction
 returns a sequence of more than one item, then under XSLT 2.0
 all items in the sequence will be output, as defined by the <code>format</code> attribute, 
 but under XSLT 1.0, all items after the first will be discarded. If the sequence is empty, then
 under XSLT 2.0 nothing will be output (other than a prefix and suffix if requested), 
 but under XSLT 1.0, the output is "NaN". If the first item
 in the sequence cannot be converted to a number, then XSLT 2.0 signals a non-recoverable error,
 while XSLT 1.0 outputs "NaN".</p>

 <p>If the expression in the <code>value</code> attribute of
<elcode>xsl:number</elcode> returns an empty sequence or a sequence including non-numeric values,
an XSLT 2.0 processor may signal a recoverable error; but with backwards compatibility enabled, it
outputs <code>NaN</code>.</p></item>
 
  <item><p>If the <termref def="dt-atomization">atomized</termref> value of the
   <code>select</code> attribute of the <elcode>xsl:sort</elcode> element
  is a sequence of more than one item, then under XSLT 2.0
 an error will be signaled, 
 while in XSLT 1.0, all items after the first will be discarded.</p></item>

 <item diff="add" at="T"><p diff="add" at="T">If an <elcode>xsl:call-template</elcode> instruction
 supplies a parameter that does not correspond to any <termref def="dt-template-parameter">template
 parameter</termref> in the template being called, then under XSLT 2.0 a
  <termref def="dt-static-error">static error</termref>
 is signaled, but under XSLT 1.0 the extra parameter is ignored.</p></item>

 <item><p diff="add" at="U">It is normally a <termref def="dt-static-error">static error</termref>
 if an XPath expression contains a call to an unknown function. But when backwards compatible behavior
 is enabled, this is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>,
 which occurs only if the function call is actually evaluated.</p></item>

    

    <item><p>An XSLT 1.0 processor compared the value of the expression in the
<code>use</code> attribute of <elcode>xsl:key</elcode> to the value supplied in the second
argument of the <function>key</function> function by converting both to strings. An XSLT 2.0 processor
normally compares the values as supplied. The XSLT 1.0 behavior is retained if any of the <elcode>xsl:key</elcode>
elements making up the <termref def="dt-key">key</termref> definition enables
backwards-compatible behavior.</p>
</item>



    <item diff="add" at="W">
							<p>If no output method is explicitly requested, and the
first element node output appears to be an XHTML document element, then under XSLT 2.0 the 
output method defaults to XHTML; with backwards compatibility enabled, the XML output method
 will be used.</p>
						</item>

 </olist>
 
 <p>Backwards compatible behavior also affects the results of certain XPath expressions, as defined in
 <bibref ref="xpath20"/>.</p>
 
</div3> 

				<div3 id="incompatibility-without-schema">
					<head>Incompatibility in the Absence of a Schema</head>
					<p>If the source documents supplied as input to a transformation contain
no type information generated from a schema then the known areas of incompatibility are as follows. 
These apply whether or not
<termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref> 
is enabled.</p>
					<olist>
						<item>
							<p>A stylesheet that specifies a version number other than 1.0 was defined
in XSLT 1.0 to execute in forwards-compatible mode; if such a stylesheet uses features
that are not defined in XSLT 2.0 then errors may be signaled by an XSLT 2.0 processor
that would not be signaled by an XSLT 1.0 processor.</p>
						</item>

						<item>
							<p>At XSLT 1.0 the <function>system-property</function> function, when called with a first
argument of <code>"xsl:version"</code>, returned 1.0 as a number. At XSLT 2.0 it returns "2.0"
as a string. The <rfc2119>recommended</rfc2119> way of testing this property is, for example,
<code diff="chg" at="T">&lt;xsl:if test="number(system-property('xsl:version')) &amp;lt; 2.0"&gt;</code>, which
will work with either an XSLT 1.0 or an XSLT 2.0 processor.</p>
						</item>						
 		

	<item>
		<p>At XSLT 2.0 it is an error to specify the <code>mode</code>
or <code>priority</code> attribute on an <elcode>xsl:template</elcode> element having no
<code>match</code> attribute. At XSLT 1.0 the attributes were silently ignored in this
situation.</p>
	</item>

	<item><p diff="add" at="ZA">When an <elcode>xsl:apply-templates</elcode>
or <elcode>xsl:apply-imports</elcode> instruction causes a built-in template rule to be
invoked, then any parameters that are supplied are automatically passed on
to any further template rules. This did not happen in XSLT 1.0.</p></item>
    
    <item><p>In XSLT 1.0 it was a recoverable error to create any node other than
    a text node while constructing the value of an attribute, comment, or processing-instruction; the
    recovery action was to ignore the offending node and its content. In XSLT 2.0 this is no longer
    an error, and the specified action is to atomize the node. An XSLT 2.0 processor will therefore
    not produce the same results as an XSLT 1.0 processor that took the error recovery action.</p></item>

    <item diff="add" at="X"><p>XSLT 1.0 defined a number of recoverable error conditions which in XSLT 2.0 have
    become non-recoverable errors. Under XSLT 1.0, a stylesheet that triggered such errors would fail
    under some XSLT processors and succeed (or at any rate, continue to completion) under others.
    Under XSLT 2.0 such a stylesheet will fail under all processors. Notable examples of such errors
    are constructing an element or attribute with an invalid name, generating attributes as children of
    a document node, and generating an attribute of an element after generating one or more children
    for the element. This change has been made in the interests of interoperability. 
    In classifying such errors as non-recoverable, the Working Group used the criterion
    that no stylesheet author would be likely to write code that deliberately triggered the error and
    relied on the recovery action.</p></item>

    <item diff="add" at="Y"><p>In XSLT 1.0, the semantics of tree construction were described as being
    top-down, in XSLT 2.0 they are described bottom up. In nearly all cases the end result is the same. One
    difference arises in the case of a tree that is constructed to contain an attribute node within a document
    node within an element node, using an instruction such as the following:</p>

<example>
<head>Attribute within Document within Element</head>
<eg diff="chg" at="T"><![CDATA[<xsl:template match="/">
  <e>
    <xsl:copy>
      <xsl:attribute name="a">5</xsl:attribute>
    </xsl:copy>
  </e>
</xsl:template>]]></eg></example>

    <p>In XSLT 1.0, the <elcode>xsl:copy</elcode> did nothing, and the attribute <code>a</code> was then 
    attached to the element <code>e</code>. In XSLT 2.0, an error occurs when attaching the attribute <code>a</code>
    to the document node constructed by <elcode>xsl:copy</elcode>, because this happens before the resulting
    document node is copied to the content of the constructed element.</p>
    </item> 

    <item diff="add" at="W"><p>In XSLT 1.0 it was not an error for the <code>namespace</code>
    attribute of <elcode>xsl:element</elcode> or <elcode>xsl:attribute</elcode> to evaluate to an invalid URI.
    Since many XML parsers accept any string as a namespace name, this rarely caused problems. The 
    <bibref ref="xpath-datamodel"/>, however, requires the name of a node to be an <code>xs:QName</code>, and
    the namespace part of an <code>xs:QName</code> is always an <code>xs:anyURI</code>. It is therefore
    now defined to be an error to create an element or attribute node in a namespace whose name is not
    a valid instance of <code>xs:anyURI</code>. <phrase diff="chg" at="X">In practice, however, 
    implementations have some flexibility in how rigorously they validate namespace URIs.</phrase></p></item>
    
	<item><p>It is now a static error for the stylesheet to contain two conflicting 
	    <elcode>xsl:namespace-alias</elcode> declarations with the same import precedence.</p>
	</item>	

	<item><p>It is now a static error for an <elcode>xsl:number</elcode> instruction to 
	contain both a <code>value</code> attribute and a <code>level</code>, <code>from</code>,
	or <code>count</code> attribute. In XSLT 1.0 the <code>value</code> attribute took
	precedence and the other attributes were silently ignored.</p>
	</item>											

						<item>
							<p>When the <code>data-type</code> attribute of <elcode>xsl:sort</elcode>
has the value <code>number</code>, an XSLT 1.0 processor would evaluate the sort key as a string,
and convert the result to a number. An XSLT 2.0 processor evaluates the sort key as a number
directly. This only affects the outcome in cases where <phrase diff="add" at="Y">in XSLT 1.0,</phrase>
 conversion of a number to a string and then
back to a number does not produce the original number, as is the case for example with the number
<phrase diff="chg" at="Y">positive infinity</phrase>.</p>
						</item>
<item><p>When the <code>data-type</code> attribute of <elcode>xsl:sort</elcode>
is omitted, an XSLT 1.0 processor would convert the sort key values to strings, and sort them as strings.
An XSLT 2.0 processor will sort them according to their actual dynamic type. This means, for example,
that if the sort key component specifies <code>&lt;xsl:sort select="string-length(.)"/&gt;</code>, an XSLT 2.0 processor will
do a numeric sort where an XSLT 1.0 processor would have done an alphabetic sort.</p>
</item>

<item diff="add" at="Y"><p>When the <code>data-type</code> attribute of <elcode>xsl:sort</elcode>
is omitted or has the value "text", an XSLT 1.0 processor treats a sort key whose value is an empty
node-set as being equal to a sort key whose value is a zero-length string. XSLT 2.0 sorts the empty
sequence before the zero-length string. This means that if there are two sort keys, say
<code><![CDATA[<xsl:sort select="@a"/>]]></code> and <code><![CDATA[<xsl:sort select="@b"/>]]></code>, then
an XSLT 1.0 processor will sort the element <code><![CDATA[<x b="2"/>]]></code> after 
<code><![CDATA[<x a="" b="1"/>]]></code>, while an XSLT 2.0 processor will produce the opposite
ordering.</p>
</item>
						

						<item>
							<p>The specification of the <function>format-number</function>
function has been rewritten to remove the normative dependency on the Java JDK 1.1
specification. The JDK 1.1 specification left aspects of the behavior undefined; it is
therefore likely that some cases will give different results.</p>

<p>The ability to include
literal text in the format picture enclosed in single quotes has been removed; any
stylesheet that uses this feature will need to be modified, for example to display the
literal text using the <xfunction>concat</xfunction> function instead.</p>

<p>One specific difference between the XSLT 2.0 specification and a JDK-based implementation
is in the handling of the negative sub-picture. JDK releases subsequent to JDK 1.1 have added
the provision: <emph>If there is an explicit negative subpattern [sub-picture], it serves only to specify
 the negative prefix and suffix; the number of digits, minimal digits, and other characteristics
  are all the same as the positive pattern [sub-picture].</emph> This statement was not present in the JDK 1.1
  specification, and therefore it is not necessarily how every XSLT 1.0 implementation will behave,
  but it does describe the behavior of some XSLT 1.0 implementations that use the JDK directly.
  This behavior is not correct in XSLT 2.0: the negative sub-picture <rfc2119>must</rfc2119> be used as written when
  the number is negative.</p>
						</item>
						
<item diff="add" at="R"><p>The recovery action has changed for the error condition where the processor
cannot handle the fragment identifier in a URI passed as an argument to the <function>document</function> function.
XSLT 1.0 specified that the entire URI reference should be ignored. XSLT 2.0 specifies that the fragment identifier
should be ignored.</p></item>						
						<item>
							<p>XSLT 1.0 allowed the URI returned by the <function>unparsed-entity-uri</function>
function to be derived from some combination of the system identifier and the public identifier
in the source XML. XSLT 2.0 returns the system identifier as defined in the Infoset, resolved using
the base URI of the source document. A new function is provided to return the public identifier.</p>
						</item>


<item>
	<p>The default priority of the pattern <code>match="/"</code> has 
	changed from +0.5 to -0.5. The effect of this is that if there are
	any template rules that specify <code>match="/"</code> with an explicit
	user-specified priority between -0.5 and +0.5, these will now be chosen
	in preference to a template rule that specifies <code>match="/"</code>
	with no explicit priority; previously such rules would never have been
	invoked.</p>
</item>
<item diff="add" at="ZA"><p>In XSLT 1.0 it was possible to create a processing instruction
in the result tree whose string value contained a leading space. However, such leading spaces
would be lost after serialization and parsing. In XSLT 2.0, any leading spaces in the string
value of the processing instruction are removed at the time the node is created.</p></item>						
<item>
	<p>At XSLT 1.0 there were no restrictions on the namespaces that could be
used for the names of user-defined stylesheet objects such as keys, variables, and named templates.
In XSLT 2.0, certain namespaces (for example the XSLT namespace and the XML Schema namespace)
are reserved.</p>
</item>
<item>
    <p>An erratum to XSLT 1.0 specified what has become known as "sticky
    disable-output-escaping": specifically, that it should be possible to use <code>disable-output-escaping</code>
    when writing a node to a temporary tree, and that this information would be retained for use 
    when the same node was later copied to a final result tree and serialized. XSLT 2.0 no longer
    specifies this behavior (though it permits it, at the discretion of the implementation). The
    use cases for this facility have been satisfied by a completely different mechanism, the
    concept of character maps (see <specref ref="character-maps"/>).</p>
</item>
         </olist>		

				</div3>

				<div3 id="compatibility-with-schema">
					<head>Compatibility in the Presence of a Schema</head>
					<p>An XSLT 1.0 processor ignored all information about data types that might be obtained from
a schema associated with a source document. 
An XSLT 2.0 processor will take account of
such information, <phrase diff="add" at="U">unless the <code>input-type-annotations</code> attribute
is set to <code>strip</code></phrase>. This may lead to a number of differences in behavior. 
This section attempts
only to give some examples of the kind of differences that might be expected when schema
information is made available:</p>
					<ulist>
						<item>
							<p>Operations such as sorting will be sensitive to the data type of the items
being sorted. For example, if the data type of a sort key component is defined in the schema
as a date, then in the absence of a <code>data-type</code> attribute on the 
<elcode>xsl:sort</elcode> element, the sequence will be sorted in date order. With XSLT 1.0,
the dates would be compared and sorted as strings.</p>
						</item>
						<item>
    						<p>Certain operations that are permitted on untyped data
    						are not permitted on typed data, if the type of the data is inappropriate
    						for the operation. <phrase diff="chg" at="Z">For example, the 
							<xfunction>substring</xfunction> function
    						expects its first argument to be a string</phrase>. It is acceptable to supply an untyped
    						value, which will be automatically converted to a string, but it is not 
    						acceptable to supply a value which has been annotated (as a result of schema
    						processing) as an integer or a date.</p>
						</item>
						<item>
						    <p>When an attribute value such as <code>colors="red green blue"</code>
						    is processed without a schema, the value is considered to be a single string. When
						    schema validation is applied, assuming the type is a list type like <code>xs:NMTOKENS</code>,
						    the value will be treated as a sequence of three strings. This affects the results
						    of many operations, for example comparison of the value with another string.
                <phrase diff="add" at="U">With this attribute value, the expression 
                <code>contains(@colors, "green")</code> returns true in XPath 1.0 and also in XPath 2.0
                if <code>input-type-annotations</code> is set to <code>strip</code>. 
                In XPath 2.0, with a schema-aware processor and with 
                <code>input-type-annotations</code> set to <code>preserve</code>, the same expression
                returns false with backwards-compatibility enabled, and raises an error with backwards
                compatibility disabled.</phrase></p>
						</item>
					</ulist>
				</div3>
				<div3 id="xpath-compatibility">
					<head>XPath 2.0 Backwards Compatibility</head>
					<p>Information about incompatibilities between XPath 2.0 and XPath 1.0
is included in <bibref ref="xpath20"/>
					</p>
					<p>Incompatibilities in the specification of individual functions in the
           <termref def="dt-core-function">core function</termref> library are listed in <bibref ref="xpath-functions"/>
					</p>
				</div3>
			</div2>
			<div2 id="changes-since-1.0">
				<head>New Functionality</head>
				<p>This section summarizes the new functionality offered in XSLT 2.0, compared
				with XSLT 1.0. These are 
arranged in three groups. Firstly, the changes that pervade the entire text. Secondly,
the major new features introduced. And thirdly, a catalog of minor technical changes.</p>
				<p>Changes since the <phrase diff="chg" at="ZC">November 2006 Proposed Recommendation</phrase> 
        are listed separately: see <specref ref="changes-2007-01"/>.</p>
				<p>In addition to these changes, 
reported <loc href="http://www.w3.org/1999/11/REC-xslt-19991116-errata/">errors</loc>
in XSLT 1.0 have been fixed.</p>
				<div3 id="pervasive-changes">
					<head>Pervasive changes</head>
					<ulist>
						<item>
							<p>There has been significant re-arrangement of the text.
More terminology definitions have been hyperlinked, and a glossary
(see <specref ref="glossary"/>) has been added. Additional appendices summarize the error conditions
and implementation-defined features of the specification.</p>
						</item>
						<item>
							<p>The specifications of many features (for example keys, <elcode>xsl:number</elcode>,
the <function>format-number</function> function, the <elcode>xsl:import</elcode>
mechanism, and the description of attribute sets) have been rewritten to make them clearer and more precise.</p>
						</item>
						<item>
							<p>Many changes have been made to support the <phrase diff="chg" at="Z">XDM</phrase> data model,
notably the support for sequences as a replacement for the node-sets of XPath 1.0. This
has affected the specification of elements such as <elcode>xsl:for-each</elcode>, 
<elcode>xsl:value-of</elcode>, and <elcode>xsl:sort</elcode>, and has led to the introduction
of new instructions such as <elcode>xsl:sequence</elcode>.</p>
						</item>
						<item>
							<p>The processing model is described differently: instead of instructions "writing
to the result tree", they now return sequences of values. This change is largely one
of terminology, but it also means that it is now possible for XSLT stylesheets to manipulate
arbitrary sequences, including sequences containing parentless element or attribute nodes.</p>
						</item>
						<item>
							<p>The description of the evaluation context has been changed. The concepts of
current node and current node list have been replaced by the XPath concepts of context item,
context position, and context size.</p>
						</item>
						<item>
							<p>With the introduction of support for XML Schema within XPath 2.0, XSLT now
							supports stronger data typing, while retaining backwards compatibility.
In particular, the types of variables and parameters can now be specified explicitly, and
schema validation can be invoked for result trees and for elements and attributes in temporary trees.</p>
						</item>
						<item>
							<p>The description of error handling has been improved (see <specref ref="errors"/>).
This formalizes the difference between static and dynamic errors, and tightens the
rules that define which errors must be signaled under which conditions.</p>
						</item>
						<item>
							<p>The terms <termref def="dt-implementation-defined">implementation-defined</termref> and
<termref def="dt-implementation-dependent">implementation-dependent</termref> are now defined and used
consistently, and a checklist of implementation-defined features is provided
 (see <specref ref="implementation-defined-features"/>).</p>
						</item>
					</ulist>
				</div3>
				<div3 id="major-features">
					<head>Major Features</head>
					<ulist>
						<item>
							<p>XSLT 2.0 is designed to work with XPath 2.0 rather than XPath 1.0. This brings an enhanced
data model with a type system based on sequences of nodes or atomic values, support for all the
built-in types defined in XML Schema, and a wide range of new functions and operators.</p>
						</item>
						<item>
							<p>The result tree fragment data-type is 
eliminated. <termref def="dt-variable-binding-element">A variable-binding element</termref> with content 
(and no <code>as</code> attribute)
now constructs a <termref def="dt-temporary-tree">temporary tree</termref>, and the value of the variable
is the root node of this tree (see <specref ref="variable-values"/>). With an <code>as</code> attribute,
a variable-binding element may be used to construct an arbitrary sequence. These features eliminate the need
for the <code>xx:node-set</code> extension function provided by many XSLT 1.0 implementations.</p>
						</item>
						<item>
							<p>Facilities are introduced for grouping of nodes (the <elcode>xsl:for-each-group</elcode>
instruction, and the <code>current-group()</code> and <code>current-grouping-key()</code> functions). 
See <specref ref="grouping"/>
							</p>
						</item>
						<item>
							<p>It is now possible to create user-defined functions within
the stylesheet, that can be called from XPath expressions. See <specref ref="stylesheet-functions"/>.
</p>
						</item>
						<item>
							<p>A transformation is allowed to produce multiple result trees. 
See <specref ref="creating-result-trees"/>.
</p>
						</item>
						<item>
							<p>A new instruction <elcode>xsl:analyze-string</elcode> is provided to process text
by matching it against a regular expression.</p>
						</item>
						<item>
							<p>It is possible to declare the types of variables and parameters, and the
							result types of templates and functions. The types
may either be built-in types, or user-defined types imported from a schema using a new
<elcode>xsl:import-schema</elcode> declaration.</p>
						</item>
						<item>
							<p>A stylesheet is able to attach type annotations to elements and attributes in a result
tree, and also in temporary trees, and to make use of any type annotations that exist in a source tree.
Result trees and temporary trees can be validated against a schema.</p>
						</item>
						<item>
							<p>A transformation may now be invoked by calling a named 
							template. This creates the
potential for a transformation to process large collections of input documents. <phrase diff="add" at="R">The
input to such a transformation may be obtained using the <xfunction>collection</xfunction> function defined
 in <bibref ref="xpath-functions"/>, or it may be supplied as a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>.</phrase></p>
						</item>
						<item>
							<p>Comparisons between values used for grouping, for sorting, and for keys can be performed
using the rules for any supported data type, including the ability to select named collations for
performing string comparison. These complement the new facilities in XPath 2.0, which are also
invoked automatically when matching template rules.</p>
						</item>
						<item>
							<p>The <elcode>xsl:for-each</elcode> instruction is able to process any sequence, not only
a sequence of nodes.</p>
						</item>
						<item>
							<p>An XHTML output method has been added. The details are described in
							 <bibref ref="xslt-xquery-serialization"/>.
</p>
						</item>
						<item>
							<p>A <code>collation</code> attribute has been added to
the <elcode>xsl:sort</elcode> element to allow sorting using a user-defined collation.</p>
						</item>
						<item><p>A new <elcode>xsl:next-match</elcode> is provided to allow multiple
						template rules to be applied to the same source node.</p></item>
						<item><p>A new <elcode>xsl:character-map</elcode> declaration is available
						to control the serialization of individual characters. This is intended as
						a replacement for some use-cases where <code>disable-output-escaping</code>
						was previously necessary.</p></item>
						<item><p>Functions have been added for formatting dates and times.
						See <specref ref="format-date"/></p></item>
						
						<item><p>The new facility of <termref def="dt-tunnel-parameter">tunnel parameters</termref>
						allows parameters to be set that affect an entire phase of the transformation, without
						requiring them to be passed explicitly in every template call.</p></item>
						
						<item><p>Many instructions that previously constructed a value using child
						instructions can now alternatively construct the value using a <code>select</code>
						attribute; and conversely, instructions that previously required a <code>select</code>
						attribute can now use child instructions.</p></item>
						
						<item diff="add" at="T"><p>The <elcode>xsl:template</elcode> declaration can now declare
						a template rule that applies to several different modes; and the <elcode>xsl:apply-templates</elcode>
						instruction can cause processing to continue in the current mode.</p></item>
					</ulist>
				</div3>
				<div3 id="minor-changes">
					<head>Minor Changes</head>
					<ulist>
						<item>
							<p>Instead of allowing the output method complete freedom to
add namespace nodes, a process of namespace fixup is applied to the
result tree before it is output; this same namespace fixup process is
also applied to documents constructed using variable-binding elements with
content (see <specref ref="namespace-fixup"/>).</p>
						</item>
						<item>
							<p>Support for XML Base has been added.</p>
						</item>
						<item>
							<p>An <elcode>xsl:apply-imports</elcode> element is allowed to have
parameters (see <specref ref="apply-imports"/> and <specref ref="with-param"/>).</p>
						</item>
						<item>
							<p>
								<termref def="dt-extension-function">Extension functions</termref> are
 allowed to return external objects, which do not have any of the builtin
XPath types.</p>
						</item>
						<item>
							<p>The specification for patterns (<specref ref="patterns"/>) has been revised to align it with the
new XPath grammar. The formal semantics of patterns has been simplified: this became possible because
of the extra compositionality now available in the expression grammar. The syntax and semantics
of patterns remains essentially unchanged, except that XPath 2.0 expressions can be used within
predicates.</p>
						</item>
						<item>
							<p>A backwards-compatible processing mode is introduced. See <specref ref="backwards"/>
							</p>
						</item>
						<item>
							<p>The <function>system-property</function> function now always
returns a string. Several new system properties have been defined. See <specref ref="system-property"/>.</p>
						</item>
						<item>
							<p>With <code>&lt;xsl:message terminate="yes"&gt;</code>, the processor now
<emph><rfc2119>must</rfc2119></emph> terminate processing. Previously the word <emph><rfc2119>should</rfc2119></emph> was
used. See <specref ref="message"/>.</p>
						</item>
						<item>
							<p>A number of new serialization parameters have been introduced.</p>
						</item>
						<item>
							<p>A new instruction <elcode>xsl:namespace</elcode> is available, for creating
namespace nodes: see <specref ref="creating-namespace-nodes"/>.</p>
						</item>
						<item>
							<p>A new instruction <elcode>xsl:perform-sort</elcode> is available, for
							returning a sorted sequence.</p>
						</item>						
						<item>
							<p>A new <code>[xsl:]xpath-default-namespace</code> attribute is available to define
the default namespace for unqualified names in an XPath expression or XSLT pattern.</p>
						</item>
						<item>
							<p>The attributes <code>[xsl:]version</code>, <code>[xsl:]exclude-result-prefixes</code>,
and <code>[xsl:]extension-element-prefixes</code>, as well as the new
 <code>[xsl:]xpath-default-namespace</code> and <code>[xsl:]default-collation</code>, 
 can be used on any <termref def="dt-xslt-element">XSLT element</termref>, not only on
<elcode>xsl:stylesheet</elcode> and on literal result elements as before. In particular, they
can now be used on the <elcode>xsl:template</elcode> element.</p>
						</item>
						<item>
							<p>A new <function>unparsed-text</function> function is introduced. It allows the contents
of an external text file to be read as a string.</p>
						</item>
						<item>
							<p>Restrictions on the use of variables within patterns and key definitions have been removed; in their place
a more general statement of the restrictions preventing circularity has been formulated. The <function>current</function>
function may also now be used within patterns.</p>
						</item>
						<item>
							<p>The built-in templates for element and document nodes now pass any supplied parameter values on
 to the templates that they call.</p>
						</item>
						<item>
							<p>A detailed specification of the <function>format-number</function> function is now provided,
              removing the reliance on specifications in Java JDK 1.1.</p>
						</item>
					</ulist>
				</div3>
				<!--<div3 diff="add" at="P" id="changes-in-may-2003-draft">
					<head>Changes since the November 2002 draft</head>
					<ulist>
						<item>
							<p>Elements can now be annotated with complex types. New attributes
							<code>[xsl:]validation</code> and <code>[xsl:]type</code> (replacing
							<code>type-annotation</code>) have been added to <elcode>xsl:element</elcode>,
							<elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, 
							<elcode>xsl:copy-of</elcode>, and literal result elements, to achieve this.</p>
						</item>
						<item>
						    <p>It is now possible to use XSLT instructions to construct an arbitrary sequence of
						    nodes and atomic values. This is achieved by defining new semantics for <elcode>xsl:variable</elcode>
						    and related instructions, when the instruction has a <termref def="dt-sequence-constructor">sequence
						    constructor</termref> (previously <emph>content constructor</emph>) as its content, and
						    has an <code>as</code> attribute. Previously it was only possible to construct an arbitrary
						    sequence using XPath expressions. To support the new facility, a new instruction <elcode>xsl:sequence</elcode>
						    is introduced. The <code>xsl:result</code> element is dropped, and stylesheet functions
						    may now use an arbitrary sequence constructor to build the result value.</p>
						</item>
						<item>
						    <p>A set of functions has been provided for formatting dates: see
						     <specref ref="format-date"/>.</p>
						</item>					
						<item>
							<p>The <elcode>xsl:text</elcode> element has reverted to its XSLT 1.0 specification:
							that is, it may only contain a single text node, and no nested instructions
							or literal result elements.</p>
						</item>
						<item>
							<p>The <code>copy-type-annotations</code> attribute of the <elcode>xsl:copy-of</elcode>
							instruction is replaced with the more general <code>validation</code> attribute;
							the default is now that type annotations are preserved.</p>
						</item>
						<item>
							<p>The <code>as</code> attribute of the <elcode>xsl:sort</elcode>
							element has been dropped. The data type for sorting is now deduced automatically
							from the dynamic types of the items selected for sorting.</p>
						</item>						
						<item>
							<p>The <code>as</code> attribute of the <elcode>xsl:for-each-group</elcode>
							element has been dropped. The data type for grouping is now deduced automatically
							from the dynamic types of the grouping key values.</p>
							<p>Note, however, that the <code>as</code> attribute of <elcode>xsl:key</elcode> has
							been retained. This is so that implementations can convert untyped values to the
							appropriate type when constructing an index. Without this, the type used for comparison
							would not be known until the <function>key</function> is used, and might be different
							on different invocations of the <function>key</function>.</p>
						</item>
						<item>
						    <p>When the <code>group-by</code> attribute of <elcode>xsl:for-each-group</elcode> is
						    used, the value may now be a sequence, allowing each item in the population to be added
						    to zero or more groups. To make this facility useful, a new function <function>current-grouping-key</function>
						    has been added.</p>			
						</item>
						<item>
							<p>The <code>[xsl:]default-xpath-namespace</code> attribute has been renamed
							<code>[xsl:]xpath-default-namespace</code>, and it has been clarified that it
							applies not only to unprefixed element names in path expressions, but also to
							unprefixed type names used either in path expressions or in <code>as</code>
							attributes in the stylesheet.</p>
						</item>						
						<item>
							<p>It is now a static error for <elcode>xsl:call-template</elcode> to supply
							a parameter whose name does not match the name of any parameter declared in the
							called template. Note that this is an incompatible change: in XSLT 1.0 the extra
							parameter was simply ignored.</p>
						</item>
						<item>
						    <p>The bulk of the specification for XSLT serialization has been moved to a separate
						    working draft: see <bibref ref="xslt-xquery-serialization"/>. This enables the specification
						    to be referenced from other W3C languages that require serialization capability. The
						    way in which serialization is controlled from XSLT (specifically, the <elcode>xsl:output</elcode>
						    declaration) remains part of this specification.</p>
						</item>
						<item>
							<p>The relationship between <code>cdata-section-elements</code> and
							<code>disable-output-escaping</code> has been clarified.</p>
						</item>
						<item>
						    <p>The rules for executing a stylesheet in backwards compatible mode
						    have been revised, fixing various issues.</p>
						</item>	
						<item>
						    <p>It is now an error to reference the context item from a global variable definition,
						    if no initial context node is supplied to the stylesheet.</p>
						</item>							
						<item>
						    <p>A new instruction, <elcode>xsl:next-match</elcode>, has been defined. This allows
						    refinement of template rules in a way that is similar to <elcode>xsl:apply-imports</elcode>,
						    but able to operate within a single stylesheet module.</p>
						</item>							
						<item>
						    <p>A new serialization capability, character mapping, has been defined. This
						    is designed as a replacement for disable-output-escaping. It uses a new
						    declaration, <elcode>xsl:character-map</elcode>.</p>
						</item>									
						<item>
						    <p>In the <function>format-number</function> function, it is no longer an error to format
						    a number such as 10000 using a picture such as <code>"#,###"</code>. Overflow is only
						    an error if the integer part of the picture consists entirely of <code>"0"</code>
						    digits.</p>
						</item>
						<item>
						    <p>In the <function>format-number</function> function, when formatting a negative number,
						    the minus sign now appears before the prefix, rather than after it. This returns to the
						    effect defined in XSLT 1.0.</p>
						</item>
						<item>
						    <p>The <elcode>xsl:value-of</elcode> instruction now outputs all values in the supplied
						    sequence, unless <termref def="dt-backwards-compatible-behavior">backwards compatible
						    behavior</termref> is enabled. Attribute value templates, and the <code>value</code> expression
						    of <elcode>xsl:number</elcode>, now discard all items after the first in a sequence if 
						    <termref def="dt-backwards-compatible-behavior">backwards compatible
						    behavior</termref> is enabled, but output all the values in the sequence otherwise.</p>
						</item>
						<item>
						    <p>The <code>separator</code> attribute of the <elcode>xsl:copy-of</elcode> instruction is
						    withdrawn.</p>
						</item>
						<item>
						    <p>New options have been added to the <function>system-property</function> function to provide
						    information about the conformance levels and features offered by the processor.</p>
						</item>	
						<item>
						    <p>Patterns (for example the match patterns in template rules) can now take advantage of
						    the new XPath syntax for testing schema types: for example <code>element(us:address)</code>, 
						    <code>attribute(*, xs:date)</code>, or <code>document-node(element(us:address))</code>. This enhancement has been achieved with very little
						    change to the XSLT specification, because patterns are defined in terms of an equivalent
						    XPath expression. The only technical change necessary was to define the default priority
						    for such patterns. Nevertheless, this feature greatly increases the ability of a stylesheet
						    to exploit type information from schema processing.</p>
						</item>
						<item>
						    <p>The rules for <elcode>xsl:number</elcode> have been clarified for the cases where there is
						    no <code>from</code> attribute, and where there is no relevant node that matches the pattern
						    in the <code>from</code> attribute. In both these cases the effect is now as if <code>from="/"</code>
						    had been specified. The rules now define a result in all cases, including edge cases such as
						    numbering of attribute nodes or document nodes.</p>	
						</item>
						<item>
						    <p>A substantial number of issues have been resolved: see <specref ref="closed-issues"/> for details.</p>
						</item>
						<item>
						    <p>The non-normative Appendix G, which defined a mapping of lexical XML constructs
						    to the XPath data model, has been removed. The Working Group decided that there
						    was no need to define such a mapping in this specification; the job could be done
						    equally well by implementers.</p>
						</item>    																																
				    </ulist>
				</div3>-->
<!--				<div3 diff="add" at="R" id="changes-in-this-draft">
				<head>Changes in the November 2003 draft</head>
				
<ulist>

<item><p>A detailed inspection of the specification has resulted in a large number
of minor editorial improvements, clarifications, and corrections.</p></item>

<item><p>Stable error codes have been added for all error conditions.</p></item>

<item><p>The set of data types recognized by a basic XSLT processor (one that does
not offer XML Schema support) has been greatly reduced. Instead of recognizing the full
set of 44 built-in types, a much smaller set of 13 types is recognized: see <specref ref="built-in-types"/>.
This set has been
chosen primarily because it includes all the types required to make use of the functions 
defined in <bibref ref="xpath-functions"/>.</p></item>

<item><p>The instructions that create simple-valued nodes (<elcode>xsl:attribute</elcode>,
 <elcode>xsl:comment</elcode>, <elcode>xsl:value-of</elcode>,
etc.) can now create the content of the node using either a 
<termref def="dt-sequence-constructor">sequence constructor</termref>, or a <code>select</code>
attribute. This creates symmetry between <elcode>xsl:attribute</elcode> and <elcode>xsl:value-of</elcode>.
The <code>separator</code> attribute is now available
on <elcode>xsl:attribute</elcode>, to facilitate the creation of list-valued simple content.</p></item>

<item><p>For similar reasons, <elcode>xsl:message</elcode> may now define its content using a
<code>select</code> attribute, while <elcode>xsl:key</elcode> and <elcode>xsl:sort</elcode> may
compute key values using a <termref def="dt-sequence-constructor">sequence constructor</termref>.
This means that templates may be called using <elcode>xsl:call-template</elcode> or <elcode>xsl:apply-templates</elcode>
to calculate the value.</p></item>

<item><p>The semantics of schema import and validation have been described in more careful language
to align the terminology with that used in the XML Schema recommendation.</p></item>

<item><p>The effect of the <code>validation</code> and <code>type</code> attributes when
<elcode>xsl:copy</elcode> and <elcode>xsl:copy-of</elcode> are used to copy document nodes has
been revised and clarified.</p></item>

<item><p>A new facility called <termref def="dt-tunnel-parameter">tunnel parameters</termref>
has been introduced, allowing the values of a parameter supplied in a calling template to
be passed transparently through intermediate called templates until they eventually reach the template that
is interested in their values. See <specref ref="tunnel-params"/></p></item>
				
<item><p>The <code>input</code> function, and the concept of the initial input
sequence, have been dropped. The same effect can be achieved by passing a stylesheet
parameter.</p></item>

<item><p>An <code>as</code> attribute has been added to the <elcode>xsl:with-param</elcode>
element, allowing the supplied value of the parameter to be evaluated as a sequence.</p></item>

<item><p>The <code>as</code> attribute has been dropped from <elcode>xsl:key</elcode>. It is
now acceptable for the values of a single key to have a mixture of different types; when the
<function>key</function> is used, the type used for comparison is based on the type of both
the key value and the requested value.</p></item>

<item><p>A <code>select</code> attribute has been added to the <elcode>xsl:number</elcode>
instruction, allowing a number to be generated for a node other than the context node. A
rule has been added disallowing the use of the <code>value</code> attribute in conjunction
with attributes that control node numbering.</p></item>

<item><p>The <elcode>xsl:sequence</elcode> instruction must have either a <code>select</code>
attribute or a contained <termref def="dt-sequence-constructor">sequence constructor</termref>,
it cannot have both.</p></item>

<item><p>The rules defining error conditions when a stylesheet contains multiple declarations
with the same name have been made more uniform. In most cases, duplicate declarations are
now an error only if the declarations have the same import precedence, and are not masked
by another declaration with higher import precedence.</p></item>

<item><p>The terminology for sort keys has been revised and clarified: see the definitions
of the terms <termref def="dt-sort-key-specification">sort key specification</termref>, 
<termref def="dt-sort-key-component">sort key component</termref>, and 
<termref def="dt-sort-key-value">sort key value</termref>.</p></item>

<item><p>The concept of named sort keys has been removed, and with it the <code>xsl:sort-key</code>
declaration and the <code>sort</code> function. To replace these, a new instruction <elcode>xsl:perform-sort</elcode>
has been added. A stylesheet function that calls the <elcode>xsl:perform-sort</elcode> instruction can
be used in place of the <code>sort</code> function, offering greater scope to define dynamic parameters, 
such as the collation to be used.</p></item>

<item><p>A registration for the media type <code>application/xslt+xml</code> has been added:
see <specref ref="xslt-mime-definition"/>.</p></item>

<item><p>The ability to specify <code>disable-output-escaping</code> on the <elcode>xsl:attribute</elcode>
instruction (a feature introduced in an earlier draft of XSLT 2.0) has been dropped.</p></item>
</ulist>


</div3>-->

<!--<div3 diff="add" at="T" id="changes-2004-11"><head>Changes in the November 2004 draft</head>

<p>Changes since the Last Call Working Draft in November 2003 include:</p>
<ulist>

<item><p>The <code>[xsl:]use-when</code> attribute: see <specref ref="conditional-inclusion"/>.</p></item>

<item><p>The <elcode>xsl:sequence</elcode> instruction may no longer have an
 <code>as</code> attribute, and may no longer contain a sequence constructor</p></item>

<item><p>The instructions <elcode>xsl:text</elcode>, <elcode>xsl:value-of</elcode>, and <elcode>xsl:number</elcode>
may now produce zero-length text nodes. Such text nodes disappear if they are used to form the content
of an element or document node, but they are significant if the result of the instruction is used
directly.</p></item>

<item><p>In <elcode>xsl:sort</elcode> it is now possible to indicate whether the sort is required
to be stable.</p></item>

<item><p>A new instruction <elcode>xsl:document</elcode> is provided to construct a document node.
Although an <elcode>xsl:variable</elcode> element can still create a temporary tree implicitly,
the explicit use of <elcode>xsl:document</elcode> allows the tree to be validated; the new instruction
also allows a document to be returned from a template or stylesheet function without the need to
define a variable for the purpose.</p></item>

<item><p>Serialization attributes can now be specified (dynamically) on the <elcode>xsl:result-document</elcode>
instruction.</p></item>

<item><p>Revisions to the <code>ElementType</code> and <code>AttributeType</code> constructs in XPath
have been incorporated into the syntax for XSLT patterns, and the rules for assigning a default
priority to a pattern have been updated accordingly.</p></item>

<item><p>Specifying a parameter in <elcode>xsl:call-template</elcode> that does not correspond to
any parameter defined in the referenced template is no longer an error if running in backwards
compatibility mode.</p></item>

<item><p>A new switch, <code>input-type-annotations</code>, has been added to the 
<elcode>xsl:stylesheet</elcode> element, to enable the stylesheet author to indicate that
source documents should be treated as untyped even if they have been validated against a schema.</p></item>

<item><p>The <elcode>xsl:number</elcode> instruction is now capable of formatting the number zero,
if the particular numbering sequence supports it. This change was made because the <function>format-time</function> function
relies on the specification of <elcode>xsl:number</elcode>, and the values of the hours, minutes and 
seconds components of the time can legitimately be zero.</p></item>

<item><p>The rules for constructing simple content have been revised so that adjacent text nodes are
concatenated; this makes the previous rule whereby a zero-length string was used as the default separator
redundant. The revised rules give a more intuitive results when an instruction such as <elcode>xsl:value-of</elcode>
or <elcode>xsl:attribute</elcode> contains a <code>select</code> attribute that invokes a function that returns
a sequence of text nodes.</p></item>

<item><p>The way in which import precedence works for <elcode>xsl:decimal-format</elcode> has been
brought into line with the rules for other declarations.</p></item>

<item><p>An <elcode>xsl:import-schema</elcode> declaration may now contain an inline <code>xs:schema</code>
element.</p></item>

<item><p>The serialization attributes on <elcode>xsl:output</elcode> and <elcode>xsl:result-document</elcode>
now allow any normalization form supported by the <xfunction>normalize-unicode</xfunction> function
to be requested. The value <code>standalone="omit"</code> has been added as an explicit representation
of the default value for this attribute.</p></item>

<item><p>A new attribute <code>[xsl:]inherit-namespaces</code> has been added to <code>xsl:copy</code> and
<code>xsl:element</code>, and to literal result elements. If it is required that the namespaces of
a parent node should not be inherited by its children then the instruction that creates the parent
node should set this attribute to <code>no</code>. When the result tree is serialized according to
XML Namespaces 1.1 this will result in namespace undeclarations being output.</p></item>

<item><p>A new standard attribute <code>[xsl:]default-collation</code> is available to define the
default collation for all XPath expressions within its scope.</p></item>

<item><p>An expanded QName now contains an optional prefix as well as a local name and namespace URI. As a result, casting of a QName to a string
never fails, so some error conditions have been removed. Further, namespace prefixes from the stylesheet (for example,
in literal result elements and in <code>xsl:element</code>) are now copied into the result tree, making them available 
for use by the <code>name()</code> function and by serialization. This has minor effects on the rules for
namespace fixup.</p></item>

<item><p>The default formatting for the minutes and seconds components in the <function>format-time</function>
function has been changed from <code>1</code> to <code>01</code> (indicating that leading zeroes
are to be included).</p></item>

<item><p>The rules for the <function>format-number</function> function have changed (a) so that
a decimal number can be formatted without the loss of precision that occurs when converting it
to <code>xs:double</code>, and (b) to use only as many significant digits in the result as are
warranted by the precision of the original value.</p></item>

<item><p>Dynamic errors occurring during the evaluation of patterns are now defined to be
recoverable. This is because it is very difficult for stylesheet authors to control which patterns
will be applied to which nodes.</p></item>

<item><p>The use of the terms <termref def="dt-result-tree">result tree</termref>, 
<termref def="dt-final-result-tree">final result tree</termref>, and 
<termref def="dt-source-tree">source tree</termref> has been made more rigorous.
(The resulting changes are <emph>not</emph> highlighted).</p></item>

<item><p>Numerous minor corrections and clarifications have been made.</p></item>

</ulist>
</div3>-->


<!--
<div3 id="changes-2005-02"><head>Changes in the February 2005 Draft</head>

<p>Changes since the Working Draft issued on 5 November 2004 include:</p>

<ulist>

<item><p>A non-schema-aware processor now allows all the built-in types defined
in XML Schema to be used; previously only a subset of the primitive types plus
<code>xs:integer</code> were permitted. This includes the type <code>xs:NOTATION</code>,
despite the fact that instances of this type cannot be constructed in the absence of a schema.</p></item>

<item><p>Error codes have been assigned to some error conditions that previously
had no code assigned.</p></item>

<item><p>The specification now makes it clear that an <code>xsl:use-when</code>
attribute can appear on any element that is not in the XSLT namespace, whether or
not it is a literal result element. For example, it can usefully appear on an
extension instruction.</p></item>

<item><p>The behavior of certain constructs in backwards-compatible mode has changed
to more closely reflect the XSLT 1.0 behavior. Specifically:</p>

  <ulist>
  <item><p>When constructing an attribute, comment, or processing instruction, any non-text
  nodes in the content are atomized when running in 2.0 mode. In backwards compatible mode,
  the existence of such nodes is a recoverable error, the recovery action being to ignore
  the offending nodes.</p></item>

  <item><p>In backwards compatible mode, the <elcode>xsl:number</elcode> instruction 
  now outputs <code>NaN</code> when the supplied value is an empty sequence or non-numeric,
  rather than signaling an error.</p></item>

    <item><p>In backwards compatible mode, parameters passed to a built-in template rule
    are not passed on.</p></item>

     <item>
							<p>If no output method is explicitly requested, and the
first element node output appears to be an XHTML document element, then under XSLT 2.0 the 
output method defaults to XHTML; with backwards compatibility enabled, the XML output method
will be used.</p>
						</item>

   <item><p>An XSLT 1.0 processor compared the value of the expression in the
<code>use</code> attribute of <elcode>xsl:key</elcode> to the value supplied in the second
argument of the <function>key</function> function by converting both to strings. An XSLT 2.0 processor
normally compares the values as supplied. The XSLT 1.0 behavior is emulated if any of the <elcode>xsl:key</elcode>
elements making up the <termref def="dt-key">key</termref> definition enables
backwards-compatible behavior.</p>
</item>
 </ulist>
</item>

<item><p>The example <emph>Aliasing the XML Namespace</emph> in
<specref ref="namespace-aliasing"/> has been corrected.</p></item>

<item><p>XPath expressions in attribute value templates are now expanded using the same
rules as apply to the <code>select</code> attribute in instructions such as <code>xsl:attribute</code>.
The effect of the change is that if the value of the expression contains several adjacent text nodes,
no whitespace is inserted between the string values of these text nodes.</p></item>

<item><p>When the 3-argument form of the <function>key</function> function is used, the search is now
restricted to the subtree rooted at the node identified by the third argument. Previously the third argument
merely identified the document to be searched.</p></item>

<item><p>Error code XT1670 has been dropped, it was a duplicate of XT0160.</p></item>

<item><p>The rules for the <function>format-number</function> function have been changed so that if
an integer (say 3) is formatted using the picture <code>0.##</code>, the result is <code>"3"</code> rather than
<code>"3."</code> &#x2014; that is, a number will never be output with a trailing decimal point.</p></item>

<item><p>An error in the effective value of an attribute value template (see <errorref code="0030"/>) may
now be signalled statically if it can be detected statically.</p></item>

<item><p>Error codes XT0300, XT0310, and XT0320, which referred to errors occurring in XPath expressions,
have been removed: more specific codes for such errors are defined in the XPath specification.</p></item>

<item><p>The serialization attribute <code>undeclare-namespaces</code> is renamed <code>undeclare-prefixes</code>,
because it does not affect whether or not undeclarations of the default namespace are output.</p></item>

<item><p>The return type of the <function>unparsed-entity-uri</function> function has been changed
to <code>xs:anyURI</code>. Note that as a result of recent changes to XPath 2.0, a value of <code>xs:anyURI</code>
can be used with any operator or function that expects a string.</p></item>

<item><p>It is now a recoverable error to generate nodes in the result tree using a namespace name that is not
a valid instance of <code>xs:anyURI</code>. XSLT 1.0 explicitly stated that this was not an error; however, the
XPath 2.0 data model assumes that the name of a node is a valid <code>xs:QName</code>, and the namespace
part of a valid <code>xs:QName</code>, if present, must be a valid <code>xs:anyURI</code>. The fact that this
error is recoverable, however, gives implementations freedom to avoid strict validation of namespace names
if they wish to do so.</p></item>

<item><p>The properties of nodes created in a result tree (properties such as <code>base-uri</code>,
<code>document-uri</code>, <code>is-id</code>, <code>is-idrefs</code>, and <code>nilled</code>) are now
spelt out in more detail.</p></item>

</ulist>


</div3>-->

<!--<div3 id="changes-2005-04" diff="add" at="X"><head>Changes in the April 2005 Draft</head>

<p>The following changes have been made since the draft of 11 February 2005:</p>

<ulist>

<item><p>As explained in the status section of the document, the list of types available in a Basic XSLT
Processor has reverted to the list defined in the November 2004 draft. The changes to this list in the
February 2005 draft were made in error.</p></item>

<item><p>The detailed semantics of validation have been refined. In particular, it is now stated more
clearly that <code>lax</code> validation operates recursively (if there is no element declaration for a
parent element, it still attempts validation of the children), and the impact of any <code>xsi:type</code>
attribute in the result tree is also explained more clearly.</p></item>

<item><p>The base URI of constructed document, element, and processing instruction nodes is now
defined in all cases. Previously some cases were undefined, for example the base URI of a parentless
element node constructed using a literal result element or <elcode>xsl:element</elcode>, and the
base URI of a document node constructed using <elcode>xsl:result-document</elcode>.</p></item>

<item><p>In the interests of interoperability, many of the errors that were previously classified as
<termref def="dt-recoverable-error">recoverable errors</termref> have been reclassified. Many of them
are now <termref def="dt-nonrec-dynamic-error">non-recoverable errors</termref>, meaning that all processors
are required to detect and signal the error. Some of them are no longer errors: that is, processors are
now required to take the action previously described as the error recovery action. A few recoverable
errors remain, in cases where the Working Group felt that there were genuine reasons for different
processors to handle the situation in different ways.</p></item>

<item><p>Errors in evaluating the <function>unparsed-text</function> function are now
non-recoverable. To enable applications to recover from errors in processing an external
unparsed text file, a new function <function>unparsed-text-available</function> is defined.</p></item>

<item><p>It remains a recoverable error to have an <elcode>xsl:strip-space</elcode> and an
<elcode>xsl:preserve-space</elcode> declaration with the same import precedence, if they both match
the same element. However, it is no longer an error to have two <elcode>xsl:strip-space</elcode>
declarations or two <elcode>xsl:preserve-space</elcode> declarations that match the same element.</p></item>

<item><p>References to RFC2396 have been replaced with references to RFC3986.</p></item>

<item><p>For consistency with XPath, error codes have been expanded to 8 characters.</p></item>

</ulist>		
</div3>-->	
<!--
<div3 id="changes-2005-09" diff="add" at="Y"><head>Changes in the 15 September 2005 Draft</head>

<p>This section describes changes made between the Last Call draft of 6 April 2005 and the 
Working Draft of 15 September 2005. Each change is cross-referenced
to the last-call comment that resulted in the change: these comments are identified by their bug number in the
Bugzilla database at <loc href="http://www.w3.org/Bugs/Public/">http://www.w3.org/Bugs/Public/</loc>.</p>

<ulist>

<item><p>Error codes XTDE1180 and XTDE1190 have been merged into one (Bugzilla Issue 1239).</p></item>	

<item><p>Error code XTDE0800 has been merged into code XTDE0070 (Bugzilla Issue 1490).</p></item>

<item><p>Error XTTE1545 has been added: this error rejects any attempt to validate
a parentless attribute against a type (<code>xs:QName</code> or <code>xs:NOTATION</code>
that requires a namespace context (Bugzilla Issue 1235).</p></item>

<item><p>Similarly, the new error XTTE0950 prevents copying of an existing attribute node
with a namespace-sensitive type using <code>validation="preserve"</code> (Bugzilla Issue 1235).</p></item>

<item><p>Namespace fixup no longer generates namespace nodes in respect of QNames found
in element or attribute content. Instead, it is now an error (error XTTE0950) to copy nodes with namespace-sensitive
content unless the in-scope namespaces are also copied. The previous rules prevented the <elcode>xsl:copy-of</elcode>
operation being pipelined, because it was necessary to inspect the content of an element before generating
its namespace nodes (Bugzilla Issue 1235).</p></item>

<item><p>To align with the usage of collation URIs in the Functions and Operators specification, the specification
is now explicit that relative collation URIs are permitted, and that they are resolved against the base URI of the
element in the stylesheet where they appear (Bugzilla Issue 1420).</p></item>

<item><p>If the initial template of a transformation specifies a required type
(by means of an <code>as</code> attribute), the specification now makes clear that the
required type applies to the sequence that results from evaluating the
template <emph>before</emph> this sequence is used to construct an implicit result
tree (Bugzilla Issue 1319).</p></item>

<item><p>The rules under which an implicit final result tree is created have been
clarified: specifically, the only situation in which no implicit final result tree is created 
is when the result of
the initial template is empty and an explicit result tree has been created using
<elcode>xsl:result-document</elcode> (Bugzilla Issue 1319).</p></item>

<item><p>The rules for forwards compatibility mode have been revised. The new rules take advantage
of the fact that many of the situations where forwards compatibility mode was required in 1.0 can now be
handled more conveniently using the new <code>use-when</code> attribute. This has enabled the rules
for forwards compatibility to be simplified. In particular, the new rules remove the provision that 
invalid syntax (for example, an invalid XPath expression) is not reported until evaluation time. This provision
was there to allow version-specific logic to be included in a branch of an <elcode>xsl:choose</elcode>
instruction. Instead such logic can now be made conditional at compile time using 
<code>use-when</code>. Since the mechanisms for forwards compatibility are intrinsically
version-specific, this change does not introduce any significant incompatibility from XSLT 1.0
(Bugzilla Issue 1230).</p></item>

<item><p>Some further examples of the date and time formatting functions have been added.
(Bugzilla Issue 1251).</p></item>  

<item><p>A problem with the sorting of heterogeneous numeric sequences (for example, sequences containing
a mix of <code>xs:decimal</code> and <code>xs:double</code> values) has been fixed. The problem arises because
in edge cases where conversion involves loss of precision, the <code>lt</code> operator is not transitive, and
therefore the ordering was not well defined. The problem has been fixed by requiring that all values in the sequence
be promoted to a common supertype before comparison (Bugzilla Issue 1753).</p></item>

<item><p>In the description of the <function>format-number</function> function, the concept of
<var>overflow-threshold</var> has been removed, since it no longer affected the result of the algorithm
(Bugzilla Issue 1813).</p></item>

<item><p>The example <emph>Conflicting Namespace Prefixes</emph> in 
<specref ref="creating-namespace-nodes"/> has been corrected. In the previous version of the example,
there was a conflict between a namespace node copied from the stylesheet (by the evaluation of a literal
result element) and a namespace node constructed explicitly using <elcode>xsl:namespace</elcode>; this
should result in an error (<errorref spec="XT" class="DE" code="0430"/>). When an <elcode>xsl:element</elcode>
instruction is used in place of the literal result element, the namespace node is created by the namespace
fixup process, which means that the processor must choose a namespace prefix that avoids the conflict
(Bugzilla Issue 1817).</p></item>

<item><p>A couple of corner cases have been found where XSLT 2.0 behavior is incompatible with XSLT 1.0. 
These incompatibilities have been documented (Bugzilla Issues 1313, 1487).</p></item>

<item><p>The internal structure of XSLT error codes is now explained, together with the fact that they share
the same namespace as the error codes defined in <bibref ref="xpath20"/> and <bibref ref="xpath-functions"/>.
A more detailed description of the purpose of these codes has been supplied (Bugzilla Issue 1498).</p></item>

<item><p>The specification continues to use the term "URI" in contexts such as "base URI" and "namespace URI",
but clarifies that in most situations this can actually be an IRI (Bugzilla Issue 1354).</p></item>

<item><p>The specifications of <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode> now say
consistently that the effective value of the namespace attribute <rfc2119>must</rfc2119> be a valid
<code>xs:anyURI</code>. Previously the specification was inconsistent on this point.
(Bugzilla Issue 1266)</p></item>

<item><p>The explanation of the <code>id</code> attribute on the <elcode>xsl:stylesheet</elcode> attribute,
and the way it can be used, has been improved. (Bugzilla Issue 1479)</p></item>

<item><p>Some additional rules have been added defining circumstances under which the current template
rule becomes null. (Bugzilla Issue 1555)</p></item>

<item><p>Some typographical errors and minor errors in examples have been corrected. The text has
been clarified in places where readers reported difficulties or suggested that there were ambiguities
 (Bugzilla Issues 1227, 1228, 1236, 1238, 1248, 1257, 1267, 1321, 1464, 
 1480, 1495, 1501, 1516, 1811, 1822).</p></item>




</ulist>
 </div3>-->
 <!--
 <div3 id="changes-2005-11" diff="add" at="Z"><head>Changes in the Candidate Recommendation</head>
 
 <p>The following changes have been made since the draft of 15 September 2005. Each change is cross-referenced
to the last-call comment that resulted in the change: these comments are identified by their bug number in the
Bugzilla database at <loc href="http://www.w3.org/Bugs/Public/">http://www.w3.org/Bugs/Public/</loc>.</p>

<ulist>

<item><p>The data model now has a name: XDM. References to "the XPath data model" or "the XPath 2.0 data model"
have been replaced by references to XDM. The phrase "data model" is now used strictly to refer to the specification,
and not to a data structure conforming to the specification.
Phrases such as "constructing a data model" and "an attribute in the data model" have therefore been excised, and replaced
by "constructing an XDM tree" or "an XDM attribute".</p></item>

<item><p>The description of the relationship of XSLT 2.0 to XML 1.1 (and XML Namespaces 1.1) in
<specref ref="xml-versions"/> has been amended. The new text recommends that processors should continue to
support XML 1.0 even if they elect to support XML 1.1 by default; and it refers implementers to the Note
issued by the XML Schema Working Group discussing the relationship of XML Schema 1.0 to XML 1.1.
(Bugzilla Issues 2276, 2278)</p></item>

<item><p>The <code>format</code> attribute of <elcode>xsl:result-document</elcode> is now an
attribute value template. (Bugzilla Issue 1233)</p></item>

<item><p>The rules for <elcode>xsl:number</elcode> have been amended to fix an edge case affecting
the numbering of attribute and namespace nodes when the <code>from</code> attribute is specified
with <code>level="single"</code> or <code>level="multiple"</code>.
 (Bugzilla Issue 1846)</p></item>
 
 <item><p>Error XTSE0812 has been added for the error condition that occurs when <elcode>xsl:namespace-alias</elcode>
 uses a namespace prefix that has not been declared. (Bugzilla Issue 1879)</p></item>	

 <item><p>Error XTSE1295 has been added for reporting that the <code>zero-digit</code> of
 <elcode>xsl:decimal-format</elcode> is not a valid digit or does not have the numeric value zero;
 and it is now specified that when any of the attributes of this declaration violate the constraint that
 the value is a single digit, error XTSE0020 applies. (Bugzilla Issue 1880)</p></item>

 <item><p>Error XTRE0905 has been renamed XTDE0905, and XTDE0790 has been renamed XTTE0790. 
 The change makes the second part of the code consistent with the kind of error. (Bugzilla Issue 1898)</p></item>

 <item><p>Some clarifications have been made to the rules defining the 
 <termref def="dt-current-template-rule">current template rule</termref> and
 <termref def="dt-current-mode">current mode</termref>. Error XTDE0865 has been
 deleted as it can never occur. (Bugzilla Issues 2268, 2269, 2270)</p></item>

 <item><p>The rules that permit extension attributes have been tightened so that they
 can no longer override mandatory provisions in the serialization specification. (Bugzilla Issue 1797)</p></item>

 <item><p>Non-normative notes have been added explaining the impact of the rules in the
 data model that cause whitespace in element-only content to be ignored when building
 a source tree. (Bugzilla Issues 1303, 1309)</p></item>

 <item><p>A section has been added (see <specref ref="limits"/>) describing various limits
 as <termref def="dt-implementation-defined">implementation-defined</termref>. The impact of this
 change is that a conformance statement must now include information about processor-imposed limits.
  (Bugzilla issues 1902, 1967)</p></item>

 <item><p>A paragraph has been added explaining that there is no conflict between the fact that some core
 functions return values of type <code>xs:NCName</code> and the fact that this type is not recognized
 by a <termref def="dt-basic-xslt-processor">Basic XSLT Processor</termref>. The clue to the reconciliation
 lies in the general XPath provisions for handling dynamic types that are not known types in the static context.
 (Bugzilla Issue 1824)</p></item>

 <item><p>The <function>unparsed-text-available</function> function now accepts an empty sequence for
 either of the two arguments, for consistency with other functions. (Bugzilla Issue 1897)</p></item> 

 <item><p>The explanation of which parts of the dynamic context must be stable has been expanded, and the
 inaccurate reference to definitions in XPath has been replaced by a reference to Functions and Operators,
 which is where the concept of stability is actually defined. (Bugzilla Issue 2149)</p></item>

 <item><p>Examples have been added to clarify the way that space-separation works when constructing element
 content and attribute content. (Bugzilla Issue 1881)</p></item>

 <item><p>A number of minor typographical errors and errors in examples have been fixed. 
 (Bugzilla Issue 2267, 2291, 2319)</p></item>

 <item><p>A number of further changes (for example, the removal of errors XTSE0330 and XTDE0331) have been
 made to implement the design changes for forwards compatibility model (Bugzilla Issue 1230)</p></item>
 
 </ulist></div3>-->
   <!--
 <div3 id="changes-2006-11" diff="chg" at="ZB"><head>Changes during the Candidate Recommendation phase</head>

 <p>This section lists the substantive changes that have been made to this publication since the first
 Candidate Recommendation was published on 3 November 2005. Each change contains a reference to the
 relevant issue number in the 
 <loc href="http://www.w3.org/Bugs/Public/">W3C public Bugzilla database</loc>.</p>
 
 <ulist>





<item><p>In <specref ref="constructing-simple-content"/> it is now specified that leading
spaces are removed from the constructed string value of a processing instruction.
This reflects the fact that the XDM data model no longer permits the string value
of a processing instruction to contain leading spaces (a change that was made because
a value containing a leading space would not round-trip through serialization and parsing).
(Bugzilla Issue 2458).</p></item>

<item><p>In <specref ref="validating-document-nodes"/> there was text that implied that validation
could be requested using the <code>default-validation</code> attribute of <elcode>xsl:stylesheet</elcode>.
This capability had been removed in an earlier draft, so the section has now been reworded to remove
this reference. (Bugzilla Issue 2465)</p></item>

<item><p>In <specref ref="global-variables"/> it was specified that a global variable should be
evaluated with the context set to the document node of the document containing the initial 
context node. This formulation did not say what should happen when the initial context node 
is in a non-document tree. The text has therefore been generalized to cover this case.
(Bugzilla Issue 2467).</p></item>


<item><p>When the text between curly braces in an attribute value template is not a valid XPath
expression, the error is now signaled using the original XPath error code. Error code XTSE0360
is no longer used. The relevant text has also been generalized to cover all XPath static errors,
not only syntax errors. (Bugzilla Issue 2468).</p></item>

<item><p>The specification is now more prescriptive about the way in which serialization errors
must be handled. Previously it was inconsistent as to whether such errors were necessarily fatal.
(Bugzilla Issue 2469).</p></item>


<item><p>The five types previously defined in the <code>xdt</code> namespace (<code>xdt:untyped</code>,
<code>xdt:untypedAtomic</code>, <code>xdt:anyAtomicType</code>, <code>xdt:dayTimeDuration</code>,
<code>xdt:yearMonthDuration</code>) have been moved to the <code>xs</code> namespace 
<code>http://www.w3.org/2001/XMLSchema</code>. (Bugzilla 2548)</p></item>

<item><p>In <specref ref="collating-sequences"/> it is now specified that <code>xs:anyURI</code>
values are sorted in the same way as <code>xs:string</code> values: in particular, that the
comparison makes use of the selected collation. This change is made to align with the XPath
rules for comparison operators applied to these types, and to ensure that a total ordering
exists for heterogeneous sequences containing both <code>xs:string</code> and <code>xs:anyURI</code>
values. (Bugzilla Issue 2561).</p></item>

<item><p>A typographical error in <specref ref="constructing-simple-content"/> 
has been corrected (Bugzilla Issue 2584)</p></item>

<item><p>The <elcode>xsl:namespace-alias</elcode> declaration may now reference the null namespace, that
is, it may be used to move elements from being in a namespace to being in no namespace, or vice versa.
This change has been made for backwards compatibility reasons: although XSLT 1.0 did not clearly specify
whether or not this situation was allowed, a number of processors adopted this interpretation and it might be
inconvenient for some users if the facility were dropped. (Bugzilla Issue 2613)</p></item>

<item><p>It is now specified that when an <code>xml:id</code> attribute is constructed, as well
as acquiring the <code>is-id</code> property, the value of the attribute is normalized (as if by
the <xfunction>normalize-space</xfunction> function). This is consistent with the principle that 
the XSLT processor performs the functions of an <code>xml:id</code> processor. (Bugzilla 2639)</p></item>

<item><p>The effect of supplying a negative argument to the <function>regex-group</function> function
has been clarified. (Bugzilla 2698)</p></item>

<item><p>The rules for stripping type annotations have been clarified, both for the case where type annotations
are stripped from input documents, and the case where <code>validation="strip"</code> is specified. The rules
now explicitly describe the effect on the typed value and the properties <code>nilled</code>, <code>is-id</code>,
and <code>is-idrefs</code>, as well as the effect on the type annotation itself. (Bugzilla 2700)</p></item>

<item><p>It has been made clear that the rule governing the relative priority of attributes of a literal
result element and attributes constructed using a child instruction of the literal result element
applies to attributes constructed using <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> as
well as to attributes constructed using <elcode>xsl:attribute</elcode>. (Bugzilla 2701).</p></item>

<item><p>The use of the term <termref def="dt-temporary-tree">temporary tree</termref> has been made
more consistent. It now refers to any tree (whether rooted at a document node or not) other than a source
or result tree. It no longer refers exclusively to a temporary tree that is constructed using 
<elcode>xsl:variable</elcode> with no <code>select</code> or <code>as</code> attribute. (Bugzilla 2702)</p></item>

<item><p>The rule for the default priority of a pattern comprising a <code>DocumentTest</code> has
been corrected so that a <code>DocumentTest</code> containing a <code>SchemaElementTest</code> is
treated in the same way as a <code>DocumentTest</code> containing an <code>ElementTest</code>.
(Bugzilla 2703).</p></item>

<item><p>A contradictory statement suggesting that a local <elcode>xsl:param</elcode> element could shadow
an <elcode>xsl:variable</elcode> or another <elcode>xsl:param</elcode> has been corrected. (Bugzilla 2704)</p></item>

<item><p>The description of how attributes such as <code>xsi:type</code> are handled if they appear on a 
literal result element has been modified to remove any implication that they have no effect on subsequent
processing. (Bugzilla 2705)</p></item>

<item><p>The rules for the <function>format-number</function> function have been changed so that <code>NaN</code>
is now formatted without any prefix or suffix. This restores compatibility with XSLT 1.0. (Bugzilla 2712)</p></item>

<item><p>Editorial improvements have been made to the introductory paragraph explaining 
<elcode>xsl:value-of</elcode>. (Bugzilla 2779)</p></item>

<item><p>Under <elcode>xsl:copy</elcode> and <elcode>xsl:copy-of</elcode>, the text now confirms that
the base URI of a parent node will be inherited whether that node is a document node or an element
node. (Bugzilla 2773/2774)</p></item>

<item><p>It is now specified that the results of the functions <function>unparsed-text</function>
and <function>unparsed-text-available</function> must be stable. (Bugzilla 2874)</p></item>

<item><p>It is now specified that the function <function>current-grouping-key</function> returns the
grouping key of the initial item in the group. Although all items in a group have equal grouping keys,
they may differ for example in their type annotation. (Bugzilla 2916)</p></item>

<item><p>A paragraph has been added to <specref ref="temporary-trees"/> to explain that a tree constructed
using <elcode>xsl:variable</elcode> with no <code>select</code> or <code>as</code> attribute effectively
has <code>validation=preserve</code>. This information was previously difficult to find. (Bugzilla 2945)</p></item>

<item><p>It is now stated that context-dependent functions such as <xfunction>current-date</xfunction> are
not required to return the same result at compile-time (specifically, when evaluating <code>[xsl:]use-when</code>
expressions) as they return at run-time. For details, see <specref ref="conditional-inclusion"/>. (Bugzilla 2946)</p></item>

<item><p>Some examples illustrating the use of <elcode>xsl:number</elcode> incorrectly used the attribute <code>language="X"</code>
in place of <code>lang="X"</code>. (Bugzilla 2975)</p></item>

<item><p>A note has been added to the specification of <elcode>xsl:next-match</elcode> explaining what happens when
two branches of a union pattern match the same node with different priorities. (Bugzilla 3002)</p></item>

<item><p>The wording of error XTDE1035 has been improved to remove the unintended implication that a processor is expected
to know whether or not an unrecognized URI refers to a collation. (Bugzilla 3014)</p></item>

<item><p>When the <function>format-time</function> function outputs the fractional seconds component in a fixed width field, the
specification now defines how the value should be rounded. (Bugzilla 3018)</p></item>

<item><p>The behavior of <function>format-date</function> when handling years earlier than 1 A.D. has been
clarified.  (Bugzilla 3019)</p></item>

<item><p>References to RFC 3023 have been labeled as referring equally to any document that supersedes
RFC 3023. (Bugzilla 3059)</p></item>



<item><p>Error XTSE0140 has been dropped, as it was a duplicate of XTSE0200. (Bugzilla 3064)</p></item>

<item><p>Using a reserved namespace in the name of a stylesheet function now 
results unambiguously in error XTSE0080 rather than XTSE0740. (Bugzilla 3065) </p></item>

<item><p>Error code XTDE0070 is no longer used. This condition (undefined focus) now produces the
underlying XPath error XPDY0002. (Bugzilla 3066)</p></item>

<item><p>The description of <elcode>xsl:fallback</elcode> now makes clear that the error behavior in the absence
of an <elcode>xsl:fallback</elcode> instruction is different
for the two cases described, namely an unknown extension instruction and an unknown XSLT instruction.
(Bugzilla 3067)</p></item>

<item><p>Error code XTDE0485 has been removed, because it was determined that the conditions giving rise
to the error could never occur. (Bugzilla 3069)</p></item>

<item><p>The text describing <termref def="dt-simplified-stylesheet-module">simplified stylesheets</termref>
and <termref def="dt-embedded-stylesheet-module">embedded stylesheets</termref> has been clarified. (Bugzilla 3070)</p></item>

<item><p>The specification previously contained a non-normative statement that the behavior of built-in
template rules was different when backwards-compatible behavior was enabled. This was not backed up by the
normative text. The Working Group confirmed the normative text: this means that built-in 
templates now pass parameters
through whether or not backwards-compatible behavior is enabled. This has now been documented as a backwards
incompatibility. (Bugzilla 3073)</p></item>

<item><p>Some clarifications have been added to the description of the semantics
 of <code>xpath-default-namespace</code>. (Bugzilla 3081)</p></item>

 <item><p>The effect of specifying serialization attributes that are inapplicable to the chosen
output method has been clarified.  (Bugzilla 3083)</p></item>

 <item><p>Error XTTE0505 has been added for the situation where the result of evaluating the content of a
 template cannot be converted to the type given in its <code>as</code> attribute. (Bugzilla 3084)</p></item>

<item><p>The <elcode>xsl:document</elcode> instruction has been added to the list of instructions that
can cause error XTDE1520. (Bugzilla 3088)</p></item>

<item><p>It has been clarified that the <code>xpath-default-namespace</code> applies to an unprefixed QName
appearing in the <code>xsl:type</code> attribute of a literal result element. (Bugzilla 3093)</p></item>



 <item><p>More rigorous definitions have been provided for common concepts such as
 <termref def="dt-xslt-element">XSLT element</termref>,
 <termref def="dt-instruction">instruction</termref>, and
 <termref def="dt-xslt-instruction">XSLT instruction</termref>, to remove any doubt about the
 results of the <function>element-available</function> function. (Bugzilla 3123)</p></item>

<item><p>The material in the non-normative backwards compatibility appendix describing how <elcode>xsl:number</elcode>
is handled when backwards-compatible behavior is enabled has been brought into line with the normative text.
(Bugzilla 3162)</p></item> 

<item><p>A note has been added to the description of <function>format-dateTime</function> to make clear that
<code>[f1]</code> requests an implementation-defined number of digits of precision in the fractional seconds.
To request exactly one digit you need to write <code>[f1,1-1]</code>. (Bugzilla 3163)</p></item>

<item><p>A new function <function>type-available</function> has been added to test the availability
of schema types in the static context. (Bugzilla 3165)</p></item>

<item><p>Error XTSE0215 has been allocated for the situation where an <elcode>xsl:import-schema</elcode>
element conflicts with a contained inline <code>xs:schema</code>. (Bugzilla 3195)</p></item>

<item><p>Error XTDE1170 has been extended in scope to cover the case where a URI supplied to
the <function>unparsed-text</function> contains a fragment identifier. (Bugzilla 3197)</p></item>

<item><p>The effect of <elcode>xsl:number</elcode> has been clarified for the case where
the <code>format</code> attribute contains a non-alphanumeric token but no format token 
(for example <code>format="#"</code>). To retain compatibility with XSLT 1.0, the chosen
interpretation is that the token acts as both a prefix and a suffix. (Bugzilla 3326)</p></item>

<item><p>An error code is now associated with the use of <code>xsl:message terminate="yes"</code>.
(Bugzilla 3335).</p></item>

<item><p>The rules for namespace fixup have been amended to clarify that the processor is allowed
to add or remove prefixes appearing on element and attribute names, as well as changing the prefix.
(Bugzilla 3336).</p></item>

<item><p>The description of error <code>XTSE1430</code> has been broadened so it covers the case
where the <code>[xsl:]extension-element-prefixes</code> attribute specifies <code>#default</code>
and there is no default namespace. (Bugzilla 3379)</p></item>

<item><p>When the instructions <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> are
used to copy an element node without attaching it to a new parent, and the element has an
<code>xml:base</code> attribute that is a relative URI, the base URI of the new element is
now computed afresh rather than being copied from that of the existing node. (Bugzilla 3417)</p></item>

<item><p>The description of the <code>xsl:type</code> and <code>xsl:validation</code> attributes
on a literal result element has been expanded to clarify that the values are not attribute
value templates. (Bugzilla 3526)</p></item>

<item><p>The specification stated in a non-normative appendix that in backwards compatibility mode,
calls on unknown extension functions would raise an error only if such calls were actually evaluated.
There was no normative statement that confirmed this. This behavior has now been made
normative. (Bugzilla 3608)</p></item>

<item><p>In the rules for constructing complex content, a bug has been fixed in the rules for namespace
inheritance. Specifically, a namespace node of the form <code>xmlns="uri"</code> on a parent element
is not inherited by a descendant element whose name is in no namespace. (Bugzilla 3689)</p></item>

<item><p>A more precise definition of the option <code>mode="#all"</code> is now given, and error codes have
been defined for the cases where (a) the initial mode supplied on stylesheet activation is not one of the
modes defined in the stylesheet, and (b) where both an initial mode and an initial template are supplied.
(Bugzilla 3690)</p></item>

<item><p>The specification of the <function>unparsed-text</function> function now allows the implementation, in
the absence of any specific encoding information, to use implementation-defined heuristics to determine
the encoding. (Bugzilla 3728)</p></item> 

<item><p>A processor is now permitted to raise an error if the stylesheet attempts to create an
<code>xml:space</code> attribute with a value other than <code>default</code> or <code>preserve</code>
(The XML specification states this is "erroneous", but does not make the document ill-formed. Some XML parsers
reject such documents.) (Bugzilla 3729)</p></item>

<item><p>The rules for the use of <function>function-available</function> when used in a <code>use-when</code>
expression have been refined: this is complicated by the fact that the intended purpose of the function
when used in <code>use-when</code> is to determine whether a function is available for use within the
part of the stylesheet governed by the <code>use-when</code> attribute, rather than specifically within
the <code>use-when</code> attribute itself. (Bugzilla 3772)</p></item>

</ulist>
 </div3>-->
 
 <div3 id="changes-2007-01" diff="chg" at="ZC"><head>Changes since Proposed Recommendation</head>
 
 <p>The following changes have been made since publication of the 
 <loc href="http://www.w3.org/TR/2006/PR-xslt20-20061121/">Proposed Recommendation</loc>.
 Each change contains a reference to its discussion and rationale, for example the
 relevant issue number in the 
 <loc href="http://www.w3.org/Bugs/Public/">W3C public Bugzilla database</loc>.</p>
 
 <ulist>
 
 <item><p>In <specref ref="analyze-string"/>, the paragraph describing the permitted contents of the
 instruction has been clarified. (The sentence "Both elements are optional, and neither may appear more than once."
 was considered awkward). This editorial change was made in response to a 
 <loc href="http://lists.w3.org/Archives/Public/public-qt-comments/2006Jan/0083">public comment</loc> made
 during the Candidate Recommendation phase.</p></item>
 
 <item><p>In <specref ref="result-trees"/> it was stated that the result of a transformation consisted of zero or more result trees;
 while <specref ref="executing-a-transformation"/> stated (correctly) that it consisted of one or more. The former statement has
 been revised. A cross-reference between the two sections has been added for clarification. (Bugzilla 4031)</p></item>
 
 <item><p>Some trivial syntax errors in examples have been fixed. (Bugzilla 4149)</p></item>
 
 </ulist>
 
 <p>The 
 <loc href="http://www.w3.org/TR/2006/PR-xslt20-20061121/">Proposed Recommendation</loc> contains
 a complete list of published working drafts prepared during the development of this specification,
 and a detailed history of changes may be assembled by viewing the change log present in each draft.
 For most of the drafts, a version is available in which changes are visually highlighted.</p>
 
 
 </div3>
			</div2>
		</inform-div1>
	</back>
</spec>
