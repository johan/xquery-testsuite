<!--XSLT Processor: SAXON 8.9.0.4 from Saxonica SAXON SA 8.9.0.4--><!--XSLT Processor: SAXON 8.9.0.4 from Saxonica SAXON SA 8.9.0.4--><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" id="spec-top" w3c-doctype="cr"><header><title>XQuery and XPath Full Text 1.0</title><w3c-designation>CR-xpath-full-text-10</w3c-designation><w3c-doctype>W3C Candidate Recommendation</w3c-doctype><pubdate><day>16</day><month>May</month><year>2008</year></pubdate><publoc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2008/CR-xpath-full-text-10-20080516/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2008/CR-xpath-full-text-10-20080516/</loc>
      </publoc><altlocs><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2008/CR-xpath-full-text-10-20080516/xpath-full-text.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc></altlocs><latestloc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xpath-full-text-10/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-full-text-10/</loc>
      </latestloc><prevlocs>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/WD-xquery-full-text-20060501/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xquery-full-text-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xquery-full-text-20050915/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xquery-full-text-20050404/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/WD-xquery-full-text-20040709/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
      </prevlocs><authlist><author><name>Sihem Amer-Yahia</name><affiliation>AT&amp;T Labs - Research</affiliation><!--	<email href="mailto:sihem@research.att.com">sihem@research.att.com</email> --></author><author><name>Chavdar Botev</name><affiliation>Invited Expert</affiliation><!--	<email href="mailto:cbotev@cs.cornell.edu">cbotev@cs.cornell.edu</email> --></author><author><name>Stephen Buxton</name><affiliation>Mark Logic Corporation</affiliation><!--	<email href="mailto:stephen.buxton@marklogic.com">stephen.buxton@marklogic.com</email> --></author><author><name>Pat Case</name><affiliation>Library of Congress</affiliation><!--	<email href="mailto:pcase@crs.loc.gov">pcase@crs.loc.gov</email> --></author><author><name>Jochen Doerre</name><affiliation>IBM</affiliation><!--  <email href="mailto:doerre@de.ibm.com">doerre@de.ibm.com</email> --></author><author><name>Mary Holstege</name><affiliation>Mark Logic Corporation</affiliation><!--	<email href="mailto:mary.holstege@marklogic.com">mary.holstege@marklogic.com</email> --></author><!-- <author>
	<name>Darin McBeath</name>
	<affiliation>Elsevier</affiliation>
	<email href="mailto:D.McBeath@elsevier.com">D.McBeath@elsevier.com</email>
</author> --><author><name>Jim Melton</name><affiliation>Oracle</affiliation><!--  <email href="mailto:jim.melton@oracle.com">jim.melton@oracle.com</email> --></author><author><name>Michael Rys</name><affiliation>Microsoft</affiliation><!--	<email href="mailto:mrys@microsoft.com">mrys@microsoft.com</email> --></author><author><name>Jayavel Shanmugasundaram</name><affiliation>Invited Expert</affiliation><!--	<email href="mailto:jai@cs.cornell.edu">jai@cs.cornell.edu</email> --></author></authlist><abstract><p>This document defines the syntax and formal semantics of XQuery and XPath Full Text 1.0
which is a language that extends XQuery 1.0 <bibref ref="xquery"/>
and XPath 2.0 <bibref ref="xpath20"/> with full-text search capabilities.</p></abstract><!--* Common status section for QT specs.
    * Use is currently not required, but it simplifies things.
    * 
    * Revisions:
    * 2007-01-15 : CMSMcQ : made file, to simplify publication of Rec.
    * 2008-02-15 : JimMelton : cloned from MSM's REC-only material
                     to generalize for all stages
    *--><status id="status"><!-- ************************************************************************** --><!-- * All Status sections must start with the standard boilerplate paragraph * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>
            <emph>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc>
         at http://www.w3.org/TR/.</emph>
         </p><!-- ************************************************************************** --><!-- * QT publishes suites of documents, which must be described in the       * --><!--     Status section of each document within such a suite.                 * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * There is a lot of detailed customization based on the document stage   * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>W3C publishes a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Candidate Recommendation</loc>, as described in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Process Document</loc>,
to indicate that the document is believed to be stable and to encourage implementation
by the developer community.
The publication of this document constitutes a
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#cfi" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">call for implementations</loc>
of this specification. </p><p>This document has been jointly developed by the W3C 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc> and the W3C <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSL Working Group</loc>, each of which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.
It will remain a Candidate Recommendation until at least 15 September 2008.
The Working Groups expect to advance this specification to <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recommendation</loc> Status.</p><p>The <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc> and <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSL Working Group</loc> intend to submit
this document for consideration as a W3C
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Proposed Recommendation</loc>
as soon as the following conditions are all met:
</p><olist><item><p>A test suite is available that tests each identified XQuery and XPath Full Text 1.0 feature,
      both required and optional.</p></item><item><p>Minimal Conformance to this specification, as defined in
      <specref ref="id-minimal-conformance"/>, has been demonstrated by at least 
      two distinct implementations, at least one of which uses the XQuery human-readable 
      syntax defined in this specification.</p></item><item><p>An XPath Full Text parsing applet that generates XQueryX is available.</p></item><item><p>The Working Groups have responded formally to all issues raised during
      the CR period against this document.</p></item></olist><p>Once the entrance criteria for Proposed Recommendation have been achieved,
the Director will be requested to advance this document to <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Proposed Recommendation</loc> status. 
Working closely with the developer community, we expect to show evidence of implementations
by approximately 15 September 2008. </p><!-- ************************************************************************** --><!-- * CR documents must cite features at risk                                * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>The 15 <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#id-conform-optional-features" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">optional features</loc> are each individually at risk.
   Optional features for which there are not at least two implementations at the end of the
   Candidate Recommendation period may be removed from this specification.</p><!-- ************************************************************************** --><!-- * Every Status section must have a customized paragraph                  * --><!-- *   This entity is defined completely in the host document.              * --><!-- ************************************************************************** --><p>The WG
believes that this document, published on 16 May 2008,
is sufficiently mature and stable for the development
community to begin developing implementation experience
and reporting on that experience. </p><p>The WGs particularly solicit feedback regarding how
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftthesaurusoption" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">thesauri</loc> are to be used in combination. </p><p>The WGs wish to point out a change in the syntax of full-text queries when weights are being specified.
The syntax has been changed so that weights are specified at the level of full-text primary expressions
instead of at the full-text selection level; this permits different weights to be specified for
different parts of a full-text query.  The previous (full-text selection level) behavior can
still be achieved by appropriate use of parentheses to force the precedence of the weight
specification to apply to the desired level.</p><!-- ************************************************************************** --><!-- * CR docs should, and PR docs must, have a pointer to an implementation  * --><!-- *   report.  We also want to point to the test suite.                    * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>No implementation report currently exists.
However, a Test Suite for this document is under development.
Implementors are encouraged to run this test suite and report their results.
The Test Suite can be found at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://dev.w3.org:/cvsweb/2007/xpath-full-text-10-test-suite/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://dev.w3.org:/cvsweb/2007/xpath-full-text-10-test-suite/</loc>.</p><!-- ************************************************************************** --><!-- * The Status section should point to a changelog                         * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This document incorporates changes made against the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#last-call" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Last Call Working Draft</loc> of 18 May 2007.
  Changes to this document since the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#last-call" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Last Call Working Draft</loc> are detailed in
  <specref ref="id-xqft-changelog"/>.</p><!-- ************************************************************************** --><!-- * The Status section must tell readers where to send comments            * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>Please report errors in this document using W3C's
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc>
         (instructions can be found at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>.
         It will be very helpful if you include the string 
         “[FT]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
         if you have more than one comment to make.
         Archives of the comments and responses are available at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/</loc>. </p><!-- ************************************************************************** --><!-- Status sections must state the stability (not stable, or REC) of the document --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>Publication as a Candidate Recommendation
does not imply endorsement by the W3C Membership. 
This is a draft document and may be updated, replaced or obsoleted
by other documents at any time. 
It is inappropriate to cite this document as other than work in progress.</p><!-- ************************************************************************** --><!-- * Finally, all Status sections must end with the appropriate IPR para    * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>This document was produced by groups operating under the
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004
   W3C Patent Policy</loc>.
   W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any 
   patent disclosures</loc> made in connection with the deliverables of the 
   XML Query Working Group and also maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent 
   disclosures</loc> made in connection with the deliverables of the XSL 
   Working Group; those pages also include instructions for
   disclosing a patent.
   An individual who has actual knowledge of a patent which the individual believes
   contains
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential Claim(s)</loc>
   must disclose the information in accordance with
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 6 of the W3C Patent Policy</loc>. </p></status><langusage><language id="EN">English</language><language id="ebnf">EBNF</language></langusage><revisiondesc><p>SA January 2004: First version of document before Feb F2F</p><p>SA 26 February 2004: Second version of document before Feb F2F
    meetings.</p><p>JM 18 May 2007: Last Call Working Draft</p></revisiondesc></header><body><!-- *********************************************************************
      Section 1. Introduction
     ********************************************************************* --><div1 id="introduction"><head>Introduction</head><p>This document defines the language and the formal semantics of
  XQuery and XPath Full Text 1.0. This language is designed to meet the requirements
  identified in W3C XQuery and XPath Full Text Requirements
  <bibref ref="xqueryft-requirements"/> and to support the queries in
  the W3C XQuery and XPath Full Text Use Cases <bibref ref="xmlquery-full-text-use-cases"/>. </p><p>XQuery and XPath Full Text 1.0 extends the syntax and semantics of XQuery 1.0 and
  XPath 2.0. </p><p>Additionally, this document defines an XML syntax for XQuery and XPath Full Text 1.0. 
  The most recent versions of the two XQueryX XML Schemas and the
  XQueryX XSLT stylesheet for XQuery and XPath Full Text 1.0 are available at
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx.xsd" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx.xsd</loc>,
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx-ftmatchoption-extensions.xsd" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx-ftmatchoption-extensions.xsd</loc>,
  and <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx.xsl" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx.xsl</loc>,
  respectively.</p><div2 id="tq-ftsearch-xml"><head>Full-Text Search and XML</head><p>As XML becomes mainstream, users expect to be able to 
search their XML documents. This requires a standard way to do
full-text search, as well as structured searches, against XML
documents.  A similar requirement for full-text search led ISO to
define the <!-- <loc
href="ftp://sqlstandards.org/SC32/WG4/Progression_Documents/CD/cd-fulltext-2001-05.pdf">SQL/MM-FT
standard</loc>.  --> SQL/MM-FT <bibref ref="sqlmm"/> standard.
SQL/MM-FT defines extensions to SQL to express
full-text searches providing functionality similar to that defined in this full-text
language extension to XQuery 1.0 and XPath 2.0.
</p><p>XML documents may contain highly structured data (fixed schemas, known types
such as numbers, dates), semi-structured data (flexible schemas and types),
markup data (text with embedded tags), and unstructured data (untagged
free-flowing text). Where a document contains unstructured
or semi-structured data, it is important to be able to search using
Information Retrieval techniques such as scoring and weighting.</p><p>Full-text search is different from substring search in many ways:</p><olist><item><p>A full-text search searches for tokens and phrases
rather than substrings. A substring search for news items that contain
the string "lease" will return a news item that contains "Foobar
Corporation releases the 20.9 version ...". A full-text search for the
token "lease" will not. </p></item><item><p>There is an expectation that a full-text search will support
language-based searches which substring search cannot. An
example of a language-based search is "find me all the news items that
contain a token with the same linguistic stem as 'mouse'" (finds "mouse"
and "mice"). Another example based on token proximity is "find me all
the news items that contain the tokens 'XML' and
'Query' allowing up to 3 intervening tokens".</p></item><item><p>Full-text search must address the vagaries and nuances of
language. Search results  are often of varying usefulness. When
you search a web site for cameras that cost less than $100, this
is an exact search.  There is a set of cameras that matches this search,
and a set that does not.  Similarly, when you do a string search across
news items for "mouse", there is only 1 expected result set. When you
do a full-text search for all the news items that contain the
token "mouse", you probably expect to find news items containing the token
"mice", and possibly "rodents", or possibly "computers".  Not
all results are equal. Some results are more "mousey" than others.
Because full-text search may be inexact, we have the notion of score
or relevance. We generally expect to see the most relevant results at
the top of the results list.</p></item></olist><note><p>As XQuery and XPath evolve, they
 may apply the notion of
score to querying structured data. For example, when making travel
plans or shopping for cameras, it is sometimes useful to get an
ordered list of near matches in addition to exact matches. If
 XQuery and XPath define a generalized 
inexact match, we expect XQuery and XPath to utilize the scoring
framework provided by XQuery and XPath Full Text.
</p></note><p>
               <termdef id="Full-TextQueriesDef" term="Full-TextQueries">
                  <term>Full-text queries</term> are 
   performed on tokens and phrases. Tokens and phrases are produced via
   tokenization.</termdef> Informally, tokenization breaks a character string into a 
    sequence of tokens, units of punctuation, and spaces.</p><p>
Tokenization, in general terms, is the process of converting a text
string into smaller units that are used in query processing. Those
units, called tokens, are the most basic text units that a full-text
search can refer to. Full-text operators typically work on sequences
of tokens found in the target text of a
search. These tokens are characterized by
integers that capture the relative position(s) of the token inside the
string, the relative position(s) of the sentence containing the token,
and the relative position(s) of the paragraph containing the token.  The
positions typically comprise a start and an end position.</p><p>
Tokenization, including the definition of the term "tokens", <termref def="should">SHOULD</termref> be
<termref def="dt-implementation-defined">implementation-defined</termref>. 
Implementations <termref def="should">SHOULD</termref> expose the rules and sample
results of tokenization as much as possible to enable users to predict and
interpret the results of tokenization. 
Tokenization operates on the string
value of an item; for element nodes this does not include the content of
attribute nodes, but for attribute nodes it does.
Tokenization is defined more formally in
<specref ref="TokenizationSec"/>.
</p><p>
               <termdef id="TokenDef" term="Token">A <term>token</term> is a non-empty sequence of characters returned by a tokenizer as a basic unit to be
searched. Beyond that, tokens are <termref def="dt-implementation-defined">implementation-defined</termref>.</termdef>
               <termdef id="PhraseDef" term="Phrase">A <term>phrase</term> is an ordered sequence of any number of tokens. Beyond that,
 phrases are <termref def="dt-implementation-defined">implementation-defined</termref>.</termdef>
            </p><note><p>Consecutive tokens need not be separated by either punctuation or
space, and tokens may overlap.</p></note><note><p>In some natural languages, tokens and words can be used
interchangeably.</p></note><!--<note><p>Tokens are distinct if they are at different positions in the tokenization, regardless of whether they comprise the same sequence of characters.</p></note>--><!--<p>Tokenization also uniquely identifies sentences and paragraphs in which tokens appear.</p>--><p>
               <termdef id="SentenceDef" term="Sentence">A <term>sentence</term> is an ordered sequence
of any number of tokens. 
Beyond that, sentences are <termref def="dt-implementation-defined">implementation-defined</termref>. 
A tokenizer is not required to support sentences.</termdef>
            </p><p>
               <termdef id="ParagraphDef" term="Paragraph">A <term>paragraph</term> is an ordered sequence
of any number of tokens. 
Beyond that, paragraphs are <termref def="dt-implementation-defined">implementation-defined</termref>. 
A tokenizer is not required to support paragraphs.</termdef>
            </p><p>
Some XML elements represent semantic
markup, e.g., &lt;title&gt;. Others represent formatting markup, e.g.,
&lt;b&gt; to indicate bold.  Semantic markup serves well as token
boundaries. Some formatting markup serves
well as token boundaries, for example, paragraphs are most commonly delimited
by formatting markup. Other formatting markup may not serve well as token
boundaries. Implementations
are free to provide <termref def="dt-implementation-defined">implementation-defined</termref> ways to differentiate between 
the markup's effect on token boundaries during tokenization. In the absence of an implementation-defined way to differentiate, element markup (start tags, end tags, and empty-element tags)  creates token boundaries.
</p><p>
A sample tokenization is used for the examples in this document. 
The results might be different for other tokenizations. </p><p>Tokenization enables functions and operators that operate on a
part or the root of the token (e.g., wildcards, stemming). </p><p>Tokenization enables functions and operators which work with the
relative positions of tokens (e.g., proximity operators). </p><p>
This specification focuses on functionality that serves all
languages. It also selectively includes functionalities useful within
specific families of languages. For example, searching within
sentences and paragraphs is useful to many western languages and to
some non-western languages, so that functionality is incorporated into
this specification.
</p><p>Certain aspects of language
		processing are described in this specification as
		<term>implementation-defined</term> or
		<term>implementation-dependent</term>.</p><ulist><item><p>
                     <termdef id="dt-implementation-defined" term="implementation defined">
                        <term>Implementation-defined</term>
		indicates an aspect that may differ between
		implementations, but must be specified by the
		implementor for each particular
		implementation.</termdef>
                  </p></item><item><p>
                     <termdef id="dt-implementation-dependent" term="implementation   dependent">
                        <term>Implementation-dependent</term>
		indicates an aspect that may differ between
		implementations, is not specified by this or any W3C
		specification, and is not required to be specified by
		the implementor for any particular
		implementation.</termdef>
                  </p></item></ulist></div2><div2 id="tq-ft-organization"><head>Organization of this document</head><p>This document is organized as follows. We first present a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#tq-extensions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">high level syntax</loc> for the XQuery and XPath Full Text 1.0
language along with some examples. Then, we present the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftselections" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">syntax and examples</loc> of the
basic primitives in the XQuery and XPath Full Text 1.0 language. This is followed by the
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#tq-semantics" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">semantics</loc> of the XQuery and XPath Full Text 1.0
language. The appendix contains a section that provides an <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#id-xpath-grammar" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">EBNF for the XPath 2.0 Grammar with Full-Text
Extensions</loc>, an <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#id-grammar" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">EBNF for XQuery 1.0
Grammar with Full-Text Extensions</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ft-acknowledgements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">acknowledgements</loc> and a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ft-glossary" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">glossary</loc>.</p></div2><div2 id="tq-ft-namespaces"><head>A word about namespaces</head><p>Certain namespace prefixes are predeclared by XQuery 1.0 and, by implication, by this specification,
and bound to fixed namespace URIs. These namespace prefixes are as follows:
</p><ulist><item><p>
                     <code>xml = http://www.w3.org/XML/1998/namespace</code>
                  </p></item><item><p>
                     <code>xs = http://www.w3.org/2001/XMLSchema</code>
                  </p></item><item><p>
                     <code>xsi = http://www.w3.org/2001/XMLSchema-instance</code>
                  </p></item><item><p>
                     <code>fn = http://www.w3.org/2005/xpath-functions</code>
                  </p></item><item><p>
                     <code>local = http://www.w3.org/2005/xquery-local-functions</code>
                  </p></item></ulist><p>
In addition to the prefixes in the above list, this document uses the prefix
<code>err</code> to represent the namespace URI <code>http://www.w3.org/2005/xqt-errors</code>, 
This namespace prefix is not predeclared and its use in this document is not normative. 
Error codes that are not defined in this document are defined in other XQuery 1.0 and XPath 2.0
specifications, particularly <bibref ref="xpath20"/> and <bibref ref="xpath-functions"/>. 
</p><p>
Finally, this document uses the prefix <code>fts</code> to represent a namespace
containing a number of functions used in this document to describe the semantics
of XQuery and XPath Full Text functions. There is no
requirement that these functions be implemented, therefore no URI is associated with that prefix. 
</p></div2></div1><!-- web35710.mail.mud.yahoo.com compressed/chunked Thu Sep 13 09:00:56 PDT 2007 --><!--
2. TeXQuery Expressions
2.1   Processing Model
2.2   FTContainsExpr 
2.3   Scoring
2.3   Extensions to the Static Context

--><div1 id="tq-extensions"><head>Full-Text Extensions to XQuery and XPath</head><p>XQuery and XPath Full Text extends the languages of XQuery
1.0 and XPath 2.0 in three ways. It:</p><olist><item><p>Adds a new expression called FTContainsExpr;</p></item><item><p>Enhances the syntax of FLWOR expressions in XQuery 1.0 and
  <code>for</code> expressions in XPath 2.0 with optional score
  variables; and</p></item><item><p>Adds static context declarations for full-text match
  options to the query prolog.</p></item></olist><p>Additionally, it extends the data model and processing models in
various ways.</p><div2 id="processing-model"><head>Processing Model</head><p>
A <termref def="dt-ftcontains">full-text contains expression</termref>
(<specref ref="section-ftcontainsexpr"/>)
is composed of
several parts:</p><olist><item><p>
  An XPath 2.0 or XQuery 1.0 expression (RangeExpr) that
  specifies the sequence of items to be searched. 
  <termdef id="dt-search-context" term="search context">
  Those items are called
  the <term>search context</term>.</termdef>
                  </p></item><item><p>
  The full-text selection to be applied (<specref ref="ftselections"/>).
  <term>Full-text selections</term> 
  are, syntactically and semantically, fully composable and contain:
  </p><ulist><item><p>
    Required:</p><ulist><item><p>
      Tokens and phrases for which a search is performed (<specref ref="ftwords"/>).</p></item></ulist></item><item><p>
    Optional:</p><ulist><item><p>
      Match options, such as indicators for case sensitivity and stop
      words (<specref ref="ftmatchoptions"/>);</p></item><item><p>
      Boolean full-text operators, that compose a full-text selection from
      simpler full-text selections (<specref ref="logical_ftoperators"/>);</p></item><item><p>
      Other full-text operators that are constraints on the positions of
      matches, such as indicators for distance between tokens and for the
      cardinality of matches (<specref ref="ftposfilter"/> and 
      <specref ref="fttimes"/>); and</p></item><item><p>
      The weighting information. Each individual search term in a
      full-text selection may be annotated with optional weight
      information. This information may be used during the evaluation
      of the full-text selections to
      calculate scoring, information that quantifies the relevance of the
      result to the given search criteria.</p></item></ulist></item></ulist></item><item><p>
  An optional XPath 2.0 or XQuery 1.0 expression (UnionExpr) that
  specifies the set of nodes, descendents of the RangeExp, whose
  contents must be ignored for the purpose of determining a match
  during the search (<specref ref="ftignoreoption"/>).</p></item></olist><p>
The results of the evaluation of the full-text selection operators are
instances of the AllMatches model, which complements the XQuery Data
Model (XDM) for processing full-text queries. An AllMatches instance
describes all possible solutions to the full-text query for a given
search context item. Each solution is described by a Match instance. A
Match instance contains the tokens from the search context that must
be included (described using StringInclude instances which model the
positive terms) and the tokens from search context item that must be
excluded (described using StringExclude instances which model the
negative terms). Each negative or positive term is modeled as a tuple:
the position of the query token or phrase in the full-text selection, and a
TokenInfo structure that describes a set of tokens in the text string which match the query token or phrase.
</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/ProcMod-XQueryFT.gif" alt="Processing Model Extensions" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Figure 1 provides a schematic overview of the XQuery and XPath Full Text processing steps that are discussed in detail below. 
Some of these steps are completely outside the domain of XQuery; in
Figure 1, these are depicted outside the black line that represents
the boundaries of the language. The diagram only shows the central pieces
of the XQuery Processing Model (see <xspecref spec="XQ" ref="id-processing-model"/>), however zooms in on the Execution Engine
where the processing of the full-text extensions takes place. The
full-text processing steps are labeled as FTn within the diagram and
are referenced within the text.</p><p>
Like all XQuery expressions, an FTContainsExpr returns an XDM
Instance (see Fig. 1). With the exception of FTWords, which consumes TokenInfos,
all full-text selections are closed under the AllMatches data model,
i.e., their input and output are AllMatches instances. Tokenization transforms an XDM
instance into TokenInfos, which ultimately get converted into AllMatches
instances by the evaluation of full-text selections. Thus, the evaluation of
nested full-text and XQuery expressions instances moves back and forth
between these two models.
</p><p>
The resulting AllMatches instance obtained by the evaluation of an FTContainsExpr 
is converted into a Boolean value before being
returned to the enclosing XPath or XQuery operation as follows. If at
least one member of the disjunction contains only positive terms then
value returned is true. If all members of the disjunction contain
negative terms the result is false.
</p><p>
Weighting information, in an <termref def="dt-implementation-dependent">implementation-dependent</termref> fashion, may be
used when calculating the scoring information computed and made
available by FTContainsExpr to the optional score construct.
</p><p>
Given the components of a given full-text contains expression, the evaluation
algorithm will proceed according to the following steps, also referenced in the processing model diagram as steps FT<emph>n</emph> (see Fig. 1):
</p><olist><item><p>
  Evaluate the search context expression
  (resulting in the sequence of search context items),
  the ignore option, if any
  (resulting in the set of ignored nodes),
  and any other XQuery/XPath exprssions nested within the full-text contains expression.
  (FT1)
  </p></item><item><p>
  Tokenize the query string(s). (FT2.1)</p></item><item><p>
  For each search context item:</p><olist><item><p>
  Delete the ignored nodes from the search context item.</p></item><item><p>
    Tokenize the result of the previous step.
    This produces a sequence of tokens. (FT2.2)
    Note that implementations may (as an optimization) perform tokenization
    as part of the External Processing that is described in the XQuery Processing Model,
    when an XML document is parsed into an Infoset/PSVI
    and ultimately into a XQuery Data Model instance.</p></item><item><p>
    Evaluate the FTSelection against the tokens of the search context. (FT3, FT4)</p></item></olist></item><item><p>
  Convert the topmost AllMatches instances into a Boolean value. (FT5)</p><!-- Bugzilla Bug# 3908 --><p>
  The additional scoring information (also part of FT5) that is produced
  by the evaluation 
  of the full-text contains expression is <termref def="dt-implementation-dependent">implementation-dependent</termref> and is not
  specified in this document. The scoring information is made available at the same time the
  Boolean value is returned.
  </p></item></olist><p>
(A more detailed version of the above procedure
appears in Section <specref ref="FTContainsSec"/>.)
</p><!-- Bugzilla Bug# 3908 --><p>
Section <specref ref="ftselections"/>
describes the syntax and the informal semantics of full-text operators. 
Their formal semantics as well as the formal definition of the
AllMatches data model are given in Section <specref ref="tq-semantics"/>.
</p></div2><div2 id="section-ftcontainsexpr"><head>Full-Text Contains Expression</head><p>
               <termdef id="dt-ftcontains" term="full-text contains expression">A
<term>full-text contains expression</term> is a expression that evaluates a
sequence of items against a full-text selection.
</termdef>
            </p><p>As a syntactic construct, a full-text contains expression
(grammar symbol: <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt>) 
behaves like a
comparison expression (see <xspecref spec="XQ" ref="id-general-comparisons"/>).
This grammar rule introduces <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt>.</p><scrap headstyle="show"><head/><prod num="50" id="noid_d4e696.doc-xquery-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ValueComp" xlink:type="simple">ValueComp</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-GeneralComp" xlink:type="simple">GeneralComp</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt> )?</rhs></prod></scrap><p>A full-text contains expression may be used anywhere a
ComparisonExpr may be 
used. The <code>ftcontains</code> operator has higher precedence than
other comparison operators,  so the results of <code>ftcontains</code>
expressions may be compared without enclosing them in parentheses.</p><div3 id="section-ftcontainsexpr-description"><head>Description</head><scrap headstyle="show"><head/><prod num="51" id="doc-xquery-FTContainsExpr"><lhs>FTContainsExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RangeExpr" xlink:type="simple">RangeExpr</nt> ( "ftcontains"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTIgnoreOption" xlink:type="simple">FTIgnoreOption</nt>? )?</rhs></prod></scrap><p>A full-text contains expression returns a Boolean
value. It returns true if there is some item returned by
the RangeExpr that, after 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#TokenizationSec" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">tokenization</loc>, 
matches the full-text selection <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt>. 
Since tokenization includes tokens derived only from the string values of
items, a full-text contains expression searches the text of element nodes
and of their descendant elements. The string value of other kinds of nodes,
such as attributes and comments, will not be included unless the attribute or
comment node itself is the target (RangeExpr) of the full-text contains
expression. 
See Section
<specref ref="ftselections"/> for more details. 
For the purpose of determining
a match, certain descendants of nodes (identified by 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTIgnoreOption" xlink:type="simple">FTIgnoreOption</nt>) in 
the RangeExpr may be ignored, as specified in Section
<specref ref="ftignoreoption"/>.</p><p>An XQuery and XPath Full Text processor <termref def="should">SHOULD</termref> try to use the
information available in xml:lang for processing of collations, as well as
the various match options defined in Section <specref ref="ftmatchoptions"/>. 
</p></div3><div3 id="section-ftcontainsexpr-examples"><head>Examples</head><p>The following example in XQuery Full Text returns the author of
each book with a title containing a token with the same root as
<code>dog</code> and the token
<code>cat</code>.

		<eg role="xquery" xml:space="preserve">
for $b in /books/book
where $b/title ftcontains ("dog" with stemming) ftand "cat" 
return $b/author</eg>
               </p><p>The same example in XPath Full Text is written as:

		<eg role="xpath" xml:space="preserve">

/books/book[title ftcontains ("dog" with stemming) ftand "cat"]/author</eg>
               </p><p>In the next example a ComparisonExpr is combined with an FTContainsExpr 
using the logical XQuery operator <code>and</code>. The query
selects books that have a price of less than 50 and a title which contains 
a token with the same root as <code>train</code>:</p><eg role="xquery" xml:space="preserve">
/books/book[price &lt; 50 and title ftcontains ("train" with stemming)]
</eg><p>The following example shows the combination of two <code>ftcontains</code>
expressions the results of which are compared using the not-equals operator. 
The query
selects books where either the title contains the token
<code>dog</code> and the token <code>cat</code> and the content
does not contain a token with the same root as <code>train</code>, or where the
title fails to have one of the matching tokens but the content does:</p><eg role="xquery" xml:space="preserve">
/books/book[title ftcontains "dog" ftand "cat" ne
            content ftcontains ("train" with stemming)]
</eg></div3></div2><div2 id="section-score-variables"><head>Score Variables</head><p>Besides specifying a match of a full-text 
        query as a Boolean condition, full-text query applications
        typically also have the ability to associate scores with
        the results. <termdef id="Score" term="Score">The <term>score</term> of a full-text query result expresses its relevance to
        the search conditions.</termdef>
            </p><p>XQuery and XPath Full Text extends the languages of
        XQuery 1.0 and XPath 2.0 further  by adding optional 
        <code>score</code> variables to the <code>for</code> and
        <code>let</code> clauses of FLWOR expressions.</p><p>The production for the extended <code>for</code> clause in XQuery 1.0 follows.


<scrap headstyle="show"><head/><prod num="35" id="doc-xquery-ForClause"><lhs>ForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PositionalVar" xlink:type="simple">PositionalVar</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTScoreVar" xlink:type="simple">FTScoreVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PositionalVar" xlink:type="simple">PositionalVar</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTScoreVar" xlink:type="simple">FTScoreVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="37" id="doc-xquery-FTScoreVar"><lhs>FTScoreVar</lhs><rhs>"score"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>
                     </rhs></prod></scrap> 
            </p><p>In XPath 2.0, the SimpleForClause is extended similarly.</p><p>When a <code>score</code> variable is present in a <code>for</code> 
clause the evaluation of the expression following the <code>in</code>
keyword not only needs to determine the result sequence of the
expression, i.e., the sequence of items which are iteratively
bound to the <code>for</code> variable. It must also determine in each
iteration the relevance "score" value of the current item
and bind the <code>score</code> variable to that value. </p><p>
The scope of a score variable bound in a for or let clause comprises all
subexpressions of the containing FLWOR expression that appear after the
variable binding. The scope does not include the expression to which the
variable is bound.
The for and let clauses of a given FLWOR expression may bind the same score
variable name more than once. In this case, each new binding occludes the
previous one, which becomes inaccessible in the remainder of the FLWOR
expression. 
</p><p>
The expanded QName of a score variable bound in a for clause must be distinct
from both the expanded 
QName of the variable with which it is associated and the expanded QName of any
positional variable with which it is associated
<xerrorref spec="XQ" class="ST" code="0089" type="static"/>.
</p><p>The semantics of scoring and how it relates to second-order functions is 
discussed in Section <specref ref="ScoreSec"/>.</p><p>In the following example <code>book</code> elements are determined that satisfy
the condition <code>[content ftcontains "web site" ftand "usability" and
.//chapter/title ftcontains "testing"]</code>. The scores assigned to the
<code>book</code> elements are returned.

		<eg role="xquery" xml:space="preserve">
for $b score $s 
    in /books/book[content ftcontains "web site" ftand "usability" 
                   and .//chapter/title ftcontains "testing"]
return $s
</eg>
            </p><p>The example above is
also a legal example of the XPath 2.0 extension.</p><p>Scores are typically used to order results, as in the 
following, more complete example.
		<eg role="xquery" xml:space="preserve">
for $b score $s 
    in /books/book[content ftcontains "web site" ftand "usability"]
where $s &gt; 0.5
order by $s descending
return &lt;result&gt;  
          &lt;title&gt; {$b//title} &lt;/title&gt; 
          &lt;score&gt; {$s} &lt;/score&gt; 
       &lt;/result&gt;
</eg>
            </p><p>Note that the score variable gets <emph>one</emph> score value for each item
     in the value of the expression after the <code>in</code> keyword,
     regardless of the number of FTContainsExprs in that expression. In the following example, two separate full-text contains expressions are
used to select the matching paragraphs. There is still just one score for each
<code>para</code> returned.  The highest scoring paragraphs will be returned
first:
</p><eg role="xquery" xml:space="preserve">
for $p score $s in //book[title ftcontains "software"]/para[. ftcontains "usability"]
     order by $s descending
  return $p
</eg><p>The following more elaborate example uses multiple score variables to
return the matching paragraphs ordered so that those from the highest scoring
books precede those from the lowest scoring books, where the highest scoring
paragraphs of each book are returned before the lower scoring paragraphs of
that book:
</p><eg role="xquery" xml:space="preserve">
for $b score $score1 in //book[title ftcontains "software"]
    order by $score1 descending
return
    for $p score $score2 in $b/para[. ftcontains "usability"]
       order by $score2 descending
    return $p
</eg><p>The <code>score</code> variable is bound to a value which reflects
the relevance of the match criteria in the 
full-text selections to the items returned by the respective RangeExprs. The
calculation of relevance is <termref def="dt-implementation-dependent">implementation-dependent</termref>, but score
evaluation must follow these rules:</p><olist><item><p>Score values are of type <code>xs:double</code> in the range
[0, 1].</p></item><item><p>For score values greater than 0, a higher score must imply a
higher degree of relevance </p></item></olist><p>Similarly to their use in a <code>for</code> clause, score variables
may be specified in a <code>let</code> clause. A score variable in a
<code>let</code> clause is also bound to the score of the expression
evaluation, but in the <code>let</code> clause one score is determined
for the complete result. </p><p>The production for the extended <code>let</code> clause follows.


<scrap headstyle="show"><head/><prod num="38" id="doc-xquery-LetClause"><lhs>LetClause</lhs><rhs>(("let"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?)  |  ("let"  "score"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>))  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  (("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTScoreVar" xlink:type="simple">FTScoreVar</nt>)  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod></scrap> 
            </p><p>When using the score option in a <code>for</code> clause the
expression following the <code>in</code> keyword has the dual purpose
of filtering, i.e., driving the iteration, and determining the scores. 
It is possible to separately specify expressions for filtering and
scoring by combining a simple <code>for</code> clause with a
<code>let</code> clause that uses scoring. The following is 
an example of this.

		<eg role="xquery" xml:space="preserve">
for $b in /books/book[.//chapter/title ftcontains "testing"]
let score $s := $b/content ftcontains "web site" ftand "usability" 
order by $s descending
return &lt;result score="{$s}"&gt;{$b}&lt;/result&gt;
</eg>
This example returns <code>book</code> elements with chapter titles that contain "testing". Along with the <code>book</code> elements scores are returned. These scores, however, reflect whether the book content contains "web site" and "usability".</p><p>Note that it is not a requirement of the score of an 
FTContainsExpr to be 0, if the expression evaluates to false, nor to
be non-zero, if the expression evaluates to true.
Hence, in the example above it is not possible to infer the Boolean
value of the FTContainsExpr in the <code>let</code> clause from the
calculated score of a returned <code>result</code> element. For instance, an
implementation may want to assign a non-zero score to a book that
contained "web site", but not "usability", as this may be
considered more relevant than a book that does not contain "web site" or "usability".
</p><p>
The expression ExprSingle associated with the score variable is passed to
the scoring algorithm. The scoring
algorithm calculates the score value based on the passed expression
(not on the value returned by evaluating the expression). The set of expressions supported by the scoring algorithm is <termref def="dt-implementation-defined">implementation-defined</termref>. If an expression not supported by the scoring algorithm is passed to the scoring algorithm, the result is implementation-defined.
</p><p>The use of <code>score</code> variables introduces a second-order
aspect to the evaluation of expressions which cannot be emulated by
(first-order) XQuery functions. Consider the following replacement of
the clause <code>let score $s := FTContainsExpr</code>
            </p><eg xml:space="preserve">
let $s := score(FTContainsExpr)
</eg><p>where a function <code>score</code> is applied to some
FTContainsExpr. If the function <code>score</code> were first-order, it
would only be applied to the result of the evaluation of 
its argument, which is one of the Boolean constants <code>true</code>
or <code>false</code>. Hence, there would be at most two possible
values such a <code>score</code> function would be able to return and
no further differentiation would be possible. </p><div3 id="section-using-weights"><head>Using Weights Within a Scored FTContainsExpr</head><p>
                  <termdef id="WeightDeclarationsDef" term="WeightDeclarations">Scoring may be influenced by adding <term>weight declarations</term> to search tokens, phrases, and expressions.</termdef> Weight declarations are introduced syntactically in the FTPrimaryWithOptions
production, described in Section <specref ref="ftweight"/>.
</p><p>The weights assigned are not related to any absolute standard,
but typically have a relationship to other weights within the same FTContains expression.</p><p>The effect of weights on the resulting score is
<termref def="dt-implementation-dependent">implementation-dependent</termref>. However, scoring algorithms <termref def="must">MUST</termref> conform to 
these constraints:</p><olist><item><p>When no explicit weight is specified, the default weight is
1.0; and</p></item><item><p>
Weight declarations in an FTContainsExpr for which no scores are
evaluated are ignored. 
</p></item></olist><p>The following example illustrates how different weights can be used
for different search terms.
		<eg role="xquery" xml:space="preserve">
for $b in /books/book
let score $s := $b/content ftcontains ("web site" weight 0.5)
                                ftand ("usability" weight 2)
return &lt;result score="{$s}"&gt;{$b}&lt;/result&gt;
</eg>
               </p></div3></div2><div2 id="section-extensions-static-context"><head>Extensions to the Static Context</head><p>
The XQuery Static Context is extended with a component for each
full-text <termref def="dt-match-option-group">match option group</termref>.
The settings of these components can be changed
by using the following declaration syntax in the Prolog.
<scrap headstyle="show"><head/><prod num="6" id="doc-xquery-Prolog"><lhs>Prolog</lhs><rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DefaultNamespaceDecl" xlink:type="simple">DefaultNamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Setter" xlink:type="simple">Setter</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NamespaceDecl" xlink:type="simple">NamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Import" xlink:type="simple">Import</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTOptionDecl" xlink:type="simple">FTOptionDecl</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Separator" xlink:type="simple">Separator</nt>)*  ((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarDecl" xlink:type="simple">VarDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FunctionDecl" xlink:type="simple">FunctionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OptionDecl" xlink:type="simple">OptionDecl</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Separator" xlink:type="simple">Separator</nt>)*</rhs></prod><prod num="14" id="doc-xquery-FTOptionDecl"><lhs>FTOptionDecl</lhs><rhs>"declare"  "ft-option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMatchOptions" xlink:type="simple">FTMatchOptions</nt>
                     </rhs></prod></scrap>
Match options modify the match semantics of full-text
expressions. They are described in detail in  
Section <specref ref="ftmatchoptions"/>. When a match
option is specified explicitly in a full-text expression,
it overrides the setting of the respective component in the
static context.
</p></div2></div1><!-- web35706.mail.mud.yahoo.com uncompressed/chunked Sun Aug  5 16:53:44 PDT 2007 --><!-- web35713.mail.mud.yahoo.com compressed/chunked Thu Sep 13 09:00:24 PDT 2007 --><div1 id="ftselections"><head>Full-Text Selections</head><p>This section describes the
full-text selections which contain the full-text
operators in a <termref def="dt-ftcontains">full-text contains
expression</termref>  
(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt>), as 
well as the match options which modify the matching semantics of the 
full-text selections. In the following, the syntax for each type of
full-text selection is given together with an informal statement of
its meaning.</p><p>
            <termdef id="ftselection" term="full-text selection">A 
<term>full-text selection</term> specifies the conditions of a full-text search.
</termdef>
         </p><scrap headstyle="show"><head/><prod num="144" id="doc-xquery-FTSelection"><lhs>FTSelection</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTOr" xlink:type="simple">FTOr</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPosFilter" xlink:type="simple">FTPosFilter</nt>*</rhs></prod></scrap><p>As shown in the grammar, a full-text selection consists of search 
conditions possibly involving logical operators (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTOr" xlink:type="simple">FTOr</nt>), followed by an 
arbitrary number of positional filters (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPosFilter" xlink:type="simple">FTPosFilter</nt>).
</p><p>The syntax and semantics of the individual full-text selection
operators follow.</p><p>This XML document
is the source document for examples in this section. </p><eg xml:space="preserve">
&lt;books&gt;
  &lt;book number="1"&gt;
    &lt;title shortTitle="Improving Web Site Usability"&gt;Improving  
        the Usability of a Web Site Through Expert Reviews and
        Usability Testing&lt;/title&gt;
    &lt;author&gt;Millicent Marigold&lt;/author&gt;
    &lt;author&gt;Montana Marigold&lt;/author&gt;
    &lt;editor&gt;Véra Tudor-Medina&lt;/editor&gt;
    &lt;content&gt;
      &lt;p&gt;The usability of a Web site is how well the  
          site supports the users in achieving specified  
          goals. A Web site should facilitate learning,  
          and enable efficient and effective task  
          completion, while propagating few errors.
      &lt;/p&gt;
      &lt;note&gt;This book has been approved by the Web Site  
          Users Association.
      &lt;/note&gt;
    &lt;/content&gt;
  &lt;/book&gt;
&lt;/books&gt;
</eg><p>Tokenization is <termref def="dt-implementation-defined">implementation-defined</termref>. A sample tokenization is
used for the examples in this section. 
This sample tokenization uses white space, punctuation and XML tags as word-breakers and 
<code>&lt;p&gt;</code> for paragraph boundaries. The results may be different
for other tokenizations.</p><p>The first five tokens in this example using the sample tokenization would be "Improving", "the", "usability", "of", and "a".</p><p>Unless stated otherwise, the results
assume a case-insensitive match.</p><div2 id="ftprimary"><head>Primary Full-Text Selections</head><scrap headstyle="show"><head/><prod num="151" id="doc-xquery-FTPrimary"><lhs>FTPrimary</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTTimes" xlink:type="simple">FTTimes</nt>?)  |  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt>  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTExtensionSelection" xlink:type="simple">FTExtensionSelection</nt>
                  </rhs></prod></scrap><p>
               <termdef id="dt-ftprimary" term="primary full-text selection">A 
<term>primary full-text selection</term> is the basic form of a 
full-text selection. It specifies tokens and phrases as search 
conditions (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt>), optionally followed by a cardinality constraint 
(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTTimes" xlink:type="simple">FTTimes</nt>). An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt> 
in parentheses and the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTExtensionSelection" xlink:type="simple">FTExtensionSelection</nt>
are also a primary full-text selections.</termdef>
            </p><div3 id="ftweight"><head>Weights</head><scrap headstyle="show"><head/><prod num="150" id="noid_d4e1110.doc-xquery-FTPrimaryWithOptions"><lhs>FTPrimaryWithOptions</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPrimary" xlink:type="simple">FTPrimary</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMatchOptions" xlink:type="simple">FTMatchOptions</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWeight" xlink:type="simple">FTWeight</nt>?</rhs></prod><prod num="145" id="doc-xquery-FTWeight"><lhs>FTWeight</lhs><rhs>"weight"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RangeExpr" xlink:type="simple">RangeExpr</nt>
                     </rhs></prod></scrap><p>As shown in the grammar, a full-text primary selection
may be optionally followed by match options (which are discussed in
<specref ref="ftmatchoptions"/>) and
by a "weight" value that is specified using a range expression.
The RangeExpr is evaluated as if it were an argument to a function 
with an expected type <code>xs:double</code>.
The weight <termref def="must">MUST</termref> have an absolute value between 0.0 and 1000.0 inclusive.
If the absolute value of the weight is greater than 1000.0, an
error is raised: <errorref class="DY" code="0016"/>. 
</p></div3></div2><div2 id="ftwords"><head>Search Tokens and Phrases</head><scrap headstyle="show"><head/><prod num="152" id="doc-xquery-FTWords"><lhs>FTWords</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWordsValue" xlink:type="simple">FTWordsValue</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt>?</rhs></prod><prod num="153" id="doc-xquery-FTWordsValue"><lhs>FTWordsValue</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Literal" xlink:type="simple">Literal</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}")</rhs></prod><prod num="155" id="doc-xquery-FTAnyallOption"><lhs>FTAnyallOption</lhs><rhs>("any"  "word"?)  |  ("all"  "words"?)  |  "phrase"</rhs></prod></scrap><p>
               <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt> finds matches that contain the specified 
tokens and phrases.</p><p>FTWords consists of two parts: a mandatory <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWordsValue" xlink:type="simple">
FTWordsValue</nt> part and an optional <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">
FTAnyallOption</nt> part. <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWordsValue" xlink:type="simple">FTWordsValue</nt> specifies the tokens and phrases
that must be contained in the matches. <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt> specifies how 
containment is checked. </p><p>In general, the tokens and phrases in <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWordsValue" xlink:type="simple">
FTWordsValue</nt> are specified using a nested XQuery expression. 
To simplify notation, the enclosing braces may be omitted if <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWordsValue" xlink:type="simple">FTWordsValue</nt> consists of a single literal.
</p><p>The following rules specify how an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWordsValue" xlink:type="simple">FTWordsValue</nt>
matches tokens and phrases. First, the 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWordsValue" xlink:type="simple">FTWordsValue</nt> is converted to a sequence of
strings as though it were an argument to a function with the expected
type of <code>xs:string*</code>. Then, each of those strings is tokenized into a
sequence of tokens as 
described in <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#TokenizationSec" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Section 4.1 Tokenization</loc>.
Then, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt> is checked.</p><p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt> is "any", the sequence of tokens for each string is
considered as a phrase, i.e. a match is found in the tokenized form of 
the text being searched, whenever that form contains a subsequence of tokens
that 
corresponds to the sequence of query tokens in an implementation-defined
way and that subsequence of tokens covers consecutive token positions in 
the tokenized text. If the value of the FTWordsValue contains more 
than one string, 
the different strings are considered to be alternatives, i.e.  the resulting 
matches must contain at least one of the generated phrases.</p><p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt> is "all", the sequence of tokens for each string is
considered as a phrase. The resulting matches must contain all of the 
generated phrases.</p><p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt> is "phrase", the tokens from all the strings are
concatenated in a single sequence, which is considered as a phrase. The
resulting matches must contain the generated phrase.</p><p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt> is "any word", the tokens from all the strings are
combined into a single set. The resulting matches must contain at least
one of the tokens in the set.</p><p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt> is "all words", the tokens from all the strings are
combined into a single set. The resulting matches must contain all
of the tokens in the set.</p><p>If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWordsValue" xlink:type="simple">FTWordsValue</nt> evaluates to
a single string, the use of "any", "all", and "phrase" in
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt> produces the same
results.</p><p>If <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt> is omitted, "any" is 
the default.</p><p>The following expression returns the sample <code>book</code> element,
because its <code>title</code>
element contains the token "Expert":</p><eg role="xpath" xml:space="preserve">//book[./title ftcontains "Expert"]</eg><p>The following expression returns the sample <code>book</code> element,
because its <code>title</code>
element contains the phrase "Expert Reviews":</p><eg role="xpath" xml:space="preserve">//book[./title ftcontains "Expert Reviews"]</eg><p>The following expression returns the sample <code>book</code> element, 
because its <code>title</code> 
element contains the two tokens "Expert" and "Reviews":</p><eg role="xpath" xml:space="preserve">//book[./title ftcontains {"Expert", "Reviews"} all]</eg><p>The following expression returns false for our sample document, because 
the <code>p</code> element doesn't
contain the phrase "Web Site Usability" although it contains all of the tokens
in the phrase:</p><eg role="xpath" xml:space="preserve">//book//p ftcontains "Web Site Usability"</eg><p>The following expression returns book numbers of <code>book</code> elements by
"Marigold" with a title about "Web Site Usability", sorting them in descending
score order: </p><eg role="xquery" xml:space="preserve">for $book in /books/book[.//author ftcontains "Marigold"] 
let score $score := $book/title/@shortTitle ftcontains "Web Site Usability" 
where $score &gt; 0.8 
order by $score descending
return $book/@number</eg></div2><div2 id="fttimes"><head>Cardinality Selection</head><scrap headstyle="show"><head/><prod num="156" id="doc-xquery-FTTimes"><lhs>FTTimes</lhs><rhs>"occurs"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTRange" xlink:type="simple">FTRange</nt>  "times"</rhs></prod></scrap><p>
               <termdef id="dt-cardinality-selection" term="cardinality selection">A
<term>cardinality selection</term> consist of an 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt> followed
by the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTTimes" xlink:type="simple">FTTimes</nt> postfix operator.</termdef>
A cardinality selection selects matches for which the operand 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt> is matched a specified number of
times. </p><p>A cardinality selection limits the number of different
matches of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt> within the
specified range. The semantics of FTRange are described in 
<specref ref="ftdistance"/>. </p><p>In the document fragment "very very big":</p><olist><item><p>
The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt> 
                     <code>"very big"</code> has 1
match consisting of the second "very" and "big".
</p></item><item><p>
The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt> 
                     <code>{"very", "big"} all</code>
has 2 matches; one consisting of the first "very" and "big", and
the other containing the second "very" and "big".
</p></item><item><p>
The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt> 
                     <code>{"very", "big"} any</code> 
has 3 matches. 
</p></item></olist><p>The following expression returns the example <code>book</code> element's 
number, because the <code>book</code> element contains 2 or more occurrences 
of "usability":</p><eg role="xpath" xml:space="preserve">//book[. ftcontains "usability" occurs at least 2 times]/@number</eg><p>The following expression returns the empty sequence, because there are 
3 occurrences of <code>{"usability", "testing"} any</code> in the designated 
<code>title</code>:</p><eg role="xpath" xml:space="preserve">//book[@number="1" and title ftcontains {"usability", 
"testing"} any occurs at most 2 times] </eg></div2><div2 id="ftmatchoptions"><head>Match Options</head><p>Full-text match options modify the matching behaviour of 
the <termref def="dt-ftprimary">primary full-text selection</termref> to which 
they are applied. </p><scrap headstyle="show"><head/><prod num="150" id="doc-xquery-FTPrimaryWithOptions"><lhs>FTPrimaryWithOptions</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPrimary" xlink:type="simple">FTPrimary</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMatchOptions" xlink:type="simple">FTMatchOptions</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWeight" xlink:type="simple">FTWeight</nt>?</rhs></prod><prod num="166" id="doc-xquery-FTMatchOptions"><lhs>FTMatchOptions</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMatchOption" xlink:type="simple">FTMatchOption</nt>+</rhs></prod><prod num="167" id="doc-xquery-FTMatchOption"><lhs>FTMatchOption</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTLanguageOption" xlink:type="simple">FTLanguageOption</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWildCardOption" xlink:type="simple">FTWildCardOption</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTThesaurusOption" xlink:type="simple">FTThesaurusOption</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTStemOption" xlink:type="simple">FTStemOption</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTCaseOption" xlink:type="simple">FTCaseOption</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTDiacriticsOption" xlink:type="simple">FTDiacriticsOption</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTStopWordOption" xlink:type="simple">FTStopWordOption</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTExtensionOption" xlink:type="simple">FTExtensionOption</nt>
                  </rhs></prod></scrap><p>
               <termdef id="dt-match-options" term="match option">
                  <term>Match options</term>  modify the set of tokens
      in the query, or how they are matched against tokens in the
      text.</termdef> 
            </p><p>
               <termdef id="dt-match-option-group" term="match option group">
Each of the seven alternatives of production 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMatchOption" xlink:type="simple">FTMatchOption</nt>
corresponds to one <term>match option group</term>. </termdef>
The match options from any given group are mutually exclusive, i.e., 
only one of these settings can be in effect, whereas match options of
different groups can be combined freely.</p><p>
It is a static error
<errorref class="ST" code="0019"/> 
if, within a single <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMatchOptions" xlink:type="simple">FTMatchOptions</nt>,
there is more than one match option of any given 
<termref def="dt-match-option-group">match option group</termref>.
For example, if the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTCaseOption" xlink:type="simple">FTCaseOption</nt> "lowercase" 
is specified, then "uppercase" cannot also be specified as part of the same 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMatchOptions" xlink:type="simple">FTMatchOptions</nt>.
</p><p>Although match options only take effect in the application of 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt>, the syntax also allows to specify 
match options that modify the non-primitive full-text selection 
<code>"(" FTSelection ")"</code>. Such a higher-level match option
provides a default for the respective match option group for any
embedded <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPrimary" xlink:type="simple">FTPrimary</nt>, just as
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTOptionDecl" xlink:type="simple">match option declarations</nt>
in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Prolog" xlink:type="simple">Prolog</nt>
provide default match options for the whole query. 
</p><p>
Match options are propagated through the query via the static context.
For each of the seven match option groups,
the static context has a component
that contains one option from that group.
The seven settings are initialized by the implementation
in accordance with the table in 
Appendix <specref ref="id-xqft-static-context-components"/>,
and are modified
by any <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTOptionDecl" xlink:type="simple">FTOptionDecl</nt>s
in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Prolog" xlink:type="simple">Prolog</nt>.
The resulting settings are then propagated unchanged
to every <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt> in the module
(including those in <code>VarDecl</code>s and <code>FunctionDecl</code>s,
and including any that happen to be nested within
another <code>FTContainsExpr</code>).
At any given <code>FTContainsExpr</code>,
the settings from the static context
are copied to the <code>FTContainsExpr</code>'s inner settings,
which are then propagated down the syntax tree.
At each <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPrimaryWithOptions" xlink:type="simple">FTPrimaryWithOptions</nt>,
the locally specified match options (if any)
overwrite the corresponding inner setting(s).
At each <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt>,
the inner settings are used
as the effective match options
for tokenizing the query strings
and matching them against the tokens in the text.
(These inner settings could be seen
as a parallel set of components in the static context,
but Section <specref ref="tq-semantics"/> models them
as structures that get passed as parameters
to various semantic functions.)
</p><p>
Thus, when a match option appears in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt>,
it applies to the associated <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPrimary" xlink:type="simple">FTPrimary</nt>,
but not to any <code>FTContainsExpr</code>s
that happen to be embedded within that <code>FTPrimary</code>.
Instead, for a nested <code>FTContainsExpr</code>,
the default match options are those declared in the <code>Prolog</code>
or, if not declared in the <code>Prolog</code>,
then supplied by the implementation's initial values. 
</p><p>
An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMatchOption" xlink:type="simple">FTMatchOption</nt>
applies to the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPrimary" xlink:type="simple">FTPrimary</nt> that immediately precedes it.
That FTPrimary is either
an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt> (possibly qualified by an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTTimes" xlink:type="simple">FTTimes</nt>),
an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTExtensionSelection" xlink:type="simple">FTExtensionSelection</nt>, or
a parenthesized <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt>.
</p><p>
               <termdef id="dt-match-option-order" term="match option application order">
The order in which effective match options for an 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt> are applied 
 is called the <term>match option application order</term>.</termdef>
This order is significant
because match options are not always commutative.
For example,
    synonym(stem(word))
is not always the same as
    stem(synonym(word)).
</p><p>
The match option application order is subject to some constraints:
<olist><item><p>The Language Option must be applied first</p></item><item><p>The Stemming Option must be applied before the Case Option and the
Diacritics Option</p></item></olist>
Aside from these constraints, the full order of the application of match
options is <termref def="dt-implementation-defined">implementation-defined</termref>.
</p><p>
 More information on
their semantics is given in <specref ref="FTMatchOptionsSec"/>.</p><p>If no match options declarations are present in the prolog and the
implementation does not define any overwriting of the static context
components for the match options, the query:</p><eg role="xpath" xml:space="preserve">/books/book/title ftcontains "usability" </eg><p>is, assuming "de" is the <termref def="dt-implementation-defined">implementation-defined</termref> default language,
equivalent to the query:</p><eg role="xpath" xml:space="preserve">/books/book/title ftcontains "usability" 
    language "de"
    without wildcards
    without thesaurus
    without stemming
    case insensitive 
    diacritics insensitive 
    without stop words</eg><p> We describe each match option group in more detail in the following
sections.</p><div3 id="ftlanguageoption"><head>Language Option</head><scrap headstyle="show"><head/><prod num="176" id="doc-xquery-FTLanguageOption"><lhs>FTLanguageOption</lhs><rhs>"language"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>
                     </rhs></prod></scrap><p>
                  <termdef id="dt-ftlanguageoption" term="language option">A 
<term>language option</term> 
modifies token matching by specifying the language of search tokens and 
phrases.</termdef>
               </p><p>The StringLiteral following the keyword <code>language</code>
designates one language. It must be castable to <code>xs:language</code>; otherwise, an
error is raised: <xerrorref spec="XP" class="TY" code="0004" type="type"/>. </p><p>The "language" option influences tokenization, stemming, and stop
words in an <termref def="dt-implementation-defined">implementation-defined</termref> way. The "language" option <termref def="may">MAY</termref> influence the behavior of other match options in an <termref def="dt-implementation-defined">implementation-defined</termref> way.</p><p>The set of standardized language identifiers is defined in <bibref ref="BCP47"/>.
The set of valid language identifiers among the standardized set is <termref def="dt-implementation-defined">implementation-defined</termref>. 
An implementation <termref def="may">MAY</termref> choose to use private extensions introduced by a
singleton 'x' for additional language identifiers, or other singletons
for registered extensions as described in sec. 2.2.6 of <bibref ref="BCP47"/>.
It is <termref def="dt-implementation-defined">implementation-defined</termref> what additional language identifiers, if any, are valid. 
If an invalid language identifier is specified, then the behavior is <termref def="dt-implementation-defined">implementation-defined</termref>. 
If the implementation chooses to raise an error in that case,
it must raise <errorref class="ST" code="0009"/>.
</p><p>The default language is specified in the static context. </p><!-- 2007-01-19 Jim: make effect of conflicting languages implementation-defined --><p>When an XQuery and XPath Full Text processor evaluates text in a document
that is governed by an xml:lang attribute and
the portion of the full-text query doing that evaluation contains an FTLanguageOption that
specifies a different language from the language specified by the governing xml:lang attribute,
the language-related behavior of that full-text query is <termref def="dt-implementation-defined">implementation-defined</termref>. </p><p>This is an example where
the language option is used to select the appropriate stop word list: </p><eg role="xpath" xml:space="preserve">//book[@number="1"]content//p ftcontains "salon de thé"
with default stop words language "fr"</eg></div3><div3 id="ftwildcardoption"><head>Wildcard Option</head><scrap headstyle="show"><head/><prod num="177" id="doc-xquery-FTWildCardOption"><lhs>FTWildCardOption</lhs><rhs>("with"  "wildcards")  |  ("without"  "wildcards")</rhs></prod></scrap><p>
                  <termdef id="dt-ftwildcardoption" term="wildcard option">A 
<term>wildcard option</term>
modifies token and phrase matching by specifying whether wildcards are used 
or not.</termdef>
               </p><p>When the "with wildcards" option is used, wildcard indicators
(represented by periods (.)) and qualifiers may be appended to or
inserted into the query tokens. 
If the period is at the beginning of a query token, the wildcard is a prefix
wildcard. If the period is at the end of a query token, it is a suffix
wildcard. If the period is inserted into a query token, it is an infix
wildcard. 
</p><p>
Each indicator and qualifier in a query token
will match zero or more characters within a token in the text being searched,
as described 
below. 
The number of characters matched depends on the qualifier. 
Qualifiers available are none, question mark, asterisk,
plus sign, and two numbers separated by a comma,
both enclosed by curly braces. </p><olist><item><p>If a period is present, but there are no qualifiers, one character in the
text will match.
</p></item><item><p>If a period is followed by a question mark (.?), zero or one
characters in the text being searched will match. </p></item><item><p>If a period is followed by an asterisk (.*), zero or more
characters will match.</p></item><item><p>If a period is followed by a plus sign (.+), one or more characters
will match. </p></item><item><p>If a period is followed by two numbers separated by a comma, both
enclosed by curly braces (.{n,m}), a specified range of characters
(at least n characters and no more than m characters)
will match.</p></item></olist><p>When "with wildcards" is present and an indicator or qualifier character 
is intended to be taken literally (as itself), that character must be
preceded by ("escaped by") a backslash (\). 
For example, a period (.) that is intended to be a sentence terminator or
a decimal point must be preceded by a backslash so that it is not
interpreted to be an indicator. 
Similarly a question mark (?), asterisk (*), or plus sign (+) that is
intended to be interpreted as an ordinary text character must be preceded by
a backslash so that it is not interpreted to be an indicator. </p><p>The "without wildcards" option finds tokens without recognizing
wildcard indicators and qualifiers. 
Periods, question marks, asterisks, plus signs, and two numbers
separated by a comma, both enclosed by curly braces,
are always recognized as ordinary text characters.</p><p>The default is "without wildcards".</p><p>
Note: Wildcard indicators and qualifiers may be token boundaries. How text with
wildcard indicators and qualifiers is tokenized is implementation-defined.
</p><p>The expression returns true, because the <code>title</code> element
contains "improving":</p><eg role="xpath" xml:space="preserve">//book[@number="1"]/title ftcontains "improv.*" with wildcards</eg><p>The following expression returns true, because the <code>title</code> element
contains "site":</p><eg role="xpath" xml:space="preserve">//book[@number="1"]/title ftcontains ".?site" with wildcards</eg><p>The following expression returns true, because the <code>p</code> element
contains "well":</p><eg role="xpath" xml:space="preserve">//book[@number="1"]/p ftcontains "w.ll" with wildcards</eg><p>The following expression returns false, because the <code>p</code> element
does not contain the phrase "w ll":</p><eg role="xpath" xml:space="preserve">//book[@number="1"]/p ftcontains "w.ll" without wildcards</eg><p>
(Note that, without wildcards, the sample tokenization
will treat the period in "w.ll" as punctuation,
thus producing "w" and "ll" as separate tokens.)
</p></div3><div3 id="ftthesaurusoption"><head>Thesaurus Option</head><scrap headstyle="show"><head/><prod num="171" id="doc-xquery-FTThesaurusOption"><lhs>FTThesaurusOption</lhs><rhs>("with"  "thesaurus"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTThesaurusID" xlink:type="simple">FTThesaurusID</nt>  |  "default"))<br/>|  ("with"  "thesaurus"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTThesaurusID" xlink:type="simple">FTThesaurusID</nt>  |  "default")  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTThesaurusID" xlink:type="simple">FTThesaurusID</nt>)*  ")")<br/>|  ("without"  "thesaurus")</rhs></prod><prod num="172" id="doc-xquery-FTThesaurusID"><lhs>FTThesaurusID</lhs><rhs>"at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  ("relationship"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTRange" xlink:type="simple">FTRange</nt>  "levels")?</rhs></prod><prod num="143" id="doc-xquery-URILiteral"><lhs>URILiteral</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>
                     </rhs></prod></scrap><p>
                  <termdef id="dt-ftthesaurusoption" term="thesaurus option">A 
<term>thesaurus option</term>
modifies token and phrase matching by specifying whether a thesaurus is used or
not.</termdef>
 If thesauri are used, the thesaurus option specifies information to locate 
the thesauri either by default or through a URI
reference. It also states the relationship to be applied and how many
levels within the thesaurus to be traversed.</p><p>Thesauri add related tokens and phrases to the query or change query tokens.  
Thus, the
user may narrow, broaden, or otherwise modify the query using
synonyms, hypernyms (more generic terms), etc. The search is performed
as though the user has specified all related query tokens and phrases
in a disjunction (FTOr). </p><note><p>A thesaurus may be standards-based or locally-defined. It may be a
traditional thesaurus, or a taxonomy, soundex, ontology, or topic
map. How the thesaurus is represented is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p></note><p>FTThesaurusID specifies the relationship sought between tokens and
phrases written in the query and terms in the thesaurus and the number
of levels to be queried in hierarchical relationships by including an
FTRange "levels". If no levels are specified, the default is to query
all levels in hierarchical relationships.</p><p>Relationships include, but are not limited to, the relationships
and their abbreviations presented in <bibref ref="iso-2788"/> and
their equivalents in other languages. The set of relationships supported by an
implementation is <termref def="dt-implementation-defined">implementation-defined</termref>, but
implementations <termref def="should">SHOULD</termref> support the relationships
defined in <bibref ref="iso-2788"/>. The following list of terms have the
meanings 
defined in <bibref ref="iso-2788"/>. If a query specifies thesaurus
relationships or levels not supported by the thesaurus, or does not specify a
relationship, 
the behavior is <termref def="dt-implementation-defined">implementation-defined</termref>.
</p><olist><item><p> 
                        <emph>equivalence relationships (synonyms):</emph> PREFERRED TERM (USE), 
NONPREFERRED USED FOR TERM (UF);</p></item><item><p> 
                        <emph>hierarchical relationships:</emph> BROADER TERM (BT), 
NARROWER TERM (NT),  BROADER TERM GENERIC (BTG), NARROWER TERM GENERIC (NTG), 
BROADER TERM PARTITIVE (BTP), NARROWER TERM PARTITIVE (NTP), 
TOP Terms (TT); and</p></item><item><p> 
                        <emph>associative relationships:</emph> RELATED TERM (RT).</p></item></olist><p>The "with thesaurus" option specifies that string matches include
tokens that can be found in one of the specified thesauri.
When "default" is used in place of a FTThesaurusID, the thesauri
specified in the static context are used, which are either given by the 
prolog declaration for the thesaurus option, or, if no such
declaration exists a system-defined default thesaurus with a 
system-defined relationship. The
default thesaurus may be used in combination with other explicitly
specified thesauri.</p><p>The "without thesaurus" option specifies that no thesaurus will be
used. </p><p>The default is "without thesaurus". </p><p>The following expression returns true, because it finds a <code>content</code>
element containing "tasks" which the thesaurus identified as a synonym for
"duties":</p><eg role="xpath" xml:space="preserve">.//book/content ftcontains "duties" with
thesaurus at "http://bstore1.example.com/UsabilityThesaurus.xml"
relationship "UF"</eg><p>The following expression returns <code>book</code> elements, because it finds a
<code>content</code> element containing "web site components", and
narrower terms "navigation" and "layout":</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[./content ftcontains "web site components" with
thesaurus at "http://bstore1.example.com/UsabilityThesaurus.xml"
relationship "NT" at most 2 levels]</eg><p>Assuming the thesaurus available at URL 
"http://bstore1.example.com/UsabilitySoundex.xml" 
contains soundex capabilities, the following query
returns a <code>book</code> element containing "Marigold" which
sounds like "Merrygould":</p><eg role="xpath" xml:space="preserve">doc("http://bstore1.example.com/full-text.xml")
/books/book[. ftcontains "Merrygould" with thesaurus at
"http://bstore1.example.com/UsabilitySoundex.xml" relationship
"sounds like"]</eg><!--
<p>The following expression returns the true if "Synonyms" is a thesaurus for synonyms 
in the English language:</p>
<eg role="xpath">/books/book[@number="1"]//p ftcontains "buttress" with
thesaurus "Synonyms"</eg>
--></div3><div3 id="ftstemoption"><head>Stemming Option</head><scrap headstyle="show"><head/><prod num="170" id="doc-xquery-FTStemOption"><lhs>FTStemOption</lhs><rhs>("with"  "stemming")  |  ("without"  "stemming")</rhs></prod></scrap><p>
                  <termdef id="dt-ftstemoption" term="stemming option">A <term>stemming option</term>
modifies token and
phrase matching by specifying whether stemming is applied or not.
</termdef>
               </p><p>The "with stemming" option specifies that matches may contain tokens
that have the same stem as the tokens and phrases written in the
query. It is <termref def="dt-implementation-defined">implementation-defined</termref> what a stem of a token is. </p><p>The "without stemming" option specifies that the tokens and
phrases are not stemmed. </p><p>It is <termref def="dt-implementation-defined">implementation-defined</termref> whether the stemming is based on an
algorithm, dictionary, or mixed approach. </p><p>The default is "without stemming". </p><p>The following expression returns true, because the <code>title</code> of the specified
<code>book</code> contains "improving" which has the same stem as
"improve":</p><eg role="xpath" xml:space="preserve">/books/book[@number="1"]/title ftcontains "improve" with stemming </eg></div3><div3 id="ftcaseoption"><head>Case Option</head><scrap headstyle="show"><head/><prod num="168" id="doc-xquery-FTCaseOption"><lhs>FTCaseOption</lhs><rhs>("case"  "insensitive")<br/>|  ("case"  "sensitive")<br/>|  "lowercase"<br/>|  "uppercase"</rhs></prod></scrap><p>
                  <termdef id="dt-ftcaseoption" term="case option">A <term>case option</term>
modifies the matching of tokens and phrases by specifying how uppercase and 
lowercase characters are considered.</termdef>
               </p><p>There are four possible character case options:</p><olist><item><p> Using the option "case insensitive", tokens and phrases are matched,
regardless of the case of characters of the query tokens and phrases.</p></item><item><p> Using the option "case sensitive", tokens and phrases are matched,
if and only if the case of their characters is the same as written in the
query.</p></item><item><p> Using the option "lowercase", tokens and phrases are matched, if
and only if they match the query without regard to character case, but contain 
only lowercase characters.</p></item><item><p> Using the option "uppercase", tokens and phrases are matched, if
and only if they match the query without regard to character case, but contain 
only uppercase characters.</p></item></olist><p>The default is "case insensitive". </p><p>The effect of the case options is also influenced by the query's 
default collation 
(see <xspecref spec="XQ" ref="static_context"/> and
 <xspecref spec="XQ" ref="id-default-collation-declaration"/>).
The following table summarizes how these interact.</p><p>
                  <table border="1" summary="Case Matrix"><caption>Case Matrix</caption><thead><tr><th rowspan="1" colspan="1">Case option \ Default collation</th><th rowspan="1" colspan="1">UCC (Unicode Codepoint Collation)</th><th rowspan="1" colspan="1">CCS (some generic case-sensitive collation)</th><th rowspan="1" colspan="1">CCI (some generic case-insensitive collation) </th></tr></thead><tbody><tr><th rowspan="1" colspan="1">case insensitive</th><td rowspan="1" colspan="1">compare as if both lower</td><td rowspan="1" colspan="1">case-insensitive variant of CCS if it exists, else error</td><td rowspan="1" colspan="1">CCI</td></tr><tr><th rowspan="1" colspan="1">case sensitive</th><td rowspan="1" colspan="1">UCC</td><td rowspan="1" colspan="1">CCS</td><td rowspan="1" colspan="1">case-sensitive variant of CCI if it exists, else error</td></tr><tr><th rowspan="1" colspan="1">lowercase</th><td rowspan="1" colspan="1">compare using UCC after applying fn:lower-case() to the query 
           string
        </td><td rowspan="1" colspan="1">compare using CCS after applying fn:lower-case() to the query 
           string</td><td rowspan="1" colspan="1">CCI</td></tr><tr><th rowspan="1" colspan="1">uppercase</th><td rowspan="1" colspan="1">compare using UCC after applying fn:upper-case() to the query 
           string</td><td rowspan="1" colspan="1">compare using CCS after applying fn:upper-case() to the query 
           string</td><td rowspan="1" colspan="1">CCI</td></tr></tbody></table>
               </p><note><p>In this table, "else error" means "Otherwise, an error
is raised: <xerrorref spec="FO" class="CH" code="0002" type="dynamic"/>". 
The phrase "if it exists" is used, because
the case-sensitive collation CCS does not always have a
case-insensitive variant (and, even if one exists, it may not be
possible to determine it algorithmically), and because the
case-insensitive collation CCI does not always have a case-sensitive
variant (and, even if one exists, it may not be possible to determine
it algorithmically).</p></note><p>The following expression returns false, because the <code>title</code> element
doesn't contain "usability" in lower-case characters:</p><eg role="xpath" xml:space="preserve">//book[@number="1"]/title ftcontains "Usability" lowercase </eg><p>The following expression returns true, because the character case is not
considered:</p><eg role="xpath" xml:space="preserve">//book[@number="1"]/title ftcontains "usability" case insensitive</eg></div3><div3 id="ftdiacriticsoption"><head>Diacritics Option</head><scrap headstyle="show"><head/><prod num="169" id="doc-xquery-FTDiacriticsOption"><lhs>FTDiacriticsOption</lhs><rhs>("diacritics"  "insensitive")<br/>|  ("diacritics"  "sensitive")</rhs></prod></scrap><p>
                  <termdef id="dt-ftdiacriticsoption" term="diacritics option">A 
<term>diacritics option</term>
modifies token and phrase matching by specifying how diacritics are considered.
</termdef>
               </p><p>There are two possible diacritics options:</p><olist><item><p>The option "diacritics" "insensitive" matches tokens and
phrases with and without diacritics. Whether diacritics are written in
the query or not is not considered.</p></item><item><p>The option "diacritics" "sensitive" matches tokens and phrases only
if they contain the diacritics as they are written in the query.</p></item></olist><p>The default is "diacritics insensitive". </p><p>The effect of the diacritics options is also influenced by the query's 
default collation 
(see <xspecref spec="XQ" ref="static_context"/> and
 <xspecref spec="XQ" ref="id-default-collation-declaration"/>).
The following table summarizes how these interact.</p><p>
                  <table border="1" summary="Diacritics Matrix"><caption>Diacritics Matrix</caption><thead><tr><th rowspan="1" colspan="1">Diacritics option \ Default collation</th><th rowspan="1" colspan="1">UCC (Unicode Codepoint Collation)</th><th rowspan="1" colspan="1">CDS (some generic diacritics-sensitive collation)</th><th rowspan="1" colspan="1">CDI (some generic diacritics-insensitive collation) </th></tr></thead><tbody><tr><th rowspan="1" colspan="1">diacritics insensitive</th><td rowspan="1" colspan="1">UCC comparison, but without considering diacritics</td><td rowspan="1" colspan="1">diacritics-insensitive variant of CDS
                                  if it exists, else error</td><td rowspan="1" colspan="1">CDI</td></tr><tr><th rowspan="1" colspan="1">diacritics sensitive</th><td rowspan="1" colspan="1">UCC</td><td rowspan="1" colspan="1">CDS</td><td rowspan="1" colspan="1">diacritics-sensitive variant of CDI if it exists, else error</td></tr></tbody></table>
               </p><note><p>In this table, "else error" means "Otherwise, an error
is raised: <xerrorref spec="FO" class="CH" code="0002" type="dynamic"/>". 
The phrase "if it exists" is used, because
the diacritics-sensitive collation CDS does not always have a
diacritics-insensitive variant (and, even if one exists, it may not be
possible to determine it algorithmically), and because the
diacritics-insensitive collation CDI does not always have a
diacritics-sensitive variant (and, even if one exists, it may not be
possible to determine it algorithmically).</p></note><p>The following expression returns true, because the token "Véra" in the
<code>editor</code> element is matched, as the acute accent is not 
considered in the comparison:</p><eg role="xpath" xml:space="preserve">//book[@number="1"]//editor ftcontains "Vera" diacritics insensitive</eg><p>This returns false, because the <code>editor</code> element does not
contain the token "Vera" in this exact form, i.e. without any diacritics:</p><eg role="xpath" xml:space="preserve">//book[@number="1"]/editors ftcontains "Vera" diacritics sensitive</eg></div3><!--<div3 id="ftspecialcharoption">
	<head>FTSpecialCharOption</head>

<scrap><head></head>
			<prodrecap ref="FTSpecialcharOption"/>
</scrap>

<p><nt def="FTSpecialCharOption">FTSpecialCharOption</nt>
specifies whether special characters such as punctuation should or
should not be ignored. </p>

<p>Influences the way <nt def="FTWords">FTWords</nt> is
applied. </p>

<p>The option "with special characters" specifies that special
characters such as punctuation must also be matched. The option
"without special characters" specifies that special characters such as
punctuation need not be matched.
</p>

<p>The default is "without special characters". </p>


<eg role="xpath">//book[@number="1"]//editor ftcontains "Tudor Medina" with 
special characters </eg> 

<p>returns true.</p>

<eg role="xpath">//book[@number="1"]/editors ftcontains "Tudor-Medina" without
special characters </eg> 

<p>returns false.</p>


</div3>
--><div3 id="ftstopwordoption"><head>Stop Word Option</head><scrap headstyle="show"><head/><prod num="173" id="doc-xquery-FTStopWordOption"><lhs>FTStopWordOption</lhs><rhs>("with"  "stop"  "words"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTStopWords" xlink:type="simple">FTStopWords</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTStopWordsInclExcl" xlink:type="simple">FTStopWordsInclExcl</nt>*)<br/>|  ("without"  "stop"  "words")<br/>|  ("with"  "default"  "stop"  "words"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTStopWordsInclExcl" xlink:type="simple">FTStopWordsInclExcl</nt>*)</rhs></prod><prod num="174" id="doc-xquery-FTStopWords"><lhs>FTStopWords</lhs><rhs>("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)<br/>|  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)*  ")")</rhs></prod><prod num="175" id="doc-xquery-FTStopWordsInclExcl"><lhs>FTStopWordsInclExcl</lhs><rhs>("union"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTStopWords" xlink:type="simple">FTStopWords</nt>
                     </rhs></prod></scrap><p>
                  <termdef id="dt-ftstopwordoption" term="stop word option">A 
<term>stop word option</term>
controls matching of FTWords by specifying whether stop words are used or not. 
Stop words are tokens in the query that match any token in the text being
searched. 
</termdef>
Normally a stop word matches 
exactly one token, but there may be <termref def="dt-implementation-defined">implementation-defined</termref> conditions, under
which a stop word may match a different number of tokens.</p><p>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTStopWords" xlink:type="simple">FTStopWords</nt> specifies the list
of stop words either explicitly as a comma-separated list of string
literals, or by the keyword <code>at</code> followed by a literal URI.
If the URI specifies a list of stop words that is not found in the statically
known stop word lists, an error is raised <errorref class="ST" code="0008"/>. 
Whether the stop word
list is resolved from the statically known stop word lists or given explicitly,
no tokenization is performed on the stop words: they are used as they occur  
in the list.
</p><p>The "with stop words" option specifies that if a token is within the
specified collection of stop words, it is removed from the search and
any token may be substituted for it. Stop words retain their position
numbers and are counted in <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTDistance" xlink:type="simple">FTDistance</nt>
and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWindow" xlink:type="simple">FTWindow</nt> searches.</p><p>Multiple stop word lists may be combined using "union" or "except".
The keywords "union" and "except" are applied from left to right. If "union" is specified, every string occurring in the lists  
specified by the left-hand side or the right-hand side is a stop 
word. If "except" is specified, only strings occurring in the list  
specified by the left-hand side but not in the list specified
by the right-hand side are stop words. </p><p>The "with default stop words" option specifies that an
<termref def="dt-implementation-defined">implementation-defined</termref> collection of stop words is used. </p><p>The "without stop words" option specifies that no stop words are
used. This is equivalent to specifying an empty list of stop
words.</p><p>The default is "without stop words". </p><note><p>
Some implementations may apply stop word lists during indexing and be
unable to comply with query-time requests to not apply those stop words. An
implementation may still support stop-word options (and therefore not raise
<errorref class="ST" code="0006"/>)
by applying any additional stop words specified in the query.
Pre-application of irrevocable stop word lists falls under
implementation-defined tokenization behavior in this case, and a query that
specifies "without stop words" may still have some words ignored.
</p></note><p>The following expression returns true, because the document contains the phrase
"propagating few errors":</p><eg role="xpath" xml:space="preserve">/books/book[@number="1"]//p ftcontains "propagation of errors"
with stemming with stop words ("a", "the", "of") </eg><p>Note the asymmetry in the stop word semantics: the property of
being a stop word is only relevant to query terms, not to document
terms. Hence, it is irrelevant for the above-mentioned match whether
"few" is a stop word or not, and on the other hand we do not want the
query above to match "propagation" followed by 2 stop words, or even a
sequence of 3 stop words in the document.</p><p>The following expression returns false. In this case specifying "few" as 
a stop word has no effect, since "few" does not appear in the query.
Although the words "propagating" and "errors" appear in the text being
searched, the phrase  
"propagating errors" cannot be matched, since that phrase does not occur.</p><eg role="xpath" xml:space="preserve">/books/book[@number="1"]//p ftcontains "propagating errors" 
with stop words ("few")</eg><p>The following expression returns false, because "of" is not in the <code>p</code>
element between "propagating" and "errors":</p><eg role="xpath" xml:space="preserve">/books/book[@number="1"]//p ftcontains "propagation of errors" 
with stemming without stop words</eg><p>The following expression uses the stop words list specified at the
URL. Assuming that the specified stop word list contains the word
"then", this query
is reduced to a query on the phrase "planning X conducting", allowing any
token as a substitute for X.  It returns a <code>book</code> element,
because its <code>content</code> element contains "planning then
conducting". It would also return the <code>book</code> if the
phrases "planning and conducting" and "planning before conducting"
had been in its <code>content</code>:</p><eg role="xpath" xml:space="preserve">
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//content ftcontains "planning then 
conducting" with stop words at 
"http://bstore1.example.com/StopWordList.xml"]
</eg><p>The following expression returns <code>book</code>s containing "planning then
conducting", but not does not return <code>book</code>s containing "planning
and conducting", since it is exempting "then" from being a stop word: </p><eg role="xpath" xml:space="preserve">
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//content ftcontains "planning then conducting"
with stop words at "http://bstore1.example.com/StopWordList.xml"
except ("the", "then")]
</eg></div3><div3 id="ftextensionoption"><head>Extension Option</head><p>
                  <termdef id="dt-ftextensionoption" term="extension option">An
<term>extension option</term> is a match option that acts in an
<termref def="dt-implementation-defined">implementation-defined</termref> way.
</termdef>
               </p><scrap headstyle="show"><head/><prod num="178" id="doc-xquery-FTExtensionOption"><lhs>FTExtensionOption</lhs><rhs>"option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>
                     </rhs></prod></scrap><p>An extension option consists of an identifying QName and a StringLiteral.
Typically, a particular option will be recognized by some implementations and
not by others. The syntax is designed so that option declarations can be
successfully parsed by all implementations.
</p><p>The QName of an extension option must resolve to a namespace URI
and local name, using 
the statically known namespaces.</p><note><p>There is no default namespace for options.</p></note><p>Each implementation recognizes an 
<termref def="dt-implementation-defined">implementation-defined</termref>
set of namespace
URIs used to denote extension options.</p><p>If the namespace part of the QName is not a namespace recognized by the
implementation as one used to denote extension option, then the extension option
is ignored.</p><p>Otherwise, the effect of the extension option, including its error behavior,
is <termref def="dt-implementation-defined">implementation-defined</termref>.
For example, if the local part of the QName is
not recognized, or if the StringLiteral does not conform to the rules
defined by the implementation for the particular extension option, the implementation may choose
whether to report an error, ignore the extension option, or take some
other action.</p><p>Implementations may impose rules on where particular extension options may
appear relative to other match options, and the
interpretation of an option declaration may depend on its position.</p><p>An extension option must not be used to change the syntax accepted by the
processor, or to suppress the detection of static errors. However, it may be
used without restriction to modify the set of tokens in the query or how they
are matched against tokens in the text being searched. 
An extension option has the same scope as other match options.
</p><p>The following examples illustrate several possible uses for extension
options:</p><p>This extension option is set as part of the static context of all 
full-text expressions in the module and might be used to ensure that 
queries are insensitive to Arabic short-vowels.
</p><eg role="parse-test" xml:space="preserve">
declare namespace exq = "http://example.org/XQueryImplementation";

declare ft-option option exq:diacritics "short-vowel insensitive"
</eg><p>This extension option applies only to the matching in the full-text
selection in which it is found and might be used to specify how compound words
should be matched.
</p><eg role="parse-test" xml:space="preserve">
declare namespace exq = "http://example.org/XQueryImplementation";

//para[. ftcontains
         ("Kinder" ftand "Platz" distance exactly 1 words)
         with stemming
	 option exq:compounds "distance=1" ]
</eg></div3></div2><div2 id="logical_ftoperators"><head>Logical Full-Text Operators</head><p>
Full-text selections can be combined with the logical connectives
<code>ftor</code> (full-text or), <code>ftand</code> (full-text and), <code>not in</code> (mild not),
and <code>ftnot</code> (unary full-text not).</p><scrap headstyle="show"><head/><prod num="146" id="doc-xquery-FTOr"><lhs>FTOr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnd" xlink:type="simple">FTAnd</nt> ( "ftor"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnd" xlink:type="simple">FTAnd</nt> )*</rhs></prod><prod num="147" id="doc-xquery-FTAnd"><lhs>FTAnd</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMildNot" xlink:type="simple">FTMildNot</nt> ( "ftand"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMildNot" xlink:type="simple">FTMildNot</nt> )*</rhs></prod><prod num="148" id="doc-xquery-FTMildNot"><lhs>FTMildNot</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnaryNot" xlink:type="simple">FTUnaryNot</nt> ( "not"  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnaryNot" xlink:type="simple">FTUnaryNot</nt> )*</rhs></prod><prod num="149" id="doc-xquery-FTUnaryNot"><lhs>FTUnaryNot</lhs><rhs>("ftnot")? <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPrimaryWithOptions" xlink:type="simple">FTPrimaryWithOptions</nt>
                  </rhs></prod></scrap><div3 id="sec-ftor"><head>Or-Selection</head><p>
                  <termdef id="dt-or-selection" term="or-selection">An
<term>or-selection</term> combines two full-text selections using the 
<code>ftor</code> operator.</termdef>
               </p><p>An or-selection finds all matches that satisfy at least
one of the operand full-text selections. </p><p>The following expression returns the <code>book</code> element written by
"Millicent":</p><eg role="xpath" xml:space="preserve">//book[.//author ftcontains "Millicent" ftor "Voltaire"]</eg></div3><div3 id="sec-ftand"><head>And-Selection</head><p>
                  <termdef id="dt-and-selection" term="and-selection">An
<term>and-selection</term> combines two full-text selections using the 
<code>ftand</code> operator.</termdef>
               </p><p>An and-selection finds matches that satisfy all of the operand full-text 
selections simultaneously. A match of an and-selection is formed by combining
matches for each of the operand full-text selections as described in
<specref ref="tq-ft-fs-FTAnd"/>. </p><p>For example, <code>"usability" ftand "testing"</code> will find two 
matches
in <code>//book[@number="1"]/title</code>: each of the two matches for the
FTWords selection <code>"usability"</code> (the two occurrences of 
 "usability" in the string value of the title element) is combined 
with the single match for the FTWords <code>"testing"</code> (only one 
occurrence of "testing" in the title).
Since the above and-selection has at least one match, the following
expression will return "true". </p><eg role="xpath" xml:space="preserve">//book[@number="1"]/title ftcontains ("usability" ftand "testing")</eg><p>The following expression returns false, because "Millicent" and "Montana" are not
contained by the same <code>author</code> element in any <code>book</code>
element:</p><eg role="xpath" xml:space="preserve">//book/author ftcontains "Millicent" ftand "Montana"</eg><p>No <code>author</code> element in any <code>book</code> element 
contains both "Millicent" and "Montana". Therefore, for any such 
<code>author</code> element, there are either one match for the 
FTWords <code>"Millicent"</code> and zero matches for the FTWords 
<code>"Montana"</code>, or vice versa, or no matches for both
of them. In any of these cases, the and-selection will have zero 
matches.</p></div3><div3 id="sec-ftmildnot"><head>Mild-Not Selection</head><p>
                  <termdef id="dt-mild-not-selection" term="mild-not selection">A
<term>mild-not selection</term> combines two full-text selections 
using the <code>not in</code> operator.</termdef>
               </p><p>The <code>not in</code> operator is a milder form of the operator combination
<code>ftand ftnot</code>. The selection <code>A not in B</code> matches a token
sequence that matches <code>A</code>, but not when it is a part of a 
match of <code>B</code>. 
In contrast, <code>A ftand ftnot B</code> only finds matches when the token 
sequence contains <code>A</code> and does not contain <code>B</code>.</p><p>
As an example, consider a search for <code>"Mexico" not in "New Mexico"</code>.
This may return, among others, a document
which is all about "Mexico" but mentions at the end that "New Mexico
was named after Mexico". The occurrence of "Mexico" in "New Mexico" is not 
considered, but other occurrences of "Mexico" are matched. Note that this
document would not be matched by the full-text selection 
<code>"Mexico" ftand ftnot "New Mexico"</code>.</p><p> A match to a mild-not selection must
contain at least one token that satisfies the first
condition and does not satisfy the second condition. If it contains a
token that satisfies both the first and the second
condition, the token is not considered as a match.</p><p>The following expression returns true, because "usability" appears in the
<code>title</code> and the <code>p</code> elements and the token within
the phrase "Usability Testing" in the <code>title</code> element is not
considered:</p><eg role="xpath" xml:space="preserve">/books/book ftcontains "usability" not in "usability testing"</eg><p>Operands of a mild-not selection may not contain a full-text selection
that evaluates to an <term>AllMatches</term> that contains a <term>StringExclude</term>. Such 
full-text selections are not-selection and 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWords" xlink:type="simple">FTWords</nt> with a cardinality constraint using <code>at most</code>,
<code>from ... to</code>, and <code>exactly</code> occurrences ranges. 
If such an expression is encountered, an error <errorref class="DY" code="0017"/>
is raised.
</p></div3><div3 id="sec-ftnot"><head>Not-Selection</head><p>
                  <termdef id="dt-unary-not-selection" term="not-selection">A
<term>not-selection</term> is a full-text selection starting with the prefix 
operator <code>ftnot</code>.</termdef>
               </p><p>A not-selection selects matches that do not
satisfy the operand full-text selection.
Details about how such matches are constructed are given in <specref ref="tq-ft-fs-FTUnaryNot"/>.
</p><p>The following expression returns the empty sequence, because all <code>book</code>
elements contain "usability":</p><eg role="xpath" xml:space="preserve">//book[. ftcontains ftnot "usability"]</eg><p>The following expression returns true, because <code>book</code> elements contain
"improving" and "usability" but not "improving usability":</p><eg role="xpath" xml:space="preserve">//book ftcontains "improving" ftand
"usability" ftand ftnot "improving usability"</eg><p>The following expression returns <code>book</code> elements containing "web site
usability" but not "usability testing":</p><eg role="xpath" xml:space="preserve">//book[title/@shortTitle ftcontains "web site usability" ftand 
ftnot "usability testing"]</eg></div3></div2><div2 id="ftposfilter"><head>Positional Filters</head><scrap headstyle="show"><head/><prod num="158" id="doc-xquery-FTPosFilter"><lhs>FTPosFilter</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTOrder" xlink:type="simple">FTOrder</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWindow" xlink:type="simple">FTWindow</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTDistance" xlink:type="simple">FTDistance</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTScope" xlink:type="simple">FTScope</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTContent" xlink:type="simple">FTContent</nt>
                  </rhs></prod></scrap><p>
               <termdef id="dt-ftposfilter" term="positional filter">
                  <term>Positional filters</term> are postfix operators that serve to
filter matches based on various constraints on their positional
information.</termdef>
            </p><p>
Recall that the grammar rule for <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt>
allows an arbitrary number of positional filters to follow an
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTOr" xlink:type="simple">FTOr</nt>. Multiple adjacent positional filters are
applied from left to right, i.e., the first filter is applied to the
result of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTOr" xlink:type="simple">FTOr</nt>, the second is applied to the
result of that first application, and so on.
</p><p>
An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTOr" xlink:type="simple">FTOr</nt> consists of
one or more <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnd" xlink:type="simple">FTAnd</nt>s (separated by <code>ftor</code>),
each of which could be
an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPosFilter" xlink:type="simple">FTPosFilter</nt> applied to an embedded FTOr, enclosed in parentheses.
</p><div3 id="ftorder"><head>Ordered Selection</head><scrap headstyle="show"><head/><prod num="159" id="doc-xquery-FTOrder"><lhs>FTOrder</lhs><rhs>"ordered"</rhs></prod></scrap><p>
                  <termdef id="dt-ordered-selection" term="ordered selection">An
<term>ordered selection</term> consists of a full-text selection followed by 
the postfix operator "ordered".</termdef>

An ordered selection constrains the order of tokens and
phrases to be the same as the order in which they are written in the
operand selection.
</p><p> The default is unordered. Unordered is in effect when ordered is
not specified in the query. Unordered cannot be written explicitly in
the query.  </p><p>An ordered selection selects matches which satisfy the operand full-text
selection and which also satisfy the following constraint: the order
that the matching tokens or phrases have in the text being searched
is the same order that the corresponding query tokens or phrases have in the
operand selection. In both cases, the ordering is determined from the minimum
start positions of the contituent tokens.
</p><p>The following expression returns true, because titles of <code>book</code> elements
contain "web site" and "usability" in the order in which they are written in
the query, i.e., "web site" must precede "usability":</p><eg role="xpath" xml:space="preserve">//book/title ftcontains ("web site" ftand "usability") ordered</eg><p>The following expression returns false, because although "Montana" and "Millicent"
both appear in the <code>book</code> element, they do not appear in the order they
are written in the query:</p><eg role="xpath" xml:space="preserve">//book[@number="1"] ftcontains ("Montana" ftand "Millicent") ordered</eg></div3><div3 id="ftwindow"><head>Window Selection</head><scrap headstyle="show"><head/><prod num="160" id="doc-xquery-FTWindow"><lhs>FTWindow</lhs><rhs>"window"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnit" xlink:type="simple">FTUnit</nt>
                     </rhs></prod><prod num="162" id="doc-xquery-FTUnit"><lhs>FTUnit</lhs><rhs>"words"  |  "sentences"  |  "paragraphs"</rhs></prod></scrap><p>
                  <termdef id="dt-window-selection" term="window selection">A
<term>window selection</term> consists of a full-text selection followed
by one of the (complex) postfix operators derived from <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTWindow" xlink:type="simple">FTWindow</nt>.</termdef> 
A window selection selects matches which satisfy the operand full-text
selection and for which the matched tokens and phrases, more precisely the 
individual StringIncludes of that match, are found
within a number of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnit" xlink:type="simple">FTUnit</nt>s (words, sentences, and paragraphs). The number of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnit" xlink:type="simple">FTUnit</nt>s is
specified by an AdditiveExpr that is converted as though it were an argument to a
function with the expected type of <code>xs:integer</code>.</p><p>A window selection may cross element
boundaries. The size of the window is not affected by the presence or
absence of element boundaries. Stop words are included in the
computation of the window size whether they are ignored by the query or not.</p><p>
A window selection examines the matches generated by the preceding
portion of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt>, and selects those for
which the matched 
tokens and phrases (more precisely, the individual StringIncludes of
that match) are all found within a window whose size is a specified
number of FTUnits (words, sentences, or paragraphs); for each such
window, the window selection then generates a match containing the
merge of those StringIncludes, plus any StringExcludes that fall
within the window.
</p><p>The following expression returns true, because "web", "site", and "usability" are
within a window of 5 tokens in the <code>title</code> element:</p><eg role="xpath" xml:space="preserve">/books/book/title ftcontains "web" ftand "site"
ftand "usability" window 5 words</eg><p>The following expression returns true, because "web" and "site" in the order they are
written in the query and either "usability" or "testing" are within a
window of at most 10 tokens:</p><eg role="xpath" xml:space="preserve">/books/book ftcontains ("web" ftand "site" ordered)
ftand ("usability" ftor "testing") window 10 words</eg><p>The following expression returns true, because the <code>title</code> element
contains "Web Site Usability". A similar query on the <code>p</code> element
would not return true, 
because its occurrences of "web site" and "usability" are not within a
window of 3:</p><eg role="xpath" xml:space="preserve">/books/book//title ftcontains "web site" ftand
"usability" window 3 words</eg><p>The following expression returns the sample <code>book</code> element, 
because its <code>number</code> attribute is 1 and it contains a
window of 2 words which contains an occurrence of "efficient"
but not an occurrence of "and". There is just one such matching window
in the sample text and it contains "enable efficient".</p><eg role="xpath" xml:space="preserve">/books/book[@number="1" and . ftcontains "efficient" 
ftand ftnot "and" window 2 words]</eg><p>The following expression returns the empty sequence, because in the selected
<code>book</code> element, there is no occurrence of "efficient"
within a window of 3 tokens which would not also contain an occurrence
of "and":</p><eg role="xpath" xml:space="preserve">/books/book[@number="1" and . ftcontains "efficient" 
ftand ftnot "and" window 3 words]</eg><p>
In order to allow meaningful results for nested positional filters,
e.g., a window selection embedded inside a distance selection, the
resulting matches for window selections are formed from the input matches
that satisfy the window constraint as follows. All StringIncludes of
such a match are coerced into a single StringInclude that spans all
token positions from the smallest to the largest position of any input
StringIncludes. This is explained in more detail in Section <specref ref="ftdistance"/>.
</p></div3><div3 id="ftdistance"><head>Distance Selection</head><scrap headstyle="show"><head/><prod num="161" id="doc-xquery-FTDistance"><lhs>FTDistance</lhs><rhs>"distance"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTRange" xlink:type="simple">FTRange</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnit" xlink:type="simple">FTUnit</nt>
                     </rhs></prod><prod num="157" id="doc-xquery-FTRange"><lhs>FTRange</lhs><rhs>("exactly"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)<br/>|  ("at"  "least"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)<br/>|  ("at"  "most"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)<br/>|  ("from"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>  "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)</rhs></prod></scrap><p>
                  <termdef id="dt-distance-selection" term="distance selection">A
<term>distance selection</term> consists of a full-text selection followed
by one of the (complex) postfix operators derived from <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTDistance" xlink:type="simple">FTDistance</nt>.</termdef> 
               </p><p>A distance selection selects matches which satisfy the operand full-text
selection and for which the matched tokens and phrases satisfy the
specified distance conditions.</p><p>Distances in the search context are measured in units of
tokens, sentences, or paragraphs.
Roughly speaking, the distance between two matches
is the number of intervening units,
so a distance of zero tokens (sentences, paragraphs) means
no intervening tokens (sentences, paragraphs).
More precisely,
given two matches,
we first determine their order
by sorting on starting position and if necessary on ending position.
Let M1 be the "earlier" and M2 be the "later".
(If there are overlapping tokens involved,
the designations "earlier" and "later" may not be intuitively obvious.)
Then the distance between the two is
M2's starting position minus M1's ending position, minus 1.
</p><p>
When computing distances
in the search context,
a distance selection
may cross element boundaries;
they affect the distance computed
only to the extent that they affect the tokenization of the search context.
Stop words are counted in those computations whether they are ignored
or not.
</p><p>
When a distance selection applies a distance condition to more than two matches,
the distance condition is required to hold on each successive pair of matches.
</p><p>
An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTDistance" xlink:type="simple">FTDistance</nt> expresses a distance condition in terms of
an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnit" xlink:type="simple">FTUnit</nt> and an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTRange" xlink:type="simple">FTRange</nt>.
An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnit" xlink:type="simple">FTUnit</nt> can be
<code>words</code>, <code>sentences</code>, or <code>paragraphs</code>,
where <code>words</code> refers to a distance measured in tokens.
</p><!-- How FTRange specifies a (possibly open) range of integers. --><p>
An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTRange" xlink:type="simple">FTRange</nt> specifies a range of integer values
by providing a minimum and/or maximum value for some integer quantity.
(Here, where the FTRange appears in an FTDistance, that quantity is a distance.
When it appears in an FTTimes, the quantity is a number of occurrences.)
Each one of the AdditiveExpr
specified in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTRange" xlink:type="simple">FTRange</nt> is converted as though it were an
argument to a function with the expected parameter type of
<code>xs:integer</code>.</p><p>Let the value of the first (or only) operand be M.  If "from" is
specified, let the value of the second operand be N. 
</p><p>If "exactly" is specified, then the range is the closed interval [M, 
M].  If "at least" is specified, then the range is the half-closed interval 
[M, unbounded).  If "at most" is specified, then the range is the half-closed 
interval (unbounded, M].  If "from-to" is specified, then the range is the closed 
interval [M, N]. Note: If M is greater than N, the range is empty. </p><p>Here are some examples of  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTRange" xlink:type="simple">FTRange</nt>s:</p><olist><item><p>'exactly 0' specifies the range [0, 0].</p></item><item><p>'at least 1' specifies the range [1,unbounded).</p></item><item><p>'at most 1' specifies the range (unbounded, 1]. </p></item><item><p>'from 5 to 10' specifies the range [5, 10].</p></item></olist><!-- Examples --><p>The following expression returns false, because "completion" and "errors" are
less than 11 tokens apart:</p><eg role="xpath" xml:space="preserve">/books/book ftcontains ("completion" ftand "errors" 
distance at least 11 words)</eg><p>The following expression returns true:</p><eg role="xpath" xml:space="preserve">/books/book ftcontains "web" ftand "site" ftand
"usability" distance at most 2 words</eg><p>
The search context contains two occurrences of the phrase
"the usability of a web site"
(once in the &lt;title&gt; and once in the &lt;content&gt;).
In this phrase, 
the tokens "usability" and "web" have a distance of 2 words,
and the tokens "web" and "site" have a distance of 0 words,
both of which satisfy the constraint <code>distance at most 2 words</code>.
(The tokens "usability" and "site" have a distance of 3 words,
but this does not cause the distance filter to fail,
because these are not successive matches.)
Thus, the full-text selection yields two matches,
and the whole expression yields true.
(The phrase "Improving Web Site Usability" would also satisfy the given full-text selection,
but in the sample document it occurs in an attribute value,
and so does not contribute to the string value or the tokenization of the book element.)
</p><p>The following expression returns the empty sequence, because 
between any token "usability" and the token in any occurrence of the phrase 
"web site" that is the nearest to the token "usability" there is always more 
than one intervening token: </p><eg role="xpath" xml:space="preserve">/books/book[.//p ftcontains "web site"
ftand "usability" distance at most 1 words] </eg><p>The following expression returns the <code>book</code> title, because for 
the occurrences of the tokens "web" and "users" in the <code>note</code> 
element only one intervening token appears: </p><eg role="xpath" xml:space="preserve">/books/book[. ftcontains "web"
ftand "users" distance at most 1 words]/title </eg><!-- JD, 2005-08-17: need to revise the foll. 2 examples;
<p>The following expression returns the
<code>title</code> element, because the token "learning" not appears
within 15 tokens of the tokens "web site" and "completion":</p>

<eg role="xpath">/books/book[@number="1" and . ftcontains ("web site"
ftand "completion" ftand ftnot  "learning") distance
exactly 15 words]/title
</eg>

<p>The following expression returns the <code>title</code>
element if the tokens "web site" and "completion" appear within 15
tokens of each other and in the same paragraph:</p>
<eg role="xpath">/books/book[@number="1" and . ftcontains "web site"
ftand "completion" distance exactly 15 words same
paragraph]/title </eg>

--><p>
In order to allow meaningful results for nested positional filters,
e.g., a distance selection embedded inside another distance selection, the
resulting matches for distance selections are formed from the input matches
that satisfy the distance constraint as follows. All StringIncludes of
such a match are coerced into a single StringInclude that spans all
token positions from the smallest to the largest position of any input
StringIncludes. Thus, a distance selection that embeds a window or a
distance selection takes the result of the embedded selection as a
single unit.
</p><p>
The following gives an example of nested distance selections:
</p><eg role="xpath" xml:space="preserve">/books/book ftcontains ((("richard" ftand "nixon") distance at most 2 words) 
                   ftand 
                   (("george" ftand "bush") distance at most 2 words) 
                  distance at least 20 words)</eg><p>
This expression allows to find <code>book</code> elements that contain, for instance, 
"Richard M. Nixon"  and "George W. Bush" at least 20 words apart. The
matches for the inner distance selections are treated as single units
(represented by StringIncludes) by the outer distance
selection. Suppose such phrases are present in 
the search context, then the outer distance selection
enforces a constraint on the number of intervening tokens ("at least
20") between the
last token of "Richard M. Nixon" and the first token of "George
W. Bush".
</p></div3><div3 id="ftscope"><head>Scope Selection</head><scrap headstyle="show"><head/><prod num="163" id="doc-xquery-FTScope"><lhs>FTScope</lhs><rhs>("same"  |  "different")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTBigUnit" xlink:type="simple">FTBigUnit</nt>
                     </rhs></prod><prod num="164" id="doc-xquery-FTBigUnit"><lhs>FTBigUnit</lhs><rhs>"sentence"  |  "paragraph"</rhs></prod></scrap><p>
                  <termdef id="dt-scope-selection" term="scope selection">A
<term>scope selection</term> consists of a full-text selection followed
by one of the (complex) postfix operators derived from <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTScope" xlink:type="simple">FTScope</nt>.</termdef> 
               </p><p>A scope selection selects matches which satisfy the operand full-text
selection and for which the matched tokens and phrases are
contained in the same scope or in different scopes. </p><p> Possible scopes are sentences and paragraphs. </p><p> By default, there are no restrictions on the scope of the
matches. </p><p>The following expression returns false, because the tokens "usability" and "Marigold"
are not contained within the same sentence:</p><eg role="xpath" xml:space="preserve">//book ftcontains "usability" ftand "Marigold" same sentence</eg><p>The following expression returns true, because the tokens "usability" and "Marigold"
are contained within different sentences: </p><eg role="xpath" xml:space="preserve">//book ftcontains "usability" ftand "Marigold" different sentence</eg><p>The following expression returns a <code>book</code> element, because it contains
"usability" and "testing" in the same paragraph:</p><eg role="xpath" xml:space="preserve">//book[. ftcontains "usability" ftand "testing" same paragraph] </eg><p>The following expression returns a <code>book</code> element, because "site" and
"errors" appear in the same sentence:</p><eg role="xpath" xml:space="preserve">//book[. ftcontains "site" ftand "errors" same sentence] </eg><p>It is possible that both "same sentence" and "different sentence" conditions are
simultaneously safisfied for several tokens and/or phrases within the same 
document fragment. This can be observed if there are occurrences of the tokens
and/or phrases both within the same sentence and within difference sentences. For
example, consider the following document fragment. </p><eg role="parse-test" xml:space="preserve">
&lt;introduction&gt;
... The usability of a Web site is how well the site supports the user in
achieving specified goals. ... Expert reviews and usability testing are methods of
identifying problems in layout, terminology, and navigation. ...
&lt;/introduction&gt;
</eg><p>This sample will satisfy both conditions <code>("usability" ftand "reviews")
different sentence</code> and <code>("usability" ftand "reviews") same
sentence</code>. The tokens "usability" and "reviews" occur both in different sentences
(the first and second shown sentences) and in the same sentence (the second shown
sentences.) </p><p>The above observation also holds for the "same paragraph" and "different paragraph"
conditions.</p></div3><div3 id="ftcontent"><head>Anchoring Selection</head><scrap headstyle="show"><head/><prod num="165" id="doc-xquery-FTContent"><lhs>FTContent</lhs><rhs>("at"  "start")  |  ("at"  "end")  |  ("entire"  "content")</rhs></prod></scrap><p>
                  <termdef id="dt-anchoring-selection" term="anchoring selection">An
<term>anchoring selection</term> consists of a full-text selection followed
by one of the postfix operators "at start", "at end", or "entire content".</termdef> 
               </p><p>An anchoring selection selects matches which satisfy the operand full-text
selection and for which the matched tokens and phrases are
the first, last, or all tokens in the tokenized form of the items being searched.
</p><ulist><item><p> Using the "at start" operator, tokens or phrases are matched, if they 
cover the first token position in the tokenized string value 
of the item being searched.</p></item><item><p> Using the "at end" operator, tokens or phrases are matched, if they
cover the last token position in the tokenized string value of the
item being searched.</p></item><item><p>Using the "entire content" operator, tokens or phrases are matched, if they
cover all token positions of the tokenized string value of the 
item being searched.</p></item></ulist><p>The following expression returns each <code>title</code> element starting with the
phrase "improving the usability of a web site":</p><eg role="xpath" xml:space="preserve">/books//title[. ftcontains "improving the usability
of a web site" at start]</eg><p>The following expression returns the <code>p</code> element of the sample, 
because it ends with the phrase
"propagating few errors":</p><eg role="xpath" xml:space="preserve">/books//p[. ftcontains "propagat.*" with wildcards ftand "few
errors" distance at most 2 words at end]</eg><p>Since the distance operator doesn't imply an ordering, the last example 
would also yield a match if the <code>p</code> element ended with, say, 
"few errors are propagated".
</p><p>The following expression returns each <code>note</code> element whose entire content
is "this book has been approved by the web site users association":</p><eg role="xpath" xml:space="preserve">/books//note[. ftcontains "this book has been
approved by the web site users association" entire content]</eg><p>The following example returns true because
both the <code>content</code> and the <code>note</code> elements match:</p><eg role="xpath" xml:space="preserve">/books//* ftcontains "Association" at end</eg></div3></div2><div2 id="ftignoreoption"><head>Ignore Option</head><scrap headstyle="show"><head/><prod num="179" id="doc-xquery-FTIgnoreOption"><lhs>FTIgnoreOption</lhs><rhs>"without"  "content"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-UnionExpr" xlink:type="simple">UnionExpr</nt>
                  </rhs></prod></scrap><p>The <term>ignore option</term> specifies a set of
nodes whose contents are ignored. It is applicable only to a top-level
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt> 
(see <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt>). 
<termdef id="IgnoredNodesDef" term="IgnoredNodes">
                  <term>Ignored nodes</term> are the set of nodes whose content are 
    ignored.</termdef> Ignored nodes are identified
by the XQuery expression UnionExpr.
The value of the UnionExpr must be a sequence of zero or more nodes;
otherwise a type error is raised 
<xerrorref spec="XP" class="TY" code="0004" type="type"/>.
</p><p>Let <code>I1, I2, ..., In</code>
be the sequence of items of the search context and let
<code>N1, N2, ..., Nk</code> be the sequence of nodes that
UnionExpr evaluates to. For each <code>Ij (j=1..n)</code> a copy is
made that omits each node <code>Ni (i=1..k)</code>.
Those copies form the new search context. If
UnionExpr evaluates to an empty sequence no nodes are omitted.</p><p>In the following fragment, if <code>$x//annotation</code> is ignored,
"Web Usability" will be found 2 times: once in the <code>title</code>
element and once in the <code>editor</code> element. The 2 occurrences
in the 2 <code>annotation</code> elements are ignored. On the other
hand, "expert" will not be found, as it appears only in an
<code>annotation</code> element.</p><eg xml:space="preserve">let $x := &lt;book&gt;
   &lt;title&gt;Web Usability and Practice&lt;/title&gt;
   &lt;author&gt;Montana &lt;annotation&gt; this author is
       an expert in Web Usability&lt;/annotation&gt; Marigold
   &lt;/author&gt;
   &lt;editor&gt;Véra Tudor-Medina on Web &lt;annotation&gt; best
       editor on Web Usability&lt;/annotation&gt; Usability
   &lt;/editor&gt;
 &lt;/book&gt;
 </eg><p>By default, no element content is ignored. </p><note><p>Nodes <termref def="may">MAY</termref> be ignored during
indexing and during query processing. The ignore option applies only
to query processing. Whether and how indexing ignores nodes is  
out of scope for this specification.</p></note></div2><div2 id="id-extension-selections"><head>Extension Selections</head><p>
               <termdef id="dt-extension-selection" term="extension selection">An <term>extension selection</term> is a full-text selection whose semantics are
<termref def="dt-implementation-defined">implementation-defined</termref>.</termdef> 
Typically, a particular extension will be recognized
by some implementations and not by others. The syntax is designed so that
extension selections can be successfully parsed by all implementations, and
so that fallback behavior can be defined for implementations that do not
recognize a particular extension.</p><scrap headstyle="show"><head/><prod num="154" id="doc-xquery-FTExtensionSelection"><lhs>FTExtensionSelection</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt>?  "}"</rhs></prod><prod num="69" id="doc-xquery-Pragma"><lhs>Pragma</lhs><rhs>"(#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PragmaContents" xlink:type="simple">PragmaContents</nt>)?  "#)"</rhs></prod><prod num="70" id="doc-xquery-PragmaContents"><lhs>PragmaContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* '#)' Char*))</rhs></prod></scrap><p>An extension selection consists of one or more pragmas followed by a full-text selection enclosed in curly braces. See
<xspecref spec="XQ" ref="id-extension-expressions"/> for information on 
pragmas in general.
A pragma is denoted by the delimiters <code>(#</code> and <code>#)</code>, and
consists of an identifying QName followed by <termref def="dt-implementation-defined">implementation-defined</termref>
content.
The content of a pragma may consist of any string of characters that does not contain the ending delimiter <code>#)</code>.  The QName of a 
pragma must resolve to a namespace URI and local name, using the statically known namespaces.</p><note><p>Since there is no default namespace for
pragmas, a pragma QName must include a namespace prefix.</p></note><p>Each implementation recognizes an
<termref def="dt-implementation-defined">implementation-defined</termref> set of namespace
URIs used to denote pragmas.</p><p>If the namespace part of a pragma QName is not recognized by the
implementation as a pragma namespace, then the pragma
is ignored. If all the pragmas in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTExtensionSelection" xlink:type="simple">FTExtensionSelection</nt> are ignored, then full-text extension selection is just
the full-text selection enclosed in curly braces; if this full-text selection is absent, then a static error is
raised <xerrorref spec="XQ" class="ST" code="0079" type="static"/>.</p><p>If an implementation recognizes the namespace of one or more pragmas in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTExtensionSelection" xlink:type="simple">FTExtensionSelection</nt>, then the value
of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTExtensionSelection" xlink:type="simple">FTExtensionSelection</nt>, including its error behavior, is <termref def="dt-implementation-defined">implementation-defined</termref>. For example, an implementation that recognizes the namespace of
a pragma QName, but does not recognize the local part of the QName, might choose
either to raise an error or to ignore the pragma.</p><p>It is a  static error <xerrorref spec="XQ" code="0013" class="ST" type="static"/> 
if an implementation recognizes a pragma but
determines that its content is invalid.</p><p>If an implementation recognizes a pragma, it must report any static
errors in the following full-text selection even if it will not apply that
selection.</p><p>The following examples illustrate three ways in which extension selections might be
used.</p><p>A pragma can be used to furnish a hint for how to evaluate the
following full-text selection, without actually changing the result.
For example:</p><eg role="parse-test" xml:space="preserve">
declare namespace exq = "http://example.org/XQueryImplementation";

/books/book/author[name ftcontains (# exq:use-index #) {'Berners-Lee'}]
</eg><p>An implementation that recognizes the <code>exq:use-index</code> pragma might use an
index to evaluate the full-text selection that follows. An implementation that
does not recognize this pragma would evaluate the full-text selection in its normal 
way.</p><p>A pragma might be used to modify the semantics of the following
full-text selection in ways that would not (in the absence of the pragma) be
conformant with this specification.  For example, a pragma might be used to 
change distance counting so that adjacent words are at a distance of 1 
(otherwise they would be at a distance of 0):
<eg role="parse-test" xml:space="preserve">
declare namespace exq = "http://example.org/XQueryImplementation";

/books/book[.//p ftcontains (# exq:distance #) { "web site"
ftand "usability" distance at most 1 words }]
</eg>
            </p><p>
Such changes to the language
semantics must be scoped to the expression contained within the curly
braces following the pragma.</p><p>A pragma might contain syntactic constructs that are
evaluated in place of the following full-text selection. In this case, the
following selection itself (if it is present) provides a fallback for use by
implementations that do not recognize the pragma. For example:</p><eg role="parse-test" xml:space="preserve">
declare namespace exq = "http://example.org/XQueryImplementation";

//city[. ftcontains (# exq:classifier with class 'Animals' #) 
       {"animal" with thesaurus at "http://example.org/thesaurus.xml" 
        relationship "RT"}]
</eg><p>Here an implementation that recognizes the pragma will return the result of
evaluating the proprietary syntax <code>with class 'animals'</code>,
while an implementation that does not recognize the pragma will instead
return the result of the thesaurus option. 
If no fallback expression is required, or
if none is feasible, then the expression between the curly braces may be
omitted, in which case implementations that do not recognize the pragma will
raise a static error.</p></div2></div1><div1 id="tq-semantics"><head>Semantics</head><p>This section describes the formal semantics of XQuery and XPath Full Text 1.0.
        The figure below shows how XQuery and XPath Full Text 1.0 integrates with XQuery 1.0
        and XPath 2.0.</p><p>The following diagram represents the interaction of XQuery and
		XPath Full Text with the rest of XQuery 1.0 and XPath 2.0.
		It illustrates how full-text expressions can be nested within XQuery 1.0
		and XPath 2.0 expressions and vice versa. </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/XQueryFullTextInteraction.jpg" alt="XQuery and Full Text Interaction diagram" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><ulist><item><p>Step 1 represents the composability of XQuery 1.0
        and XPath 2.0 expressions and the fact that such expressions
        evaluate to a sequence of XDM items.  This process is outside the scope of this
        document and will not be discussed further.  </p></item><item><p>Step 2 shows how XQuery 1.0 and XPath 2.0 expressions
          can be nested within full-text expressions. 
          If an XQuery 1.0 and XPath 2.0 expression
          is nested on the left-hand side of an
          <term>FTContains</term> expression or within <term>FTWords</term>,
          the sequence of XDM items that result from evaluation
          of that XQuery 1.0 or XPath 2.0 expression
          are converted to their tokenized form, as described
          in <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#TokenizationSec" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Tokenization</loc>. 
          If the XQuery 1.0 and XPath 2.0 expression is nested
          within another type of <term>FTSelection</term>,
          the items in its result sequence are
          converted to atomic values, as discussed in 
          <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftselections" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">FTSelections</loc>.</p></item><item><p>Step 3 represents the composability of <term>FTSelection</term>s. 
        Each <term>FTSelection</term> operates on zero or more
        <term>AllMatches</term> and returns an <term>AllMatches</term>. The process is
        described in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#FTSelectionEvalSec" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Evaluation 
        of FTSelections</loc> section. </p></item><item><p>Step 4 shows how XQuery and XPath Full Text 1.0 and scoring
        expressions can be nested into XQuery 1.0 and XPath 2.0 expressions.
        The sections <specref ref="FTContainsSec"/> and <specref ref="ScoreSec"/>
        describe how this is achieved.</p></item></ulist><note><p>In the list above and throughout the rest of this section, bold 
		typeface has been used to distinguish the concepts that are part of the
		<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#AllMatchesSec" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">AllMatches</loc> model.</p></note><!-- Jim; 2007-08-11 - ACTION FTTF-147-09 - clarify that this section is descriptive only --><p>The functions and schemas defined in this section are
		considered to be within the fts: namespace (as discussed in
    section <specref ref="tq-ft-namespaces"/>). These functions and schemas
		are used only for describing the semantics.  There is no
    requirement that an implementation of this specification must
    use the functions, schemas, or algorithms described in this
    section of this specification.  The only requirement is that
    implementations must achieve the same results that an implementation
    that does use these functions, schemas, and algorithms would
    achieve. </p><p>
    Note that by using XQuery 1.0 and XPath 2.0
    to specify the formal semantics,
    we avoid the need to introduce new formalism.
    We simply reuse the formal semantics of XQuery 1.0 and XPath 2.0.
    </p><!-- **************************************************************
         *                            Tokenization                       *
         ************************************************************** --><div2 role="xquery" id="TokenizationSec"><head>Tokenization</head><p>
               <termdef id="TokenizationDef" term="Tokenization">Formally, <term>tokenization</term> is the process 
        of converting
        an XDM item to a collections of tokens, taking any
        structural information of the item into account
        to identify token, sentence, and paragraph boundaries. Each token is
        assigned a starting and ending position.</termdef>
            </p><p>Tokenization, including the definition of the term "token",
        <termref def="should">SHOULD</termref> be <termref def="dt-implementation-defined">implementation-defined</termref>. 
        Implementations <termref def="should">SHOULD</termref> expose
        the rules and sample results of tokenization as much as possible
        to enable users to predict and interprete the results of tokenization. 
        Tokenization <termref def="must">MUST</termref> conform to these 
        constraints:</p><olist><item><p>Each token <termref def="must">MUST</termref> consist of
              one or more characters.</p></item><item><p>Tokenization of an item
              <termref def="must">MUST</termref> include only tokens derived 
              from the string value of that item.  
              The string value is defined in <bibref ref="xpath-datamodel"/> in
              <xspecref spec="DM" ref="StringValue"/>; for element 
              nodes it does not include the contents of attributes, but for
              attribute nodes it does.
              </p></item><item><p>The tokenizer <termref def="should">SHOULD</termref>, when
              tokenizing two equal items, identify the same tokens in each.
              The cases where it does not are <termref def="dt-implementation-defined">implementation-defined</termref>.
              </p></item><item><p>The starting and ending position of a token
              <termref def="must">MUST</termref> be integers, and the
              starting position <termref def="must">MUST</termref> be
              less than or equal to the ending position.</p></item><item><p>In the tokenization of an item,
              consider the range of token positions
              from the smallest starting position to the largest ending position;
              every token position in that range must be covered by some token in the tokenization.
              That is, for every token position <code>P</code>,
              there must exist some token <code>T</code> such that
              <code>T's starting position &lt;= P &lt;= T's ending position</code>.
              </p></item><item><p>The tokenizer <termref def="must">MUST</termref> preserve
              the containment hierarchy (paragraphs contain sentences contain 
              tokens) by adhering to the following constraints:</p><olist><item><p>
                Each token is contained in at most one sentence and at most
                one paragraph.
		(In particular, this means that
		no tokens of any sentence are contained in any other sentence,
		and
                no tokens of any paragraph are contained in any other paragraph.)
                </p></item><item><p>
                All tokens of a sentence are contained in at most
                one paragraph.
                </p></item><!-- "No interleaving" rules: --><item><p>
                The range of token positions from the smallest starting position
                to the largest ending position in a sentence does not overlap
                with the token position range from any other sentence.
                </p></item><item><p>
                The range of token positions from the smallest starting position
                to the largest ending position in a paragraph does not overlap
                with the token position range from any other paragraph.
                </p></item></olist></item></olist><p>Useful information for tokenizer implementors may be found
        in <bibref ref="UAX29"/>.</p><note><p>Usually, the starting and ending positions of a 
        token are the same. 
        For some languages, some tokenizers may identify
        overlapping tokens.  For example, the German word
        "Donaudampfschifffahrtskapitaensmuetze" might be
        tokenized into the following tokens:
        "Donaudampfschifffahrtskapitaensmuetze", "Donau",
        "dampf", "schiff", "dampfschiff", "kapitaen", "muetze",
        "kapitaensmuetze", "schifffahrt", "dampfschifffahrt", 
        and perhaps others.
        In the face of overlapping tokens, it is implementation-dependent what
        positions a tokenizer assigns to each such token. For
        example, a tokenizer might assign the same position value to each of
        the tokens "Donaudampfschifffahrtskapitaensmuetze",
        "Donau", "dampf", "schiff", "dampfshiff", etc.
		In that case, the distance between each (overlapping) token
        assigned the same position is -1. Tokenizers might retain additional
        information about those overlapping tokens that allows the full-text
        implementation to distinguish among them.
        </p><p>Consider the sentence "Ich sehe den Dampfschifffahrtskapitän auf dem
        Fluß." If an implementation tokenizes "Dampfschifffahrtskapitän"
        as overlapping tokens at the same position, then the implementation
        could still determine that the query
        "'Schifffahrt Dampf' window 0 words ordered" fails to match the
        sentence because phrase
        matching is implementation-defined and may make use of additional
        implementation-dependent token information.
        </p><p>Even more complex situations can arise. Consider, for example,
        the German sentence "Er stellte sie vor." A sophisticated tokenizer
        might construct the token "vorstellen" covering positions 2 through 4,
        which overlaps the token "sie" at position 3.  For the purposes of
        distance calculations, tokens are considered in the order of their
        starting positions, so the distance between "vorstellen" and
        "sie" would be 3-4-1=-2. (See <code>fts:wordDistance</code>, below.)</p></note><div3 role="xquery" id="tq-ft-Tokenization-examples"><head>Examples</head><p>For example, the following example must return false, because the 'secret'
only occurs within an attribute and a comment, neither of which contributes
characters to the string value of the 'p' element node:
</p><eg role="parse-text" xml:space="preserve">
&lt;p kind='secret'&gt;Sensitive material &lt;!-- secret --&gt;&lt;/p&gt; ftcontains 'secret'

</eg><p>The following document may lead to overlapping tokens to account for the
ambiguity caused by the hyphen:
</p><eg role="parse-text" xml:space="preserve">
&lt;p&gt;I will re-
sign tommorow.&lt;/p&gt;

</eg><p>The following document fragment is the source document for examples in this section. 
    A sample tokenization is used for the examples in this section. 
    The results might be different for other tokenizations.</p><p>Unless stated otherwise, the results assume a case-insensitive match.</p><eg role="parse-text" xml:space="preserve">
&lt;offers&gt;
    &lt;offer id="1000" price="10000"&gt;
        Ford Mustang 2000, 65K, excellent condition, runs 
        great, AC, CC, power all
    &lt;/offer&gt;
    &lt;offer id="1001" price="8000"&gt;
        Honda Accord 1999, 78K, A/C, cruise control, runs 
        and looks great, excellent condition
    &lt;/offer&gt;
    &lt;offer id="1005" price="5500"&gt;
        Ford Mustang, 1995, 150K highway mileage, no rust, 
        excellent condition
    &lt;/offer&gt;
&lt;/offers&gt;
        </eg><p>In this sample tokenization, tokens are delimited by punctuation and 
		whitespace symbols. </p><ulist><item><p>The token "Ford" is at relative position 1.</p></item><item><p>The token "Mustang" is at relative position 2.</p></item><item><p>The token "2000" is at relative position 3.</p></item><item><p>Relative position numbers are assigned sequentially through the 
		end of the document.</p></item></ulist><p>Hence in this example each token occupies exactly one position, and no overlapping of 
                tokens occurs. The relative positions of tokens
                are shown
                below in parentheses.</p><eg role="parse-text" id="SampleTokenizedDoc" xml:space="preserve">
&lt;offers&gt;
    &lt;offer id="1000" price="10000"&gt;
        Ford(1) Mustang(2) 2000(3), 65K(4), excellent(5)
        condition(6), runs(7) great(8), AC(9), CC(10), 
        power(11) all(12)
    &lt;/offer&gt;
    &lt;offer id="1001" price="8000"&gt;
        Honda(13) Accord(14) 1999(15), 78K(16), A(17)/C(18),
        cruise(19) control(20), runs(21) and(22) looks(23)
        great(24), excellent(25) condition(26)
    &lt;/offer&gt;
    &lt;offer id="1005" price="5500"&gt;
        Ford(27) Mustang(28), 1995(29), 150K(30) highway(31)
        mileage(32), little(33)  rust(34), excellent(35) 
        condition(36)
    &lt;/offer&gt;
&lt;/offers&gt;
        </eg><p>The relative positions of paragraphs are determined similarly. In
		this sample tokenization, the paragraph delimiters are start tags and 
        end tags.</p><ulist><item><p>The tokens in the first 'offer' element are assigned relative 
		paragraph number 1.</p></item><item><p>The tokens from the next 'offer' element are assigned relative  
		paragraph number 2.</p></item><item><p>Relative paragraph numbers are assigned sequentially through 
		the end of the document.</p></item></ulist><p>The relative positions of sentences are determined similarly using 
        sentence delimiters.</p><p>Implementations may provide for the means to ignore or side-step
           certain structural elements when performing tokenization.  In the
           following example, the implementation has decided to ignore the
           markup for <code>&lt;bold&gt;</code> and prune out the entire
           subtree headed by <code>&lt;deleted&gt;</code>.</p><eg role="parse-text" xml:space="preserve">
&lt;para&gt;&lt;deleted&gt;This sentence was deleted.&lt;/deleted&gt;
This &lt;bold&gt;entire paragraph&lt;/bold&gt; is one sentence
as far as the tokenizer is concerned.
&lt;/para&gt;
</eg><p>Using the same notation as before, this sample tokenization is
        shown below. All the tokens marked with a
        token position also have the same sentence and paragraph relative
        positions. Note that there are no tokens marked for the 
        ignored subtree.
        </p><eg role="parse-text" xml:space="preserve">
&lt;para&gt;&lt;deleted&gt;This sentence was deleted.&lt;/deleted&gt;
This(1) &lt;bold&gt;entire(2) paragraph(3)&lt;/bold&gt; is(4) one(5) sentence(6)
as(7) far(8) as(9) the(10) tokenizer(11) is(12) concerned(13).
&lt;/para&gt;
</eg></div3><div3 role="xquery" id="TokenizationRepresentationsSec"><head>Representations of Tokenized Text and Matching</head><p>
                  <termdef id="QueryItemDef" term="QueryItem">A <term>QueryItem</term> is a sequence of
        <term>QueryTokenInfo</term>s representing the collection of tokens derived
        from tokenizing one query string. </termdef>
               </p><p>
                  <termdef id="QueryTokenInfoDef" term="QueryTokenInfo">A <term>QueryTokenInfo</term> is the
        identity of a token inside a query string. </termdef>
        Each <term>QueryTokenInfo</term> is
        associated with a starting and ending position
        that captures the relative
        position of the query string in the query.</p><p>
                  <termdef id="TokenInfoDef" term="TokenInfo">A <term>TokenInfo</term> 
        represents a contiguous collection of tokens from an XML document. 
        </termdef>
        Each <term>TokenInfo</term> is associated with:</p><ulist><item><p>
                        <code>startPos</code>: the smallest starting position
                of a token in the sequence</p></item><item><p>
                        <code>endPos</code>: the largest ending position
                of any token of the sequence</p></item><item><p>
                        <code>startSent</code>: the relative position of the 
                sentence containing the token with the smallest starting
                position
                or zero if the tokenizer does not report
                sentences</p></item><item><p>
                        <code>endSent</code>: the relative position of the sentence 
                containing the token with the largest ending position
                or zero if the tokenizer does not report
                sentences</p></item><item><p>
                        <code>startPara</code>: the relative position of the 
                paragraph containing the token with the smallest starting
                position or zero if the tokenizer does not report
                paragraphs</p></item><item><p>
                        <code>endPara</code>: the relative position of the paragraph
                containing the token with the largest ending position or
                zero if the tokenizer does not report paragraphs</p></item></ulist><p>The following matching function is the central
        <termref def="dt-implementation-defined">implementation-defined</termref> primitive performing the full-text
        retrieval.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:matchTokenInfos (
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $stopWords as xs:string*,
      $queryTokens as element(fts:queryToken)* )
   as element(fts:tokenInfo)*  external;
            </eg><p>The above function returns the <term>TokenInfo</term>s in items in
        <code>$searchContext</code> that match the query string represented by
        the sequence <code>$queryTokens</code>, when using the match
        options in <code>$matchOptions</code> and stop words in
        <code>$stopWords</code>. If <code>$queryTokens</code> is a
        sequence of more than one query token, each returned
        <term>TokenInfo</term> must represent a phrase matching that sequence. 
        </p><note><p>While this matching function assumes a tokenized
      representation of the query strings, it does not assume a tokenized
      representation of the input items in <code>$searchContext</code>,
      i.e. the texts being searched.
      Hence, the tokenization of the search context is implicit in
      this function and coupled to the retrieval of matches. 
      Of course, this does not imply that tokenization of the
      search context cannot be done a priori. 
      The tokenization of each item in <code>$searchContext</code> does not
      necessarily take into account the match options in
      <code>$matchOptions</code> or the query tokens in
      <code>$queryTokens</code>. 
      This allows implementations to tokenize and index input data
      without the knowledge of particular match options
      used in full-text queries.</p></note></div3></div2><!-- ***********************************************
         ***               AllMatches                ***
         *********************************************** --><div2 role="xquery" id="FTSelectionEvalSec"><head>Evaluation of FTSelections</head><p>The XQuery 1.0 and XPath 2.0 Data Model is
        inadequate to support fully composable <term>FTSelection</term>s. 
        Full-text operations, such as <term>FTSelection</term>s, operate on linguistic
        units, such as positions of tokens, and which are not captured
        in the XQuery 1.0 and XPath 2.0 Data Model (XDM). </p><p>XQuery and XPath Full Text adds relative token, sentence, and 
		paragraph position numbers via <term>AllMatches</term>. <term>AllMatches</term> make 
		<term>FTSelection</term>s fully composable.</p><!-- **********************************************************************
         *                            AllMatches                              *
         ********************************************************************** --><div3 role="xquery" id="AllMatchesSec"><head>AllMatches</head><div4 role="xquery" id="tq-ft-formalmodel"><head>Formal Model</head><p>
                     <termdef id="AllMatchesDef" term="AllMatches">An <term>AllMatches</term>
                describes the possible results of an <term>FTSelection</term>.</termdef>
                The UML Static Class diagram of <term>AllMatches</term> is shown
                on the diagram given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/AllMatchesClassDiagram.png" alt="AllMatches class diagram" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>The <term>AllMatches</term> object contains zero or more <term>Match</term>es. </p><p>
                     <termdef id="MatchDef" term="Match">Each  
                <term>Match</term> describes one result to the <term>FTSelection</term>.</termdef> 
				The result is described in terms of zero or more <term>StringInclude</term>s and zero
                or more <term>StringExclude</term>s.</p><p>
                     <termdef id="StringMatchDef" term="StringMatch">A
				<term>StringMatch</term> is a
				possible match of a sequence of query
				tokens with a corresponding sequence
				of tokens in a document. A StringMatch may be a <term>StringInclude</term>
				or <term>StringExclude</term>.</termdef> The <term>queryPos</term> 
				attribute specifies the position of the query token in the 
				query. This attribute is needed for <term>FTOrder</term>s. The matched
				document token sequence is described in the <term>TokenInfo</term> 
                associated with
				the <term>StringMatch</term>.</p><p>
                     <termdef id="StringIncludeDef" term="StringInclude">A <term>StringInclude</term>
				is a <term>StringMatch</term> that describes a <term>TokenInfo</term> that must be
				contained in the document.</termdef>
                  </p><p>
                     <termdef id="StringExcludeDef" term="StringExclude">A <term>StringExclude</term>
				is a <term>StringMatch</term> that describes a <term>TokenInfo</term> that must not be
				contained in the document.</termdef>
                  </p><p>Intuitively, <term>AllMatches</term> specifies the <term>TokenInfo</term>s that a
                search context item contains and does not contain to satisfy an <term>FTSelection</term>.</p><p>The <term>AllMatches</term> structure resembles the Disjunctive Normal
                Form (DNF) in propositional and first-order logic. The
                <term>AllMatches</term> is a disjunction of <term>Match</term>es. Each <term>Match</term> is a
                conjunction of <term>StringInclude</term>s, and <term>StringExclude</term>s. </p></div4><div4 role="xquery" id="tq-ft-AllMatches-examples"><head>Examples</head><p>Since in most of the examples below the tokens span only a single 
                position, we characterize the <term>TokenInfo</term> instance by simply giving this position, 
                written as "Pos:X". This should be read as the value for both, the 
                <code>startPos</code> and the <code>endPos</code>
                attribute. Furthermore, for expository reasons, we
                include in each <term>StringMatch</term> example an attribute
                "query string", set to the original
                query string, in order to facilitate the association
                from which query string that match came from.</p><p>The simplest example of an <term>FTSelection</term> is an <term>FTWords</term> such 
				as  <code>"Mustang"</code>. The
                <term>AllMatches</term> corresponding to this <term>FTWords</term> is given below. </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/SampleAllMatches1.jpg" alt="Sample AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>As shown, the <term>AllMatches</term> consists of two <term>Match</term>es. Each
                <term>Match</term> represents one possible result of the <term>FTWords</term>
                     <code>"Mustang"</code>. The result represented by the first
                <term>Match</term>, represented as a <term>StringInclude</term>, contains the token
                "Mustang" at position 2. The result described by the second <term>Match</term>
                contains the token "Mustang" at position 28. </p><p>A more complex example of an <term>FTSelection</term> is an <term>FTWords</term> 
				such as <code>"Ford Mustang"</code>. The <term>AllMatches</term> for this 
				<term>FTWords</term> is given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/SampleAllMatches2.jpg" alt="Sample AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>There are two possible results for this <term>FTWords</term>, and
                these are represented by the two <term>Match</term>es. Each of the
                <term>Match</term>es requires two tokens to be matched. The first <term>Match</term> is 
				obtained by matching "Ford" at position 1 and matching "Mustang" at position 2.
                Similarly, the second <term>Match</term> is obtained by
                matching "Ford" at position 27 and "Mustang" at position 28.</p><p>An even more complex example of an <term>FTSelection</term> is an 
				<term>FTSelection</term> such as <code>"Mustang"
                ftand ftnot "rust"</code> that searches for 
                "Mustang" but not "rust". The <term>AllMatches</term> for this
                <term>FTSelection</term> is given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/SampleAllMatches3.jpg" alt="Sample AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>This example introduces <term>StringExclude</term>. <term>StringExclude</term> 
				corresponds to negation in DNF (Disjunctive Normal Form). It specifies that the 
                result described by the corresponding <term>Match</term> must not match the token at 
                the specified position. In this example, the first <term>Match</term> specifies 
                that "Mustang" is matched at position 2, and that the token "rust" 
                at position 34 is not matched.</p></div4><!-- **********************************************************************
             *                            XML Representation                      *
             ********************************************************************** --><div4 id="tq-ft-XML-representation"><head>XML representation</head><p> 
                     <term>AllMatches</term> has a well-defined hierarchical
                structure. Therefore, the <term>AllMatches</term> can be easily
                modeled in XML. 
                This XML representation and those which follow formally describe the
                semantics of <term>FTSelection</term>s. For example, 
                the XML representation of <term>AllMatches</term> formally
                specifies how an <term>FTSelection</term> operates on zero or more
                <term>AllMatches</term> to produce a resulting <term>AllMatches</term>. </p><p>The XML schema for representing <term>AllMatches</term> is
                given below.</p><!-- file: AllMatches.xsd --><eg role="semfunc-file-allmatches-xsd" xml:space="preserve">
&lt;xs:schema 
     xmlns:xs="http://www.w3.org/2001/XMLSchema" 
     xmlns:fts="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified" 
     attributeFormDefault="unqualified"&gt;

  &lt;xs:complexType name="allMatches"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:match" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="stokenNum" type="xs:integer" use="required" /&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="allMatches" type="fts:allMatches"/&gt;

  &lt;xs:complexType name="match"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:stringInclude" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
      &lt;xs:element ref="fts:stringExclude" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
   &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:element name="stringInclude" 
              type="fts:stringMatch" /&gt;

  &lt;xs:element name="stringExclude" 
              type="fts:stringMatch" /&gt;

  &lt;xs:element name="match" type="fts:match"/&gt;

  &lt;xs:complexType name="stringMatch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:tokenInfo"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="queryPos" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="isContiguous" 
                  type="xs:boolean" 
                  use="required"/&gt;  
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="tokenInfo"&gt;
    &lt;xs:attribute name="startPos" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="endPos" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="startSent" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="endSent" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="startPara" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="endPara" 
                  type="xs:integer" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="tokenInfo" type="fts:tokenInfo"/&gt;

  &lt;xs:complexType name="queryItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:queryToken" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
   &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="queryTokenInfo"&gt;
    &lt;xs:attribute name="word" 
                  type="xs:string" 
                  use="required"/&gt;
    &lt;xs:attribute name="queryPos" 
                  type="xs:integer" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="queryToken" type="fts:queryTokenInfo"/&gt;
&lt;/xs:schema&gt;
                </eg><p>The <code>stokenNum</code> attribute in 
	<term>AllMatches</term> is related to the representation of the semantics as XQuery functions. 
	Therefore, it is not considered part of the <term>AllMatches</term> model.
	The <code>stokenNum</code> attribute stores
	the number of query tokens used when evaluating the <term>AllMatches</term>. This 
	value is used to compute the correct value for the <code>queryPos</code>
	attribute in new <term>StringMatch</term>es. </p></div4></div3><!-- *************************************************************
         ***                       FTSelections                    ***
         ************************************************************* --><div3 role="xquery" id="FTSelectionsXMLSec"><head>XML Representation</head><p>
                  <term>FTSelection</term>s are fully composable and may be nested arbitrarily under
        other <term>FTSelection</term>s. Each <term>FTSelection</term> may be associated with
        match options (such as stemming and stop words) and score weights.
        Since score weights are solely interpreted by the formal semantics
        scoring function, they do not influence the semantics of
        <term>FTSelection</term>s. Therefore, score weights are not considered in
        the formal semantics.</p><p>
            The XML structures defined by the following schema
            represent <term>FTSelection</term>s
            within the semantic functions of section <specref ref="tq-semantics"/>.
            This representation is used for definitional purposes only
            and should not be confused with
            the XML representation for queries in Appendix <specref ref="id-xqft-xqueryx"/>.
	    Every <term>FTSelection</term>
	    is represented as an XML element. Every nested <term>FTSelection</term> is
	    represented as a nested descendant element. 
	    For binary <term>FTSelection</term>s, e.g., <term>FTAnd</term>, the nested <term>FTSelection</term>s
	    are represented in <code>&lt;left&gt;</code> and <code>&lt;right&gt;
	    </code> descendant elements. For unary <term>FTSelection</term>s, a 
	    <code>&lt;selection&gt;</code> descendant element is used. Additional
	    characteristics of <term>FTSelection</term>s, e.g., the distance unit for
	    <term>FTDistance</term>, are stored in attributes. </p><!-- file: FTSelection.xsd --><eg role="semfunc-file-ftselection-xsd" xml:space="preserve">
&lt;xs:schema
     xmlns:xs="http://www.w3.org/2001/XMLSchema" 
     xmlns:fts="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified" 
     attributeFormDefault="unqualified"&gt;
           
  &lt;xs:include schemaLocation="AllMatches.xsd" /&gt;
  &lt;xs:include schemaLocation="MatchOptions.xsd" /&gt;

  &lt;xs:complexType name="ftSelection"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element name="ftWords" type="fts:ftWords"/&gt;
        &lt;xs:element name="ftAnd" type="fts:ftAnd"/&gt;
        &lt;xs:element name="ftOr" type="fts:ftOr"/&gt;
        &lt;xs:element name="ftUnaryNot" type="fts:ftUnaryNot"/&gt;
        &lt;xs:element name="ftMildNot" type="fts:ftMildNot"/&gt;
        &lt;xs:element name="ftOrder" type="fts:ftOrder"/&gt;
        &lt;xs:element name="ftScope" type="fts:ftScope"/&gt;
        &lt;xs:element name="ftContent" type="fts:ftContent"/&gt;
        &lt;xs:element name="ftDistance" type="fts:ftDistance"/&gt;
        &lt;xs:element name="ftWindow" type="fts:ftWindow"/&gt;
        &lt;xs:element name="ftTimes" type="fts:ftTimes"/&gt;
      &lt;/xs:choice&gt;
      &lt;xs:element ref="fts:matchOptions" 
                  minOccurs="0"/&gt;
      &lt;xs:element name="weight" 
                  type="xs:double" 
                  minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="selection" type="fts:ftSelection"/&gt;

  &lt;xs:complexType name="ftWords"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:queryItem" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:ftWordsType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="queryItem" type="fts:queryItem"/&gt;
  
  &lt;xs:complexType name="ftAnd"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="left" type="fts:ftSelection"/&gt;
      &lt;xs:element name="right" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftOr"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="left" type="fts:ftSelection"/&gt;
      &lt;xs:element name="right" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftUnaryNot"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftMildNot"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="left" type="fts:ftSelection"/&gt;
      &lt;xs:element name="right" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftOrder"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftScope"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:scopeType" 
                  use="required"/&gt;
    &lt;xs:attribute name="scope" 
                  type="fts:scopeSelector" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftContent"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:contentMatchType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftDistance"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="range" type="fts:ftRangeSpec"/&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:distanceType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftWindow"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="size" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="type" 
                  type="fts:distanceType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftTimes"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="range" type="fts:ftRangeSpec"/&gt;
      &lt;xs:element name="selection" type="fts:ftWords"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
    
  &lt;xs:simpleType name="ftWordsType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="any"/&gt;
      &lt;xs:enumeration value="all"/&gt;
      &lt;xs:enumeration value="phrase"/&gt;
      &lt;xs:enumeration value="any word"/&gt;
      &lt;xs:enumeration value="all word"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="scopeType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="same"/&gt;
      &lt;xs:enumeration value="different"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="scopeSelector"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="paragraph"/&gt;
      &lt;xs:enumeration value="sentence"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="distanceType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="paragraph"/&gt;
      &lt;xs:enumeration value="sentence"/&gt;
      &lt;xs:enumeration value="word"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="contentMatchType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="at start"/&gt;
      &lt;xs:enumeration value="at end"/&gt;
      &lt;xs:enumeration value="entire content"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
&lt;/xs:schema&gt;
            </eg></div3><!-- **********************************************************************
             *                       The evaluate function                        *
             ********************************************************************** --><div3 role="xquery" id="tq-ft-evaluate-function"><head>The <function>evaluate</function> function</head><p>The semantics for the evaluation of
            <term>FTSelection</term>s is defined using the <function>fts:evaluate</function> 
			function. The function takes three
            parameters: (1) an <term>FTSelection</term>, 2) a search
            context item, and 3) the default set of match options
            that apply to the evaluation of the <term>FTSelection</term>.</p><p>The <function>fts:evaluate</function> function returns the
            <term>AllMatches</term> that is the result of evaluating the
            <term>FTSelection</term>. When <function>fts:evaluate</function> is applied to some
            <term>FTSelection</term> X, it calls the function
            <function>fts:ApplyX</function> to build the resulting <term>AllMatches</term>.
            If X is applied on nested <term>FTSelection</term>s, the 
            <function>fts:evaluate</function> function is recursively called on these nested
            <term>FTSelection</term>s and the returned <term>AllMatches</term> are used in the evaluation of
            <function>fts:ApplyX</function>.
            </p><p>The semantics for the <function>fts:evaluate</function> function 
            is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:evaluate (
      $ftSelection as element(*, fts:ftSelection), 
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $queryTokenNum as xs:integer )
   as element(fts:allMatches)
{
   if (fn:count($ftSelection/fts:matchOptions) &gt; 0) then 
      (: First we deal with all match options that the    :)
      (: FTSelection might bear: we add the match options :)
      (: to the current match options structure, and      :)
      (: pass the new structure to the recursive call.    :)
      let $newFTSelection := 
         &lt;fts:selection&gt;{$ftSelection/*
                           [fn:not(self::fts:matchOptions)]}&lt;/fts:selection&gt;
      return fts:evaluate($newFTSelection, 
                          $searchContext, 
                          fts:replaceMatchOptions($matchOptions, 
                                              $ftSelection/fts:matchOptions),
                          $queryTokenNum)
   else if (fn:count($ftSelection/fts:weight) &gt; 0) then
      (: Weight has no bearing on semantics -- just :)
      (: call "evaluate" on nested FTSelection     :)
      let $newFTSelection := $ftSelection/*[fn:not(self::fts:weight)]
      return fts:evaluate($newFTSelection, 
                          $searchContext, 
                          $matchOptions,
                          $queryTokenNum)
   else
      typeswitch ($ftSelection/*[1]) 
         case $nftSelection as element(fts:ftWords) return
            (: Apply the FTWords in the search context :)
            fts:ApplyFTWords($searchContext,
                             $matchOptions,
                             $nftSelection/@type,
                             $nftSelection/fts:queryItem,
                             $queryTokenNum + 1)
         case $nftSelection as element(fts:ftAnd) return
            let $left := fts:evaluate($nftSelection/fts:left,
                                     $searchContext,
                                     $matchOptions,
                                     $queryTokenNum)
            let $newQueryTokenNum := $left/@stokenNum
            let $right := fts:evaluate($nftSelection/fts:right,
                                      $searchContext,
                                      $matchOptions,
                                      $newQueryTokenNum)
            return fts:ApplyFTAnd($left, $right)
         case $nftSelection as element(fts:ftOr) return
            let $left := fts:evaluate($nftSelection/fts:left,
                                     $searchContext,
                                     $matchOptions,
                                     $queryTokenNum)
            let $newQueryTokenNum := $left/@stokenNum
            let $right := fts:evaluate($nftSelection/fts:right,
                                      $searchContext,
                                      $matchOptions,
                                      $newQueryTokenNum)
            return fts:ApplyFTOr($left, $right)
         case $nftSelection as element(fts:ftUnaryNot) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTUnaryNot($nested)
         case $nftSelection as element(fts:ftMildNot) return
            let $left := fts:evaluate($nftSelection/fts:left,
                                     $searchContext,
                                     $matchOptions,
                                     $queryTokenNum)
            let $newQueryTokenNum := $left/@stokenNum
            let $right := fts:evaluate($nftSelection/fts:right,
                                      $searchContext,
                                      $matchOptions,
                                      $newQueryTokenNum)
            return fts:ApplyFTMildNot($left, $right)
         case $nftSelection as element(fts:ftOrder) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTOrder($nested)
         case $nftSelection as element(fts:ftScope) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTScope($nftSelection/@type, 
                                    $nftSelection/@scope,
                                    $nested)
         case $nftSelection as element(fts:ftContent) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTContent($searchContext,
                                      $nftSelection/@type, 
                                      $nested)
         case $nftSelection as element(fts:ftDistance) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTDistance($nftSelection/@type,
                                       $nftSelection/fts:range,
                                       $nested)
         case $nftSelection as element(fts:ftWindow) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTWindow($nftSelection/@type,
                                     $nftSelection/@size,
                                     $nested)
         case $nftSelection as element(fts:ftTimes) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTTimes($nftSelection/fts:range,
                                    $nested)
         default return ()
};
            </eg><p>For
            concreteness, assume that the <term>FTSelection</term> was
            invoked inside an <code>ftcontains</code> expression such
            as <code>searchContext ftcontains ftSelection</code>. In order to 
	    determine the
            <term>AllMatches</term> result of <code>ftSelection</code>, the
            <function>fts:evaluate</function> function is invoked as
            follows: <code>fts:evaluate($ftSelection,
            $searchContext, $matchOptions, 0)</code>, where
            <code>$ftSelection</code> is the XML representation of the
            <code>ftSelection</code> and
            <code>$searchContext</code> is bound to the result of
            the evaluation of the XQuery expression
            <code>searchContext</code>. </p><p>Initially, the
            <code>$queryTokensNum</code> is 0, i.e., no
            query tokens have been processed.</p><p>The variable <code>$matchOptions</code> is bound to the 
            list of match options as defined in the static context (see
            Appendix <specref ref="id-xqft-static-context-components"/>).
			Match options embedded in
            <code>$ftSelection</code> modify the match options collection as
            evaluation proceeds. </p><p>Given the invocation of: <code>fts:evaluate($ftSelection,
            $searchContext, $matchOptions)</code>, evaluation proceeds as
            follows. First, <code>$ftSelection</code> is checked to see whether
	    1) it contains a match option,
	    2) it contains a weight specification,
	    3) it is an <term>FTWords</term>, or
	    4) none of the above hold.
            </p><olist><item><p>If <code>$ftSelection</code> contains one or more match options,
            these are combined with the inherited match options
            via a call to <function>fts:replaceMatchOptions</function>
            (see <specref ref="FTMatchOptionsSec"/>).
            The <function>evaluate</function> function is then invoked on the
            nested <term>FTSelection</term> with the new set of match options,
            and the result of that call is returned.
            </p></item><item><p>If <code>$ftSelection</code> contains a weight
            specification, then the specification is ignored because it
            does not alter the semantics. The <function>evaluate</function>
            function is recursively called on the nested <term>FTSelection</term> and the
            resulting <term>AllMatches</term> is returned. </p></item><item><p>If <code>$ftSelection</code> is an <term>FTWords</term>, then 
			it does
            not have any nested <term>FTSelection</term>s. Consequently, this is the base
            of the recursive call, and the <term>AllMatches</term> result of the <term>FTWords</term>
            is computed and returned. The <term>AllMatches</term> is computed by invoking
            the <function>ApplyFTWords</function> function with the current
            search context and other necessary information. </p></item><item><p>If <code>$ftSelection</code> contains neither a match
            option nor a weight specification and is not an <term>FTWords</term>, the
            <term>FTSelection</term> performs a full-text operation, such as
            <code>ftand</code>, <code>ftor</code>, <code>window</code>.
            These operations are fully-compositional and may be
            invoked on nested <term>FTSelection</term>s. Consequently, evaluation proceeds
            as follows. </p><ulist><item><p>First, the <function>evaluate</function> function is
            recursively invoked on each nested <term>FTSelection</term>.
				The result of
            evaluating each nested <term>FTSelection</term> is an <term>AllMatches</term>. </p></item><item><p>The <term>AllMatches</term> are transformed into the resulting 
			<term>AllMatches</term> by applying the full-text operation corresponding to 
			<code>FTSelection1</code> which is
            generically named <function>applyX</function> for some type of
            <term>FTSelection</term> X in the code.  </p></item></ulist><p>For example, let
            <code>FTSelection1</code> be <code>FTSelection2 ftand
            FTSelection3 </code>. Here <code>FTSelection2</code> and
            <code>FTSelection3</code> may themselves be arbitrarily nested
            <term>FTSelection</term>s. Thus, <function> evaluate</function> is invoked on
            <code>FTSelection2</code> and <code> FTSelection3</code>, and the
            resulting <term>AllMatches</term> are transformed to the final <term>AllMatches</term>
            using the <function> ApplyFTAnd</function> function corresponding to
            <code>ftand </code>.</p></item></olist><p>The semantics of the <function>ApplyX</function> function for
            each <term>FTSelection</term> kind X is given below.</p></div3><!-- **********************************************************************
             *                     Formal semantics functions                     *
             ********************************************************************** --><div3 role="xquery" id="tq-ft-formal-semantics-functions"><head>Formal semantics functions</head><p>The formal semantics of the <function>applyX</function>
            functions for each <term>FTSelection</term> kind X is specified by
            five functions. How two of these functions are computed is
            <termref def="dt-implementation-dependent">implementation-dependent</termref>, but all the functions must satisfy some
            well-defined properties. </p><p>The <function>wordDistance</function> function returns the
            number of tokens that occur between the positions of the
            <term>TokenInfo</term>s <code>$tokenInfo1</code> and
            <code>$tokenInfo2</code>. For example, two tokens with consecutive
            positions have a distance of 0 tokens, and two overlapping tokens
            have a distance of -1 tokens. </p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:wordDistance (
             $tokenInfo1 as element(fts:tokenInfo),
             $tokenInfo2 as element(fts:tokenInfo) )
   as xs:integer
{
   (: Ensure tokens are in order :)
   let $sorted := 
     for $ti in ($tokenInfo1, $tokenInfo2) 
     order by $ti/@startPos ascending, $ti/@endPos ascending
     return $ti
   return
     (: -1 because we count starting at 0 :)
     $sorted[2]/@startPos - $sorted[1]/@endPos - 1
};
            </eg><p>The <function>sentenceDistance</function> function 
            returns the number of sentences between the
            <term>TokenInfo</term>s <code>$tokenInfo1</code> and
            <code>$tokenInfo2</code>. </p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:sentenceDistance (
             $tokenInfo1 as element(fts:tokenInfo),
             $tokenInfo2 as element(fts:tokenInfo) )
   as xs:integer
{
   (: Ensure tokens are in order :)
   let $sorted := 
     for $ti in ($tokenInfo1, $tokenInfo2) 
     order by $ti/@startPos ascending, $ti/@endPos ascending
     return $ti
   return
     (: -1 because we count starting at 0 :)
     $sorted[2]/@startSent - $sorted[1]/@endSent - 1
};
            </eg><p>The <function>paraDistance</function> function returns the number of
            paragraphs between the <term>TokenInfo</term>s
            <code>$tokenInfo1</code> and <code>$tokenInfo2</code>.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:paraDistance (
             $tokenInfo1 as element(fts:tokenInfo),
             $tokenInfo2 as element(fts:tokenInfo) )
   as xs:integer 
{
   (: Ensure tokens are in order :)
   let $sorted := 
     for $ti in ($tokenInfo1, $tokenInfo2) 
     order by $ti/@startPos ascending, $ti/@endPos ascending
     return $ti
   return
     (: -1 because we count starting at 0 :)
     $sorted[2]/@startPara - $sorted[1]/@endPara - 1
};
            </eg><p>The <function>isStartToken</function> function
            returns true if the <term>TokenInfo</term> 
                  <code>$tokenInfo</code> 
            describes a token whose starting position is the first position of
            the item <code>$searchContext</code>. </p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:isStartToken (
             $searchContext as item(),
             $tokenInfo as element(fts:tokenInfo) ) 
   as xs:boolean external;
            </eg><p>The <function>isEndToken</function> function
            returns true if the <term>TokenInfo</term> 
                  <code>$tokenInfo</code> 
            describes a token whose ending position is the last position of
            the item <code>$searchContext</code>. </p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:isEndToken (
             $searchContext as item(),
             $tokenInfo as element(fts:tokenInfo) ) 
   as xs:boolean external;
            </eg></div3><!-- **********************************************************************
             *                            FTWords                       *
             ********************************************************************** --><div3 role="xquery" id="tq-ft-fs-FTWords"><head>FTWords</head><p>An <term>FTWords</term> that consists of a single
            query string consisting of a sequence of token to be
            matched as a phrase is evaluated by 
            the <function>applyQueryTokensAsPhrase</function> function. Its parameters 
            are 1) the search context, 2) the list of match options, 3) the query
            string to be matched as a sequence of <code>fts:queryToken</code>
            items, and 4) the position where the latter query string occurs in the
            query. 
            </p><!-- file: fts-simple.xqy --><eg role="semfunc-file-ftssimple-xquery" xml:space="preserve">
(: simplified version not dealing with special match options :)
declare function fts:applyQueryTokensAsPhrase (
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $queryTokens as element(fts:queryToken)*,
      $queryPos as xs:integer )
   as element(fts:allMatches)
{
   &lt;fts:allMatches stokenNum="{$queryPos}"&gt; 
   {
      for $tokenInfo in
         fts:matchTokenInfos( 
            $searchContext,
            $matchOptions,
            (),
            $queryTokens )
      return  
         &lt;fts:match&gt;  
            &lt;fts:stringInclude queryPos="{$queryPos}" isContiguous="true"&gt; 
            {$tokenInfo}
            &lt;/fts:stringInclude&gt; 
         &lt;/fts:match&gt;
   } 
   &lt;/fts:allMatches&gt;
};
</eg><p>If after the application of all the match options, the sequence 
			of query tokens returned for an <term>FTWords</term> is empty, an empty
            <term>AllMatches</term> is returned. </p><p>The <term>AllMatches</term> corresponding to an
            <term>FTWords</term> is a set of <term>Match</term>es. Each of the <term>Match</term>es
            is associated with a starting and an ending position indicating where the corresponding
            query tokens were found. For example, the <term>AllMatches</term>
            result for the <term>FTWords</term> "Mustang" is given
            below. To simplify the presentation in the figures we write
            <code>Pos: N</code>, if the attributes
            <code>startPos</code> and <code>endPos</code> are the same
            with <code>N</code> being that position.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTWordEx.jpg" alt="FTWords example" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>There are five variations of <term>FTWords</term> depending on how the 
			tokens and phrases in the nested XQuery 1.0 and XPath 2.0 
			expression are matched. </p><ulist><item><p>When <code>any word</code> is specified, at 
			least one token in the tokenization of the nested expression must be 
			matched. </p></item><item><p>When <code>all word</code> is specified, all 
			tokens in the tokenization of the nested expression must be 
			matched.</p></item><item><p>When <code>phrase</code> is specified, all 
			tokens in the tokenization of the nested expression must be 
			matched as a phrase.</p></item><item><p>When <code>any</code> is specified, at least one 
			string atomic value in the nested expression must be 
			matched as a phrase.</p></item><item><p>When <code>all</code> is specified, all 
			string atomic values in the nested expression must be 
			matched as a phrase.</p></item></ulist><p>The semantics for <term>FTWords</term> when <code>any word</code> is specified 
			is given below. Since <term>FTWords</term>
            does not have nested <term>FTSelection</term>s, the
            <function>ApplyFTWords</function> function does not take 
            <term>AllMatches</term> parameters corresponding to nested
            <term>FTSelection</term> results.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:MakeDisjunction (
      $curRes as element(fts:allMatches),
      $rest as element(fts:allMatches)* ) 
   as element(fts:allMatches) 
{
   if (fn:count($rest) = 0)
   then $curRes
   else 
      let $firstAllMatches := $rest[1]
      let $restAllMatches := fn:subsequence($rest, 2)
      let $newCurRes := fts:ApplyFTOr($curRes, 
                                      $firstAllMatches)
      return fts:MakeDisjunction($newCurRes, 
                                 $restAllMatches)
};

declare function fts:ApplyFTWordsAnyWord (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   (: Tokenization of query string has already occurred. :)
   (: Get sequence of QueryTokens over all query items. :)
   let $queryTokens := $queryItems/fts:queryToken
   return
      if (fn:count($queryItems) eq 0) 
      then &lt;fts:allMatches stokenNum="0" /&gt;
      else
         let $allAllMatches := 
            for $queryToken at $pos in $queryTokens
            return fts:applyQueryTokensAsPhrase($searchContext,
                                                 $matchOptions,
                                                 $queryToken,
                                                 $queryPos + $pos - 1)
         let $firstAllMatches := $allAllMatches[1]
         let $restAllMatches := fn:subsequence($allAllMatches, 2)
         return fts:MakeDisjunction($firstAllMatches, $restAllMatches)
};
</eg><p>The tokenized query strings are passed to
            ApplyFTWordsAnyWord as a sequence of
            <code>fts:queryItem</code>, each containing the tokens of
            a single query string. A single flattened sequence of all
            tokens (of type <code>fts:queryToken</code>) over all
            query items is constructed. For each of these,
            the result of <term>FTWords</term> is computed using
            <function>applyQueryTokensAsPhrase</function>. Finally, the
            disjunction of all resulting <term>AllMatches</term> is computed.</p><p>The semantics for <term>FTWords</term> when <code>all word</code>
            is specified is similar to the above, however composes a
            conjunction. It is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:MakeConjunction ( 
      $curRes as element(fts:allMatches),
      $rest as element(fts:allMatches)* ) 
   as element(fts:allMatches)
{
   if (fn:count($rest) = 0)
   then $curRes
   else 
      let $firstAllMatches := $rest[1]
      let $restAllMatches := fn:subsequence($rest, 2)
      let $newCurRes := fts:ApplyFTAnd($curRes, 
                                       $firstAllMatches)
      return fts:MakeConjunction($newCurRes, 
                                 $restAllMatches)
};

declare function fts:ApplyFTWordsAllWord (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   (: Tokenization of query strings has already occurred. :)
   (: Get sequence of QueryTokens over all query items :)
   let $queryTokens := $queryItems/fts:queryToken
   return
      if (fn:count($queryTokens) eq 0) 
      then &lt;fts:allMatches stokenNum="0" /&gt;
      else
         let $allAllMatches := 
            for $queryToken at $pos in $queryTokens
            return fts:applyQueryTokensAsPhrase($searchContext,
                                                 $matchOptions,
                                                 $queryToken,
                                                 $queryPos + $pos - 1)
            let $firstAllMatches := $allAllMatches[1]
            let $restAllMatches := fn:subsequence($allAllMatches, 2)
            return fts:MakeConjunction($firstAllMatches, $restAllMatches)
};
</eg><p>The semantics for <term>FTWords</term> if <code>phrase</code> is specified 
			is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTWordsPhrase (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   (: Get sequence of QueryTokenInfos over all query items :)
   let $queryTokens := $queryItems/fts:queryToken
   return
      if (fn:count($queryTokens) eq 0) 
      then &lt;fts:allMatches stokenNum="0" /&gt;
      else
         fts:applyQueryTokensAsPhrase($searchContext,
                                       $matchOptions,
                                       $queryTokens,
                                       $queryPos)
};
</eg><p>The <function>ApplyFTWordsPhrase</function> function
            also flattens the sequence of query items to a sequence of
            query tokens, but then calls
            <function>applyQueryTokensAsPhrase</function> on that
            entire sequence, instead of calling it on each query token
            individually. Hence, the sequence of all query tokens is
            matched as a single phrase and the computed <term>TokenInfo</term>s
            are returned.</p><p>The semantics for <term>FTWords</term> when <code>any</code> is specified is 
			given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTWordsAny (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   if (fn:count($queryItems) eq 0) 
   then &lt;fts:allMatches stokenNum="0" /&gt;
   else 
      let $firstQueryItem := $queryItems[1]
      let $restQueryItem := fn:subsequence($queryItems, 2)
      let $firstAllMatches := 
         fts:ApplyFTWordsPhrase($searchContext,
                                $matchOptions,
                                $firstQueryItem,
                                $queryPos)
      let $newQueryPos := 
         if ($firstAllMatches//@queryPos) 
         then fn:max($firstAllMatches//@queryPos) + 1
         else $queryPos
      let $restAllMatches :=
         fts:ApplyFTWordsAny($searchContext,
                             $matchOptions,
                             $restQueryItem,
                             $newQueryPos)
      return fts:ApplyFTOr($firstAllMatches, $restAllMatches)
};
</eg><p>The <term>FTWords</term> with <code>any</code>
            specified forms the disjunction of the <term>AllMatches</term> that
            are the result of the matching of each query item as a phrase.</p><p>The semantics for <term>FTWords</term> when <code>all </code> is specified 
			is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTWordsAll (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   if (fn:count($queryItems) = 0) 
   then &lt;fts:allMatches stokenNum="0" /&gt;
   else 
      let $firstQueryItem := $queryItems[1]
      let $restQueryItem := fn:subsequence($queryItems, 2)
      let $firstAllMatches := 
         fts:ApplyFTWordsPhrase($searchContext,
                                $matchOptions,
                                $firstQueryItem,
                                $queryPos)
      return
         if ($restQueryItem) then
            let $newQueryPos := 
               if ($firstAllMatches//@queryPos) 
               then fn:max($firstAllMatches//@queryPos) + 1
               else $queryPos
            let $restAllMatches :=
               fts:ApplyFTWordsAll($searchContext,
                                   $matchOptions,
                                   $restQueryItem,
                                   $newQueryPos)
            return 
               fts:ApplyFTAnd($firstAllMatches, $restAllMatches)
         else $firstAllMatches
};
</eg><p>The difference between <code>all</code> and 
            <code>any</code> is the use of conjunction instead of
            disjunction.</p><p>The <function>ApplyFTWords</function> function combines
            all of these functions.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTWords ( 
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $type as fts:ftWordsType,
      $queryItems as element(fts:queryItem)*, 
      $queryPos as xs:integer )
   as element(fts:allMatches) 
{
   if ($type eq "any word")
   then fts:ApplyFTWordsAnyWord($searchContext,
                                $matchOptions,
                                $queryItems,
                                $queryPos)
   else if ($type eq "all word")
   then fts:ApplyFTWordsAllWord($searchContext,
                                $matchOptions,
                                $queryItems,
                                $queryPos)
   else if ($type eq "phrase")
   then fts:ApplyFTWordsPhrase($searchContext,
                               $matchOptions,
                               $queryItems,
                               $queryPos)
   else if ($type eq "any")
   then fts:ApplyFTWordsAny($searchContext,
                            $matchOptions,
                            $queryItems,
                            $queryPos)
   else fts:ApplyFTWordsAll($searchContext,
                            $matchOptions,
                            $queryItems,
                            $queryPos)
};
                </eg></div3><!-- *************************************************************
         ***                  Match Options Semantics              ***
         ************************************************************* --><div3 role="xquery" id="FTMatchOptionsSec"><head>Match Options Semantics</head><div4 role="xquery" id="tq-ft-matchopt-types"><head>Types</head><p>XQuery 1.0 functions are used to 
            define the semantics of <term>FTMatchOption</term>s. These functions 
            operate on an XML representation of the <term>FTMatchOption</term>s. 
            The representation closely follows the 
            <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftmatchoptions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">syntax</loc>. Each <term>FTMatchOption</term> is 
	    represented by an XML element. Additional characteristics of the match 
	    option are represented as attributes.
	    The schema is given below.</p><!-- file: MatchOptions.xsd --><eg xml:space="preserve">
&lt;xs:schema 
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    xmlns:fts="http://www.w3.org/2007/xpath-full-text"
    targetNamespace="http://www.w3.org/2007/xpath-full-text"
    elementFormDefault="qualified" 
    attributeFormDefault="unqualified"&gt;

  &lt;xs:complexType name="ftMatchOptions"&gt;
    &lt;xs:sequence&gt;
       &lt;xs:element ref="fts:thesaurus" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:stopwords" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:case" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:diacritics" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:stem" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:wildcard" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:language" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="matchOptions" type="fts:ftMatchOptions"/&gt;

  &lt;xs:element name="case" type="fts:ftCaseOption" /&gt;
  &lt;xs:element name="diacritics" type="fts:ftDiacriticsOption" /&gt;
  &lt;xs:element name="thesaurus" type="fts:ftThesaurusOption" /&gt;
  &lt;xs:element name="stem" type="fts:ftStemOption" /&gt;
  &lt;xs:element name="wildcard" type="fts:ftWildCardOption" /&gt;
  &lt;xs:element name="language" type="fts:ftLanguageOption" /&gt;
  &lt;xs:element name="stopwords" type="fts:ftStopWordOption" /&gt; 

 &lt;xs:complexType name="ftCaseOption"&gt;
   &lt;xs:sequence&gt;
     &lt;xs:element name="value"&gt;
       &lt;xs:simpleType&gt;
         &lt;xs:restriction base="xs:string"&gt;
           &lt;xs:enumeration value="case insensitive"/&gt;
           &lt;xs:enumeration value="case sensitive"/&gt;
           &lt;xs:enumeration value="lowercase"/&gt;
           &lt;xs:enumeration value="uppercase"/&gt;
         &lt;/xs:restriction&gt;
       &lt;/xs:simpleType&gt;
     &lt;/xs:element&gt;
   &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="ftDiacriticsOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="case insensitive"/&gt;
            &lt;xs:enumeration value="case sensitive"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
       
  &lt;xs:complexType name="ftThesaurusOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="thesaurusName" type="xs:string" 
                  minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="relationship" type="xs:string" 
                  minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="range" type="fts:ftRangeSpec" 
                  minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="thesaurusIndicator"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:string"&gt;
          &lt;xs:enumeration value="with"/&gt;
          &lt;xs:enumeration value="without"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:attribute&gt;
    &lt;xs:attribute name="language" type="xs:string"/&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="ftRangeSpec"&gt;
    &lt;xs:attribute name="type" 
                  type="fts:rangeSpecType" 
                  use="required"/&gt;
    &lt;xs:attribute name="m" 
                  type="xs:integer"/&gt;
    &lt;xs:attribute name="n" 
                  type="xs:integer" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:simpleType name="rangeSpecType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="exactly"/&gt;
      &lt;xs:enumeration value="at least"/&gt;
      &lt;xs:enumeration value="at most"/&gt;
      &lt;xs:enumeration value="from to"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:complexType name="ftStemOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="with stemming"/&gt;
            &lt;xs:enumeration value="without stemming"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="ftWildCardOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="with wildcards"/&gt;
            &lt;xs:enumeration value="without wildcards"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="ftLanguageOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="ftStopWordOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element name="default-stopwords"&gt;
            &lt;xs:complexType /&gt;
        &lt;/xs:element&gt;
        &lt;xs:element name="stopword" type="xs:string" /&gt;
        &lt;xs:element name="uri" type="xs:anyURI" /&gt;
      &lt;/xs:choice&gt;
      &lt;xs:element name="oper" minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:complexType&gt;
          &lt;xs:choice&gt;
            &lt;xs:element name="stopword" type="xs:string" /&gt;
            &lt;xs:element name="uri" type="xs:anyURI" /&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="type"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:string"&gt;
                &lt;xs:enumeration value="union"/&gt;
                &lt;xs:enumeration value="except"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
&lt;/xs:schema&gt;            
</eg></div4><div4 role="xquery" id="tq-ft-matchopt-highlevel"><head>High-Level Semantics</head><p>The previous section described FTSelections without
            giving any details about how <term>FTMatchOption</term>s need to be
            interpreted. All processing of <term>FTMatchOption</term>s was
            delegated to the function
            <function>matchTokenInfos</function>, which is
            <termref def="dt-implementation-defined">implementation-defined</termref>. In this section, further details
            on the semantics of <term>FTMatchOption</term>s are given.</p><p>The extension is achieved by modifying an existing 
            function and adding functions that are specific to the
            <term>FTMatchOption</term>s.</p><p>
                     <emph>Modifications in the semantics of existing functions</emph>
                  </p><p>The semantics of most of the
            <term>FTSelection</term>s remains unmodified. The modifications are
            to the method for matching a sequence of query tokens. </p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:applyQueryTokensAsPhrase (
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $queryTokens as element(fts:queryToken)*,
      $queryPos as xs:integer )
   as element(fts:allMatches)
{
   let $thesaurusOption := $matchOptions/fts:thesaurus[1]
   return 
      if ($thesaurusOption and 
          $thesaurusOption/@thesaurusIndicator eq "with") then
         let $noThesaurusOptions := 
            &lt;fts:matchOptions&gt;{
               $matchOptions/*[fn:not(self::fts:thesaurus)]
            }&lt;/fts:matchOptions&gt;
         let $lookupRes := fts:applyThesaurusOption($thesaurusOption,
                                                    $queryTokens)            
         return fts:ApplyFTWordsAny($searchContext,
                                    $noThesaurusOptions,
                                    $lookupRes,
                                    $queryPos)
      else
         (: from here on we have a single sequence of query tokens :)
         (: which is to be matched a phrase; no alternatives anymore :)
         &lt;fts:allMatches stokenNum="{$queryPos}"&gt; 
         {
            for $pos in
               fts:matchTokenInfos( 
                  $searchContext,
                  $matchOptions,
                  fts:applyStopWordOption($matchOptions/fts:stopwords),
                  $queryTokens )
            return  
               &lt;fts:match&gt;  
                  &lt;fts:stringInclude queryPos="{$queryPos}" isContiguous="true"&gt; 
                  {$pos}
                  &lt;/fts:stringInclude&gt; 
               &lt;/fts:match&gt;
         } 
         &lt;/fts:allMatches&gt; 
};
</eg><p>Two <term>FTMatchOption</term>s need to be
    processed differently than the rest of the <term>FTMatchOption</term>s as
    shown in the function above. </p><ulist><item><p>Unlike all other <term>FTMatchOption</term>s the semantics
    of the <term>FTThesaurusOption</term> cannot be formulated as an operation on
    individual query tokens, because a thesaurus lookup may return
    alternative query items for a whole phrase, i.e., a sequence of
    query tokens. Since
    the result of a thesaurus lookup is a sequence of alternatives, 
    there must be a higher level of processing. The above call to
    <function>applyThesaurusOption&gt;</function> returns for the given
    sequence of query tokens (representing a phrase) all thesaurus
    expansions for the selected thesaurus, relationship and level
    range as a sequence of query items. The 
    alternative expansions are evaluated as a disjunction using
    the <code>fts:ApplyFTWordsAny</code>.
    The matching of the alternatives is performed with
    <term>FTThesaurusOption</term> turned off to avoid double expansions,
    i.e., expansion of an already expanded token.</p></item><item><p>For the semantics of the <term>FTStopWordOption</term> the list of
    stop words needs to be computed as demanded by the special syntax
    for stop word lists involving the operators "union" and
    "except". </p></item></ulist><p>
                     <emph>Semantics of new <term>FTMatchOption</term>s functions </emph>
                  </p><p>The expansion of <term>FTSelection</term>s also includes adding additional functions
    that are specific to the <term>FTMatchOption</term>s. </p><p>The <function>evaluate</function> function above handles match options
    occurring in the query structure by using a call to the function
    <function>replaceMatchOptions</function> which is defined below. The latter
    function replaces match options from the list given by the first argument
    with match options of the same group in the list given by the second
    argument, if any. If an option is present in the second list but not in
    the first list, the option is included to the resulting list too.
    Intuitively, the <function>replaceMatchOptions</function> computes the
    effective match options for a given <term>FTSelection</term>. The function uses
    the options specified specifically for the current <term>FTSelection</term> (
    <code>$ftSelection/fts:matchOptions</code> to override any options
    of the same group declared up the query tree (<code>$matchOptions</code>).
    </p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:replaceMatchOptions (
      $matchOptions as element(fts:matchOptions),
      $newMatchOptions as element(fts:matchOptions) )
   as element(fts:matchOptions)
{
   &lt;fts:matchOptions&gt;
   {
      (if ($newMatchOptions/fts:thesaurus) then $newMatchOptions/fts:thesaurus
       else $matchOptions/fts:thesaurus),
      (if ($newMatchOptions/fts:stopwords) then $newMatchOptions/fts:stopwords
       else $matchOptions/fts:stopwords),
      (if ($newMatchOptions/fts:case) then $newMatchOptions/fts:case
       else $matchOptions/fts:case),
      (if ($newMatchOptions/fts:diacritics) then $newMatchOptions/fts:diacritics
       else $matchOptions/fts:diacritics),
      (if ($newMatchOptions/fts:stem) then $newMatchOptions/fts:stem
       else $matchOptions/fts:stem),
      (if ($newMatchOptions/fts:wildcard) then $newMatchOptions/fts:wildcard
       else $matchOptions/fts:wildcard),
      (if ($newMatchOptions/fts:language) then $newMatchOptions/fts:language
       else $matchOptions/fts:language)
   }
   &lt;/fts:matchOptions&gt;
};

</eg><p>This function determines how match
    options of the same group overwrite each other, so that only one
    option of the same group remains.</p><p>The details of the semantics of the remaining <term>FTMatchOption</term>s
    are determined by the <termref def="dt-implementation-defined">implementation-defined</termref> function
    <function>matchTokenInfos</function>.</p></div4><div4 role="xquery" id="options-sem-functions"><head>Formal Semantics Functions</head><p>
                     <term>FTMatchOption</term> functions which are necessary to support match
            option processing are given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:resolveStopWordsUri ( $uri as xs:string? ) 
   as xs:string* external;

declare function fts:lookupThesaurus (
      $tokens as element(fts:queryToken)*,
      $thesaurusName as xs:string?, 
      $thesaurusLanguage as xs:string?,
      $relationship as xs:string?,
      $range as element(fts:range)? ) 
   as element(fts:queryItem)* external;
</eg><p>The function <function>resolveStopWordsUri</function>
            is used to resolve any URI to a sequence of strings to be
            used as stop words.</p><p>The function <function>lookupThesaurus</function> finds
            all expansions related to  <code>$tokens</code>
            in the thesaurus <code>$thesaurusName</code> for the language
            <code>$thesaurusLanguage</code> using the relationship 
            <code>$relationship</code> within the optional number of levels
            <code>$range</code>. If <code>$tokens</code> consists of 
            more than one query token, it is regarded as a
            phrase.
            </p><p>The thesaurus function returns a sequence of expansion
           alternatives. Each alternative is regarded as a new search
           phrase and is represented as a query item.
           Alternatives are treated as though they are connected with
           a disjunction (<term>FTOr</term>). </p></div4><div4 role="xquery" id="tq-ft-matchopt-FTCaseOption"><head>FTCaseOption</head><p>
                     <term>FTMatchOption</term>s of type <term>FTCaseOption</term> are passed in the
        <code>$matchOptions</code> parameter to
        <function>matchTokenInfos</function>. If the <term>FTCaseOption</term> is
        "lowercase" the returned <term>TokenInfo</term>s must span
        only tokens that are all lowercase.  If the
        <term>FTCaseOption</term> is
        "uppercase" the returned <term>TokenInfo</term>s must span
        only tokens that are all uppercase.  If the
        <term>FTCaseOption</term> is "case insensitive" the
        function must return all <term>TokenInfo</term>s matching the query
        tokens when disregarding character case. If the
        <term>FTCaseOption</term> is "case sensitive" the
        function must return all <term>TokenInfo</term>s that also accord with
        the query tokens in character case.</p></div4><div4 role="xquery" id="tq-ft-matchopt-FTDiacriticsOption"><head>FTDiacriticsOption</head><p>
                     <term>FTMatchOption</term>s of type <term>FTDiacriticsOption</term> are passed in the
        <code>$matchOptions</code> parameter to
        <function>matchTokenInfos</function>. If the
        <term>FTDiacriticsOption</term> is "diacritics insensitive" the function must 
        return all <term>TokenInfo</term>s matching 
        the query tokens when disregarding diacritical marks. If the
        <term>FTDiacriticsOption</term> is "diacritics sensitive" the function must 
        return all <term>TokenInfo</term>s that
        also accord with the query tokens in diacritical marks.</p></div4><div4 role="xquery" id="tq-ft-matchopt-FTStemOption"><head>FTStemOption</head><p>
                     <term>FTMatchOption</term>s of type <term>FTStemOption</term> are passed in the
        <code>$matchOptions</code> parameter to
        <function>matchTokenInfos</function>. It is
        <termref def="dt-implementation-defined">implementation-defined</termref> what the effect of the option "with
        stemming" is on matching tokens, however, it is expected that
        this option allows to match linguistic variants of the query
        tokens. If the <term>FTStemOption</term> is "without stemming" the
        returned <term>TokenInfo</term>s must span exact matches (i.e. not
        including linguistic variations) of the query tokens.</p></div4><div4 role="xquery" id="tq-ft-matchopt-FTThesaurusOption"><head>FTThesaurusOption</head><p>The semantics for the <term>FTThesaurusOption</term>
			is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:applyThesaurusOption (
      $matchOption as element(fts:thesaurus),
      $queryTokens as element(fts:queryToken)* )
   as element(fts:queryItem)*
{
   if ($matchOption/@thesaurusIndicator = "with") then
      fts:lookupThesaurus( $queryTokens,
                           $matchOption/fts:thesaurusName,
                           $matchOption/@language,
                           $matchOption/fts:relationship,
                           $matchOption/fts:range )
   else if ($matchOption/@thesaurusIndicator = "without") then
      &lt;fts:queryItem&gt;
      {$queryTokens}
      &lt;/fts:queryItem&gt;
   else ()
};
</eg></div4><div4 role="xquery" id="tq-ft-matchopt-FTStopWordOption"><head>FTStopWordOption</head><p>Stop words interact with <term>FTDistance</term> and
			<term>FTWindow</term>. The semantics for the <term>FTStopWordOption</term>
			is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:applyStopWordOption (
      $stopWordOption as element(fts:stopwords)? )
   as xs:string*
{
   if ($stopWordOption) then
      let $swords := 
         typeswitch ($stopWordOption/*[1])
            case $e as element(fts:stopword) 
               return $e/text()
            case $e as element(fts:uri) 
               return fts:resolveStopWordsUri($e/text())
            case element(fts:default-stopwords)
               return fts:resolveStopWordsUri(())
            default return ()
      return fts:calcStopWords( $swords, $stopWordOption/fts:oper )
   else ()
};
declare function fts:calcStopWords ( 
      $stopWords as xs:string*,
      $opers as element(fts:oper)* )
   as element(fts:queryToken)*
{
   if ( fn:empty($opers) ) then $stopWords
   else
      let $swords := 
         typeswitch ($opers[1]/*[1])
            case $e as element(fts:stopword) 
               return $e/text()
            case $e as element(fts:uri) 
               return fts:resolveStopWordsUri($e/text())
            default return ()
      return
         if ($opers[1]/@type eq "union") then
            fts:calcStopWords( ($stopWords, $swords), 
                               $opers[fn:position() gt 2] )
         else (: "except" :)
            fts:calcStopWords( $stopWords[fn:not(.)=$swords],
                               $opers[fn:position() gt 2] )
};
            </eg><p>The stop words set is computed using the
            <code>fts:calcStopWords</code> function. The function uses
            the function <code>fts:resolveStopWordsUri</code> to resolve any URI
            to a sequence of strings. Then, the stop words are
            removed from the set of query tokens. </p></div4><div4 role="xquery" id="tq-ft-matchopt-FTLanguageOption"><head>FTLanguageOption</head><p>The <term>FTLanguageOption</term> is not associated with a semantics function. It 
                is just a parameter to other semantics functions.</p></div4><div4 role="xquery" id="tq-ft-matchopt-FTWildCardOption"><head>FTWildCardOption</head><p>
                     <term>FTMatchOption</term>s of type <term>FTWildCardOption</term> are passed in the
        <code>$matchOptions</code> parameter to
        <function>matchTokenInfos</function>. If the
        <term>FTWildCardOption</term> is "with wildcards" the function must
        return all <term>TokenInfo</term>s in the search context that span tokens,
        such that those tokens are wildcard
        expansions of the corresponding query token. The wildcard
        expansions are described in <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftwildcardoption" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Section 3.2.7 FTWildCardOption</loc>. If the
        <term>FTWildCardOption</term> is "without wildcards" all query tokens
        must be matched literally.</p></div4></div3><!-- *************************************************************
         ***                  Operators Semantics                  ***
         ************************************************************* --><div3 role="xquery" id="FTOperatorsSemanticsSec"><head>Full-Text Operators Semantics</head><div4 role="xquery" id="tq-ft-fs-FTOr"><!-- **********************************************************************
             *                            FTOr                          *
             ********************************************************************** --><head>FTOr</head><p>The parameters of the <function>ApplyFTOr</function> 
            function are the two <term>AllMatches</term> parameters 
            corresponding to the results of the two nested 
            <term>FTSelection</term>s. 
            The semantics is given 
			below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTOr (
      $allMatches1 as element(fts:allMatches),
      $allMatches2 as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{fn:max(($allMatches1/@stokenNum, 
                                       $allMatches2/@stokenNum))}"&gt;
   {$allMatches1/fts:match,$allMatches2/fts:match}
   &lt;/fts:allMatches&gt;
};
            </eg><p>The <function>ApplyFTOr</function> function creates a new <term>AllMatches</term> 
			in which 
            <term>Match</term>es are the union of those found 
            in the input <term>AllMatches</term>. 
			Each <term>Match</term> represents one possible result of the corresponding 
            <term>FTSelection</term>. Thus, a <term>Match</term> from either 
            of the <term>AllMatches</term> is a result. </p><p>For example, consider the <term>FTSelection</term>
                     <code>"Mustang" ftor "Honda"</code>. The 
			<term>AllMatches</term> corresponding to 
            "Mustang" and "Honda" are given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTOrEx1.jpg" alt="FTOr input AllMatches 1" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
                     <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTOrEx2.jpg" alt="FTOr input AllMatches 2" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
                  </p><p>The <term>AllMatches</term> produced by <function>
            ApplyFTOr</function> is given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTOrEx3.jpg" alt="FTOr result AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/></div4><div4 role="xquery" id="tq-ft-fs-FTAnd"><!-- **********************************************************************
             *                            FTAnd                         *
             ********************************************************************** --><head>FTAnd</head><p>The parameters of the <function>ApplyFTAnd</function> 
            function are the two <term>AllMatches</term>  
            corresponding to the results of the two nested 
            <term>FTSelection</term>s.
            The semantics is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTAnd (
      $allMatches1 as element(fts:allMatches),
      $allMatches2 as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{fn:max(($allMatches1/@stokenNum, 
                                       $allMatches2/@stokenNum))}" &gt;
   {
      for $sm1 in $allMatches1/fts:match
      for $sm2 in $allMatches2/fts:match
      return &lt;fts:match&gt;
             {$sm1/*, $sm2/*}
             &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
            </eg><p>The result of the conjunction is a new 
            <term>AllMatches</term> that contains the "Cartesian 
            product" of the matches of the participating 
            <term>FTSelection</term>s. Every resulting <term>Match</term> 
            is formed by the combination of the <term>StringInclude</term> components 
            and <term>StringExclude</term> from the 
            <term>AllMatches</term> of the nested <term>FTSelection</term> 
            . Thus every match contains the positions 
            to satisfy a <term>Match</term> from both original 
            <term>FTSelection</term>s and excludes the positions that 
            violate the same <term>Match</term>es. </p><p>For example, consider the <term>FTSelection</term>
                     <code>"Mustang" ftand "rust"</code>. The 
			source <term>AllMatches</term> are give below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTAndEx1.jpg" alt="FTAnd input AllMatches 1" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
                     <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTAndEx2.jpg" alt="FTAnd input AllMatches 2" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
                  </p><p>The <term>AllMatches</term> produced by <function>ApplyFTAnd</function> is
			given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTAndEx3.jpg" alt="FTAnd result AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/></div4><div4 role="xquery" id="tq-ft-fs-FTUnaryNot"><!-- **************************************************
             *                  FTUnaryNot                    *
             ************************************************** --><head>FTUnaryNot</head><p>The <function>ApplyFTUnaryNot</function>
        function
        has one <term>AllMatches</term> parameter corresponding to the
        result of the nested <term>FTSelection</term> to be negated.
        The 
		semantics is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:InvertStringMatch ( $strm as element(*,fts:stringMatch) ) 
   as element(*,fts:stringMatch)
{
   if ($strm instance of element(fts:stringExclude)) then
      &lt;fts:stringInclude queryPos="{$strm/@queryPos}" isContiguous="{$strm/@isContiguous}"&gt;
      {$strm/fts:tokenInfo}
      &lt;/fts:stringInclude&gt;
   else
      &lt;fts:stringExclude queryPos="{$strm/@queryPos}" isContiguous="{$strm/@isContiguous}"&gt;
      {$strm/fts:tokenInfo}
      &lt;/fts:stringExclude&gt;
};

declare function fts:UnaryNotHelper ( $matches as element(fts:match)* )
   as element(fts:match)*
{
   if (fn:empty($matches))
   then &lt;match/&gt;
   else
      for $sm in $matches[1]/*
      for $rest in fts:UnaryNotHelper( fn:subsequence($matches, 2) )
      return 
         &lt;fts:match&gt;
         {
            fts:InvertStringMatch($sm),
            $rest/*
         }
         &lt;/fts:match&gt;
};

declare function fts:ApplyFTUnaryNot (
      $allMatches as element(fts:allMatches) )
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      fts:UnaryNotHelper($allMatches/fts:match)
   }
   &lt;/fts:allMatches&gt;
};
            </eg><p>The generation of the resulting
            <term>AllMatches</term> of an <term>FTUnaryNot</term> resembles the transformation
            of a negation of prepositional formula in DNF back to DNF.
            The negation of <term>AllMatches</term> requires
            the inversion of all the <term>StringMatch</term>es
            within the <term>AllMatches</term>.</p><p>In the <function>InvertStringMatch</function> function  above, 
			this inversion occurs as follows. </p><olist><item><p>The function <function>fts:invertStringMatch</function>
			inverts a <term>StringInclude </term> into a <term>StringExclude</term> and
			vice versa. </p></item><item><p>The function <function>fts:UnaryNotHelper</function> transforms
			the source <term>Match</term>es into the resulting
			<term>Match</term>es by forming the combinations of the
			inversions of a <term>StringInclude</term> or <term>StringExclude</term>
			component over the source <term>Match</term>es into new <term>Match</term>es.</p></item></olist><p>For example, consider the <term>FTSelection</term>
                     <code>ftnot ("Mustang" ftor "Honda")</code>. The 
			source <term>AllMatches</term> is given below:</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTNegationEx1.jpg" alt="FTUnaryNot input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>The <term>FTUnaryNot</term> transforms the <term>StringInclude</term>s to 
			<term>StringExclude</term>s as illustrated below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTNegationEx2.jpg" alt="FTUnaryNot result AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/></div4><!-- **********************************************************************
             *                            FTMildNot                          *
             ********************************************************************** --><div4 role="xquery" id="tq-ft-fs-FTMildNot"><head>FTMildNot</head><p>The parameters of the <function>ApplyFTMildNot</function>
            function are the two <term>AllMatches</term> parameters corresponding
            to the results of the two nested <term>FTSelection</term>s.
            The semantics is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:CoveredIncludePositions (
       $match as element(fts:match) )
    as xs:integer*
{
    for $strInclude in $match/fts:stringInclude
    return $strInclude/fts:tokenInfo/@startPos
           to $strInclude/fts:tokenInfo/@endPos
};

declare function fts:ApplyFTMildNot (
       $allMatches1 as element(fts:allMatches),
       $allMatches2 as element(fts:allMatches) )
    as element(fts:allMatches)
{
    if (fn:count($allMatches1//fts:stringExclude) gt 0) then
       fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'FTDY0017'), 
                "Invalid expression on the left-hand side of a not-in")
    else if (fn:count($allMatches2//fts:stringExclude) gt 0) then
       fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'FTDY0017'), 
                "Invalid expression on the right-hand side of a not-in")
    else if (fn:count($allMatches2//fts:stringInclude) eq 0) then
       $allMatches1
    else
       &lt;fts:allMatches stokenNum="{$allMatches1/@stokenNum}"&gt;
       {
          $allMatches1/fts:match[
             every $matches2 in $allMatches2/fts:match
             satisfies
                let $posSet1 := fts:CoveredIncludePositions(.)
                let $posSet2 := fts:CoveredIncludePositions($matches2)
                   return some $pos in $posSet1 satisfies fn:not($pos = $posSet2)
          ]
       }
       &lt;/fts:allMatches&gt;
};
            </eg><p>The resulting <term>AllMatches</term> contains <term>Match</term>es
            of the first operand that do not mention in their
            <term>StringInclude</term> components positions in a <term>StringInclude</term> component 
			in the <term>AllMatches</term> of the second operand.</p><p>For example, consider the <term>FTSelection</term>
                     <code>("Ford" not in "Ford
            Mustang")</code>. The
            source <term>AllMatches</term> for the left-hand side argument is given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTMildNegationEx1.jpg" alt="FTMildNot input AllMatches 1" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>The
            source <term>AllMatches</term> for the right-hand side argument is given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTMildNegationEx2.jpg" alt="FTMildNot input AllMatches 2" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>The <term>FTMildNot</term> will transform these to an empty
            <term>AllMatches</term> because both position 1 and position 27 from
            the first <term>AllMatches</term> contain only <term>TokenInfo</term>s from
            <term>StringInclude</term> components of the second
            <term>AllMatches</term>.</p></div4><!-- **********************************************************************
             *                                FTOrder                             *
             ********************************************************************** --><div4 role="xquery" id="tq-ft-fs-FTOrder"><head>FTOrder</head><p>The <function>ApplyFTOrder</function>
            function
            has one <term>AllMatches</term> parameter corresponding to
            the result of the nested <term>FTSelection</term>s.
            The semantics is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTOrder (
      $allMatches as element(fts:allMatches) )
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude
            satisfies (($stringInclude1/fts:tokenInfo/@startPos &lt;= 
                        $stringInclude2/fts:tokenInfo/@startPos)
                       and
                       ($stringInclude1/@queryPos &lt;= 
                        $stringInclude2/@queryPos))
                      or
                       (($stringInclude1/fts:tokenInfo/@startPos&gt;= 
                         $stringInclude2/fts:tokenInfo/@startPos)
                        and
                        ($stringInclude1/@queryPos &gt;= 
                         $stringInclude2/@queryPos))
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where every $stringIncl in $match/fts:stringInclude
                  satisfies (($stringExcl/fts:tokenInfo/@startPos &lt;= 
                              $stringIncl/fts:tokenInfo/@startPos)
                             and
                              ($stringExcl/@queryPos &lt;= 
                               $stringIncl/@queryPos))
                            or
                             (($stringExcl/fts:tokenInfo/@startPos &gt;= 
                               $stringIncl/fts:tokenInfo/@startPos)
                              and
                              ($stringExcl/@queryPos &gt;= 
                               $stringIncl/@queryPos))
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }         
   &lt;/fts:allMatches&gt;
};
            </eg><p>The resulting <term>AllMatches</term> contains the <term>Match</term>es for which the starting positions 
			in the <term>StringInclude</term> elements are in the order of the
            query positions of their query strings.  
			<term>StringExclude</term>s that preserve the order (with respect to their starting positions) are also retained.</p><p>For example, consider the <term>FTSelection</term>
                     <code>("great" ftand "condition")
            ordered</code>. The source <term>AllMatches</term> is given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTOrderEx1.jpg" alt="FTOrder input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTOrderEx2.jpg" alt="FTOrder input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTOrderEx3.jpg" alt="FTOrder input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>The <term>AllMatches</term> for <term>FTOrder</term> are given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTOrderEx4.jpg" alt="FTOrder result AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTOrderEx5.jpg" alt="FTOrder result AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/></div4><!-- **********************************************************************
             *                            FTScope                        *
             ********************************************************************** --><div4 role="xquery" id="tq-ft-fs-FTScope"><head>FTScope</head><p>The parameters of the <function>ApplyFTScope</function>
            function are 
            1) the type of the scope (same or different), 2) the
            linguistic unit (sentence or paragraph), and 2) one
            <term>AllMatches</term> parameter corresponding to the result of the
            nested <term>FTSelection</term>s.
            The function
            definitions depend on the type of the scope (paragraph,
            sentence) and the scope predicate (same, different).</p><p>The semantics of <code>same sentence</code> is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTScopeSameSentence (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude 
            satisfies $stringInclude1/fts:tokenInfo/@startSent = 
                      $stringInclude2/fts:tokenInfo/@startSent
                  and $stringInclude1/fts:tokenInfo/@startSent = 
                      $stringInclude1/fts:tokenInfo/@endSent
                  and $stringInclude2/fts:tokenInfo/@startSent = 
                      $stringInclude2/fts:tokenInfo/@endSent
                  and $stringInclude1/fts:tokenInfo/@startSent &gt; 0
                  and $stringInclude2/fts:tokenInfo/@startSent &gt; 0
      return 
        &lt;fts:match&gt;
        {
           $match/fts:stringInclude,
           for $stringExcl in $match/fts:stringExclude
           where
              $stringExcl/fts:tokenInfo/@startSent = 0
              or
              ($stringExcl/fts:tokenInfo/@startSent = 
               $stringExcl/fts:tokenInfo/@endSent
               and 
                  (every $stringIncl in $match/fts:stringInclude
                   satisfies $stringIncl/fts:tokenInfo/@startSent = 
                             $stringExcl/fts:tokenInfo/@startSent) )
           return $stringExcl
        }
        &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>An <term>AllMatches</term> returned by the scope <code>same sentence</code> 
             contains those <term>Match</term>es whose <term>StringInclude</term>s span only a single 
             sentence and all span the same sentence. In these <term>Match</term>es only 
             those <term>StringExclude</term>s are retained that also only span a single 
             sentence, which is, in case there are <term>StringInclude</term>s in that <term>Match</term>, 
             the same as the one spanned by the <term>StringInclude</term>s.</p><p>The semantics of <code>different sentence
            </code> is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTScopeDifferentSentence (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude  
            satisfies $stringInclude1 is $stringInclude2
                  or $stringInclude1/fts:tokenInfo/@endSent &lt;
                     $stringInclude2/fts:tokenInfo/@startSent
                  or $stringInclude2/fts:tokenInfo/@endSent &lt;
                     $stringInclude1/fts:tokenInfo/@startSent
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where every $stringIncl in $match/fts:stringInclude
                  satisfies $stringExcl/fts:tokenInfo/@endSent &lt;  
                            $stringIncl/fts:tokenInfo/@startSent
                         or $stringIncl/fts:tokenInfo/@endSent &lt;
                            $stringExcl/fts:tokenInfo/@startSent
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>An <term>AllMatches</term> returned by the scope <code>different sentence</code> 
            contains those <term>Match</term>es that have no two <term>StringInclude</term>s covering 
            the same sentence.
            In these <term>Match</term>es only those <term>StringExclude</term>s are retained that also do not 
            cover a common sentence with one of the <term>StringInclude</term>s.</p><p>The semantics of <code>same paragraph</code> is analogous to <code>same
            sentence</code> and is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTScopeSameParagraph (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude  
            satisfies $stringInclude1/fts:tokenInfo/@startPara = 
                      $stringInclude2/fts:tokenInfo/@startPara
                  and $stringInclude1/fts:tokenInfo/@startPara = 
                      $stringInclude1/fts:tokenInfo/@endPara
                  and $stringInclude2/fts:tokenInfo/@startPara = 
                      $stringInclude2/fts:tokenInfo/@endPara
                  and $stringInclude1/fts:tokenInfo/@startPara &gt; 0
                  and $stringInclude2/fts:tokenInfo/@endPara &gt; 0
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where 
               $stringExcl/fts:tokenInfo/@startPara = 0
               or
               ($stringExcl/fts:tokenInfo/@startPara = 
                $stringExcl/fts:tokenInfo/@endPara
                and
                   (every $stringIncl in $match/fts:stringInclude
                    satisfies $stringIncl/fts:tokenInfo/@startPara = 
                              $stringExcl/fts:tokenInfo/@startPara) )
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>different paragraph</code> is analogous to 
            <code>different sentence</code> and is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTScopeDifferentParagraph (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude  
            satisfies $stringInclude1 is $stringInclude2
                   or $stringInclude1/fts:tokenInfo/@endPara &lt;
                      $stringInclude2/fts:tokenInfo/@startPara
                   or $stringInclude2/fts:tokenInfo/@endPara &lt;
                      $stringInclude1/fts:tokenInfo/@startPara
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where every $stringIncl in $match/fts:stringInclude
                  satisfies $stringExcl/fts:tokenInfo/@endPara &lt;  
                            $stringIncl/fts:tokenInfo/@startPara
                         or $stringIncl/fts:tokenInfo/@endPara &lt;
                            $stringExcl/fts:tokenInfo/@startPara
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics for the general case is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTScope (
      $type as fts:scopeType,
      $selector as fts:scopeSelector, 
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if ($type eq "same" and $selector eq "sentence")
   then fts:ApplyFTScopeSameSentence($allMatches)
   else if ($type eq "different" and $selector eq "sentence")
      then fts:ApplyFTScopeDifferentSentence($allMatches)
   else if ($type eq "same" and $selector eq "paragraph")
      then fts:ApplyFTScopeSameParagraph($allMatches)
   else fts:ApplyFTScopeDifferentParagraph($allMatches)
};
</eg><p>For example, consider the <term>FTSelection</term>
                     <code>("Mustang" ftand "Honda") same 
            paragraph</code>. The source <term>AllMatches</term> is given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTScopeEx.jpg" alt="FTScope input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>The <term>FTScope</term> returns an empty <term>AllMatches</term> because neither 
			<term>Match</term> contains <term>TokenInfo</term>s from a single sentence.</p></div4><!-- ***************************************************************
             *                            FTContent                        *
             *************************************************************** --><div4 role="xquery" id="tq-ft-fs-FTContent"><head>FTContent</head><p>The parameters of the <function>ApplyFTContent</function>
            function are 1) the search context,
            2) the type of the content
	    match
	    (<code>at start</code>, <code>at end</code>, or <code>entire content</code>),
            and 3) one
            <term>AllMatches</term> parameter corresponding to the result of the
            nested <term>FTSelection</term>s. The semantics is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTContent (
      $searchContext as item(),
      $type as fts:contentMatchType,
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if ($type eq "entire content") then
      let $temp1 := fts:ApplyFTWordDistanceExactly(
                        $allMatches,
                        1)
      let $temp2 := fts:ApplyFTContent(
                        $searchContext,
                        fts:contentMatchType("at start"),
                        $temp1)
      let $temp3 := fts:ApplyFTContent(
                        $searchContext,
			fts:contentMatchType("at end"),
			$temp2)
      return
         &lt;fts:allMatches stokenNum="{$temp3/@stokenNum}"&gt;
         {
            for $match in $temp3/fts:match
            return
               &lt;fts:match&gt;
               {
                  (: Note: due to ApplyFTWordDistanceExactly above there
                     must be either one or no stringInclude in $match :)
                  $match/fts:stringInclude[@isContiguous],
                  $match/fts:stringExclude[@isContiguous]
               }
               &lt;/fts:match&gt;
         }
         &lt;/fts:allMatches&gt;

   else
      &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
      {
         for $match in $allMatches/fts:match
         where if ($type eq "at start") then
                  some $si in $match/fts:stringInclude
                  satisfies fts:isStartToken($searchContext,
                                             $si/fts:tokenInfo)
               else (: $type eq "at end" :) 
                  some $si in $match/fts:stringInclude
                  satisfies fts:isEndToken($searchContext,
                                           $si/fts:tokenInfo)
         return $match
      }
      &lt;/fts:allMatches&gt;
};
</eg><p>The evaluation of scope functions depends on 
        the type of the content match.</p><ulist><item><p>
                           <code>entire content</code> is evaluated as
		<code>distance exactly 0 words at start at end</code>, i.e., all the
		<term>StringInclude</term>s must match every token in the
		search context item.</p></item><item><p>
                           <code>at start</code> retains only 
        <term>Match</term>es that contain a <term>StringInclude</term> that matches the 
        first token. This is checked using the semantic function
        <code>fts:isStartToken</code>.</p></item><item><p>
                           <code>at end</code> retains the 
        <term>Match</term>es that contain a <term>StringInclude</term> that matches the 
        last token. This is checked using the semantic function
        <code>fts:isEndToken</code>.</p></item></ulist></div4><!-- **********************************************************************
             *                            FTWindow                       *
             ********************************************************************** --><div4 role="xquery" id="tq-ft-fs-FTWindow"><head>FTWindow</head><p>Before we define the semantics functions of the <term>FTWindow</term> and <term>FTDistance</term> 
		  	 operations, we introduce the auxiliary function <code>joinIncludes</code> that will
		  	 be used in their definitions. <code>joinIncludes</code> takes a sequence of 
		  	 <term>StringInclude</term>s of a <term>Match</term> and transforms it into either the empty sequence, in 
		  	 case the input sequence was empty, or otherwise a single <term>StringInclude</term>
		  	 representing the span from the first position of the match to the last. For the 
		  	 purpose of being able to evaluate an "entire content" operator further up in the 
		  	 tree, we pre-evaluate whether all possible positions between first and last are 
			 covered in the input <term>StringInclude</term>s and store that boolean in the 
			 attribute "isContiguous".</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:joinIncludes(
      $strIncls as element(fts:stringInclude)* )
   as element(fts:stringInclude)?
{
   if (fn:empty($strIncls))
   then 
      $strIncls
   else
      let $posSet := fts:CoveredIncludePositions(&lt;fts:match&gt;$strIncls&lt;/fts:match&gt;),
         $minPos := fn:min($strIncls/fts:tokenInfo/@startPos),
         $maxPos := fn:max($strIncls/fts:tokenInfo/@endPos),
         $isContiguous := 
            ( every $pos in $minPos to $maxPos
              satisfies ($pos = $posSet) )
            and
            ( every $strIncl in $strIncls
              satisfies $strIncl/@isContiguous )
      return
         &lt;fts:stringInclude 
            queryPos="{$strIncls[1]/@queryPos}"
            isContiguous="{$isContiguous}"&gt;
            &lt;fts:tokenInfo
               startPos="{$minPos}"
               endPos="{$maxPos}"
               startSent="{fn:min($strIncls/fts:tokenInfo/@startSent)}"
               endSent="{fn:max($strIncls/fts:tokenInfo/@startSent)}"
               startPara="{fn:min($strIncls/fts:tokenInfo/@startPara)}"
               endPara="{fn:max($strIncls/fts:tokenInfo/@startPara)}"/&gt;
         &lt;/fts:stringInclude&gt;
};
</eg><p>The parameters of the
            <function>ApplyFTWindow</function> function are
            1) the unit of
            type <code>fts:distanceType</code>, 2) a size, and 3) one
            <term>AllMatches</term> parameter 
            corresponding to the result of the nested <term>FTSelection</term>s.
            For each unit 
			type a function is defined as follows.</p><p>The semantics of <code>window N words </code> is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTWordWindow (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $minpos := fn:min($match/fts:stringInclude/fts:tokenInfo/@startPos),
          $maxpos := fn:max($match/fts:stringInclude/fts:tokenInfo/@endPos)
      for $windowStartPos in ($maxpos - $n + 1 to $minpos)
      let $windowEndPos := $windowStartPos + $n - 1
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExclude in $match/fts:stringExclude
            where $stringExclude/fts:tokenInfo/@startPos &gt;=
                  $windowStartPos
              and $stringExclude/fts:tokenInfo/@endPos &lt;=
                  $windowEndPos
            return $stringExclude
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>window N sentences</code> is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTSentenceWindow (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $minpos := fn:min($match/fts:stringInclude/fts:tokenInfo/@startSent),
          $maxpos := fn:max($match/fts:stringInclude/fts:tokenInfo/@endSent)
      for $windowStartPos in ($maxpos - $n + 1 to $minpos)
      let $windowEndPos := $windowStartPos + $n - 1
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExclude in $match/fts:stringExclude
            where $stringExclude/fts:tokenInfo/@startSent &gt;=
                  $windowStartPos
              and $stringExclude/fts:tokenInfo/@endSent &lt;=
                  $windowEndPos
            return $stringExclude
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>window N paragraphs </code> is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTParagraphWindow (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches)
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $minpos := fn:min($match/fts:stringInclude/fts:tokenInfo/@startPara),
          $maxpos := fn:max($match/fts:stringInclude/fts:tokenInfo/@endPara)
      for $windowStartPos in ($maxpos - $n + 1 to $minpos)
      let $windowEndPos := $windowStartPos + $n - 1
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExclude in $match/fts:stringExclude
            where $stringExclude/fts:tokenInfo/@startPara &gt;=
                  $windowStartPos
              and $stringExclude/fts:tokenInfo/@endPara &lt;=
                  $windowEndPos
            return $stringExclude
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>The resulting <term>AllMatches</term> contains 
            <term>Match</term>es of the operand that satisfy the condition that
            there exists a sequence of the specified number of
            consecutive (token, sentence, or paragraph) positions, such
            that all <term>StringInclude</term>s are within that window, and the
            <term>StringExclude</term>s retained are also within that window. For each 
            <term>Match</term> that satisfies the window condition the 
            <term>StringInclude</term>s are joined into a single <term>StringInclude</term>. This 
            enables further window or distance operations to be applied to the
            result in a way that that result is taken as a single entity.</p><p>The semantics for the general function  is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTWindow (
      $type as fts:distanceType,
      $size as xs:integer,
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if ($type eq "word") then
      fts:ApplyFTWordWindow($allMatches, $size)
   else if ($type eq "sentence") then 
      fts:ApplyFTSentenceWindow($allMatches, $size)
   else
      fts:ApplyFTParagraphWindow($allMatches, $size)
};
</eg><p>For example, consider the <term>FTWindow</term> selection
            <code>("Ford Mustang" ftand
            "excellent") window 10 words</code>.
            The <term>Match</term>es of the source <term>AllMatches</term> for
            <code>("Ford Mustang" ftand
            "excellent")</code> are given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTWindowEx1.jpg" alt="FTWindow AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
                     <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTWindowEx2.jpg" alt="FTWindow AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
                  </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTWindowEx3.jpg" alt="FTWindow AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
                     <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTWindowEx4.jpg" alt="FTWindow AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
                  </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTWindowEx5.jpg" alt="FTWindow AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
                     <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTWindowEx6.jpg" alt="FTWindow AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
                  </p><p>The result for the <term>FTWindow</term> selection 
            consists of only the first, the fifth, and the sixth
            <term>Match</term>es because their respective window sizes are 5, 4,
            and 9.</p></div4><!-- **********************************************************************
             *                            FTDistance                     *
             ********************************************************************** --><div4 role="xquery" id="tq-ft-fs-FTDistance"><head>FTDistance</head><p>The parameters of the
            <function>ApplyFTDistance</function> function are
            1) one
            <term>AllMatches</term> parameter corresponding to the result of the
            nested <term>FTSelection</term>s, 2) the unit of the distance (tokens,
            sentences, paragraphs), and 3) the range specified.
            The
            function definitions depend on the distance units and the range 
			specifications.</p><p>The semantics of case <code>word distance exactly N</code> 
			is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTWordDistanceExactly(
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $idx in 1 to fn:count($sorted) - 1
            satisfies fts:wordDistance(
                         $sorted[$idx]/fts:tokenInfo,
                         $sorted[$idx+1]/fts:tokenInfo
                      ) = $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) = $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>word distance at least N</code> is given 
			below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTWordDistanceAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:wordDistance(
                         $sorted[$index]/fts:tokenInfo,
                         $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>word distance at most N</code> is given 
			below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTWordDistanceAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:wordDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
        &lt;fts:match&gt;
        {
           fts:joinIncludes($match/fts:stringInclude),
           for $stringExcl in $match/fts:stringExclude
           where some $stringIncl in $match/fts:stringInclude
                 satisfies fts:wordDistance(
                               $stringIncl/fts:tokenInfo,
                               $stringExcl/fts:tokenInfo
                           ) &lt;= $n
           return $stringExcl
        }
        &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>word distance from M to N</code> is given 
			below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTWordDistanceFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:wordDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $m 
                      and
                      fts:wordDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $m
                            and
                            fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>sentence distance exactly N</code> 
			is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTSentenceDistanceExactly (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startSent ascending,
                              $si/fts:tokenInfo/@endSent ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) = $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) = $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>sentence distance at least N</code> 
			is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTSentenceDistanceAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                    order by $si/fts:tokenInfo/@startSent ascending,
                             $si/fts:tokenInfo/@endSent ascending
                    return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>sentence distance at most N</code> 
            is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTSentenceDistanceAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startSent ascending,
                              $si/fts:tokenInfo/@endSent ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of  <code>sentence distance from M to N</code> 
            is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTSentenceDistanceFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startSent ascending,
                              $si/fts:tokenInfo/@endSent ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $m 
                      and
                      fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $m
                            and
                            fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>paragraph distance exactly N</code> 
			is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTParagraphDistanceExactly (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) = $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) = $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>paragraph distance at least N</code> 
		is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTParagraphDistanceAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>paragraph distance at most N</code>
		is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTParagraphDistanceAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>paragraph distance from M to N</code>
		is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTParagraphDistanceFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $m 
                      and
                      fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $m
                            and
                            fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</eg><p>The resulting <term>AllMatches</term> contains 
            <term>Match</term>es of the operand that satisfy the condition that
            the distance 
            for every pair of consecutive <term>StringInclude</term>s is within the specified interval,
            where the distance is measured in tokens, sentences, or paragraphs from the end 
            of the preceding <term>StringInclude</term> to the start of the next.
<!--			<termdef id="ConsecutivePosDef" term="ConsecutivePos"><term>Consecutive 
			Positions</term> in a &Match; are two positions from the same 
			&Match; with no intervening &StringInclude;s.</termdef>-->
            </p><p>In the general case, the semantics is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTDistance (
      $type as fts:distanceType,
      $range as element(fts:range),
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if ($type eq "word") then
      if ($range/@type eq "exactly") then
         fts:ApplyFTWordDistanceExactly($allMatches, $range/@n)
      else if ($range/@type eq "at least") then 
         fts:ApplyFTWordDistanceAtLeast($allMatches, $range/@n)
      else if ($range/@type eq "at most") then
         fts:ApplyFTWordDistanceAtMost( $allMatches, $range/@n)
      else
         fts:ApplyFTWordDistanceFromTo( $allMatches, $range/@m, $range/@n)
   else if ($type eq "sentence") then
      if ($range/@type eq "exactly") then
         fts:ApplyFTSentenceDistanceExactly($allMatches, $range/@n)
      else if ($range/@type eq "at least") then
         fts:ApplyFTSentenceDistanceAtLeast($allMatches, $range/@n)
      else if ($range/@type eq "at most") then
         fts:ApplyFTSentenceDistanceAtMost( $allMatches, $range/@n)
      else
         fts:ApplyFTSentenceDistanceFromTo( $allMatches, $range/@m, $range/@n)
   else
      if ($range/@type eq "exactly") then
         fts:ApplyFTParagraphDistanceExactly($allMatches, $range/@n)
      else if ($range/@type eq "at least") then
         fts:ApplyFTParagraphDistanceAtLeast($allMatches, $range/@n)
      else if ($range/@type eq "at most") then
         fts:ApplyFTParagraphDistanceAtMost( $allMatches, $range/@n)
      else
         fts:ApplyFTParagraphDistanceFromTo( $allMatches, $range/@m, $range/@n)
};
</eg><p>For example, consider the <term>FTDistance</term> selection
            <code>("Ford Mustang" ftand
            "excellent") distance at most 3 words</code>.
            The <term>Match</term>es of the source <term>AllMatches</term> for
            <code>("Ford Mustang" ftand
            "excellent")</code> are given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTDistanceEx1.jpg" alt="FTDistance input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
                     <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTDistanceEx2.jpg" alt="FTDistance input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
                  </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTDistanceEx3.jpg" alt="FTDistance input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
                     <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTDistanceEx4.jpg" alt="FTDistance input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
                  </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTDistanceEx5.jpg" alt="FTDistance input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
                     <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTDistanceEx6.jpg" alt="FTDistance input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
                  </p><p>The result for the <term>FTDistance</term> selection
            consists of only the first <term>Match</term> (with positions 1, 2, and 5) and
            the fifth <term>Match</term> (with positions 25, 27, and 28), because only
            for these <term>Match</term>es the word distance between consecutive
            <term>TokenInfo</term>s  is always less than or equal to 3.
            For the first <term>Match</term>,
	    the word distance between the two <term>TokenInfo</term>s
	    is 2 (<code>startPos</code> 5 - <code>endPos</code> 2 - 1),
            and for the fifth <term>Match</term>,
	    it's 1 (<code>startPos</code> 27 - <code>endPos</code> 25 - 1).
            </p></div4><!-- *************************************************************
             *                            FTTimes                        *
             ************************************************************* --><div4 role="xquery" id="tq-ft-fs-FTTimes"><head>FTTimes</head><p>The parameters of the <function>ApplyFTTimes</function>
            function are 1) an <term>FTRange</term> specification, and 2)
            a parameter corresponding to the result of the nested
            <term>FTWords</term>. </p><p>The function definitions depend on the range
            specification <term>FTRange</term> to limit the number of
            occurrences. </p><p>The general semantics is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:FormCombinations (
      $sms as element(fts:match)*, 
      $k as xs:integer ) 
   as element(fts:match)*
(:
   Find all combinations of exactly $k elements from $sms, and
   for each such combination, construct a match whose children are
   copies of all the children of all the elements in the combination.
   Return the sequence of all such matches.
:)
{
   if ($k eq 0) then &lt;fts:match/&gt;
   else if (fn:count($sms) lt $k) then ()
   else if (fn:count($sms) eq $k) then &lt;fts:match&gt;{$sms/*}&lt;/fts:match&gt;
   else
      let $first := $sms[1],
          $rest  := fn:subsequence($sms, 2)
      return (
         (: all the combinations that don't involve $first :)
         fts:FormCombinations($rest, $k),

         (: and all the combinations that do involve $first :)
         for $combination in fts:FormCombinations($rest, $k - 1)
         return
            &lt;fts:match&gt;
            {
               $first/*,
               $combination/*
            }
            &lt;/fts:match&gt;
      )
};

declare function fts:FormCombinationsAtLeast (
      $sms as element(fts:match)*,
      $times as xs:integer)
   as element(fts:match)*
(:
   Find all combinations of $times or more elements from $sms, and
   for each such combination, construct a match whose children are
   copies of all the children of all the elements in the combination.
   Return the sequence of all such matches.
:)
{
   for $k in $times to fn:count($sms)
   return fts:FormCombinations($sms, $k)
};

declare function fts:FormRange (
      $sms as element(fts:match)*, 
      $l as xs:integer, 
      $u as xs:integer, 
      $stokenNum as xs:integer ) 
   as element(fts:allMatches)
{
   if ($l &gt; $u) then ()
   else 
      let $am1 := &lt;fts:allMatches stokenNum="{$stokenNum}"&gt;
                     {fts:FormCombinationsAtLeast($sms, $l)}
                  &lt;/fts:allMatches&gt;
      let $am2 := &lt;fts:allMatches stokenNum="{$stokenNum}"&gt;
                     {fts:FormCombinationsAtLeast($sms, $u+1)}
                  &lt;/fts:allMatches&gt;
      return fts:ApplyFTAnd($am1,
                            fts:ApplyFTUnaryNot($am2))
};
            </eg><p>The semantics of <code>occurs exactly N times</code> is given 
			below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTTimesExactly (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   fts:FormRange($allMatches/fts:match, $n, $n, $allMatches/@stokenNum)      
};
</eg><p>The semantics of <code>occurs at least N times</code> is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTTimesAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt; 
   {fts:FormCombinationsAtLeast($allMatches/fts:match, $n)} 
   &lt;/fts:allMatches&gt;
};
</eg><p>The semantics of <code>occurs at most N times</code> is given
			below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTTimesAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   fts:FormRange($allMatches/fts:match, 0, $n, $allMatches/@stokenNum)
};
</eg><p>The semantics of <code>occurs from M to N times</code> is given below.</p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTTimesFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   fts:FormRange($allMatches/fts:match, $m, $n, $allMatches/@stokenNum)  
};
</eg><p>The way to ensure that
            there are at least <term>N</term> different matches of an
            <term>FTSelection</term> is to ensure that at least <term>N</term> of
            its <term>Match</term>es occur simultaneously. This is similar to
            forming their conjunction by combining <term>N</term> or more distinct
            <term>Match</term>es into one simple match. Therefore, the <term>AllMatches</term>
            for the selection condition specifying the range qualifier
            <code>at least N </code> contains the possible
            combinations of <term>N</term> or more simple matches of the
            operand.
            This operation
            is performed in the function <function>
            fts:FormCombinationsAtLeast</function>.</p><p>The range [L, U] is represented by the condition 
			<code>at least L and not at least U+1</code>. This transformation
            is performed in the function
            <function>fts:FormRange</function>.</p><p>The semantics for the general case is given below. </p><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:ApplyFTTimes (
      $range as element(fts:range),
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if (fn:count($allMatches//fts:stringExclude) gt 0) then
      fn:error(fn:QName('http://www.w3.org/2005/xqt-errors',
                        'XPST0003'))
   else if ($range/@type eq "exactly") then
      fts:ApplyFTTimesExactly($allMatches, $range/@n)
   else if ($range/@type eq "at least") then 
      fts:ApplyFTTimesAtLeast($allMatches, $range/@n)
   else if ($range/@type eq "at most") then
      fts:ApplyFTTimesAtMost($allMatches, $range/@n)
   else fts:ApplyFTTimesFromTo($allMatches, 
                               $range/@m, 
                               $range/@n)
};
</eg><p>The above function performs a sanity check to ensure that the nested 
<term>AllMatches</term> is a result of the evaluation of <term>FTWords</term> as defined in
the grammar rule for <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPrimary" xlink:type="simple">FTPrimary</nt> . 
Otherwise, an error <xerrorref spec="XP" class="ST" code="0003" type="static"/>
is raised. </p><p>For example, consider the <term>FTTimes</term> selection
            <code>"Mustang" occurs at least 2 times</code>. The source 
			<term>AllMatches</term> of the <term>FTWords</term>
            selection <code>"Mustang"</code> is given below.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTTimesEx1.jpg" alt="FTTimes input AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>The result consists of the pairs of the <term>Match</term>es.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/FTTimesEx2.jpg" alt="FTTimes result AllMatches" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/></div4></div3></div2><!-- *************************************************************
         ***                     FTContainsExpr                    ***
         ************************************************************* --><div2 role="xquery" id="FTContainsSec"><head>FTContainsExpr</head><p>Consider an <term>FTContainsExpr</term> expression of the form
            <code>SearchContext ftcontains FTSelection</code>,
            where <code>SearchContext</code> is an XQuery 1.0
            expression that returns a sequence of items.
            The <term>FTContainsExpr</term> returns true if and only if
            one of those items
            satisfies the <code>FTSelection</code>.</p><p>If the <term>FTContainsExpr</term> is of the form <code>SearchContext 
	    ftcontains FTSelection without content IgnoreExpr</code> for
	    some XQuery 1.0 expression <code>IgnoreExpr</code>, then
	    any nodes returned by <code>IgnoreExpr</code>
	    are (notionally) pruned from each search context item
            before attempting to satisfy the <code>FTSelection</code>.</p><p>
        More formally, evaluation of an <term>FTContainsExpr</term>
        proceeds according to the following steps.
        Where appropriate, the explanation includes references to
        arcs labelled "FTn" in the processing model diagram (Figure 1)
        in <specref ref="processing-model"/>.
        </p><olist><!-- 1 --><item><p>
            For each XQuery/XPath expression nested within the FTContainsExpr,
            evaluate it with respect to
            the same dynamic context as the FTContainsExpr (FT1).
            Specifically:
            </p><olist><!-- 1a --><item><p>
                Evaluate the search context expression (<code>SearchContext</code>),
                resulting in the sequence of search context items.
                </p></item><!-- 1b --><item><p>
                Evaluate the ignore option (<code>IgnoreExpr</code>) if any,
                resulting in the set of ignored nodes.
                </p></item><!-- 1c --><item><p>
                At each FTWordsValue,
                evaluate the literal/expression and convert the result to <code>xs:string*</code>.
                </p></item><!-- 1d --><item><p>
                At each weight specification,
                evaluate the expression and convert the result to <code>xs:double</code>.
                </p></item><!-- 1e --><item><p>
                At each FTWindow and FTRange,
                evaluate the AdditiveExpr(s) and convert each to <code>xs:integer</code>.
                </p></item></olist></item><!-- 3 --><item><p>
            Using the settings of the match option components
            in the FTContainsExpr's static context,
            construct an <code>element(fts:matchOptions)</code> structure.
            </p></item><!-- 2 --><item><p>
            Based on the parse-tree of the FTContainsExpr's FTSelection
            and the results of steps 1c-1e,
            construct an <code>element(*,fts:ftSelection)</code> structure.
            We refer to this as the "operator tree" below.
            In this process:
            </p><olist><item><p>Construct the operator tree from the top down, propagating
        FTMatchOptions down to FTWordsValues.</p></item><item><p>
            Tokenize the query string(s) obtained at 1c. (FT2.1)
            </p></item></olist></item><!-- 4 --><item><p>
            Call the function <function>fts:FTContainsExpr</function> (see declaration below),
            passing the following arguments to its parameters:
            </p><ulist><item><p>
                           <code>$searchContextItems</code>:
                    The sequence of items returned by <code>SearchContext</code>,
                    calculated in step 1a.
                    </p></item><item><p>
                           <code>$ignoreNodes</code>:
                    The sequence of items returned by <code>IgnoreExpr</code> (in 1b),
                    if that expression is present,
                    or the empty sequence otherwise.
                    </p></item><item><p>
                           <code>$ftSelection</code>:
                    The XML node representation of <code>FTSelection</code>
                    (constructed in step 2).
                    </p></item><item><p>
                           <code>$defOptions</code>:
                    The XML representation of the match options
                    in the FTContainsExpr's static context
                    (constructed in step 3).
                    </p></item></ulist><p>
            Within the function,
            for each search context item:
            </p><olist><!-- 4a --><item><p>
                Delete the ignored nodes from the search
                context item.
                [<function>fts:FTContainsExpr</function> calls <function>fts:reconstruct</function>.]
                </p></item><!-- 4b --><item><p>
                Traverse the operator tree from the top down,
                propagating FTMatchOptions down to FTWordsValues.
                [<function>fts:evaluate</function> calls
                itself and <function>fts:replaceMatchOptions</function>.]
                </p></item><!-- 4c --><item><p>
                At each FTWordsValue, using the prevailing FTMatchOptions:
                </p><olist><item><p>
                    Tokenize the search context obtained at 4a. (FT2.2)
                    (Whether this pays any attention to FTMatchOptions is
                    up to the implementation.)
                    [This happens within <function>fts:matchTokenInfos</function>.]
                    </p></item><item><p>
                    Match the search context tokens and the query tokens, 
                    yielding an
                    <code>element(fts:tokenInfo)*</code> structure.
                    [This happens within <function>fts:matchTokenInfos</function>.]
                    </p></item><item><p>
                    Convert that into an <code>element(fts:allMatches)</code>. (FT3)
                    [This happens in <function>fts:applyQueryTokensAsPhrase</function>.]
                    </p></item></olist></item><!-- 4d --><item><p>
                Traverse the operator tree from the bottom up.
                At each point,
                the <term>AllMatches</term> instances produced by subtrees are taken as input,
                and a new <term>AllMatches</term> instance is obtained as output.
                (FT4)
                [This is most of the section 4 code.]
                </p></item><!-- 4e --><item><p>
                If the topmost <term>AllMatches</term> instance contains a <term>Match</term> with no <term>StringExclude</term>s,
                then the search context item
                satisfies the full-text condition given by the <term>FTSelection</term>,
                and the call to <function>fts:FTContainsExpr</function> returns <code>true</code>.
                [This is handled by the QuantifiedExpr in <function>fts:FTContainsExpr</function>.]
                </p></item></olist><p>
            [Note that the section 4 code doesn't implement 4b-4d as three sequential steps.
            Instead, they are different aspects of a single traversal of the operator tree.]
            </p><p>
            If none of the topmost <term>AllMatches</term> provides a successful match,
            then <function>fts:FTContainsExpr</function> returns <code>false</code>.
            </p></item><!-- 4 --><item><p>
            The boolean value returned by the call to <function>fts:FTContainsExpr</function>
            is the value of the FTContainsExpr.
            (FT5)
            </p></item></olist><!-- file: fts.xqy --><eg role="semfunc-file-fts-xquery" xml:space="preserve">
declare function fts:FTContainsExpr (
      $searchContextItems as item()*,
      $ignoreNodes as node()*,
      $ftSelection as element(*,fts:ftSelection),
      $defOptions as element(fts:matchOptions) )
   as xs:boolean 
{ 
   some $searchContext in $searchContextItems
   satisfies 
      let $newSearchContext := fts:reconstruct( $searchContext, $ignoreNodes )
      return
         if (fn:empty($newSearchContext)) then fn:false()
         else
            let $allMatches := fts:evaluate($ftSelection,
                                            $newSearchContext,
                                            $defOptions,
                                            0)
            return 
               some $match in $allMatches/fts:match
               satisfies 
                  fn:count($match/fts:stringExclude) eq 0
};

declare function fts:reconstruct (
      $n as item(),
      $ignore as node()* )
   as item()?
{
   typeswitch ($n)
     case node() return
        if (some $i in $ignore satisfies $n is $i) then ()
        else if ($n instance of element()) then
           let $nodeName := fn:node-name($n)
           let $nodeContent := for $nn in $n/node()
                               return fts:reconstruct($nn,$ignore)
           return element {$nodeName} {$nodeContent}
        else if ($n instance of document-node()) then
           document {
              for $nn in $n/node()
              return fts:reconstruct($nn, $ignore)
           }
        else $n
     default return $n
};
            </eg></div2><!-- **********************************************************
         ***                     Scoring                    ***
         *********************************************************** --><div2 role="xquery" id="ScoreSec"><head>Scoring</head><p>This section addresses the semantics of 
               scoring variables in XQuery 1.0 <code>for</code> and
               <code>let</code> clauses and XPath 2.0 <code>for</code>
               expressions.</p><p>Scoring variables associate a numeric score with the result of the evaluation
			 of XQuery 1.0 and XPath 2.0 expressions. This numeric score
			 tries to estimate the value of a result item to the user
			 information need expressed using the XQuery 1.0 and XPath 2.0 
			 expression. The numeric score is computed using an
             <termref def="dt-implementation-dependent">implementation-dependent</termref> 
			            <emph>scoring algorithm</emph>.</p><p>There are numerous scoring algorithms used in practice. Most of
			 the scoring algorithms take as inputs a query and a set of results
			 to the query. In computing the score, these algorithms rely on the
			 structure of the query to estimate the relevance of the results. 
			 </p><p>In the context of defining the semantics of XQuery and XPath 
			 Full Text, passing the structure of the query poses a problem.
			 The query may contain XQuery 1.0 and XPath 2.0 expressions and
			 XQuery and XPath Full Text expressions in particular. The 
			 semantics of XQuery 1.0 and XPath 2.0 expressions is
			 defined using (among other things) functions that take as
			 arguments sequences of 
			 items and return sequences of items. They are not aware of what
			 expression produced a particular sequence, i.e., they are not
			 aware of the expression structure.</p><p>To define the semantics of scoring in XQuery and XPath 
			 Full Text using XQuery 1.0, expressions that produce
			 the query result (or the functions that implement the expressions)
			 must be passed as arguments. In other words, second-order functions
			 are necessary. Currently XQuery 1.0 and XPath 2.0 do
			 not provide such functions. </p><p>Nevertheless, in the interest of the exposition, assume 
               that such second-order functions are present. In particular, that 
               there are two semantic second-order function
               <code>fts:score</code> and <code>fts:scoreSequence</code>
               that take one argument (an expression) and return the
               score value of this expression, respectively a sequence
               of score values, one for each item to which the expression
               evaluates. The scores must satisfy <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#section-score-variables" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">scoring properties</loc>.</p><p>A <code>for</code> clause containing a score variable
<eg xml:space="preserve">
for $result score $score in Expr
...
</eg>
               is evaluated as
               though it is replaced by the following  the set of clauses.
               
<eg xml:space="preserve">
let $scoreSeq := fts:scoreSequence(Expr)
for $result at $i in Expr
let $score := $scoreSeq[$i]
...
</eg>
               Here, <code>$scoreSeq</code> and <code>$i</code> are
               new variables, not appearing elsewhere, and
               <code>fts:scoreSequence</code> is the 
               second-order function.
            </p><p>Similarly, a <code>let</code> clause containing a score variable
<eg xml:space="preserve">
let score $score := Expr
...
</eg>
               is evaluated as
               though it is replaced by the following clause.
<eg xml:space="preserve">
let $score := fts:score(Expr)
...
</eg>	
            </p></div2><!-- ***************************************************
         ***                    Example                  ***
         *************************************************** --><div2 role="xquery" id="tq-ft-FTContainsExpr-example"><head>Example</head><p>This section presents a more complex example for the evaluation of <term>FTContainsExpr</term>. This example uses the same 
			sample document fragment and assigns it <code>$doc</code>. 
            Consider the following <term>FTContainsExpr</term>.</p><eg role="parse-text" xml:space="preserve">
    $doc ftcontains (
      (
       "mustang" ftand ({("great", "excellent")} any word
       occurs at least 2 times)
      ) window 11 words
      ftand
      ftnot "rust"
    ) same paragraph
</eg><p>Begin by evaluating the <term>FTSelection</term> to <term>AllMatches</term>.</p><eg role="parse-text" xml:space="preserve">
    (
      (
       "mustang" ftand ({("great", "excellent")} any word
       occurs at least 2 times)
      ) window 11 words
      ftand
      ftnot "rust"
    ) same paragraph
</eg><p>Step 1: Evaluate the <term>FTWords</term>
                <code>"mustang"</code>.
            </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample01.jpg" alt="Example, step 1" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Step 2: Evaluate the <term>FTWords</term>
                <code>{"great", "excellent"} any word</code>.
            </p><p>Step 2.1: Match the token "great"</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample02.jpg" alt="Example, step 2" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Step 2.2 Match the token "excellent"</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample03.jpg" alt="Example, step 3" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Step 2.3 - Combine the above <term>AllMatches</term> as if <term>FTOr</term> is used, i.e., by
                forming  a union of the <term>Match</term>es.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample04.jpg" alt="Example, step 4" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Step 3 - Apply the <term>FTTimes</term>
                <code>{("great", "excellent")} any word occurs at least 2 times</code>
				forming two pairs of <term>Match</term>es.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample05_1.jpg" alt="Example, step 5.1" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample05_1_2.jpg" alt="Example, step 5.1" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample05_2.jpg" alt="Example, step 5.2" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Step 4 - Apply the <term>FTAnd</term>
                <code>"Mustang" 
                ftand ({("great", "excellent")} any word occurs at least 2 
                times)</code> forming all possible pairs of <term>StringMatch</term>es.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample06_1.jpg" alt="Example, step 6.1" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
               <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample06_1_2.jpg" alt="Example, step 6.1" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
            </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample06_2.jpg" alt="Example, step 6.2" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
               <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample06_2_2.jpg" alt="Example, step 6.2" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
            </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample06_3.jpg" alt="Example, step 6.3" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
               <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample06_3_2.jpg" alt="Example, step 6.3" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
            </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample06_4.jpg" alt="Example, step 6.4" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
               <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample06_4_2.jpg" alt="Example, step 6.4" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
            </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample06_5.jpg" alt="Example, step 6.5" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
               <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample06_5_2.jpg" alt="Example, step 6.5" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
            </p><p>Step 5 - Apply the <term>FTWindow</term>
                <code>("Mustang" 
                ftand ({("great", "excellent")} any word 
                occurs at least 2 times)) window 11 words</code>, filtering out <term>Match</term>es 
                for which the window is not less than or equal to 11 tokens.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample07_1.jpg" alt="Example, step 7.1" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>
               <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample07_2.jpg" alt="Example, step 7.2" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
            </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample07_2_2.jpg" alt="Example, step 7.2" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Step 6 - Evaluate <term>FTWords</term>
                <code>"rust"</code>.
            </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample08.jpg" alt="Example, step 8" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Step 7 - Apply the <term>FTUnaryNot</term>
                <code>ftnot "rust"</code>, 
                transforming the <code>StringInclude</code> into a 
				<code>StringExclude</code>.
            </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample09.jpg" alt="Example, step 9" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Step 8 - Apply the <term>FTAnd</term>
                <code>(("Mustang"
                ftand ({("great", "excellent")} any word occurs at least 2 times)) 
                window 11 words) ftand ftnot "rust"</code>, forming all
				possible combintations of three <term>StringMatch</term>es from the first
				<term>AllMatches</term> and one <term>StringMatch</term> from the second <term>AllMatches</term>. </p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample10_1.jpg" alt="Example, step 10.1" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p/><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample10_2.jpg" alt="Example, step 10.2" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p/><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample10_3.jpg" alt="Example, step 10.3" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p/><p>Step 9: Apply the <term>FTScope</term>,  filtering out <term>
                Match</term>es whose <term>TokenInfo</term>s are not within the same paragraph 
				(assuming the <code>&lt;offer&gt;</code> elements determine
				paragraph boundaries).</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="images/CompleteExample11.jpg" alt="Example, step 11" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>The resulting <term>AllMatches</term> contains a <term>Match</term> 
            that does not contain a <term>StringExclude</term>. Therefore, the
            sample <term>FTContainsExpr</term> returns <code>true</code>.</p></div2></div1><div1 id="id-tq-conformance"><head>Conformance</head><p>This section defines the conformance criteria for a XQuery and XPath Full Text 1.0
       processor.
  </p><p>In this section, the following terms are used to indicate the
     requirement levels defined in <bibref ref="RFC2119"/>.
      <termdef id="must" term="must">
               <term>MUST</term> means that the item is an absolute requirement of the specification.</termdef>
            <termdef id="may" term="may">
               <term>MAY</term> means that an item is truly optional.</termdef>
            <termdef id="should" term="should">
               <term>SHOULD</term> means that there may exist valid reasons in particular circumstances
          to ignore a particular item, but the full implications must be understood and carefully
          weighed before choosing a different course.</termdef>
         </p><p>An XQuery and XPath Full Text 1.0 processor that claims to conform to 
     this specification <termref def="must">MUST</termref>
     include a claim of Minimal Conformance as defined in 
     <specref ref="id-minimal-conformance"/>.
     In addition to a claim of Minimal Conformance, 
     it <termref def="may">MAY</termref>
     claim conformance to one or more optional features defined in 
     <specref ref="id-conform-optional-features"/>
         </p><div2 id="id-minimal-conformance"><head>Minimal Conformance</head><p>Minimal Conformance to this specification 
    <termref def="must">MUST</termref> include all of the following items:</p><olist><item><p>Minimal support for XQuery 1.0 <bibref ref="xquery"/>
        or XPath 2.0 <bibref ref="xpath20"/>. 
        The optional features of XQuery 1.0 <bibref ref="xquery"/> or
        XPath 2.0 <bibref ref="xpath20"/> 
                     <termref def="may">MAY</termref>
        be supported.</p></item><item><p>Support for everything specified in this document except those
          operators and match options specified in 
          <specref ref="id-conform-optional-features"/> to be optional.
          If an implementation does not provide a given optional operator or
          match option, it  <termref def="must">MUST</termref>
          implement any requirements specified in 
          <specref ref="id-conform-optional-features"/>
          for implementations that do not provide that operator or match
          option.</p></item><item><p>A definition of every item specified to be 
           <termref def="dt-implementation-defined">implementation-defined</termref> in 
           <specref ref="impl-def"/>.</p><note><p>Implementations are not required to define items specified to
              be <termref def="dt-implementation-dependent">implementation-dependent</termref>
                     </p></note></item></olist></div2><div2 id="id-conform-optional-features"><head>Optional Features</head><div3 id="id-ftmildnot-option"><head>FTMildNot Operator</head><p>It is optional whether the implementation supports the FTMildNot. If
        it does not support FTMildNot and encounters one in a full-text
        query, then it <termref def="must">MUST</termref> raise
        an error <errorref class="ST" code="0001"/>.</p></div3><div3 id="id-unary-not-option"><head>FTUnaryNot Operator</head><p>The unrestricted form of negation in FTUnaryNot,
         that can negate every kind of FTSelection, is
         optional. Implementations may choose to support the negation
         operation in a restricted form, enforcing one or both of the
         following restrictions.</p><ulist><item><p>
                        <termdef id="id-Negation-Restriction-1" term="Negation Restriction 1">
                           <term>Negation Restriction 1.</term> An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnaryNot" xlink:type="simple">FTUnaryNot</nt>
        expression may only appear as a direct right operand of an
        "ftand" (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTAnd" xlink:type="simple">FTAnd</nt>) operation.</termdef>
                     </p></item><item><p>
                        <termdef id="id-Negation-Restriction-2" term="Negation Restriction 2">
                           <term>Negation Restriction 2.</term> An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnaryNot" xlink:type="simple">FTUnaryNot</nt>
        expression may not appear as a descendant of an 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTOr" xlink:type="simple">FTOr</nt> that is modified by an 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTPosFilter" xlink:type="simple">FTPosFilter</nt>. (An
        FTOr is modified by an FTPosFilter, if it is derived using
        the production for <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTSelection" xlink:type="simple">FTSelection</nt> 
         together with that FTPosFilter.)</termdef>
                     </p></item></ulist><p>Consider the following example FTSelections.</p><eg xml:space="preserve">
1. ftnot "web"

2. "web" ftand ( ftnot "information" ftor "retrieval" )

3. "web" ftand ftnot("information" ftand "retrieval")

4. "web" ftand ftnot("information" ftand "retrieval" window 5 words)

5. "web" ftand ("information" ftand ftnot "retrieval" window 5 words)
</eg><p>The first two FTSelections both violate restriction 1, while the third and 
the fourth are conform with both restrictions. The fifth one violates 
restriction 2, while obeying restriction 1. Note that in the last example 
the FTSelection to which the window operation is applied is 
<code>"information" ftand ftnot "retrieval"</code>, which contains an FTUnaryNot 
expression.</p><p>If the implementation does enforce
           one or both of these restrictions on FTUnaryNot and encounters a
           full-text query that does not obey the restriction then it 
           <termref def="must">MUST</termref>
           raise an error <errorref class="ST" code="0002"/>.</p></div3><div3 id="id-ftunit-option"><head>FTUnit and FTBigUnit</head><p>It is optional whether the implementation supports all the choices
        of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTUnit" xlink:type="simple">FTUnit</nt> and 
        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTBigUnit" xlink:type="simple">FTBigUnit</nt>. If it does not support one or
          more choices of FTUnit or FTBigUnit and encounters an unsupported
        FTUnit or FTBigUnit in a full-text query, then it 
        <termref def="must">MUST</termref> raise an error
        <errorref class="ST" code="0003"/>.</p></div3><div3 id="id-ftorder-option"><head>FTOrder Operator</head><p>The unrestricted form of the FTOrder postfix operator, that can be 
        applied to any kind of FTSelection, is optional.
        Implementations may choose to enforce the following
        restriction on the use of FTOrder.</p><p>
                  <termdef id="id-Order-Operator-Restriction" term="Order Operator Restriction">
                     <term>Order Operator Restriction.</term> FTOrder may only appear directly succeeding 
        an FTWindow or an FTDistance operator.</termdef>
               </p><p>If the implementation does enforce this restriction and encounters a
        full-text query that does not obey the restriction then it 
        <termref def="must">MUST</termref>
        raise an error <errorref class="ST" code="0010"/>.</p></div3><div3 id="id-ftscope-option"><head>FTScope Operator</head><p>It is optional whether the implementation supports the FTScope
      operator.  If it does not support FTScope and encounters one in a
      full-text query, then it <termref def="must">MUST</termref> raise an
      error <errorref class="ST" code="0004"/>.</p></div3><div3 id="id-ftwindow-option"><head>FTWindow Operator</head><p>The unrestricted form of the FTWindow postfix operator, that can be 
        applied to any kind of FTSelection, is optional.
        Implementations may choose to enforce the following
        restriction on the use of FTWindow.</p><p>
                  <termdef id="id-Window-Operator-Restriction" term="Window Operator Restriction">
                     <term>Window Operator Restriction.</term> FTWindow can only be applied to an FTOr that
        is either a single FTWords or a combination of FTWords involving only the 
        operators ftand and ftor.</termdef>
               </p><p>If the implementation does enforce this restriction and encounters a
        full-text query that does not obey the restriction then it 
        <termref def="must">MUST</termref>
        raise an error <errorref class="ST" code="0011"/>.</p></div3><div3 id="id-ftdistance-option"><head>FTDistance Operator</head><p>The unrestricted form of the FTDistance postfix operator, that can be 
        applied to any kind of FTSelection, is optional.
        Implementations may choose to enforce the following
        restriction on the use of FTDistance.</p><p>
                  <termdef id="id-Distance-Operator-Restriction" term="Distance Operator Restriction">
                     <term>Distance Operator Restriction.</term> FTDistance can only be applied to an FTOr that
        is either a single FTWords or a combination of FTWords involving only the 
        operators ftand and ftor.</termdef>
               </p><p>If the implementation does enforce this restriction and encounters a
        full-text query that does not obey the restriction then it 
        <termref def="must">MUST</termref>
        raise an error <errorref class="ST" code="0011"/>.</p></div3><div3 id="id-fttimes-option"><head>FTTimes Operator</head><p>It is optional whether the implementation supports the FTTimes
        operator. If it does not support FTTimes and encounters one in a
        full-text query, then it <termref def="must">MUST</termref> raise an
        error <errorref class="ST" code="0005"/>.</p></div3><div3 id="id-ftcontent-option"><head>FTContent Operator</head><p>It is optional whether the implementation supports the FTContent
      operator.  If it does not support FTContent and encounters one in a
      full-text query, then it <termref def="must">MUST</termref> raise an
      error <errorref class="ST" code="0012"/>.</p></div3><div3 id="id-ftcase-option"><head>FTCaseOption</head><p>It is optional whether the implementation supports the
    "lowercase" and "uppercase" choices for the
    FTCaseOption.  If it does not support these choices for the FTCaseOption
    and encounters an unsupported choice in a full-text query, then it 
        <termref def="must">MUST</termref> raise an error
        <errorref class="ST" code="0015"/>.
    </p></div3><div3 id="id-ftstopword-option"><head>FTStopWordOption</head><p>It is optional whether the implementation supports the
        FTStopWordOption. If it does not support FTStopWordOption and
        encounters one in a full-text query, then it 
        <termref def="must">MUST</termref> raise an
        error <errorref class="ST" code="0006"/>.</p><p>It is optional whether the implementation supports the
        FTStopWordOption in the body of the query. If it supports
        FTStopWordOption in the prolog, but not in the body of a query, and
        encounters one in the body of a query it 
        <termref def="must">MUST</termref> raise an
        error <errorref class="ST" code="0006"/>.</p><p>It is optional whether the implementation supports the StringLiteral
        alternative of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTStopWords" xlink:type="simple">FTStopWords</nt> in the 
        FTStopWordOption. If it does not support the StringLiteral alternative
        of FTStopWords and encounters such an alternative in a full-text query,
        then it <termref def="must">MUST</termref> raise an
        error <errorref class="ST" code="0006"/>.</p></div3><div3 id="id-ftlanguage-option"><head>FTLanguageOption</head><p>It is optional whether the implementation supports the unrestricted form 
        of FTLanguageOption. Implementations may choose to enforce the following 
        restriction on the use of FTLanguageOption.</p><p>
                  <termdef id="id-Single-Language-Restriction" term="Single Language Restriction">
                     <term>Single Language Restriction.</term> If a full-text query contains more than one
        FTLanguageOption in its body and the prolog, then the languages specified 
        must be the same.</termdef>
               </p><p>If the implementation does enforce this restriction and encounters a
        full-text query that does not obey the restriction then it 
        <termref def="must">MUST</termref>
        raise an error <errorref class="ST" code="0013"/>.</p></div3><div3 id="id-ftignore-option"><head>FTIgnoreOption</head><p>The implementation may constrain the set of ignored nodes.
      If the operand of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTIgnoreOption" xlink:type="simple">FTIgnoreOption</nt> violates
      the <termref def="dt-implementation-defined">implementation-defined</termref> restriction on that operand, it 
      <termref def="must">MUST</termref> raise an
      error <errorref class="ST" code="0007"/>.</p></div3><div3 id="id-scoring-option"><head>Scoring</head><p>The implementation may restrict the allowable expressions used to
      compute scores.  The restrictions are <termref def="dt-implementation-defined">implementation-defined</termref>.
      </p><p>If the implementation does enforce such restrictions and encounters a
        full-text query that does not obey the restriction then it 
        <termref def="must">MUST</termref>
        raise an error <errorref class="ST" code="0014"/>.</p></div3><div3 id="id-weights-conf"><head>Weights</head><p>An implementation may constrain the range of valid weights to
    non-negative values. If an implementation does enforce this restriction and
    encounters a full-text query that uses a negative weight, it 
    <termref def="must">MUST</termref> raise an
    error <errorref class="DY" code="0016"/>.
    </p></div3></div2></div1></body><back id="id-appendices"><div1 id="id-grammar"><head>EBNF for XQuery 1.0 Grammar with Full-Text
		extensions</head><p>The EBNF in this document and in this section is aligned with
the current XML Query 1.0 grammar (see <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xquery-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/CR-xquery-20051103/</loc>).</p><scrap role="non-terminal-structure-expand" headstyle="show"><head/><prod num="1" id="prod-xquery-Module"><lhs>Module</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VersionDecl" xlink:type="simple">VersionDecl</nt>?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-LibraryModule" xlink:type="simple">LibraryModule</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-MainModule" xlink:type="simple">MainModule</nt>)</rhs></prod><prod num="2" id="prod-xquery-VersionDecl"><lhs>VersionDecl</lhs><rhs>"xquery"  "version"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>  ("encoding"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Separator" xlink:type="simple">Separator</nt>
               </rhs></prod><prod num="3" id="prod-xquery-MainModule"><lhs>MainModule</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Prolog" xlink:type="simple">Prolog</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QueryBody" xlink:type="simple">QueryBody</nt>
               </rhs></prod><prod num="4" id="prod-xquery-LibraryModule"><lhs>LibraryModule</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ModuleDecl" xlink:type="simple">ModuleDecl</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Prolog" xlink:type="simple">Prolog</nt>
               </rhs></prod><prod num="5" id="prod-xquery-ModuleDecl"><lhs>ModuleDecl</lhs><rhs>"module"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Separator" xlink:type="simple">Separator</nt>
               </rhs></prod><prod num="6" id="prod-xquery-Prolog"><lhs>Prolog</lhs><rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DefaultNamespaceDecl" xlink:type="simple">DefaultNamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Setter" xlink:type="simple">Setter</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NamespaceDecl" xlink:type="simple">NamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Import" xlink:type="simple">Import</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTOptionDecl" xlink:type="simple">FTOptionDecl</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Separator" xlink:type="simple">Separator</nt>)*  ((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarDecl" xlink:type="simple">VarDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FunctionDecl" xlink:type="simple">FunctionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OptionDecl" xlink:type="simple">OptionDecl</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Separator" xlink:type="simple">Separator</nt>)*</rhs></prod><prod num="7" id="prod-xquery-Setter"><lhs>Setter</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-BoundarySpaceDecl" xlink:type="simple">BoundarySpaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DefaultCollationDecl" xlink:type="simple">DefaultCollationDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-BaseURIDecl" xlink:type="simple">BaseURIDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ConstructionDecl" xlink:type="simple">ConstructionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderingModeDecl" xlink:type="simple">OrderingModeDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EmptyOrderDecl" xlink:type="simple">EmptyOrderDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CopyNamespacesDecl" xlink:type="simple">CopyNamespacesDecl</nt>
               </rhs></prod><prod num="8" id="prod-xquery-Import"><lhs>Import</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SchemaImport" xlink:type="simple">SchemaImport</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ModuleImport" xlink:type="simple">ModuleImport</nt>
               </rhs></prod><prod num="9" id="prod-xquery-Separator"><lhs>Separator</lhs><rhs>";"</rhs></prod><prod num="10" id="prod-xquery-NamespaceDecl"><lhs>NamespaceDecl</lhs><rhs>"declare"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>
               </rhs></prod><prod num="11" id="prod-xquery-BoundarySpaceDecl"><lhs>BoundarySpaceDecl</lhs><rhs>"declare"  "boundary-space"  ("preserve"  |  "strip")</rhs></prod><prod num="12" id="prod-xquery-DefaultNamespaceDecl"><lhs>DefaultNamespaceDecl</lhs><rhs>"declare"  "default"  ("element"  |  "function")  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>
               </rhs></prod><prod num="13" id="prod-xquery-OptionDecl"><lhs>OptionDecl</lhs><rhs>"declare"  "option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>
               </rhs></prod><prod num="14" id="prod-xquery-FTOptionDecl"><lhs>FTOptionDecl</lhs><rhs>"declare"  "ft-option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTMatchOptions" xlink:type="simple">FTMatchOptions</nt>
               </rhs></prod><prod num="15" id="prod-xquery-OrderingModeDecl"><lhs>OrderingModeDecl</lhs><rhs>"declare"  "ordering"  ("ordered"  |  "unordered")</rhs></prod><prod num="16" id="prod-xquery-EmptyOrderDecl"><lhs>EmptyOrderDecl</lhs><rhs>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</rhs></prod><prod num="17" id="prod-xquery-CopyNamespacesDecl"><lhs>CopyNamespacesDecl</lhs><rhs>"declare"  "copy-namespaces"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PreserveMode" xlink:type="simple">PreserveMode</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-InheritMode" xlink:type="simple">InheritMode</nt>
               </rhs></prod><prod num="18" id="prod-xquery-PreserveMode"><lhs>PreserveMode</lhs><rhs>"preserve"  |  "no-preserve"</rhs></prod><prod num="19" id="prod-xquery-InheritMode"><lhs>InheritMode</lhs><rhs>"inherit"  |  "no-inherit"</rhs></prod><prod num="20" id="prod-xquery-DefaultCollationDecl"><lhs>DefaultCollationDecl</lhs><rhs>"declare"  "default"  "collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>
               </rhs></prod><prod num="21" id="prod-xquery-BaseURIDecl"><lhs>BaseURIDecl</lhs><rhs>"declare"  "base-uri"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>
               </rhs></prod><prod num="22" id="prod-xquery-SchemaImport"><lhs>SchemaImport</lhs><rhs>"import"  "schema"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SchemaPrefix" xlink:type="simple">SchemaPrefix</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod><prod num="23" id="prod-xquery-SchemaPrefix"><lhs>SchemaPrefix</lhs><rhs>("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "=")  |  ("default"  "element"  "namespace")</rhs></prod><prod num="24" id="prod-xquery-ModuleImport"><lhs>ModuleImport</lhs><rhs>"import"  "module"  ("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "=")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod><prod num="25" id="prod-xquery-VarDecl"><lhs>VarDecl</lhs><rhs>"declare"  "variable"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ((":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)  |  "external")</rhs></prod><prod num="26" id="prod-xquery-ConstructionDecl"><lhs>ConstructionDecl</lhs><rhs>"declare"  "construction"  ("strip"  |  "preserve")</rhs></prod><prod num="27" id="prod-xquery-FunctionDecl"><lhs>FunctionDecl</lhs><rhs>"declare"  "function"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SequenceType" xlink:type="simple">SequenceType</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>  |  "external")</rhs></prod><prod num="28" id="prod-xquery-ParamList"><lhs>ParamList</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Param" xlink:type="simple">Param</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Param" xlink:type="simple">Param</nt>)*</rhs></prod><prod num="29" id="prod-xquery-Param"><lhs>Param</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs></prod><prod num="30" id="prod-xquery-EnclosedExpr"><lhs>EnclosedExpr</lhs><rhs>"{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="31" id="prod-xquery-QueryBody"><lhs>QueryBody</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>
               </rhs></prod><prod num="32" id="prod-xquery-Expr"><lhs>Expr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="33" id="prod-xquery-ExprSingle"><lhs>ExprSingle</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FLWORExpr" xlink:type="simple">FLWORExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeswitchExpr" xlink:type="simple">TypeswitchExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-IfExpr" xlink:type="simple">IfExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrExpr" xlink:type="simple">OrExpr</nt>
               </rhs></prod><prod num="34" id="prod-xquery-FLWORExpr"><lhs>FLWORExpr</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-LetClause" xlink:type="simple">LetClause</nt>)+  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-WhereClause" xlink:type="simple">WhereClause</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderByClause" xlink:type="simple">OrderByClause</nt>?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>
               </rhs></prod><prod num="35" id="prod-xquery-ForClause"><lhs>ForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PositionalVar" xlink:type="simple">PositionalVar</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTScoreVar" xlink:type="simple">FTScoreVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PositionalVar" xlink:type="simple">PositionalVar</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTScoreVar" xlink:type="simple">FTScoreVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="36" id="prod-xquery-PositionalVar"><lhs>PositionalVar</lhs><rhs>"at"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>
               </rhs></prod><prod num="37" id="prod-xquery-FTScoreVar"><lhs>FTScoreVar</lhs><rhs>"score"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>
               </rhs></prod><prod num="38" id="prod-xquery-LetClause"><lhs>LetClause</lhs><rhs>(("let"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?)  |  ("let"  "score"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>))  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  (("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTScoreVar" xlink:type="simple">FTScoreVar</nt>)  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="39" id="prod-xquery-WhereClause"><lhs>WhereClause</lhs><rhs>"where"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>
               </rhs></prod><prod num="40" id="prod-xquery-OrderByClause"><lhs>OrderByClause</lhs><rhs>(("order"  "by")  |  ("stable"  "order"  "by"))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderSpecList" xlink:type="simple">OrderSpecList</nt>
               </rhs></prod><prod num="41" id="prod-xquery-OrderSpecList"><lhs>OrderSpecList</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderSpec" xlink:type="simple">OrderSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderSpec" xlink:type="simple">OrderSpec</nt>)*</rhs></prod><prod num="42" id="prod-xquery-OrderSpec"><lhs>OrderSpec</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderModifier" xlink:type="simple">OrderModifier</nt>
               </rhs></prod><prod num="43" id="prod-xquery-OrderModifier"><lhs>OrderModifier</lhs><rhs>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs></prod><prod num="44" id="prod-xquery-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>
               </rhs></prod><prod num="45" id="prod-xquery-TypeswitchExpr"><lhs>TypeswitchExpr</lhs><rhs>"typeswitch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CaseClause" xlink:type="simple">CaseClause</nt>+  "default"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>)?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>
               </rhs></prod><prod num="46" id="prod-xquery-CaseClause"><lhs>CaseClause</lhs><rhs>"case"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  "as")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SequenceType" xlink:type="simple">SequenceType</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>
               </rhs></prod><prod num="47" id="prod-xquery-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>
               </rhs></prod><prod num="48" id="prod-xquery-OrExpr"><lhs>OrExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod><prod num="49" id="prod-xquery-AndExpr"><lhs>AndExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod><prod num="50" id="prod-xquery-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ValueComp" xlink:type="simple">ValueComp</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-GeneralComp" xlink:type="simple">GeneralComp</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt> )?</rhs></prod><prod num="51" id="prod-xquery-FTContainsExpr"><lhs>FTContainsExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RangeExpr" xlink:type="simple">RangeExpr</nt> ( "ftcontains"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTSelection" xlink:type="simple">FTSelection</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTIgnoreOption" xlink:type="simple">FTIgnoreOption</nt>? )?</rhs></prod><prod num="52" id="prod-xquery-RangeExpr"><lhs>RangeExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod><prod num="53" id="prod-xquery-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod><prod num="54" id="prod-xquery-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod><prod num="55" id="prod-xquery-UnionExpr"><lhs>UnionExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod><prod num="56" id="prod-xquery-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod><prod num="57" id="prod-xquery-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="58" id="prod-xquery-TreatExpr"><lhs>TreatExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="59" id="prod-xquery-CastableExpr"><lhs>CastableExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="60" id="prod-xquery-CastExpr"><lhs>CastExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="61" id="prod-xquery-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ValueExpr" xlink:type="simple">ValueExpr</nt>
               </rhs></prod><prod num="62" id="prod-xquery-ValueExpr"><lhs>ValueExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ValidateExpr" xlink:type="simple">ValidateExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PathExpr" xlink:type="simple">PathExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt>
               </rhs></prod><prod num="63" id="prod-xquery-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod><prod num="64" id="prod-xquery-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod><prod num="65" id="prod-xquery-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod><prod num="66" id="prod-xquery-ValidateExpr"><lhs>ValidateExpr</lhs><rhs>"validate"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ValidationMode" xlink:type="simple">ValidationMode</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="67" id="prod-xquery-ValidationMode"><lhs>ValidationMode</lhs><rhs>"lax"  |  "strict"</rhs></prod><prod num="68" id="prod-xquery-ExtensionExpr"><lhs>ExtensionExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod><prod num="69" id="prod-xquery-Pragma"><lhs>Pragma</lhs><rhs>"(#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PragmaContents" xlink:type="simple">PragmaContents</nt>)?  "#)"</rhs><com>
                  <phrase>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                  </phrase>
               </com></prod><prod num="70" id="prod-xquery-PragmaContents"><lhs>PragmaContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* '#)' Char*))</rhs></prod><prod num="71" id="prod-xquery-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>
               </rhs><com>
                  <phrase>
                     <xspecref ref="parse-note-leading-lone-slash" spec="XQ">xgc: leading-lone-slash</xspecref>
                  </phrase>
               </com></prod><prod num="72" id="prod-xquery-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod><prod num="73" id="prod-xquery-StepExpr"><lhs>StepExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FilterExpr" xlink:type="simple">FilterExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AxisStep" xlink:type="simple">AxisStep</nt>
               </rhs></prod><prod num="74" id="prod-xquery-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredicateList" xlink:type="simple">PredicateList</nt>
               </rhs></prod><prod num="75" id="prod-xquery-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt>
               </rhs></prod><prod num="76" id="prod-xquery-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")</rhs></prod><prod num="77" id="prod-xquery-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NodeTest" xlink:type="simple">NodeTest</nt>
               </rhs></prod><prod num="78" id="prod-xquery-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt>
               </rhs></prod><prod num="79" id="prod-xquery-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod><prod num="80" id="prod-xquery-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod><prod num="81" id="prod-xquery-NodeTest"><lhs>NodeTest</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NameTest" xlink:type="simple">NameTest</nt>
               </rhs></prod><prod num="82" id="prod-xquery-NameTest"><lhs>NameTest</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Wildcard" xlink:type="simple">Wildcard</nt>
               </rhs></prod><prod num="83" id="prod-xquery-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>)</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="84" id="prod-xquery-FilterExpr"><lhs>FilterExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredicateList" xlink:type="simple">PredicateList</nt>
               </rhs></prod><prod num="85" id="prod-xquery-PredicateList"><lhs>PredicateList</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod><prod num="86" id="prod-xquery-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod><prod num="87" id="prod-xquery-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FunctionCall" xlink:type="simple">FunctionCall</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderedExpr" xlink:type="simple">OrderedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-UnorderedExpr" xlink:type="simple">UnorderedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Constructor" xlink:type="simple">Constructor</nt>
               </rhs></prod><prod num="88" id="prod-xquery-Literal"><lhs>Literal</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>
               </rhs></prod><prod num="89" id="prod-xquery-NumericLiteral"><lhs>NumericLiteral</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>
               </rhs></prod><prod num="90" id="prod-xquery-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>
               </rhs></prod><prod num="91" id="prod-xquery-VarName"><lhs>VarName</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>
               </rhs></prod><prod num="92" id="prod-xquery-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod><prod num="93" id="prod-xquery-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod><prod num="94" id="prod-xquery-OrderedExpr"><lhs>OrderedExpr</lhs><rhs>"ordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="95" id="prod-xquery-UnorderedExpr"><lhs>UnorderedExpr</lhs><rhs>"unordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="96" id="prod-xquery-FunctionCall"><lhs>FunctionCall</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs><com>
                  <phrase>
                     <xspecref ref="parse-note-reserved-function-names" spec="XQ">xgc: reserved-function-names</xspecref>
                  </phrase>
               </com><com>
                  <phrase>
                     <xspecref ref="parse-note-parens" spec="XQ">gn: parens</xspecref>
                  </phrase>
               </com></prod><prod num="97" id="prod-xquery-Constructor"><lhs>Constructor</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ComputedConstructor" xlink:type="simple">ComputedConstructor</nt>
               </rhs></prod><prod num="98" id="prod-xquery-DirectConstructor"><lhs>DirectConstructor</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirElemConstructor" xlink:type="simple">DirElemConstructor</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirCommentConstructor" xlink:type="simple">DirCommentConstructor</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirPIConstructor" xlink:type="simple">DirPIConstructor</nt>
               </rhs></prod><prod num="99" id="prod-xquery-DirElemConstructor"><lhs>DirElemConstructor</lhs><rhs>"&lt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirAttributeList" xlink:type="simple">DirAttributeList</nt>  ("/&gt;"  |  ("&gt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirElemContent" xlink:type="simple">DirElemContent</nt>*  "&lt;/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  "&gt;"))</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="100" id="prod-xquery-DirAttributeList"><lhs>DirAttributeList</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirAttributeValue" xlink:type="simple">DirAttributeValue</nt>)?)*</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="101" id="prod-xquery-DirAttributeValue"><lhs>DirAttributeValue</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QuotAttrValueContent" xlink:type="simple">QuotAttrValueContent</nt>)*  '"')<br/>|  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AposAttrValueContent" xlink:type="simple">AposAttrValueContent</nt>)*  "'")</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="102" id="prod-xquery-QuotAttrValueContent"><lhs>QuotAttrValueContent</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QuotAttrContentChar" xlink:type="simple">QuotAttrContentChar</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CommonContent" xlink:type="simple">CommonContent</nt>
               </rhs></prod><prod num="103" id="prod-xquery-AposAttrValueContent"><lhs>AposAttrValueContent</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AposAttrContentChar" xlink:type="simple">AposAttrContentChar</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CommonContent" xlink:type="simple">CommonContent</nt>
               </rhs></prod><prod num="104" id="prod-xquery-DirElemContent"><lhs>DirElemContent</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CDataSection" xlink:type="simple">CDataSection</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CommonContent" xlink:type="simple">CommonContent</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementContentChar" xlink:type="simple">ElementContentChar</nt>
               </rhs></prod><prod num="105" id="prod-xquery-CommonContent"><lhs>CommonContent</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  "{{"  |  "}}"  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
               </rhs></prod><prod num="106" id="prod-xquery-DirCommentConstructor"><lhs>DirCommentConstructor</lhs><rhs>"&lt;!--"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirCommentContents" xlink:type="simple">DirCommentContents</nt>  "--&gt;"</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="107" id="prod-xquery-DirCommentContents"><lhs>DirCommentContents</lhs><rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - '-')  |  ('-'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - '-')))*</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="108" id="prod-xquery-DirPIConstructor"><lhs>DirPIConstructor</lhs><rhs>"&lt;?"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PITarget" xlink:type="simple">PITarget</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirPIContents" xlink:type="simple">DirPIContents</nt>)?  "?&gt;"</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="109" id="prod-xquery-DirPIContents"><lhs>DirPIContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* '?&gt;' Char*))</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="110" id="prod-xquery-CDataSection"><lhs>CDataSection</lhs><rhs>"&lt;![CDATA["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CDataSectionContents" xlink:type="simple">CDataSectionContents</nt>  "]]&gt;"</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="111" id="prod-xquery-CDataSectionContents"><lhs>CDataSectionContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* ']]&gt;' Char*))</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="112" id="prod-xquery-ComputedConstructor"><lhs>ComputedConstructor</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompDocConstructor" xlink:type="simple">CompDocConstructor</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompElemConstructor" xlink:type="simple">CompElemConstructor</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompAttrConstructor" xlink:type="simple">CompAttrConstructor</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompTextConstructor" xlink:type="simple">CompTextConstructor</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompCommentConstructor" xlink:type="simple">CompCommentConstructor</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompPIConstructor" xlink:type="simple">CompPIConstructor</nt>
               </rhs></prod><prod num="113" id="prod-xquery-CompDocConstructor"><lhs>CompDocConstructor</lhs><rhs>"document"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="114" id="prod-xquery-CompElemConstructor"><lhs>CompElemConstructor</lhs><rhs>"element"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ContentExpr" xlink:type="simple">ContentExpr</nt>?  "}"</rhs></prod><prod num="115" id="prod-xquery-ContentExpr"><lhs>ContentExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>
               </rhs></prod><prod num="116" id="prod-xquery-CompAttrConstructor"><lhs>CompAttrConstructor</lhs><rhs>"attribute"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod><prod num="117" id="prod-xquery-CompTextConstructor"><lhs>CompTextConstructor</lhs><rhs>"text"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="118" id="prod-xquery-CompCommentConstructor"><lhs>CompCommentConstructor</lhs><rhs>"comment"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="119" id="prod-xquery-CompPIConstructor"><lhs>CompPIConstructor</lhs><rhs>"processing-instruction"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod><prod num="120" id="prod-xquery-SingleType"><lhs>SingleType</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod><prod num="121" id="prod-xquery-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SequenceType" xlink:type="simple">SequenceType</nt>
               </rhs></prod><prod num="122" id="prod-xquery-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ItemType" xlink:type="simple">ItemType</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod><prod num="123" id="prod-xquery-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs><com>
                  <phrase>
                     <xspecref ref="parse-note-occurrence-indicators" spec="XQ">xgc: occurrence-indicators</xspecref>
                  </phrase>
               </com></prod><prod num="124" id="prod-xquery-ItemType"><lhs>ItemType</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AtomicType" xlink:type="simple">AtomicType</nt>
               </rhs></prod><prod num="125" id="prod-xquery-AtomicType"><lhs>AtomicType</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>
               </rhs></prod><prod num="126" id="prod-xquery-KindTest"><lhs>KindTest</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DocumentTest" xlink:type="simple">DocumentTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementTest" xlink:type="simple">ElementTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AttributeTest" xlink:type="simple">AttributeTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PITest" xlink:type="simple">PITest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CommentTest" xlink:type="simple">CommentTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TextTest" xlink:type="simple">TextTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AnyKindTest" xlink:type="simple">AnyKindTest</nt>
               </rhs></prod><prod num="127" id="prod-xquery-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod><prod num="128" id="prod-xquery-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod><prod num="129" id="prod-xquery-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod><prod num="130" id="prod-xquery-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod><prod num="131" id="prod-xquery-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod><prod num="132" id="prod-xquery-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod><prod num="133" id="prod-xquery-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod><prod num="134" id="prod-xquery-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="135" id="prod-xquery-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AttributeName" xlink:type="simple">AttributeName</nt>
               </rhs></prod><prod num="136" id="prod-xquery-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod><prod num="137" id="prod-xquery-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod><prod num="138" id="prod-xquery-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="139" id="prod-xquery-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementName" xlink:type="simple">ElementName</nt>
               </rhs></prod><prod num="140" id="prod-xquery-AttributeName"><lhs>AttributeName</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>
               </rhs></prod><prod num="141" id="prod-xquery-ElementName"><lhs>ElementName</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>
               </rhs></prod><prod num="142" id="prod-xquery-TypeName"><lhs>TypeName</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>
               </rhs></prod><prod num="143" id="prod-xquery-URILiteral"><lhs>URILiteral</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>
               </rhs></prod><prod num="144" id="prod-xquery-FTSelection"><lhs>FTSelection</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTOr" xlink:type="simple">FTOr</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTPosFilter" xlink:type="simple">FTPosFilter</nt>*</rhs></prod><prod num="145" id="prod-xquery-FTWeight"><lhs>FTWeight</lhs><rhs>"weight"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RangeExpr" xlink:type="simple">RangeExpr</nt>
               </rhs></prod><prod num="146" id="prod-xquery-FTOr"><lhs>FTOr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTAnd" xlink:type="simple">FTAnd</nt> ( "ftor"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTAnd" xlink:type="simple">FTAnd</nt> )*</rhs></prod><prod num="147" id="prod-xquery-FTAnd"><lhs>FTAnd</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTMildNot" xlink:type="simple">FTMildNot</nt> ( "ftand"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTMildNot" xlink:type="simple">FTMildNot</nt> )*</rhs></prod><prod num="148" id="prod-xquery-FTMildNot"><lhs>FTMildNot</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTUnaryNot" xlink:type="simple">FTUnaryNot</nt> ( "not"  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTUnaryNot" xlink:type="simple">FTUnaryNot</nt> )*</rhs></prod><prod num="149" id="prod-xquery-FTUnaryNot"><lhs>FTUnaryNot</lhs><rhs>("ftnot")? <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTPrimaryWithOptions" xlink:type="simple">FTPrimaryWithOptions</nt>
               </rhs></prod><prod num="150" id="prod-xquery-FTPrimaryWithOptions"><lhs>FTPrimaryWithOptions</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTPrimary" xlink:type="simple">FTPrimary</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTMatchOptions" xlink:type="simple">FTMatchOptions</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTWeight" xlink:type="simple">FTWeight</nt>?</rhs></prod><prod num="151" id="prod-xquery-FTPrimary"><lhs>FTPrimary</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTWords" xlink:type="simple">FTWords</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTTimes" xlink:type="simple">FTTimes</nt>?)  |  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTSelection" xlink:type="simple">FTSelection</nt>  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTExtensionSelection" xlink:type="simple">FTExtensionSelection</nt>
               </rhs></prod><prod num="152" id="prod-xquery-FTWords"><lhs>FTWords</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTWordsValue" xlink:type="simple">FTWordsValue</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt>?</rhs></prod><prod num="153" id="prod-xquery-FTWordsValue"><lhs>FTWordsValue</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Literal" xlink:type="simple">Literal</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}")</rhs></prod><prod num="154" id="prod-xquery-FTExtensionSelection"><lhs>FTExtensionSelection</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTSelection" xlink:type="simple">FTSelection</nt>?  "}"</rhs></prod><prod num="155" id="prod-xquery-FTAnyallOption"><lhs>FTAnyallOption</lhs><rhs>("any"  "word"?)  |  ("all"  "words"?)  |  "phrase"</rhs></prod><prod num="156" id="prod-xquery-FTTimes"><lhs>FTTimes</lhs><rhs>"occurs"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTRange" xlink:type="simple">FTRange</nt>  "times"</rhs></prod><prod num="157" id="prod-xquery-FTRange"><lhs>FTRange</lhs><rhs>("exactly"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)<br/>|  ("at"  "least"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)<br/>|  ("at"  "most"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)<br/>|  ("from"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>  "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)</rhs></prod><prod num="158" id="prod-xquery-FTPosFilter"><lhs>FTPosFilter</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTOrder" xlink:type="simple">FTOrder</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTWindow" xlink:type="simple">FTWindow</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTDistance" xlink:type="simple">FTDistance</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTScope" xlink:type="simple">FTScope</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTContent" xlink:type="simple">FTContent</nt>
               </rhs></prod><prod num="159" id="prod-xquery-FTOrder"><lhs>FTOrder</lhs><rhs>"ordered"</rhs></prod><prod num="160" id="prod-xquery-FTWindow"><lhs>FTWindow</lhs><rhs>"window"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTUnit" xlink:type="simple">FTUnit</nt>
               </rhs></prod><prod num="161" id="prod-xquery-FTDistance"><lhs>FTDistance</lhs><rhs>"distance"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTRange" xlink:type="simple">FTRange</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTUnit" xlink:type="simple">FTUnit</nt>
               </rhs></prod><prod num="162" id="prod-xquery-FTUnit"><lhs>FTUnit</lhs><rhs>"words"  |  "sentences"  |  "paragraphs"</rhs></prod><prod num="163" id="prod-xquery-FTScope"><lhs>FTScope</lhs><rhs>("same"  |  "different")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTBigUnit" xlink:type="simple">FTBigUnit</nt>
               </rhs></prod><prod num="164" id="prod-xquery-FTBigUnit"><lhs>FTBigUnit</lhs><rhs>"sentence"  |  "paragraph"</rhs></prod><prod num="165" id="prod-xquery-FTContent"><lhs>FTContent</lhs><rhs>("at"  "start")  |  ("at"  "end")  |  ("entire"  "content")</rhs></prod><prod num="166" id="prod-xquery-FTMatchOptions"><lhs>FTMatchOptions</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTMatchOption" xlink:type="simple">FTMatchOption</nt>+</rhs><com>
                  <phrase>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-multiple-match-options" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: multiple-match-options</loc>
                  </phrase>
               </com></prod><prod num="167" id="prod-xquery-FTMatchOption"><lhs>FTMatchOption</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTLanguageOption" xlink:type="simple">FTLanguageOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTWildCardOption" xlink:type="simple">FTWildCardOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTThesaurusOption" xlink:type="simple">FTThesaurusOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTStemOption" xlink:type="simple">FTStemOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTCaseOption" xlink:type="simple">FTCaseOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTDiacriticsOption" xlink:type="simple">FTDiacriticsOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTStopWordOption" xlink:type="simple">FTStopWordOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTExtensionOption" xlink:type="simple">FTExtensionOption</nt>
               </rhs></prod><prod num="168" id="prod-xquery-FTCaseOption"><lhs>FTCaseOption</lhs><rhs>("case"  "insensitive")<br/>|  ("case"  "sensitive")<br/>|  "lowercase"<br/>|  "uppercase"</rhs></prod><prod num="169" id="prod-xquery-FTDiacriticsOption"><lhs>FTDiacriticsOption</lhs><rhs>("diacritics"  "insensitive")<br/>|  ("diacritics"  "sensitive")</rhs></prod><prod num="170" id="prod-xquery-FTStemOption"><lhs>FTStemOption</lhs><rhs>("with"  "stemming")  |  ("without"  "stemming")</rhs></prod><prod num="171" id="prod-xquery-FTThesaurusOption"><lhs>FTThesaurusOption</lhs><rhs>("with"  "thesaurus"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTThesaurusID" xlink:type="simple">FTThesaurusID</nt>  |  "default"))<br/>|  ("with"  "thesaurus"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTThesaurusID" xlink:type="simple">FTThesaurusID</nt>  |  "default")  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTThesaurusID" xlink:type="simple">FTThesaurusID</nt>)*  ")")<br/>|  ("without"  "thesaurus")</rhs></prod><prod num="172" id="prod-xquery-FTThesaurusID"><lhs>FTThesaurusID</lhs><rhs>"at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  ("relationship"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTRange" xlink:type="simple">FTRange</nt>  "levels")?</rhs></prod><prod num="173" id="prod-xquery-FTStopWordOption"><lhs>FTStopWordOption</lhs><rhs>("with"  "stop"  "words"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTStopWords" xlink:type="simple">FTStopWords</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTStopWordsInclExcl" xlink:type="simple">FTStopWordsInclExcl</nt>*)<br/>|  ("without"  "stop"  "words")<br/>|  ("with"  "default"  "stop"  "words"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTStopWordsInclExcl" xlink:type="simple">FTStopWordsInclExcl</nt>*)</rhs></prod><prod num="174" id="prod-xquery-FTStopWords"><lhs>FTStopWords</lhs><rhs>("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)<br/>|  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)*  ")")</rhs></prod><prod num="175" id="prod-xquery-FTStopWordsInclExcl"><lhs>FTStopWordsInclExcl</lhs><rhs>("union"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FTStopWords" xlink:type="simple">FTStopWords</nt>
               </rhs></prod><prod num="176" id="prod-xquery-FTLanguageOption"><lhs>FTLanguageOption</lhs><rhs>"language"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>
               </rhs></prod><prod num="177" id="prod-xquery-FTWildCardOption"><lhs>FTWildCardOption</lhs><rhs>("with"  "wildcards")  |  ("without"  "wildcards")</rhs></prod><prod num="178" id="prod-xquery-FTExtensionOption"><lhs>FTExtensionOption</lhs><rhs>"option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>
               </rhs></prod><prod num="179" id="prod-xquery-FTIgnoreOption"><lhs>FTIgnoreOption</lhs><rhs>"without"  "content"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-UnionExpr" xlink:type="simple">UnionExpr</nt>
               </rhs></prod></scrap><div2 id="grammar-terminals"><head>Terminal Symbols</head><scrap headstyle="show"><head/><prod num="180" id="prod-xquery-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt>
                  </rhs></prod><prod num="181" id="prod-xquery-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs><com>
                     <phrase>
                        <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                     </phrase>
                  </com></prod><prod num="182" id="prod-xquery-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt>
                  </rhs><com>
                     <phrase>
                        <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                     </phrase>
                  </com></prod><prod num="183" id="prod-xquery-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"&amp;])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'&amp;])*  "'")</rhs><com>
                     <phrase>
                        <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                     </phrase>
                  </com></prod><prod num="184" id="prod-xquery-PredefinedEntityRef"><lhs>PredefinedEntityRef</lhs><rhs>"&amp;"  ("lt"  |  "gt"  |  "amp"  |  "quot"  |  "apos")  ";"</rhs><com>
                     <phrase>
                        <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                     </phrase>
                  </com></prod><prod num="185" id="prod-xquery-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="186" id="prod-xquery-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="187" id="prod-xquery-ElementContentChar"><lhs>ElementContentChar</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - [{}&lt;&amp;]</rhs></prod><prod num="188" id="prod-xquery-QuotAttrContentChar"><lhs>QuotAttrContentChar</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - ["{}&lt;&amp;]</rhs></prod><prod num="189" id="prod-xquery-AposAttrContentChar"><lhs>AposAttrContentChar</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - ['{}&lt;&amp;]</rhs></prod><prod num="190" id="prod-xquery-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs><com>
                     <phrase>
                        <xspecref ref="ws-explicit" spec="XQ">ws: explicit</xspecref>
                     </phrase>
                  </com><com>
                     <phrase>
                        <xspecref ref="parse-note-comments" spec="XQ">gn: comments</xspecref>
                     </phrase>
                  </com></prod><prod num="191" id="prod-xquery-PITarget"><lhs>PITarget</lhs><rhs>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-PITarget" spec="XML" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-PITarget]</xnt>
                  </rhs><com>
                     <phrase>
                        <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                     </phrase>
                  </com></prod><prod num="192" id="prod-xquery-CharRef"><lhs>CharRef</lhs><rhs>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-CharRef" spec="XML" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-CharRef]</xnt>
                  </rhs><com>
                     <phrase>
                        <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                     </phrase>
                  </com></prod><prod num="193" id="prod-xquery-QName"><lhs>QName</lhs><rhs>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-QName" spec="Names" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt>
                  </rhs><com>
                     <phrase>
                        <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                     </phrase>
                  </com></prod><prod num="194" id="prod-xquery-NCName"><lhs>NCName</lhs><rhs>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-NCName" spec="Names" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt>
                  </rhs><com>
                     <phrase>
                        <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                     </phrase>
                  </com></prod><prod num="195" id="prod-xquery-S"><lhs>S</lhs><rhs>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-S" spec="XML" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-S]</xnt>
                  </rhs><com>
                     <phrase>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: xml-version</loc>
                     </phrase>
                  </com></prod><prod num="196" id="prod-xquery-Char"><lhs>Char</lhs><rhs>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-Char" spec="XML" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-Char]</xnt>
                  </rhs><com>
                     <phrase>
                        <xspecref ref="parse-note-xml-version" spec="XQ">xgc: xml-version</xspecref>
                     </phrase>
                  </com></prod></scrap><p>The following symbols are used only in the definition of
  terminal symbols; they are not terminal symbols in the
  grammar of <specref ref="id-grammar"/>.</p><scrap headstyle="show"><head/><prod num="197" id="prod-xquery-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod><prod num="198" id="prod-xquery-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod></scrap></div2></div1><div1 id="id-xpath-grammar"><head>EBNF for XPath 2.0 Grammar with Full-Text
		extensions</head><p>The EBNF in this document and in this section is aligned with
the current XPath 2.0 grammar (see <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xpath20-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/CR-xpath20-20051103/</loc>).</p><scrap role="non-terminal-structure-expand" headstyle="show"><head/><prod num="1" id="prod-xpath-XPath"><lhs>XPath</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>
               </rhs></prod><prod num="2" id="prod-xpath-Expr"><lhs>Expr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="3" id="prod-xpath-ExprSingle"><lhs>ExprSingle</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ForExpr" xlink:type="simple">ForExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IfExpr" xlink:type="simple">IfExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-OrExpr" xlink:type="simple">OrExpr</nt>
               </rhs></prod><prod num="4" id="prod-xpath-ForExpr"><lhs>ForExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SimpleForClause" xlink:type="simple">SimpleForClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>
               </rhs></prod><prod num="5" id="prod-xpath-SimpleForClause"><lhs>SimpleForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTScoreVar" xlink:type="simple">FTScoreVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTScoreVar" xlink:type="simple">FTScoreVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="6" id="prod-xpath-FTScoreVar"><lhs>FTScoreVar</lhs><rhs>"score"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>
               </rhs></prod><prod num="7" id="prod-xpath-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>
               </rhs></prod><prod num="8" id="prod-xpath-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>
               </rhs></prod><prod num="9" id="prod-xpath-OrExpr"><lhs>OrExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod><prod num="10" id="prod-xpath-AndExpr"><lhs>AndExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod><prod num="11" id="prod-xpath-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ValueComp" xlink:type="simple">ValueComp</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-GeneralComp" xlink:type="simple">GeneralComp</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTContainsExpr" xlink:type="simple">FTContainsExpr</nt> )?</rhs></prod><prod num="12" id="prod-xpath-FTContainsExpr"><lhs>FTContainsExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RangeExpr" xlink:type="simple">RangeExpr</nt> ( "ftcontains"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTSelection" xlink:type="simple">FTSelection</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTIgnoreOption" xlink:type="simple">FTIgnoreOption</nt>? )?</rhs></prod><prod num="13" id="prod-xpath-RangeExpr"><lhs>RangeExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod><prod num="14" id="prod-xpath-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod><prod num="15" id="prod-xpath-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod><prod num="16" id="prod-xpath-UnionExpr"><lhs>UnionExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod><prod num="17" id="prod-xpath-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod><prod num="18" id="prod-xpath-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="19" id="prod-xpath-TreatExpr"><lhs>TreatExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="20" id="prod-xpath-CastableExpr"><lhs>CastableExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="21" id="prod-xpath-CastExpr"><lhs>CastExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="22" id="prod-xpath-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ValueExpr" xlink:type="simple">ValueExpr</nt>
               </rhs></prod><prod num="23" id="prod-xpath-ValueExpr"><lhs>ValueExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PathExpr" xlink:type="simple">PathExpr</nt>
               </rhs></prod><prod num="24" id="prod-xpath-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod><prod num="25" id="prod-xpath-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod><prod num="26" id="prod-xpath-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod><prod num="27" id="prod-xpath-Pragma"><lhs>Pragma</lhs><rhs>"(#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-S" xlink:type="simple">S</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PragmaContents" xlink:type="simple">PragmaContents</nt>)?  "#)"</rhs><com>
                  <phrase>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                  </phrase>
               </com></prod><prod num="28" id="prod-xpath-PragmaContents"><lhs>PragmaContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>* - (Char* '#)' Char*))</rhs></prod><prod num="29" id="prod-xpath-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>
               </rhs><com>
                  <phrase>
                     <xspecref ref="parse-note-leading-lone-slash" spec="XP">xgc: leading-lone-slash</xspecref>
                  </phrase>
               </com></prod><prod num="30" id="prod-xpath-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod><prod num="31" id="prod-xpath-StepExpr"><lhs>StepExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FilterExpr" xlink:type="simple">FilterExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AxisStep" xlink:type="simple">AxisStep</nt>
               </rhs></prod><prod num="32" id="prod-xpath-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PredicateList" xlink:type="simple">PredicateList</nt>
               </rhs></prod><prod num="33" id="prod-xpath-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt>
               </rhs></prod><prod num="34" id="prod-xpath-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")<br/>|  ("namespace"  "::")</rhs></prod><prod num="35" id="prod-xpath-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeTest" xlink:type="simple">NodeTest</nt>
               </rhs></prod><prod num="36" id="prod-xpath-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt>
               </rhs></prod><prod num="37" id="prod-xpath-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod><prod num="38" id="prod-xpath-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod><prod num="39" id="prod-xpath-NodeTest"><lhs>NodeTest</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NameTest" xlink:type="simple">NameTest</nt>
               </rhs></prod><prod num="40" id="prod-xpath-NameTest"><lhs>NameTest</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Wildcard" xlink:type="simple">Wildcard</nt>
               </rhs></prod><prod num="41" id="prod-xpath-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>)</rhs><com>
                  <phrase>
                     <xspecref ref="ws-explicit" spec="XP">ws: explicit</xspecref>
                  </phrase>
               </com></prod><prod num="42" id="prod-xpath-FilterExpr"><lhs>FilterExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PredicateList" xlink:type="simple">PredicateList</nt>
               </rhs></prod><prod num="43" id="prod-xpath-PredicateList"><lhs>PredicateList</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod><prod num="44" id="prod-xpath-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod><prod num="45" id="prod-xpath-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FunctionCall" xlink:type="simple">FunctionCall</nt>
               </rhs></prod><prod num="46" id="prod-xpath-Literal"><lhs>Literal</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>
               </rhs></prod><prod num="47" id="prod-xpath-NumericLiteral"><lhs>NumericLiteral</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>
               </rhs></prod><prod num="48" id="prod-xpath-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>
               </rhs></prod><prod num="49" id="prod-xpath-VarName"><lhs>VarName</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>
               </rhs></prod><prod num="50" id="prod-xpath-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod><prod num="51" id="prod-xpath-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod><prod num="52" id="prod-xpath-FunctionCall"><lhs>FunctionCall</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs><com>
                  <phrase>
                     <xspecref ref="parse-note-reserved-function-names" spec="XP">xgc: reserved-function-names</xspecref>
                  </phrase>
               </com><com>
                  <phrase>
                     <xspecref ref="parse-note-parens" spec="XP">gn: parens</xspecref>
                  </phrase>
               </com></prod><prod num="53" id="prod-xpath-SingleType"><lhs>SingleType</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod><prod num="54" id="prod-xpath-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ItemType" xlink:type="simple">ItemType</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod><prod num="55" id="prod-xpath-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs><com>
                  <phrase>
                     <xspecref ref="parse-note-occurrence-indicators" spec="XP">xgc: occurrence-indicators</xspecref>
                  </phrase>
               </com></prod><prod num="56" id="prod-xpath-ItemType"><lhs>ItemType</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AtomicType" xlink:type="simple">AtomicType</nt>
               </rhs></prod><prod num="57" id="prod-xpath-AtomicType"><lhs>AtomicType</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>
               </rhs></prod><prod num="58" id="prod-xpath-KindTest"><lhs>KindTest</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DocumentTest" xlink:type="simple">DocumentTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementTest" xlink:type="simple">ElementTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PITest" xlink:type="simple">PITest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CommentTest" xlink:type="simple">CommentTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TextTest" xlink:type="simple">TextTest</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AnyKindTest" xlink:type="simple">AnyKindTest</nt>
               </rhs></prod><prod num="59" id="prod-xpath-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod><prod num="60" id="prod-xpath-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod><prod num="61" id="prod-xpath-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod><prod num="62" id="prod-xpath-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod><prod num="63" id="prod-xpath-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod><prod num="64" id="prod-xpath-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod><prod num="65" id="prod-xpath-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod><prod num="66" id="prod-xpath-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="67" id="prod-xpath-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeName" xlink:type="simple">AttributeName</nt>
               </rhs></prod><prod num="68" id="prod-xpath-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod><prod num="69" id="prod-xpath-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod><prod num="70" id="prod-xpath-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="71" id="prod-xpath-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementName" xlink:type="simple">ElementName</nt>
               </rhs></prod><prod num="72" id="prod-xpath-AttributeName"><lhs>AttributeName</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>
               </rhs></prod><prod num="73" id="prod-xpath-ElementName"><lhs>ElementName</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>
               </rhs></prod><prod num="74" id="prod-xpath-TypeName"><lhs>TypeName</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>
               </rhs></prod><prod num="75" id="prod-xpath-URILiteral"><lhs>URILiteral</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>
               </rhs></prod><prod num="76" id="prod-xpath-FTSelection"><lhs>FTSelection</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTOr" xlink:type="simple">FTOr</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTPosFilter" xlink:type="simple">FTPosFilter</nt>*</rhs></prod><prod num="77" id="prod-xpath-FTWeight"><lhs>FTWeight</lhs><rhs>"weight"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RangeExpr" xlink:type="simple">RangeExpr</nt>
               </rhs></prod><prod num="78" id="prod-xpath-FTOr"><lhs>FTOr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTAnd" xlink:type="simple">FTAnd</nt> ( "ftor"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTAnd" xlink:type="simple">FTAnd</nt> )*</rhs></prod><prod num="79" id="prod-xpath-FTAnd"><lhs>FTAnd</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTMildNot" xlink:type="simple">FTMildNot</nt> ( "ftand"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTMildNot" xlink:type="simple">FTMildNot</nt> )*</rhs></prod><prod num="80" id="prod-xpath-FTMildNot"><lhs>FTMildNot</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTUnaryNot" xlink:type="simple">FTUnaryNot</nt> ( "not"  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTUnaryNot" xlink:type="simple">FTUnaryNot</nt> )*</rhs></prod><prod num="81" id="prod-xpath-FTUnaryNot"><lhs>FTUnaryNot</lhs><rhs>("ftnot")? <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTPrimaryWithOptions" xlink:type="simple">FTPrimaryWithOptions</nt>
               </rhs></prod><prod num="82" id="prod-xpath-FTPrimaryWithOptions"><lhs>FTPrimaryWithOptions</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTPrimary" xlink:type="simple">FTPrimary</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTMatchOptions" xlink:type="simple">FTMatchOptions</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTWeight" xlink:type="simple">FTWeight</nt>?</rhs></prod><prod num="83" id="prod-xpath-FTPrimary"><lhs>FTPrimary</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTWords" xlink:type="simple">FTWords</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTTimes" xlink:type="simple">FTTimes</nt>?)  |  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTSelection" xlink:type="simple">FTSelection</nt>  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTExtensionSelection" xlink:type="simple">FTExtensionSelection</nt>
               </rhs></prod><prod num="84" id="prod-xpath-FTWords"><lhs>FTWords</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTWordsValue" xlink:type="simple">FTWordsValue</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTAnyallOption" xlink:type="simple">FTAnyallOption</nt>?</rhs></prod><prod num="85" id="prod-xpath-FTWordsValue"><lhs>FTWordsValue</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Literal" xlink:type="simple">Literal</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>  "}")</rhs></prod><prod num="86" id="prod-xpath-FTExtensionSelection"><lhs>FTExtensionSelection</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTSelection" xlink:type="simple">FTSelection</nt>?  "}"</rhs></prod><prod num="87" id="prod-xpath-FTAnyallOption"><lhs>FTAnyallOption</lhs><rhs>("any"  "word"?)  |  ("all"  "words"?)  |  "phrase"</rhs></prod><prod num="88" id="prod-xpath-FTTimes"><lhs>FTTimes</lhs><rhs>"occurs"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTRange" xlink:type="simple">FTRange</nt>  "times"</rhs></prod><prod num="89" id="prod-xpath-FTRange"><lhs>FTRange</lhs><rhs>("exactly"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)<br/>|  ("at"  "least"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)<br/>|  ("at"  "most"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)<br/>|  ("from"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>  "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>)</rhs></prod><prod num="90" id="prod-xpath-FTPosFilter"><lhs>FTPosFilter</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTOrder" xlink:type="simple">FTOrder</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTWindow" xlink:type="simple">FTWindow</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTDistance" xlink:type="simple">FTDistance</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTScope" xlink:type="simple">FTScope</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTContent" xlink:type="simple">FTContent</nt>
               </rhs></prod><prod num="91" id="prod-xpath-FTOrder"><lhs>FTOrder</lhs><rhs>"ordered"</rhs></prod><prod num="92" id="prod-xpath-FTWindow"><lhs>FTWindow</lhs><rhs>"window"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTUnit" xlink:type="simple">FTUnit</nt>
               </rhs></prod><prod num="93" id="prod-xpath-FTDistance"><lhs>FTDistance</lhs><rhs>"distance"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTRange" xlink:type="simple">FTRange</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTUnit" xlink:type="simple">FTUnit</nt>
               </rhs></prod><prod num="94" id="prod-xpath-FTUnit"><lhs>FTUnit</lhs><rhs>"words"  |  "sentences"  |  "paragraphs"</rhs></prod><prod num="95" id="prod-xpath-FTScope"><lhs>FTScope</lhs><rhs>("same"  |  "different")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTBigUnit" xlink:type="simple">FTBigUnit</nt>
               </rhs></prod><prod num="96" id="prod-xpath-FTBigUnit"><lhs>FTBigUnit</lhs><rhs>"sentence"  |  "paragraph"</rhs></prod><prod num="97" id="prod-xpath-FTContent"><lhs>FTContent</lhs><rhs>("at"  "start")  |  ("at"  "end")  |  ("entire"  "content")</rhs></prod><prod num="98" id="prod-xpath-FTMatchOptions"><lhs>FTMatchOptions</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTMatchOption" xlink:type="simple">FTMatchOption</nt>+</rhs><com>
                  <phrase>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-multiple-match-options" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: multiple-match-options</loc>
                  </phrase>
               </com></prod><prod num="99" id="prod-xpath-FTMatchOption"><lhs>FTMatchOption</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTLanguageOption" xlink:type="simple">FTLanguageOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTWildCardOption" xlink:type="simple">FTWildCardOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTThesaurusOption" xlink:type="simple">FTThesaurusOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTStemOption" xlink:type="simple">FTStemOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTCaseOption" xlink:type="simple">FTCaseOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTDiacriticsOption" xlink:type="simple">FTDiacriticsOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTStopWordOption" xlink:type="simple">FTStopWordOption</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTExtensionOption" xlink:type="simple">FTExtensionOption</nt>
               </rhs></prod><prod num="100" id="prod-xpath-FTCaseOption"><lhs>FTCaseOption</lhs><rhs>("case"  "insensitive")<br/>|  ("case"  "sensitive")<br/>|  "lowercase"<br/>|  "uppercase"</rhs></prod><prod num="101" id="prod-xpath-FTDiacriticsOption"><lhs>FTDiacriticsOption</lhs><rhs>("diacritics"  "insensitive")<br/>|  ("diacritics"  "sensitive")</rhs></prod><prod num="102" id="prod-xpath-FTStemOption"><lhs>FTStemOption</lhs><rhs>("with"  "stemming")  |  ("without"  "stemming")</rhs></prod><prod num="103" id="prod-xpath-FTThesaurusOption"><lhs>FTThesaurusOption</lhs><rhs>("with"  "thesaurus"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTThesaurusID" xlink:type="simple">FTThesaurusID</nt>  |  "default"))<br/>|  ("with"  "thesaurus"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTThesaurusID" xlink:type="simple">FTThesaurusID</nt>  |  "default")  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTThesaurusID" xlink:type="simple">FTThesaurusID</nt>)*  ")")<br/>|  ("without"  "thesaurus")</rhs></prod><prod num="104" id="prod-xpath-FTThesaurusID"><lhs>FTThesaurusID</lhs><rhs>"at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-URILiteral" xlink:type="simple">URILiteral</nt>  ("relationship"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTRange" xlink:type="simple">FTRange</nt>  "levels")?</rhs></prod><prod num="105" id="prod-xpath-FTStopWordOption"><lhs>FTStopWordOption</lhs><rhs>("with"  "stop"  "words"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTStopWords" xlink:type="simple">FTStopWords</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTStopWordsInclExcl" xlink:type="simple">FTStopWordsInclExcl</nt>*)<br/>|  ("without"  "stop"  "words")<br/>|  ("with"  "default"  "stop"  "words"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTStopWordsInclExcl" xlink:type="simple">FTStopWordsInclExcl</nt>*)</rhs></prod><prod num="106" id="prod-xpath-FTStopWords"><lhs>FTStopWords</lhs><rhs>("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-URILiteral" xlink:type="simple">URILiteral</nt>)<br/>|  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>)*  ")")</rhs></prod><prod num="107" id="prod-xpath-FTStopWordsInclExcl"><lhs>FTStopWordsInclExcl</lhs><rhs>("union"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FTStopWords" xlink:type="simple">FTStopWords</nt>
               </rhs></prod><prod num="108" id="prod-xpath-FTLanguageOption"><lhs>FTLanguageOption</lhs><rhs>"language"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>
               </rhs></prod><prod num="109" id="prod-xpath-FTWildCardOption"><lhs>FTWildCardOption</lhs><rhs>("with"  "wildcards")  |  ("without"  "wildcards")</rhs></prod><prod num="110" id="prod-xpath-FTExtensionOption"><lhs>FTExtensionOption</lhs><rhs>"option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>
               </rhs></prod><prod num="111" id="prod-xpath-FTIgnoreOption"><lhs>FTIgnoreOption</lhs><rhs>"without"  "content"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt>
               </rhs></prod></scrap><div2 id="xpath-grammar-terminals"><head>Terminal Symbols</head><scrap headstyle="show"><head/><prod num="112" id="prod-xpath-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>
                  </rhs></prod><prod num="113" id="prod-xpath-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs><com>
                     <phrase>
                        <xspecref ref="ws-explicit" spec="XP">ws: explicit</xspecref>
                     </phrase>
                  </com></prod><prod num="114" id="prod-xpath-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>
                  </rhs><com>
                     <phrase>
                        <xspecref ref="ws-explicit" spec="XP">ws: explicit</xspecref>
                     </phrase>
                  </com></prod><prod num="115" id="prod-xpath-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'])*  "'")</rhs><com>
                     <phrase>
                        <xspecref ref="ws-explicit" spec="XP">ws: explicit</xspecref>
                     </phrase>
                  </com></prod><prod num="116" id="prod-xpath-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="117" id="prod-xpath-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="118" id="prod-xpath-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs><com>
                     <phrase>
                        <xspecref ref="ws-explicit" spec="XP">ws: explicit</xspecref>
                     </phrase>
                  </com><com>
                     <phrase>
                        <xspecref ref="parse-note-comments" spec="XP">gn: comments</xspecref>
                     </phrase>
                  </com></prod><prod num="119" id="prod-xpath-QName"><lhs>QName</lhs><rhs>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-QName" spec="Names" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt>
                  </rhs><com>
                     <phrase>
                        <xspecref ref="parse-note-xml-version" spec="XP">xgc: xml-version</xspecref>
                     </phrase>
                  </com></prod><prod num="120" id="prod-xpath-NCName"><lhs>NCName</lhs><rhs>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-NCName" spec="Names" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt>
                  </rhs><com>
                     <phrase>
                        <xspecref ref="parse-note-xml-version" spec="XP">xgc: xml-version</xspecref>
                     </phrase>
                  </com></prod><prod num="121" id="prod-xpath-S"><lhs>S</lhs><rhs>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-S" spec="XML" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-S]</xnt>
                  </rhs><com>
                     <phrase>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: xml-version</loc>
                     </phrase>
                  </com></prod><prod num="122" id="prod-xpath-Char"><lhs>Char</lhs><rhs>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-Char" spec="XML" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-Char]</xnt>
                  </rhs><com>
                     <phrase>
                        <xspecref ref="parse-note-xml-version" spec="XP">xgc: xml-version</xspecref>
                     </phrase>
                  </com></prod></scrap><p>The following symbols are used only in the definition of
  terminal symbols; they are not terminal symbols in the
  grammar of <specref ref="id-xpath-grammar"/>.</p><scrap headstyle="show"><head/><prod num="123" id="prod-xpath-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod><prod num="124" id="prod-xpath-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod></scrap></div2></div1><!-- JD
<div1 role="xquery" id="id-xqft-context-components"><head>Context
Components</head><p>The tables in this section describe how values are
assigned to the various components of the static context and dynamic
context, and to the parameters that control the serialization
process.</p>
--><div1 id="id-xqft-static-context-components"><head>Static Context Components</head><p>The following table describes the full-text components of
the <term>static context</term> (as defined in <xspecref spec="XQ" ref="static_context"/>). 
The following aspects of each
component are described:</p><ulist><item><p>
                  <emph>Default initial value:</emph> This is the initial value of the component if it is not
overridden or augmented by the implementation or by a query.</p></item><item><p>
                  <emph>Can be overwritten or augmented by
implementation:</emph> Indicates whether an XQuery implementation is
allowed to replace the default initial value of the component by a
different, <termref def="dt-implementation-defined">implementation-defined</termref> value
and/or to augment the default initial value by additional
<termref def="dt-implementation-defined">implementation-defined</termref> values.</p></item><item><p>
                  <emph>Can be overwritten or augmented by a
query:</emph> Indicates whether a query is allowed to replace and/or
augment the initial value provided by default or by the
implementation. If so, indicates how this is accomplished (for
example, by a declaration in the
<term>prolog</term>; as defined in <xspecref spec="XQ" ref="id-query-prolog"/>).</p></item><item><p>
                  <emph>Scope:</emph> Indicates where the
component is applicable. "Global" indicates that the component applies
globally, throughout all the modules used in a query. "Module"
indicates that the component applies throughout a <term>module</term>
(as defined in <xspecref spec="XQ" ref="id-query-prolog"/>). "Lexical" indicates that the
component applies within the expression in which it is defined
(equivalent to "module", if the component is declared in a
prolog.)</p></item><item><p>
                  <emph>Consistency
Rules:</emph> Indicates rules that must be observed in assigning
values to the component. </p></item></ulist><table width="100%" border="1" summary="Static Context" role="small"><caption>Static Context Components</caption><tbody><tr><th rowspan="1" colspan="1">Component</th><th rowspan="1" colspan="1">Default initial value</th><th rowspan="1" colspan="1">Can be
overwritten or augmented by implementation?</th><th rowspan="1" colspan="1">Can be
overwritten or augmented by a query?</th><th rowspan="1" colspan="1">Scope</th><th rowspan="1" colspan="1">Consistency rules</th></tr><tr><td rowspan="1" colspan="1">
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftcaseoption" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">FTCaseOption</loc>
                  </td><td rowspan="1" colspan="1">
                     <code>case
insensitive</code>
                  </td><td rowspan="1" colspan="1">overwriteable</td><td rowspan="1" colspan="1">overwriteable by prolog</td><td rowspan="1" colspan="1">lexical</td><td rowspan="1" colspan="1">Value must be
<code>case insensitive</code>, <code>case sensitive</code>, 
<code>lowercase</code>, or <code>uppercase</code>.</td></tr><tr><td rowspan="1" colspan="1">
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftdiacriticsoption" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">FTDiacriticsOption</loc>
                  </td><td rowspan="1" colspan="1">
                     <code>diacritics insensitive</code>
                  </td><td rowspan="1" colspan="1">overwriteable</td><td rowspan="1" colspan="1">overwriteable by prolog</td><td rowspan="1" colspan="1">lexical</td><td rowspan="1" colspan="1">Value must be <code>diacritics insensitive</code> or
<code>diacritics sensitive</code>.</td></tr><tr><td rowspan="1" colspan="1">
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftstemoption" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">FTStemOption</loc>
                  </td><td rowspan="1" colspan="1">
                     <code>without stemming</code>
                  </td><td rowspan="1" colspan="1">overwriteable</td><td rowspan="1" colspan="1">overwriteable by prolog</td><td rowspan="1" colspan="1">lexical</td><td rowspan="1" colspan="1">Value must be <code>without stemming</code> or
<code>with stemming</code>.</td></tr><tr><td rowspan="1" colspan="1">
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftthesaurusoption" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">FTThesaurusOption</loc>
                  </td><td rowspan="1" colspan="1">
                     <code>without thesaurus</code>
                  </td><td rowspan="1" colspan="1">overwriteable</td><td rowspan="1" colspan="1">overwriteable by prolog (refer to default to augment)</td><td rowspan="1" colspan="1">lexical</td><td rowspan="1" colspan="1"> Value must be part of the statically known thesauri.</td></tr><tr><td rowspan="1" colspan="1">Statically known thesauri</td><td rowspan="1" colspan="1">none</td><td rowspan="1" colspan="1">augmentable</td><td rowspan="1" colspan="1">cannot be augmented or overwritten by prolog</td><td rowspan="1" colspan="1">module</td><td rowspan="1" colspan="1"> Each URI uniquely identifies a thesaurus list.</td></tr><tr><td rowspan="1" colspan="1">
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftstopwordoption" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">FTStopWordOption</loc>
                  </td><td rowspan="1" colspan="1">
                     <code>without stop words</code>
                  </td><td rowspan="1" colspan="1">overwriteable</td><td rowspan="1" colspan="1">overwriteable by prolog (refer to default to augment)</td><td rowspan="1" colspan="1">lexical</td><td rowspan="1" colspan="1">Value must be part of the statically known stop word lists.</td></tr><tr><td rowspan="1" colspan="1">Statically known stop word lists</td><td rowspan="1" colspan="1">none</td><td rowspan="1" colspan="1">augmentable</td><td rowspan="1" colspan="1">cannot be augmented or overwritten by prolog</td><td rowspan="1" colspan="1">module</td><td rowspan="1" colspan="1">Each URI uniquely identifies a stop word list.</td></tr><tr><td rowspan="1" colspan="1">
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftlanguageoption" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">FTLanguageOption</loc>
                  </td><td rowspan="1" colspan="1">
                     <termref def="dt-implementation-defined">implementation-defined</termref>
                  </td><td rowspan="1" colspan="1">overwriteable</td><td rowspan="1" colspan="1">overwriteable by prolog</td><td rowspan="1" colspan="1">lexical</td><td rowspan="1" colspan="1">Value must be castable to <code>xs:language</code>.</td></tr><tr><td rowspan="1" colspan="1">Statically known languages</td><td rowspan="1" colspan="1">none</td><td rowspan="1" colspan="1">augmentable</td><td rowspan="1" colspan="1">cannot be augmented or overwritten by prolog</td><td rowspan="1" colspan="1">module</td><td rowspan="1" colspan="1">Each string uniquely identifies a language.</td></tr><tr><td rowspan="1" colspan="1">
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ftwildcardoption" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">FTWildCardOption</loc>
                  </td><td rowspan="1" colspan="1">
                     <code>without wildcards</code>
                  </td><td rowspan="1" colspan="1">no</td><td rowspan="1" colspan="1">overwriteable by prolog</td><td rowspan="1" colspan="1">lexical</td><td rowspan="1" colspan="1">Value must be <code>without wildcards</code> or <code>without
wildcards</code>.</td></tr></tbody></table></div1><div1 id="id-errors"><head>Error Conditions</head><error-list><error spec="FT" code="0001" class="ST" type="static"><p>
An implementation that does not support the FTMildNot operator must raise 
a static error if a full-text query contains a mild not.</p></error><error spec="FT" code="0002" class="ST" type="static"><p>
An implementation that enforces one of the restrictions on FTUnaryNot must
raise a static error if a full-text query does not obey the restriction.</p></error><error spec="FT" code="0003" class="ST" type="static"><p>
An implementation that does not support one or more of the choices on FTUnit
and FTBigUnit must
raise a static error if a full-text query contains one of those choices.</p></error><error spec="FT" code="0004" class="ST" type="static"><p>
An implementation that does not support the FTScope operator must raise
a static error if a full-text query contains a scope.</p></error><error spec="FT" code="0005" class="ST" type="static"><p>
An implementation that does not support the FTTimes operator must raise
a static error if a full-text query contains a times.</p></error><error spec="FT" code="0006" class="ST" type="static"><p>
An implementation that restricts the use of FTStopWordOption must raise
a static error if a full-text query contains a stop word option that does not
meet the restriction.</p></error><error spec="FT" code="0007" class="ST" type="static"><p>
An implementation that restricts the use of FTIgnoreOption must raise
a static error if a full-text query contains an ignore option that does not
meet the restriction.</p></error><error spec="FT" code="0008" class="ST" type="static"><p>It is a static error if, during the static analysis phase, the query is
found to contain a stop word option that refers to a stop word list that is not
found in the statically known stop word lists.
</p></error><error spec="FT" code="0009" class="ST" type="static"><p>It may be a static error if, during the static analysis phase, the query is
found to contain a language identifier in a language option that the
implementation does not support. The implementation may choose not to raise
this error and instead provide some other implementation-defined behavior.
</p></error><error spec="FT" code="0010" class="ST" type="static"><p>It is a static error if, during the static analysis phase,
an expression is found to use an FTOrder operator that does not appear
directly succeeding an FTWindow or an FTDistance operator and the
implementation enforces this restriction.
</p></error><error spec="FT" code="0011" class="ST" type="static"><p>An implementation may restrict the use of FTWindow and FTDistance to an FTOr
that is either a single FTWords or a combination of FTWords involving
only the operators &amp;&amp; and ||. If it a static error if, during the
static analysis phase, an expression is found that violates this restriction
and the implementation enforces this restriction.
</p></error><error spec="FT" code="0012" class="ST" type="static"><p>
An implementation that does not support the FTContent operator must raise
a static error if a full-text query contains one.
</p></error><error spec="FT" code="0013" class="ST" type="static"><p>
It is a static error if, during the static analysis phase, 
an implementation that restricts the use of FTLanguageOption to a single
language, encounters more than one distinct language option.
</p></error><error spec="FT" code="0014" class="ST" type="static"><p>An implementation may constrain the form of the expression used to compute
scores. It is a static error if, during the static analysis phase, 
such an implementation encounters a scoring expression that does not meet
the restriction.
</p></error><error spec="FT" code="0015" class="ST" type="static"><p>
It is a static error if, during the static analysis phase, 
an implementation that restricts the choices of FTCaseOption
encounters the "lowercase" or "uppercase" option.
</p></error><error spec="FT" code="0016" class="DY" type="dynamic"><p>
It is a dynamic error if a weight value is not within the required range of values;
it is also a dynamic error if an implementation that does not support negative weights
encounters a negative weight value. 
</p></error><error spec="FT" code="0017" class="DY" type="dynamic"><p>
It is a dynamic error if an implementation encounters a mild not 
selection, one of whose operands evaluates to an <term>AllMatches</term> that contains a
<term>StringExclude</term> 
               </p></error><error spec="FT" code="0019" class="ST" type="static"><p>
It is a static error if,
within a single <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FTMatchOptions" xlink:type="simple">FTMatchOptions</nt>,
there is more than one match option of any given 
<termref def="dt-match-option-group">match option group</termref>.
</p></error><error spec="XP" code="0004" class="TY" type="type"><p>It is a type error if, during the static analysis phase,
an expression is found to have a static type
that is not appropriate for the context in which the expression occurs, or during the
dynamic evaluation phase, the dynamic type of a value does not match a required type as
specified by the matching rules in <xspecref spec="XP" ref="id-sequencetype-matching"/>.</p></error><error spec="FO" code="0002" class="CH" type="dynamic"><p>It is a dynamic error if, in a function invocation, the argument corresponding to
the specified function's collation parameter does not identify a supported collation.</p></error></error-list></div1><div1 id="id-xqft-xqueryx"><head>XML Syntax (XQueryX) for XQuery and XPath Full Text 1.0</head><p>
            <bibref ref="xqueryx"/> defines an XML representation of <bibref ref="xquery"/>. 
<bibref ref="xqueryft-requirements"/>, section 5.4, XML Syntax, states
"XQuery and XPath Full Text MAY have more than one syntax binding. 
One query language syntax MUST be expressed in XML in a way that
reflects the underlying structure of the query. See XML Query Requirements."
This appendix specifies XML Schemas that together define the
XML representation of XQuery and XPath Full Text 1.0 by representing the abstract syntax
found in <specref ref="id-grammar"/>.  Because XQuery and XPath Full Text 1.0
integrates seamlessly with XQuery 1.0,
it follows that the XML Syntax for XQuery and XPath Full Text 1.0 must integrate well
with the XML Syntax for XQuery 1.0. 
</p><p>
The XML Schema specified in this appendix accomplishes integration by importing
the XML Schema defined for XQueryX in <xspecref spec="XQX" ref="Schema"/>,
incorporating all of its type and element definitions. 
It then extends that schema by adding definitions of new types and elements
in a namespace belonging to the full-text specification. 
</p><p>
The semantics of a Full Text XQueryX document are determined by the
semantics of the XQuery Full Text expression that
results from transforming the XQueryX document into XQuery Full Text
syntax using the XSLT stylesheet that appears in
section <specref ref="id-xqft-full-text-stylesheet"/>. 
The "correctness" of that transformation is determined by
asking the following the question:
Can some Full Text XQueryX processor QX process some
Full Text XQueryX document D1 to produce results R1,
after which the stylesheet is used to translate D1 into an
XQuery Full Text expression E1 that, when processed by some
XQuery Full Text processor Q, produces results R2 that are equivalent
(under some meaningful definition of "equivalent") to results R1?
</p><div2 id="id-xqft-full-text-schema"><head>XQueryX representation of XQuery and XPath Full Text 1.0</head><p>
The XML Schema that defines the complex types and elements
for XQueryX in support of XQuery and XPath Full Text 1.0, including the ftContainsExpr,
incorporates a second XML Schema that defines
types and elements to support the ftMatchOption. 
Both XML Schemas are defined in this section. 
</p><eg xml:space="preserve">

&lt;xsd:schema
     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
     xmlns:xqx="http://www.w3.org/2005/XQueryX"
     xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified"
     attributeFormDefault="unqualified"&gt;

&lt;!-- Initial creation                            2006-08-17: Jim Melton    --&gt;
&lt;!-- Added ftOptionDecl, ftScoreVariableBinding  2006-08-21: Jim Melton    --&gt;
&lt;!-- First version believed complete             2006-08-29: Jim Melton    --&gt;
&lt;!-- Cleaned up naming                           2007-04-27: Mary Holstege --&gt;
&lt;!-- Revised to align with updated syntax        2008-01-14: Jim Melton    --&gt;
&lt;!-- Moved ftOptionDecl: prolog part two to one  2008-01-24: Jim Melton    --&gt;
&lt;!-- Revised position of "weight" in grammar     2008-11-12: Jim Melton    --&gt;

  &lt;xsd:import namespace="http://www.w3.org/2005/XQueryX"
              schemaLocation="http://www.w3.org/2005/XQueryX/xqueryx.xsd"/&gt;

  &lt;xsd:include schemaLocation="./xpath-full-text-10-xqueryx-ftmatchoption-extensions.xsd"/&gt;

  &lt;xsd:element name="ftOptionDecl" substitutionGroup="xqx:prologPartOneItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence minOccurs="1" maxOccurs="unbounded"&gt;
        &lt;xsd:element ref="xqxft:ftMatchOption"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;


  &lt;!-- Create a new substitution group for full-text expressions           --&gt;
  &lt;xsd:complexType name="ftExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqx:expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftExpr" type="xqxft:ftExpr" abstract="true" substitutionGroup="xqx:expr"/&gt;


  &lt;!-- Represents an untyped variable for the "score" clause               --&gt;
  &lt;xsd:element name="ftScoreVariableBinding" type="xqx:QName"
               substitutionGroup="xqx:forLetClauseItemExtensions"/&gt;



  &lt;!-- FTContains                                                          --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTContainsExpr ::= RangeExpr                                      --&gt;
  &lt;!--                      ( "ftcontains" FTSelection FTIgnoreOption? )?  --&gt;
  &lt;xsd:complexType name="ftContainsExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftRangeExpr"
                       type="xqx:exprWrapper" /&gt;
          &lt;xsd:sequence minOccurs="0" maxOccurs="1"&gt;
            &lt;xsd:element name="ftSelectionExpr"
                         type="xqxft:ftSelectionWrapper" /&gt;
            &lt;xsd:element name="ftIgnoreOption"
                         type="xqxft:ftIgnoreOption"
                         minOccurs="0" maxOccurs="1" /&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftContainsExpr" type="xqxft:ftContainsExpr" substitutionGroup="xqxft:ftExpr" /&gt;


  &lt;!-- FTProximity                                                         --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPosFilter ::=                                                   --&gt;
  &lt;!--     FTOrder | FTWindow | FTDistance | FTScope | FTContent           --&gt;
  &lt;xsd:complexType name="ftProximity" /&gt;

  &lt;xsd:element name="ftProximity" type="xqxft:ftProximity" abstract="true"/&gt;


  &lt;!-- some simple type definitions                                        --&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTUnit ::= "words" | "sentences" | "paragraphs"                   --&gt;
  &lt;xsd:simpleType name="ftUnit"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="paragraph"/&gt;
      &lt;xsd:enumeration value="sentence"/&gt;
      &lt;xsd:enumeration value="word"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTBigUnit ::= "sentence" | "paragraph"                            --&gt;
  &lt;xsd:simpleType name="ftBigUnit"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="paragraph"/&gt;
      &lt;xsd:enumeration value="sentence"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTContent ::= ("at" "start") | ("at" "end") | ("entire" "content")--&gt;
  &lt;xsd:simpleType name="contentLocation"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="at start"/&gt;
      &lt;xsd:enumeration value="at end"/&gt;
      &lt;xsd:enumeration value="entire content"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTScope ::= ("same" | "different") FTBigUnit                      --&gt;
  &lt;xsd:simpleType name="ftScopeType"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="same"/&gt;
      &lt;xsd:enumeration value="different"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;


  &lt;!-- range-related definitions                                           --&gt;
  &lt;xsd:complexType name="unaryRange"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="value" type="xqx:exprWrapper" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="binaryRange"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="lower" type="xqx:exprWrapper" /&gt;
      &lt;xsd:element name="upper" type="xqx:exprWrapper" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTRange ::= ("exactly" AdditiveExpr)                              --&gt;
  &lt;!--             | ("at" "least" AdditiveExpr)                           --&gt;
  &lt;!--             | ("at" "most" AdditiveExpr)                            --&gt;
  &lt;!--             | ("from" AdditiveExpr "to" AdditiveExpr)               --&gt;
  &lt;xsd:complexType name="ftRange"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="atLeastRange" type="xqxft:unaryRange" /&gt;
      &lt;xsd:element name="atMostRange" type="xqxft:unaryRange" /&gt;
      &lt;xsd:element name="exactlyRange" type="xqxft:unaryRange" /&gt;
      &lt;xsd:element name="fromToRange" type="xqxft:binaryRange" /&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- ftPosFilter alternative: ordered                                    --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTOrder ::= "ordered"                                             --&gt;
  &lt;xsd:complexType name="ftOrdered"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftOrdered" type="xqxft:ftOrdered" substitutionGroup="xqxft:ftProximity"/&gt;


  &lt;!-- ftPosFilter alternative: window                                     --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWindow ::= "window" AdditiveExpr FTUnit                         --&gt;
  &lt;xsd:complexType name="ftWindow"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xqx:exprWrapper" /&gt;
          &lt;xsd:element name="unit" type="xqxft:ftUnit" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftWindow" type="xqxft:ftWindow" substitutionGroup="xqxft:ftProximity"/&gt;


  &lt;!-- ftPosFilter alternative: distance                                   --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTDistance ::= "distance" FTRange FTUnit                          --&gt;
  &lt;xsd:complexType name="ftDistance"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftRange" type="xqxft:ftRange" /&gt;
          &lt;xsd:element name="unit" type="xqxft:ftUnit" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftDistance" type="xqxft:ftDistance" substitutionGroup="xqxft:ftProximity"/&gt;

  &lt;!-- ftPosFilter alternative: scope                                      --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;xsd:complexType name="ftScope"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="type" type="xqxft:ftScopeType" /&gt;
          &lt;xsd:element name="unit" type="xqxft:ftBigUnit" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftScope" type="xqxft:ftScope" substitutionGroup="xqxft:ftProximity"/&gt;

  &lt;!-- ftPosFilter alternative: FTContent                                  --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;xsd:complexType name="ftContent"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="location" type="xqxft:contentLocation" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftContent" type="xqxft:ftContent" substitutionGroup="xqxft:ftProximity"/&gt;


  &lt;!-- ftPosFilter                                                         --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPosFilter ::=                                                   --&gt;
  &lt;!--     FTOrder | FTWindow | FTDistance | FTScope | FTContent           --&gt;
  &lt;xsd:complexType name="ftPosFilter"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xsd:element ref="xqxft:ftProximity" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- FTSelection                                                         --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTSelection ::= FTOr FTPosFilter*                                 --&gt;
  &lt;xsd:complexType name="ftSelection" &gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftSelectionSource" type="xqx:exprWrapper"/&gt;
          &lt;xsd:element name="ftPosFilter"
                       type="xqxft:ftPosFilter"
                       minOccurs="0" maxOccurs="1" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftSelection" type="xqxft:ftSelection" substitutionGroup="xqxft:ftExpr" /&gt;


  &lt;xsd:complexType name="ftSelectionWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="xqxft:ftSelection"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTIgnoreOption ::= "without" "content" UnionExpr                  --&gt;
  &lt;xsd:complexType name="ftIgnoreOption"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="xqx:expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- Full-Text logical operators                                         --&gt;
  &lt;xsd:element name="ftLogicalOp" type="xqx:binaryOperatorExpr" abstract="true"
               substitutionGroup="xqx:operatorExpr"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTOr ::= FTAnd ( "ftor" FTAnd )*                                  --&gt;
  &lt;xsd:element name="ftOr" type="xqx:binaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalOp"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTAnd ::= FTMildNot ( "ftand" FTMildNot )*                        --&gt;
  &lt;xsd:element name="ftAnd" type="xqx:binaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalOp"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   	FTMildNot ::= FTUnaryNot ( "not" "in" FTUnaryNot )*              --&gt;
  &lt;xsd:element name="ftMildNot" type="xqx:binaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalOp"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;xsd:element name="ftLogicalNot" type="xqx:unaryOperatorExpr" abstract="true"
               substitutionGroup="xqx:operatorExpr"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTUnaryNot ::= ("ftnot")? FTPrimaryWithOptions                    --&gt;
  &lt;xsd:element name="ftUnaryNot" type="xqx:unaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalNot"/&gt;


  &lt;!-- Definitions associated with FTWords                                 --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTTimes ::= "occurs" FTRange "times"                              --&gt;
  &lt;xsd:complexType name="ftTimes"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="ftRange" type="xqxft:ftRange"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--  FTAnyallOption ::= ("any" "word"?) | ("all" "words"?) | "phrase"   --&gt;
  &lt;xsd:simpleType name="ftAnyAllOption"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="any"/&gt;
      &lt;xsd:enumeration value="all"/&gt;
      &lt;xsd:enumeration value="any word"/&gt;
      &lt;xsd:enumeration value="all words"/&gt;
      &lt;xsd:enumeration value="phrase"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWordsValue ::= Literal | ("{" Expr "}")                         --&gt;
  &lt;xsd:complexType name="ftWordsAlternatives"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="ftWordsLiteral" type="xqx:exprWrapper"/&gt;
      &lt;xsd:element name="ftWordsExpression" type="xqx:exprWrapper"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWords ::= FTWordsValue FTAnyallOption?                          --&gt;
  &lt;xsd:complexType name="ftWords"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="ftWordsValue" type="xqxft:ftWordsAlternatives" /&gt;
      &lt;xsd:element name="ftAnyAllOption" type="xqxft:ftAnyAllOption"
                   minOccurs="0" maxOccurs="1" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--  ... FTWordsValue FTAnyallOption?                                   --&gt;
  &lt;xsd:group name="ftWordsWithTimes"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="ftWords" type="xqxft:ftWords" /&gt;
      &lt;xsd:element name="ftTimes" type="xqxft:ftTimes" minOccurs="0" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:group&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTExtensionSelection ::= Pragma+ "{" FTSelection? "}"             --&gt;
  &lt;xsd:complexType name="ftExtensionSelection"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="pragma" type="xqx:pragma"
                   minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="ftSelection" type="xqxft:ftSelection"
                   minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPrimary ::= (FTWords FTTimes?)                                  --&gt;
  &lt;!--               | ("(" FTSelection ")")                               --&gt;
  &lt;!--               | FTExtensionSelection                                --&gt;
  &lt;xsd:complexType name="ftPrimary"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr" &gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="parenthesized" type="xqx:exprWrapper"/&gt;
          &lt;xsd:group ref="xqxft:ftWordsWithTimes" /&gt;
          &lt;xsd:element name="ftExtensionSelection" type="xqxft:ftExtensionSelection"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPrimaryWithOptions ::= FTPrimary FTMatchOptions? FTWeight?      --&gt;
  &lt;xsd:complexType name="ftPrimaryWithOptions"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftPrimary" type="xqxft:ftPrimary"/&gt;
          &lt;xsd:element ref="xqxft:ftMatchOptions"
                       minOccurs="0" maxOccurs="1"/&gt;
          &lt;xsd:element name="weight"
                       type="xqx:exprWrapper"
                       minOccurs="0" maxOccurs="1" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftPrimaryWithOptions" type="xqxft:ftPrimaryWithOptions"
               substitutionGroup="xqxft:ftExpr"/&gt;

&lt;/xsd:schema&gt;


</eg><eg xml:space="preserve">

&lt;xsd:schema
     xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
     xmlns:xqx="http://www.w3.org/2005/XQueryX"
     xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified" 
     attributeFormDefault="unqualified"&gt;

&lt;!-- Initial creation                         2006-08-17: Jim Melton       --&gt;
&lt;!-- First version believed complete          2006-08-29: Jim Melton       --&gt;
&lt;!-- Cleaned up naming                        2007-04-27: Mary Holstege    --&gt;     
&lt;!-- Revised to align with updated syntax     2008-01-14: Jim Melton       --&gt;
&lt;!-- Comments added to clarify each element   2008-11-12: Jim Melton       --&gt;

  &lt;xsd:import namespace="http://www.w3.org/2005/XQueryX"
              schemaLocation="http://www.w3.org/2005/XQueryX/xqueryx.xsd"/&gt;

  &lt;!-- FTMatchOption                                                       --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTMatchOption ::= FTLanguageOption                                --&gt;
  &lt;!--                   | FTWildCardOption                                --&gt;
  &lt;!--                   | FTThesaurusOption                               --&gt;
  &lt;!--                   | FTStemOption                                    --&gt;
  &lt;!--                   | FTCaseOption                                    --&gt;
  &lt;!--                   | FTDiacriticsOption                              --&gt;
  &lt;!--                   | FTStopWordOption                                --&gt;
  &lt;!--                   | FTExtensionOption                               --&gt;
  &lt;xsd:complexType name="ftMatchOption" /&gt;

  &lt;xsd:element name="ftMatchOption" type="xqxft:ftMatchOption"
               abstract="true" /&gt;
  
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTMatchOptions ::= FTMatchOption+                                 --&gt;
  &lt;xsd:complexType name="ftMatchOptions"&gt;
    &lt;xsd:sequence minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xsd:element ref="xqxft:ftMatchOption"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  

  &lt;!-- ftMatchOption alternative: case                                     --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTCaseOption ::= ("case" "insensitive")                           --&gt;
  &lt;!--                  | ("case" "sensitive")                             --&gt;
  &lt;!--                  | "lowercase"                                      --&gt;
  &lt;!--                  | "uppercase"                                      --&gt;
  &lt;xsd:complexType name="ftCaseOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="lowercase"/&gt;
                &lt;xsd:enumeration value="uppercase"/&gt;
                &lt;xsd:enumeration value="case sensitive"/&gt;
                &lt;xsd:enumeration value="case insensitive"/&gt;
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="case" type="xqxft:ftCaseOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: diacritics                               --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTDiacriticsOption ::= ("diacritics" "insensitive")               --&gt;
  &lt;!--                        | ("diacritics" "sensitive")                 --&gt;
  &lt;xsd:complexType name="ftDiacriticsOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="diacritics sensitive"/&gt;
                &lt;xsd:enumeration value="diacritics insensitive"/&gt;
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  
  &lt;xsd:element name="diacritics" type="xqxft:ftDiacriticsOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: stemming                                 --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTStemOption ::= ("with" "stemming") | ("without" "stemming")     --&gt;
  &lt;xsd:complexType name="ftStemOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="with stemming" /&gt; 
                &lt;xsd:enumeration value="without stemming" /&gt; 
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  
  &lt;xsd:element name="stem" type="xqxft:ftStemOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: thesaurus                                --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTThesaurusID ::= "at" URILiteral ("relationship" StringLiteral)? --&gt;
  &lt;!--                       (FTRange "levels")?                           --&gt;
  &lt;xsd:complexType name="ftThesaurusID"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="at" type="xsd:anyURI" /&gt;
      &lt;xsd:element name="relationship" type="xsd:string" minOccurs="0" /&gt;
      &lt;xsd:element name="levels" type="xqxft:ftRange" minOccurs="0" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   ... (FTThesaurusID | "default")                                   --&gt;
  &lt;!--   ... "(" (FTThesaurusID | "default") ("," FTThesaurusID)* ")")     --&gt;
  &lt;xsd:complexType name="thesaurusSpecSequence"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="default" /&gt;
        &lt;xsd:element name="thesaurusID"
                     type="xqxft:ftThesaurusID" /&gt;
      &lt;/xsd:choice&gt;
      &lt;xsd:element name="thesaurusID" type="xqxft:ftThesaurusID"
                   minOccurs="0" maxOccurs="unbounded" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTThesaurusOption ::=                                             --&gt;
  &lt;!--       ("with" "thesaurus" (FTThesaurusID | "default"))              --&gt;
  &lt;!--     | ("with" "thesaurus"                                           --&gt;
  &lt;!--          "(" (FTThesaurusID | "default") ("," FTThesaurusID)* ")")  --&gt;
  &lt;!--     | ("without" "thesaurus")                                       --&gt;
  &lt;xsd:complexType name="ftThesaurusOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="without" /&gt;
          &lt;xsd:element name="thesauri" type="xqxft:thesaurusSpecSequence" /&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="thesaurus" type="xqxft:ftThesaurusOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: stopwords                                --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--     FTStopWords ::= ("at" URILiteral)                               --&gt;
  &lt;!--   | ("(" StringLiteral ("," StringLiteral)* ")")                    --&gt;
  &lt;xsd:complexType name="ftStopWords"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="ref" type="xsd:anyURI" /&gt;
      &lt;xsd:element name="list"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="xqx:stringConstantExpr"
             minOccurs="1" maxOccurs="unbounded" /&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftStopWords" type="xqxft:ftStopWords" /&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   ... "with" "stop" "words" FTStopWords ...                         --&gt;
  &lt;!--   ... "with" "default" "stop" "words" ...                           --&gt;
  &lt;xsd:group name="baseStopWords"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="default" /&gt;
      &lt;xsd:element ref="xqxft:ftStopWords" /&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:group&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTStopWordsInclExcl ::= ("union" | "except") FTStopWords          --&gt;
  &lt;xsd:complexType name="ftStopWordsInclExcl"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="union" type="xqxft:ftStopWords" /&gt;
      &lt;xsd:element name="except" type="xqxft:ftStopWords" /&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   ... ("with" "stop" "words" FTStopWords FTStopWordsInclExcl*) ...  --&gt;
  &lt;!--   ... ("with" "default" "stop" "words" FTStopWordsInclExcl*) ...    --&gt;
  &lt;xsd:complexType name="stopWordsSpecSequence"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:group ref="xqxft:baseStopWords" /&gt;
      &lt;xsd:element name="ftStopWordsInclExcl"
                   type="xqxft:ftStopWordsInclExcl"
                   minOccurs="0" maxOccurs="unbounded" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTStopWordOption ::=                                              --&gt;
  &lt;!--       ("with" "stop" "words" FTStopWords FTStopWordsInclExcl*)      --&gt;
  &lt;!--     | ("without" "stop" "words")                                    --&gt;
  &lt;!--     | ("with" "default" "stop" "words" FTStopWordsInclExcl*)        --&gt;
  &lt;xsd:complexType name="ftStopWordOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="without" /&gt;
          &lt;xsd:element name="stopwords" type="xqxft:stopWordsSpecSequence" /&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="stopword" type="xqxft:ftStopWordOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: language                                 --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTLanguageOption ::= "language" StringLiteral                     --&gt;
  &lt;xsd:complexType name="ftLanguageOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:string" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="language" type="xqxft:ftLanguageOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: wildcards                                --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWildCardOption ::= ("with" "wildcards")                         --&gt;
  &lt;!--                      | ("without" "wildcards")                      --&gt;
  &lt;xsd:complexType name="ftWildCardOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="with wildcards" /&gt; 
                &lt;xsd:enumeration value="without wildcards" /&gt;
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="wildcard" type="xqxft:ftWildCardOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTExtensionOption ::= "option" QName StringLiteral                --&gt;
  &lt;xsd:complexType name="ftExtensionOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftExtensionName" type="xqx:QName"/&gt;
          &lt;xsd:element name="ftExtensionValue" type="xsd:string"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftExtensionOption" type="xqxft:ftExtensionOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;

&lt;/xsd:schema&gt;


</eg></div2><div2 id="id-xqft-full-text-stylesheet"><head>XQueryX stylesheet for XQuery and XPath Full Text 1.0</head><p>
The XSLT stylesheet that defines the semantics of XQueryX
in support of XQuery and XPath Full Text 1.0 integrates seamlessly with the
XQueryX XSLT stylesheet defined in <xspecref spec="XQX" ref="Stylesheet"/>
by importing the XQueryX XSLT stylesheet. 
It provides additional templates that
define the semantics of the XQueryX representation of XQuery and XPath Full Text 1.0
by transforming that XQueryX representation into
the human readable syntax of XQuery and XPath Full Text 1.0. 
</p><eg xml:space="preserve">

&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
                xmlns:xqx="http://www.w3.org/2005/XQueryX"&gt;

&lt;!-- Initial creation                            2006-08-17: Jim Melton --&gt;
&lt;!-- Added ftOptionDecl, ftScoreVariableBinding  2006-08-21: Jim Melton --&gt;
&lt;!-- First version believed complete             2006-08-29: Jim Melton --&gt;
&lt;!-- Revised to align with 2008-01-24 draft      2008-02-08: Jim Melton --&gt;
&lt;!-- Revised position of "weight" in grammar     2008-11-12: Jim Melton --&gt;

&lt;xsl:import href="http://www.w3.org/2005/XQueryX/xqueryx.xsl"/&gt;


&lt;!-- ftOptionDecl --&gt;
&lt;xsl:template match="xqxft:ftOptionDecl"&gt;
  &lt;xsl:text&gt;declare ft-option &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftScoreVariableBinding --&gt;
&lt;xsl:template match="xqxft:ftScoreVariableBinding"&gt;
  &lt;xsl:text&gt; score &lt;/xsl:text&gt;
  &lt;xsl:value-of select="$DOLLAR"/&gt;
  &lt;xsl:if test="@xqx:prefix"&gt;
    &lt;xsl:value-of select="@xqx:prefix"/&gt;
    &lt;xsl:value-of select="$COLON"/&gt;
  &lt;/xsl:if&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftcontains --&gt;
&lt;xsl:template match="xqxft:ftContainsExpr"&gt;
  &lt;xsl:apply-templates select="xqxft:ftRangeExpr"/&gt;
  &lt;xsl:text&gt; ftcontains &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:ftSelectionExpr"/&gt;
  &lt;xsl:apply-templates select="xqxft:ftIgnoreOption"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:value"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftRangeExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftSelectionExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftIgnoreOption"&gt;
  &lt;xsl:text&gt;without content &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftSelection"&gt;
  &lt;xsl:apply-templates select="xqxft:ftSelectionSource"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:text&gt;    &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:posFilter"/&gt;
  &lt;xsl:apply-templates select="xqxft:weight"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftSelectionSource"&gt;
&lt;xsl:message&gt;Entering ftSelectionSource&lt;/xsl:message&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftPosFilter"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:text&gt;      &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- FTProximity alternative: ordered --&gt;
&lt;xsl:template match="xqxft:ftOrder"&gt;
  &lt;xsl:text&gt;ordered &lt;/xsl:text&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: window --&gt;
&lt;xsl:template match="xqxft:ftWindow"&gt;
  &lt;xsl:text&gt;window &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:unit"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: distance --&gt;
&lt;xsl:template match="xqxft:ftDistance"&gt;
  &lt;xsl:text&gt;distance &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:ftRange"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:unit"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: scope --&gt;
&lt;xsl:template match="xqxft:ftScope"&gt;
  &lt;xsl:value-of select="xqxft:type"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:unit"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: content --&gt;
&lt;xsl:template match="xqxft:ftContent"&gt;
  &lt;xsl:value-of select="xqxft:location"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:exactlyRange"&gt;
  &lt;xsl:text&gt;exactly &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:atLeastRange"&gt;
  &lt;xsl:text&gt;at least &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:atMostRange"&gt;
  &lt;xsl:text&gt;at most &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:fromToRange"&gt;
  &lt;xsl:text&gt;from &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:lower"/&gt;
  &lt;xsl:text&gt; to &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:upper"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:lower"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:upper"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: case --&gt;
&lt;xsl:template match="xqxft:case"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:value"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: diacritics --&gt;
&lt;xsl:template match="xqxft:diacritics"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:value"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: stemming --&gt;
&lt;xsl:template match="xqxft:stem"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:value"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: thesaurus --&gt;
&lt;xsl:template match="xqxft:thesaurus"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="without"&gt;
      &lt;xsl:text&gt;without thesaurus &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:thesauri"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:text&gt;with thesaurus &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="child::*[2]"&gt;
      &lt;xsl:call-template name="parenthesizedList"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:default"&gt;
  &lt;xsl:text&gt;default &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:thesaurusID"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:at"&gt;
  &lt;xsl:text&gt;at "&lt;/xsl:text&gt;
  &lt;xsl:value-of select="."/&gt;
  &lt;xsl:text&gt;" &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:relationship"&gt;
  &lt;xsl:text&gt;relationship "&lt;/xsl:text&gt;
  &lt;xsl:value-of select="."/&gt;
  &lt;xsl:text&gt;" &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:levels"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; levels &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: stopword --&gt;
&lt;xsl:template match="xqxft:stopword"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="without"&gt;
      &lt;xsl:text&gt;without stop words &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt; 
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:stopwords"&gt;
  &lt;xsl:text&gt;with &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="default"&gt;
      &lt;xsl:text&gt;default stop words &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;stop words &lt;/xsl:text&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:ftStopWords"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="ref"&gt;
      &lt;xsl:text&gt;at "&lt;/xsl:text&gt;
      &lt;xsl:value-of select="ref"/&gt;
      &lt;xsl:text&gt;" &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:list"&gt;
  &lt;xsl:call-template name="parenthesizedList"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:FTStopWordsInclExcl"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:union"&gt;
  &lt;xsl:text&gt;union &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:except"&gt;
  &lt;xsl:text&gt;except &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:language"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:wildcard"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftAnd"&gt;
  &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
  &lt;xsl:text&gt;ftand &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftOr"&gt;
  &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
  &lt;xsl:text&gt;ftor &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftMildNot"&gt;
  &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
  &lt;xsl:text&gt;not in &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftUnaryNot"&gt;
  &lt;xsl:text&gt;ftnot &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:operand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftPrimaryWithOptions"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftPrimary"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:parenthesized"&gt;
  &lt;xsl:text&gt;( &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; ) &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWords"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWordsValue"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWordsLiteral"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWordsExpression"&gt;
  &lt;xsl:text&gt; { &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; } &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftAnyAllOption"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftTimes"&gt;
  &lt;xsl:text&gt;occurs &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt;times &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionSelection"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionOption"&gt;
  &lt;xsl:text&gt;option &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionName"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionValue"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:weight"&gt;
  &lt;xsl:text&gt; weight &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;


</eg></div2><div2 id="id-xqft-full-text-examples"><head>XQueryX for XQuery and XPath Full Text 1.0 example</head><!-- Jim, 2007-08-11 - Bug #4735 --><p>
The following example is based on the data and queries of one of the use cases
in <bibref ref="xmlquery-full-text-use-cases"/>. 
In this example, we show the English description of the query,
the XQuery Full Text solution given in <bibref ref="xmlquery-full-text-use-cases"/>,
a Full Text XQueryX solution, and the XQuery Full Text query
that results from applying the Full Text XQueryX-to-XQuery Full Text transformation
defined by the stylesheet in <specref ref="id-xqft-full-text-stylesheet"/>
to the Full Text XQueryX solution.
The latter XQuery Full Text expression is presented only as a sanity-check —
the intent of the stylesheet is not to create the identical
XQuery Full Text expression given in <bibref ref="xmlquery-full-text-use-cases"/>,
but to produce <emph>a</emph> valid
XQuery Full Text expression with the same semantics. 
</p><p>Comparison of the results of the Full Text XQueryX-to-XQuery Full Text
transformation given in this document with the XQuery Full Text solutions
in the <bibref ref="xmlquery-full-text-use-cases"/> may be helpful in evaluating
the correctness of the Full Text XQueryX solution in the example. </p><p>The XQuery Full Text Use Cases solution given for the
example is provided only to assist readers of this
document in understanding the Full Text XQueryX solution. 
There is no intent to imply that this
document specifies a "compilation" or "transformation" of
XQuery Full Text syntax into Full Text XQueryX syntax. 
</p><p>In the following example, note that path expressions are expanded to show their
structure. Also, note that the prefix syntax for binary operators like "and" makes the
precedence explicit. In general, humans find it easier to read an XML representation
that does not expand path expressions, but it is less convenient for programmatic
representation and manipulation.  XQueryX is designed as a language that is convenient
for production and modification by software, and not as a convenient syntax for humans to
read and write. </p><p>Finally, please note that white space, including new lines, have been added to
some of the Full Text XQueryX documents and XQuery Full Text expressions for readability. 
That additional white space is not necessarily produced by the
Full Text XQueryX-to-XQuery Full Text transformation. </p><div3 id="Example1"><head>Example</head><p>Here is Q4 from the <bibref ref="xmlquery-full-text-use-cases"/>,
    use case SCORE: Find all books with parts about "usability testing".</p><div4 id="Example1-XQuery-Full-Text"><head>XQuery solution in XQuery and XPath Full Text 1.0 Use Cases:</head><eg xml:space="preserve">
declare function local:filter ( $nodes 
   as node()*, $exclude as element()* ) as node()*
   {
      for $node in $nodes except $exclude
      return
         typeswitch ($node)
            case $e as element()
               return 
                 element {node-name($e)}
                   {
                       $e/@*,
                      filter( $e/node() except $exclude, 
                      $exclude )
                   }
            default 
               return $node
   };

for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $irrelevantParts := 
   for $part in $book//part
   let score $score := $part ftcontains "usability test.*" 
      with wildcards
   where $score &lt; 0.5
   return $part
where count($irrelevantParts) &lt; count($book//part)
return filter($book, $irrelevantParts)
</eg></div4><div4 id="Example1-Full-Text-XQueryX"><head>A Solution in Full Text XQueryX:</head><eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
            xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2007/xpath-full-text
                                http://www.w3.org/2007/xpath-full-text/XQueryX-Full-Text-extensions.xsd
                                http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;

  &lt;xqx:mainModule&gt;
    &lt;xqx:prolog&gt;
      &lt;xqx:functionDecl&gt;
        &lt;xqx:functionName xqx:prefix="local"&gt;filter&lt;/xqx:functionName&gt;
        &lt;xqx:paramList&gt;
          &lt;xqx:param&gt;
            &lt;xqx:varName&gt;nodes&lt;/xqx:varName&gt;
            &lt;xqx:typeDeclaration&gt;
              &lt;xqx:anyKindTest/&gt;&lt;xqx:occurrenceIndicator&gt;*&lt;/xqx:occurrenceIndicator&gt;
            &lt;/xqx:typeDeclaration&gt;
          &lt;/xqx:param&gt;
          &lt;xqx:param&gt;
            &lt;xqx:varName&gt;exclude&lt;/xqx:varName&gt;
            &lt;xqx:typeDeclaration&gt;
              &lt;xqx:elementTest/&gt;&lt;xqx:occurrenceIndicator&gt;*&lt;/xqx:occurrenceIndicator&gt;
            &lt;/xqx:typeDeclaration&gt;
          &lt;/xqx:param&gt;
        &lt;/xqx:paramList&gt;
        &lt;xqx:typeDeclaration&gt;
          &lt;xqx:anyKindTest/&gt;
        &lt;/xqx:typeDeclaration&gt;
        &lt;xqx:functionBody&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;node&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:exceptOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;nodes&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;exclude&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:exceptOp&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:typeswitchExpr&gt;
                &lt;xqx:argExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;node&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:argExpr&gt;
                &lt;xqx:typeswitchExprCaseClause&gt;
                  &lt;xqx:variableBinding&gt;e&lt;/xqx:variableBinding&gt;
                  &lt;xqx:sequenceType&gt;
                    &lt;xqx:elementTest/&gt;
                  &lt;/xqx:sequenceType&gt;
                  &lt;xqx:resultExpr&gt;
                    &lt;xqx:computedElementConstructor&gt;
                      &lt;xqx:tagNameExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName xqx:prefix="fn"&gt;node-name&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;e&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:tagNameExpr&gt;
                      &lt;xqx:contentExpr&gt;
                        &lt;xqx:sequenceExpr&gt;
                          &lt;xqx:pathExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:filterExpr&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;e&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:filterExpr&gt;
                            &lt;/xqx:stepExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                              &lt;xqx:attributeTest&gt;
                                &lt;xqx:attributeName&gt;
                                  &lt;xqx:star/&gt;
                                &lt;/xqx:attributeName&gt;
                              &lt;/xqx:attributeTest&gt;
                            &lt;/xqx:stepExpr&gt;
                          &lt;/xqx:pathExpr&gt;
                          &lt;xqx:functionCallExpr&gt;
                            &lt;xqx:functionName xqx:prefix="fn"&gt;filter&lt;/xqx:functionName&gt;
                            &lt;xqx:arguments&gt;
                              &lt;xqx:exceptOp&gt;
                                &lt;xqx:firstOperand&gt;
                                  &lt;xqx:pathExpr&gt;
                                    &lt;xqx:stepExpr&gt;
                                      &lt;xqx:filterExpr&gt;
                                        &lt;xqx:varRef&gt;
                                          &lt;xqx:name&gt;e&lt;/xqx:name&gt;
                                        &lt;/xqx:varRef&gt;
                                      &lt;/xqx:filterExpr&gt;
                                    &lt;/xqx:stepExpr&gt;
                                    &lt;xqx:stepExpr&gt;
                                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                      &lt;xqx:anyKindTest/&gt;
                                    &lt;/xqx:stepExpr&gt;
                                  &lt;/xqx:pathExpr&gt;
                                &lt;/xqx:firstOperand&gt;
                                &lt;xqx:secondOperand&gt;
                                  &lt;xqx:varRef&gt;
                                    &lt;xqx:name&gt;exclude&lt;/xqx:name&gt;
                                  &lt;/xqx:varRef&gt;
                                &lt;/xqx:secondOperand&gt;
                              &lt;/xqx:exceptOp&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;exclude&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
                            &lt;/xqx:arguments&gt;
                          &lt;/xqx:functionCallExpr&gt;
                        &lt;/xqx:sequenceExpr&gt;
                      &lt;/xqx:contentExpr&gt;
                    &lt;/xqx:computedElementConstructor&gt;
                  &lt;/xqx:resultExpr&gt;
                &lt;/xqx:typeswitchExprCaseClause&gt;
                &lt;xqx:typeswitchExprDefaultClause&gt;
                  &lt;xqx:resultExpr&gt;
                    &lt;xqx:varRef&gt;
                      &lt;xqx:name&gt;node&lt;/xqx:name&gt;
                    &lt;/xqx:varRef&gt;
                  &lt;/xqx:resultExpr&gt;
                &lt;/xqx:typeswitchExprDefaultClause&gt;
              &lt;/xqx:typeswitchExpr&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:functionBody&gt;
      &lt;/xqx:functionDecl&gt;
    &lt;/xqx:prolog&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:flworExpr&gt;
        &lt;xqx:forClause&gt;
          &lt;xqx:forClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;book&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:forExpr&gt;
              &lt;xqx:pathExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:filterExpr&gt;
                    &lt;xqx:functionCallExpr&gt;
                      &lt;xqx:functionName xqx:prefix="fn"&gt;doc&lt;/xqx:functionName&gt;
                      &lt;xqx:arguments&gt;
                        &lt;xqx:stringConstantExpr&gt;
                          &lt;xqx:value&gt;http://bstore1.example.com/full-text.xml&lt;/xqx:value&gt;
                        &lt;/xqx:stringConstantExpr&gt;
                      &lt;/xqx:arguments&gt;
                    &lt;/xqx:functionCallExpr&gt;
                  &lt;/xqx:filterExpr&gt;
                &lt;/xqx:stepExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                  &lt;xqx:nameTest&gt;books&lt;/xqx:nameTest&gt;
                &lt;/xqx:stepExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                  &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                &lt;/xqx:stepExpr&gt;
              &lt;/xqx:pathExpr&gt;
            &lt;/xqx:forExpr&gt;
          &lt;/xqx:forClauseItem&gt;
        &lt;/xqx:forClause&gt;
        &lt;xqx:letClause&gt;
          &lt;xqx:letClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;irrelevantParts&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:letExpr&gt;
              &lt;xqx:flworExpr&gt;
                &lt;xqx:forClause&gt;
                  &lt;xqx:forClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;part&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:forExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;book&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;part&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:forExpr&gt;
                  &lt;/xqx:forClauseItem&gt;
                &lt;/xqx:forClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqxft:ftScoreVariableBinding&gt;score&lt;/xqxft:ftScoreVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqxft:ftContainsExpr&gt;
                        &lt;xqxft:ftRangeExpr&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;part&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqxft:ftRangeExpr&gt;
                        &lt;xqxft:ftSelectionExpr&gt;
                          &lt;xqxft:ftSelection&gt;
                            &lt;xqxft:ftSelectionSource&gt;
                              &lt;xqx:primaryWithOptions&gt;
                                &lt;xqx:primary&gt;
                                  &lt;xqx:ftWords&gt;
                                    &lt;xqx:ftWordsValue&gt;
                                      &lt;xqx:ftWordsLiteral&gt;
                                        &lt;xqx:stringConstantExpr&gt;
                                          &lt;xqx:value&gt;usability test.*&lt;/xqx:value&gt;
                                        &lt;/xqx:stringConstantExpr&gt;
                                     &lt;/xqx:ftWordsLiteral&gt;
                                    &lt;/xqx:ftWordsValue&gt;
                                  &lt;/xqx:ftWords&gt;
                                &lt;/xqx:primary&gt;
                                &lt;xqx:ftMatchOptions&gt;
                                  &lt;xqxft:wildcard&gt;
                                    &lt;xqxft:value&gt;with wildcards&lt;/xqxft:value&gt;
                                  &lt;/xqxft:wildcard&gt;
                                &lt;/xqx:ftMatchOptions&gt;
                              &lt;/xqx:primaryWithOptions&gt;
                            &lt;/xqxft:ftSelectionSource&gt;
                          &lt;/xqxft:ftSelection&gt;
                        &lt;/xqxft:ftSelectionExpr&gt;
                      &lt;/xqxft:ftContainsExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:whereClause&gt;
                  &lt;xqx:lessThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;score&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:decimalConstantExpr&gt;
                        &lt;xqx:value&gt;0.5&lt;/xqx:value&gt;
                      &lt;/xqx:decimalConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:lessThanOp&gt;
                &lt;/xqx:whereClause&gt;
                &lt;xqx:returnClause&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;part&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:returnClause&gt;
              &lt;/xqx:flworExpr&gt;
            &lt;/xqx:letExpr&gt;
          &lt;/xqx:letClauseItem&gt;
        &lt;/xqx:letClause&gt;
        &lt;xqx:whereClause&gt;
          &lt;xqx:lessThanOp&gt;
          &lt;xqx:firstOperand&gt;
            &lt;xqx:functionCallExpr&gt;
              &lt;xqx:functionName xqx:prefix="fn"&gt;count&lt;/xqx:functionName&gt;
              &lt;xqx:arguments&gt;
                &lt;xqx:varRef&gt;
                  &lt;xqx:name&gt;irrelevantParts&lt;/xqx:name&gt;
                &lt;/xqx:varRef&gt;
              &lt;/xqx:arguments&gt;
            &lt;/xqx:functionCallExpr&gt;
          &lt;/xqx:firstOperand&gt;
          &lt;xqx:secondOperand&gt;
            &lt;xqx:functionCallExpr&gt;
              &lt;xqx:functionName xqx:prefix="fn"&gt;count&lt;/xqx:functionName&gt;
              &lt;xqx:arguments&gt;
                &lt;xqx:pathExpr&gt;
                  &lt;xqx:stepExpr&gt;
                    &lt;xqx:filterExpr&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;book&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:filterExpr&gt;
                  &lt;/xqx:stepExpr&gt;
                  &lt;xqx:stepExpr&gt;
                    &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                    &lt;xqx:nameTest&gt;part&lt;/xqx:nameTest&gt;
                  &lt;/xqx:stepExpr&gt;
                &lt;/xqx:pathExpr&gt;
              &lt;/xqx:arguments&gt;
            &lt;/xqx:functionCallExpr&gt;
          &lt;/xqx:secondOperand&gt;
          &lt;/xqx:lessThanOp&gt;
        &lt;/xqx:whereClause&gt;
        &lt;xqx:returnClause&gt;
          &lt;xqx:functionCallExpr&gt;
            &lt;xqx:functionName xqx:prefix="local"&gt;filter&lt;/xqx:functionName&gt;
            &lt;xqx:arguments&gt;
              &lt;xqx:varRef&gt;
                &lt;xqx:name&gt;book&lt;/xqx:name&gt;
              &lt;/xqx:varRef&gt;
              &lt;xqx:varRef&gt;
                &lt;xqx:name&gt;irrelevantParts&lt;/xqx:name&gt;
              &lt;/xqx:varRef&gt;
            &lt;/xqx:arguments&gt;
          &lt;/xqx:functionCallExpr&gt;
        &lt;/xqx:returnClause&gt;
      &lt;/xqx:flworExpr&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</eg></div4><div4 id="Example1-Full-Text-Transformation"><head>Transformation of Full Text XQueryX Solution into XQuery Full Text</head><p>Application of the stylesheet in <specref ref="id-xqft-full-text-stylesheet"/>
          to the Full Text XQueryX solution results in:</p><eg xml:space="preserve">
declare function local:filter($nodes as node()*, $exclude as element()*) as node()
{
( for $node in ($nodes except $exclude)
  return ( typeswitch($node)
             case $e as element()
               return element {fn:node-name($e)}
                  {( $e/child::attribute(*),
                     fn:filter( ($e/child::node() except $exclude), $exclude ) )}
             default return $node )
)
};

( for $book
    in fn:doc("http://bstore1.example.com/full-text.xml")/child::books/child::book
  let $irrelevantParts:=
  ( for $part in $book/descendant-or-self::part
    let score $score := $part ftcontains "usability test.*"
        with wildcards
    where ($score &lt; 0.5)
    return $part
)
  where (fn:count($irrelevantParts) &lt; fn:count($book/descendant-or-self::part))
  return local:filter($book, $irrelevantParts)
)
</eg></div4></div3></div2></div1><div1 id="References"><head>References</head><div2 id="id-normative-references"><head>Normative References</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery" key="XQuery 1.0: An XML Query Language" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath20" key="XML Path Language (XPath) 2.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions" key="XQuery 1.0 and XPath 2.0 Functions and Operators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-datamodel" key="XQuery 1.0 and XPath 2.0 Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xqueryx" key="XML Syntax for XQuery 1.0 (XQueryX)" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xqueryft-requirements" key="XQuery and XPath Full Text Requirements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                  <emph>
                     <loc href="http://www.w3.org/TR/xpath-full-text-10-requirements/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery 
and XPath Full Text Requirements</loc>
                  </emph>,
Stephen Buxton, Michael Rys, Editors. World Wide Web Consortium, 18 May 2007.
This version is http://www.w3.org/TR/2007/WD-xpath-full-text-10-requirements-20070518/.
The <loc href="http://www.w3.org/TR/xpath-full-text-10-requirements/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version</loc>
is available at <loc href="http://www.w3.org/TR/xpath-full-text-10-requirements/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-full-text-10-requirements/</loc>.
</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlquery-full-text-use-cases" key="XQuery and XPath Full Text Use Cases" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><!--  <bibl id="xqueryft-usecases" key="XQuery and XPath Full Text Use Cases"><emph><loc href="http://www.w3.org/TR/xmlquery-full-text-use-cases/">XQuery and XPath Full Text Use Cases</loc></emph>, --><!--  Sihem Amer-Yahia, Pat Case, Editors. World Wide Web Consortium, 04 April 2005. --><!--  This version is http://www.w3.org/TR/2004/WD-xmlquery-full-text-use-cases-20040709/. The --><!--  <loc href="http://www.w3.org/TR/xmlquery-full-text-use-cases/">latest version</loc> is available at --><!--  <loc href="http://www.w3.org/TR/xmlquery-full-text-use-cases/">http://www.w3.org/TR/xmlquery-full-text-use-cases/.</loc> --><!--  </bibl> --><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="BCP47" key="BCP 47" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">A. Phillips and M. Davis. <emph>Tags for Identifying Languages.</emph>
IETF BCP 47.
See <loc href="http://tools.ietf.org/html/bcp47" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://tools.ietf.org/html/bcp47</loc>.
This reference leads to <bibref ref="RFC4646"/> and <bibref ref="RFC4647"/> and
replaces <bibref ref="RFC3066"/>. </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC 2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner.
<emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF RFC 2119. 
See <loc href="http://rfc.net/rfc2119.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2119.txt</loc>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3066" key="RFC 3066" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">H. Alvestrand. <emph>Tags for the Identification of Languages.</emph>
IETF RFC 3066. See <loc href="http://rfc.net/rfc3066.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3066.txt</loc>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC4646" key="RFC 4646" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">A. Phillips and M. Davis. <emph>Tags for Identifying Languages.</emph>
IETF RFC 4646. See <loc href="http://rfc.net/rfc4646.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc4646.txt</loc>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC4647" key="RFC 4647" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">A. Phillips and M. Davis. <emph>Matching of Language Tags.</emph>
IETF RFC 4647. See <loc href="http://rfc.net/rfc4647.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc4647.txt</loc>.</bibl></blist></div2><div2 id="id-non-normative-references"><head>Non-normative References</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="iso-2788" key="ISO 2788" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
Documentation Guidelines for the Establishment and Development of
Monolingual Thesauri, Geneva: International Organization for
Standardization, 2nd edition, 1986.
</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="sqlmm" key="SQL/MM" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> ISO/IEC 13249-2 Information technology
--- Database languages --- SQL Multimedia and Application Packages ---
Part 2: Full-Text. Geneva: International Organization for
Standardization, 2nd edition, 2003.
</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UAX29" key="UAX29" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Davis. <emph>Unicode Standard Annex #29
Text Boundaries, revision 11, 2006.
</emph>  See <loc href="http://www.unicode.org/reports/tr29/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/reports/tr29/</loc>
               </bibl></blist></div2></div1><inform-div1 id="ft-acknowledgements"><head>Acknowledgements</head><p>We would like to thank the members of the XQuery and XPath
Full-Text group for their fruitful discussions. </p><p>We would like to thank the following people for their contributions on earlier drafts of this document.</p><ulist><item><p> Andrew Cencini, Microsoft - acencini@microsoft.com </p></item><item><p> Andrew Eisenberg, IBM - andrew.eisenberg@us.ibm.com</p></item><item><p> Nimish Khanolkar, Microsoft - nimishk@exchange.microsoft.com </p></item><item><p> Ashok Malhotra, Oracle - ashok.malhotra@oracle.com </p></item><item><p> Tapas Nayak, Microsoft - tapasnay@exchange.microsoft.com </p></item><item><p> Roland Seiffert, IBM - seiffert@de.ibm.com</p></item></ulist></inform-div1><inform-div1 id="ft-glossary"><head>Glossary</head><!-- This processing instruction automatically generates the glossary. --><?glossary?></inform-div1><inform-div1 id="impl-def"><head>Checklist of Implementation-Defined Features</head><p>This appendix provides a summary of features defined in this specification
whose effect is explicitly <termref def="dt-implementation-defined">implementation-defined</termref>. 
The conformance rules require vendors to provide documentation that
explains how these choices have been exercised.
</p><olist><item><p> 
Tokenization, including the definition of the term "tokens",
<termref def="should">SHOULD</termref> be <termref def="dt-implementation-defined">implementation-defined</termref>. 
Implementations <termref def="should">SHOULD</termref> expose the rules and
sample results of tokenization as much as possible to
enable users to predict and interprete the results of tokenization. 
</p></item><item><p>
A phrase is an ordered sequence of any number of tokens. Beyond that, phrases
are <termref def="dt-implementation-defined">implementation-defined</termref>.
</p></item><item><p>
A sentence is an ordered sequence of any number of tokens. Beyond that,
sentences are <termref def="dt-implementation-defined">implementation-defined</termref>.  An implementation is not required
to support sentences.
</p></item><item><p>
A  paragraph is an ordered sequence of any number of tokens. Beyond that,
paragraphs are <termref def="dt-implementation-defined">implementation-defined</termref>.  An implementation is not required
to support paragraphs.
</p></item><item><p> Implementations are free to provide
<termref def="dt-implementation-defined">implementation-defined</termref> ways to differentiate between markup's 
effect on token boundaries during tokenization. </p></item><item><p> How text with wildcard indicators and qualifiers is tokenized is
<termref def="dt-implementation-defined">implementation-defined</termref>.</p></item><item><p>
The set of expressions (of form ExprSingle) that can be assigned to a
score variable in a let-clause is <termref def="dt-implementation-defined">implementation-defined</termref>.  The result
of passing an expression to the scoring algorithm that it does not support is
<termref def="dt-implementation-defined">implementation-defined</termref>. 
</p></item><item><p> The <termref def="dt-match-option-order">match option application order</termref>, subject to the
stated constraints, is <termref def="dt-implementation-defined">implementation-defined</termref>. 
</p></item><item><p>  It is <termref def="dt-implementation-defined">implementation-defined</termref> what a stem of a token is and 
whether stemming will based on an algorithm, dictionary, or mixed approach. </p></item><item><p> It is <termref def="dt-implementation-defined">implementation-defined</termref> which thesaurus relationships an
implementation supports.</p></item><item><p> The behavior of the implementation when it encounters a combination of
thesauri, levels, and relationships that it does not support is <termref def="dt-implementation-defined">implementation-defined</termref>.</p></item><item><p> When the option "with default stop words" is used, an
<termref def="dt-implementation-defined">implementation-defined</termref> collection of stop words is used. </p></item><item><p> When a stop word is specified in a query, then the number of tokens in the text that are matched by that stop word is <termref def="dt-implementation-defined">implementation-defined</termref>. </p></item><item><p> The "language" option influences tokenization, stemming, and stop
words in an <termref def="dt-implementation-defined">implementation-defined</termref> way. It 
<termref def="may">MAY</termref> influence the behavior of
other match options in an <termref def="dt-implementation-defined">implementation-defined</termref> way.</p></item><item><p> The set of valid language identifiers is <termref def="dt-implementation-defined">implementation-defined</termref>. </p></item><item><p> The behavior of the implementation when it encounters a language
identifier it does not support is <termref def="dt-implementation-defined">implementation-defined</termref>.</p></item><item><p>Certain values in the static context (see <specref ref="id-xqft-static-context-components"/>)
that can be overwritten or augmented by implementations are
<termref def="dt-implementation-defined">implementation-defined</termref>. </p></item><item><p>Which namespace URIs will be recognized for denoting extension
selection pragmas is <termref def="dt-implementation-defined">implementation-defined</termref>, as is the syntax
and behavior of recognized pragmas.
</p></item><item><p>Which namespace URIs will be recognized for denoting extension
options is <termref def="dt-implementation-defined">implementation-defined</termref>, as is the syntax
and behavior of recognized options.
</p></item><item><p>The conditions under which tokenization of two equal items produces
different tokens is <termref def="dt-implementation-defined">implementation-defined</termref>.
</p></item><item><p>The restrictions on allowable expressions used to compute scores are
<termref def="dt-implementation-defined">implementation-defined</termref>.
</p></item></olist></inform-div1><!--	&issues; --><inform-div1 id="id-xqft-changelog"><head>Change Log</head><table border="1" summary="Change Log Table"><tbody><!--
=================== commented out from here
<tr>
<td>Jochen Doerre</td>
<td>2004-10-04</td>
<td>Added issue on FTIgnore</td>
<td>Added Cluster B, Issue 50 IGNORE Queries.</td>
</tr>
<tr>
<td>Jochen Doerre</td>
<td>2004-10-04</td>
<td>Added issue on FTWindow</td>
<td>Added Cluster I, Issue 51 Alternative Semantics for FTWindow.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-01-14</td>
<td>Added issue on UnionExpr in StopWords</td>
<td>Added Cluster D, Issue 52 UnionExpr in StopWords.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-01-16</td>
<td>Added FTStartswith to syntax</td>
<td>Added Section 3.1.12 on startswith. Closed Cluster C, Issue 40 Starts With</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-01-16</td>
<td>Removed FTSpecialCharacter syntax</td>
<td>Removed the Special Character match option in section 3 and closed Cluster E, Issue 22 DiacriticsMatchOption and Cluster E, Issue 24 SpecialCharMatchOption.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-01-16</td>
<td>Updated FTLanguage syntax</td>
<td>Added the sentence "The set of valid language identifiers is implementation-defined." in Section 3.2.7 (now 3.2.6) FTLanguage.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-01-16</td>
<td>Updated score syntax</td>
<td>Changed syntax of ft:score() into score $var as Expr in Section 3.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-01-16</td>
<td>Added score weighting syntax</td>
<td>Added 1) weight to FTSelection inside a scoring expression and 2) text stating that Weight values in scoring expressions are in the interval [0,1]. Closed Cluster A, Issue 17 Weighting and Cluster A, Issue 18 Weight Values.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-01-24</td>
<td>Changed FTStartswith syntax to FTContent syntax</td>
<td>Changed FTStartswith to FTContent and changed wording to use "the tokenized string of elements".</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-01-24</td>
<td>Added issue on defaults</td>
<td>Added issue Cluster D, Issue 45 MatchOptions Default.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-01-24</td>
<td>Changed FTStopWords and FTThesaurus syntax</td>
<td>Closed Cluster E, Issue 26 StopWordsMatchOption, Cluster E, Issue 48 Stop words option, and Cluster D, Issue 8 Thesaurus, among other things changing the syntax to allow URIs for a stop word list or thesaurus.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-01</td>
<td>Added issue on score weights</td>
<td>Added Issue 54 Cluster A on weights in scores.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-10</td>
<td>Updated FTStopwords syntax</td>
<td>Updated syntax in Section 2.3.5 Stop Words.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-10</td>
<td>Updated FTThesaurus section</td>
<td>Updated descriptive text, adding reference to ISO 2788, in Section 2.3.4 Theasurus.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-10</td>
<td>Updated introduction</td>
<td>Modified item 7 in Section 1.1 to reflect conditions on tokenizers.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-10</td>
<td>Updated FTDistance syntax</td>
<td>Removed the optional keyword "with" from FTDistance.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-10</td>
<td>Updated FTWindow syntax</td>
<td>Removed the optional keyword "within" from FTWindow.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-14</td>
<td>Updated FTDiacritics syntax</td>
<td>Closed Cluster E, Issue 33 FTSpecialCharOption and Updated Section 3.2.2 Diacritics according to its resolution.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-14</td>
<td>Added FTCase and FTDiacritics matrices</td>
<td>Added matrices which summarize the interaction between the diacritics and case match options and types of collations.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-14</td>
<td>Added FTRegex escape syntax</td>
<td>Closed Cluster C, Issue 15 RegExp Escape by adding wildcard escape syntax.</td>
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-02-14</td>
<td>Updated FTThesaurusOption and FTRegexOption semantics</td>
<td>Updated FTThesaurusOption and FTRegexOption in Section 4 Semantics.</td>
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-02-14</td>
<td>Updated FTDiacritics semantics</td>
<td>The fts:applySingleSearchToken function in the match-options semantics section has been modified. Now it explicitly checks for the diacritics option and applies the necessary semantic functions.</td>
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-02-14</td>
<td>Removed FTSpecialCharacter semantics</td>
<td>Removed the special-characters option semantics.</td>
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-02-14</td>
<td>Updated FTStopWord semantics</td>
<td>Changed the XML representation and the fts:ApplyStopwordOption semantic function to reflex the new syntax.</td>
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-02-14</td>
<td>Added FTContent semantics</td>
<td>Added an XML representation and a semantic function for FTContent.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-18</td>
<td>Updated FTRegex syntax</td>
<td>Closed Cluster C, Issue 27 MatchOption and Tokenization which required changes only to FTRegex specifying it impact on tokenization. Text added.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-21</td>
<td>Replaced FTRegex syntax with FTWildcard syntax</td>
<td>Replaced FTRegex syntax with FTWildcard syntax in Section 3.2.8</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-02-21</td>
<td>Added issue proposing FTCollationOption</td>
<td>Added Cluster D, Issue 57 Collations Match Option.</td>
</tr>
<tr>
<td>Jochen Doerre</td>
<td>2005-02-22</td>
<td>Closed issues resolved previously</td>
<td>Closed Cluster A, Issue 1 Scoring Properties with no change to the document. Closed Cluster C, Issue 7 Wildcards - regular expressions were dropped in favor of wildcards. Closed Cluster F, Issue 31 Optional Keyword "with" in FTDistance - "with" was dropped. Closed Cluster F, Issue 32 Optional Keyword "within" in FTWindow - "within" was dropped. Closed Cluster F, Issue 34 FTNegation Includes Unary Not with no change to the document.</td>
</tr>
<tr>
<td>Jochen Doerre</td>
<td>2005-02-22</td>
<td>Added issue on ft-about</td>
<td>Added Cluster H, Issue 58 Free-text search operator ft-about.</td>
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-02-22</td>
<td>Updated FTDistance semantics</td>
<td>Removed the optional keyword "with" from FTDistance.</td>
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-02-22</td>
<td>Updated FTWindow semantics</td>
<td>Removed the optional keyword "within" from FTWindow.</td>
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-02-22</td>
<td>Updated FTWords semantics</td>
<td>Updated FTWords semantics to allow for zero-length string: An FTWords with an empty list of search tokens returns an empty AllMatches.</td>
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-02-22</td>
<td>Replaced FTRegex semantics with FTWildcards semantics</td>
<td>Replaced FTRegex semantics with FTWildcards semantics.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-03-03</td>
<td>Updated FTWildcards syntax</td>
<td>Updated FTWildcards syntax in Section 3.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-03-04</td>
<td>Updated Section 2 (syntax) and issues list</td>
<td>Closed and updated Section 2 to reflect resolutions for 1) Cluster F, Issue 30 Precedence of XQuery and full text, 2) Cluster G, Issue 47 Zero-length phrase, 3) Cluster F, Issue 49 Grammar Precedence and Lookahead. Also added introduction to the Issues List explaining the clusters.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-03-04</td>
<td>Updated FTIgnoreOption syntax</td>
<td>Updated FTIgnoreOption in Section 3.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-03-04</td>
<td>Updated FTThesaurus examples</td>
<td>Added "at" in thesaurus examples in Section 3.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-03-04</td>
<td>Updated FTWindow section</td>
<td>Added descriptive text to FTWindow.</td>
</tr>
<tr>
<td>Scott Boag</td>
<td>2005-03-10</td>
<td>Updated grammar</td>
<td>1) Integrated full-text grammar (including the "{" "}" bracketing of expressions) into the main XPath grammar file. 2) Changed the way ftcontains is called. 3) Generated parser is now generated without any lookahead enabled.</td> 
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-03-17</td>
<td>Updated Thesauri lookup</td>
<td>Closed Cluster D, Issue 42 Thesauri lookup for multi-word phrases, and updated section 4 to reflect the changes.
</td>
</tr>
<tr>
<td>Chavdar Botev</td>
<td>2005-03-17</td>
<td>Added text to describe schemas</td>
<td>Added two paragraphs to FTSelections and FTMatchOptions which describe the schemas.
</td>
</tr>
<tr>
<td>Scott Boag</td>
<td>2005-03-19</td>
<td>Updated FTThesaurus production</td>
<td>Updated FTThesaurus production by adding "at" before "except" and "union".</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-03-22</td>
<td>Removed ft and fts namespace references</td>
<td>Removed references to the ft (full text) and fts (full-text semantics) namespaces.</td>
</tr>
<tr>
<td>Sihem Amer-Yahia</td>
<td>2005-03-28</td>
<td>Updated FTThesaurus syntax</td>
<td>Updated FTThesaurus in Section 3.</td>
</tr>
============= commented out upto here
--><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-04-08</td><td rowspan="1" colspan="1">Updated case matrix</td><td rowspan="1" colspan="1">Updated case matrix row "sensitive", column "CCI" from "case-insensitive variant of CCI if it exists, else error" to 
"case-sensitive variant of CCI if it exists, else error".</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-05-02</td><td rowspan="1" colspan="1">Closed issues with no changes</td><td rowspan="1" colspan="1">Closed Cluster B, Issue 28 IGNORE Syntax with no change to the document. Closed Cluster B, Issue 50 IGNORE Queries with no change to the document.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-05-02</td><td rowspan="1" colspan="1">Updated FTTimes syntax</td><td rowspan="1" colspan="1">Closed Cluster G, Issue 14 FTTimesSelection and added a related bullet item in Section 3.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-05-02</td><td rowspan="1" colspan="1">Updated FTWildCard syntax</td><td rowspan="1" colspan="1">Updated FTWildCardOption in Section 3.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-05-03</td><td rowspan="1" colspan="1">Updated introduction</td><td rowspan="1" colspan="1">Replaced "semantic element" with "semantic markup" and "tag" with "element" in the introduction.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-05-03</td><td rowspan="1" colspan="1">Added issue on error codes</td><td rowspan="1" colspan="1">Added Cluster J, Issue 59 Error Codes.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-05-03</td><td rowspan="1" colspan="1">Closed issues with no change</td><td rowspan="1" colspan="1">Closed Cluster A, Issue 54 Weight Granularity in Scoring with same resolution as for Cluster A, Issue 5 Score Weighting, no further change to document. Closed Cluster H, Issue 9 Window with no change to the document. Closed Cluster H, Issue 19 FTScopeSelection on structure with no change to the document. Closed Cluster E, Issue 25 MatchOption Syntax with no change to the document. Closed Cluster H, Issue 44 FTContains Semantics with no change to the document.
</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-05-03</td><td rowspan="1" colspan="1">Updated FTContent syntax</td><td rowspan="1" colspan="1">Updated FTContent adding "entire content", Closed Cluster C, Issue 39 Exact Element Content.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-05-03</td><td rowspan="1" colspan="1">Closed issue on Boolean Naming</td><td rowspan="1" colspan="1">Closed Cluster F, Issue 38 Boolean Naming. Changes to the document are pending awaiting a decision on whether it is OK to use "and", "or", "not" for full text. If so change existing symbols to "and", "or", "not". If not change existing symbols to "ftand", "ftor", "ftnot".</td></tr><tr><td rowspan="1" colspan="1">Chavdar Botev</td><td rowspan="1" colspan="1">2005-05-03</td><td rowspan="1" colspan="1">Updated FTDistance semantics</td><td rowspan="1" colspan="1">Updated the semantics for distance.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-05-03</td><td rowspan="1" colspan="1">Updated FTRange syntax</td><td rowspan="1" colspan="1">Made "exactly" required before an exact number in FTRange. Closed Cluster F, Issue 43 Exactly in FTRangeSpec.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-05-04</td><td rowspan="1" colspan="1">Closed issue on collations</td><td rowspan="1" colspan="1">Closed Cluster D, Issue 57 Collations Match Option.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-05-19</td><td rowspan="1" colspan="1">Added issue on scoring</td><td rowspan="1" colspan="1">Added Cluster A, Issue 60 Extended Scoring.</td></tr><tr><td rowspan="1" colspan="1">Chavdar Botev</td><td rowspan="1" colspan="1">2005-06-29</td><td rowspan="1" colspan="1">Added issue on FTNegation</td><td rowspan="1" colspan="1">Added Cluster G, Issue 62 Precise semantics of double negation.</td></tr><tr><td rowspan="1" colspan="1">Chavdar Botev</td><td rowspan="1" colspan="1">2005-06-29</td><td rowspan="1" colspan="1">Added issue on FTTimes</td><td rowspan="1" colspan="1">Added Cluster G, Issue 61 Desired semantics of FTTimes.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-07-11</td><td rowspan="1" colspan="1">Updated FTMildNegation syntax</td><td rowspan="1" colspan="1">Updated the mild not syntax from "mild not" to "not in". Closed Cluster I, Issue 10 MildNot and Cluster F, Issue 41 Mildnot Naming.</td></tr><tr><td rowspan="1" colspan="1">Chavdar Botev</td><td rowspan="1" colspan="1">2005-07-12</td><td rowspan="1" colspan="1">Updated FTIgnore semantics</td><td rowspan="1" colspan="1">Changed semantics of FTIgnoreOption.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-07-18</td><td rowspan="1" colspan="1">Corrected error codes</td><td rowspan="1" colspan="1">Corrected and added error codes, closing and implementing the resolution for Cluster J Issue 59 Error Codes.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-07-18</td><td rowspan="1" colspan="1">Closed issues with no changes</td><td rowspan="1" colspan="1">closed Cluster I, Issue 13 "loose-grammar" leaving the grammar as it is. Closed issue Cluster D, Issue 53 "matchoptions-default" with no change to the document. Closed Cluster H, Issue 58 "ft-about-operator" with no change to the document.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-07-21</td><td rowspan="1" colspan="1">Updated score syntax</td><td rowspan="1" colspan="1">Closed Cluster A, Issue 60 "new-scoring-proposal" and Issue 2
"scoring-values" and updated Section 2.2 Score Clause to reflect new score syntaxes. There are now syntaxes for scored queries 1) returning the same results as queries with Boolean predicates and 2) for returning more or fewer results.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-07-21</td><td rowspan="1" colspan="1">Added appendix for defaults</td><td rowspan="1" colspan="1">Added appendix for defaults in the query prolog analogous to C.1 in the XQuery language document.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-07-21</td><td rowspan="1" colspan="1">Updated FTThesaurus section</td><td rowspan="1" colspan="1">Aligned description in Section 3.2.4 FTThesaurusOption with current grammar.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-07-21</td><td rowspan="1" colspan="1">Opened and closed issue on nested FTNegation</td><td rowspan="1" colspan="1">Opened and closed Cluster I, Issue 65 Nested FTNegations on the right side of an FTMildNegation.</td></tr><tr><td rowspan="1" colspan="1">Chavdar Botev</td><td rowspan="1" colspan="1">2005-07-25</td><td rowspan="1" colspan="1">Updated FTMildNegation semantics</td><td rowspan="1" colspan="1">Changed the semantics of MildNot.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-08-10</td><td rowspan="1" colspan="1">Added Change Log</td><td rowspan="1" colspan="1">Added Change Log harvesting back entries from CVS change log.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-08-17</td><td rowspan="1" colspan="1">Grammar changes</td><td rowspan="1" colspan="1">Changed XQuery/XPath grammar for new scoring syntax (resolution of
Issue 60), for match option defaults in query prolog (resolution of
Issue 45), for simplified window operator (resolution to Issue 51),
renamed "mild not" to "not in" (resolution of Issue 41), modified
FTThesaurusOption, FTStopwordOption and FTLanguageOption to require
StringLiterals as decided in May 05 F2F.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-08-17</td><td rowspan="1" colspan="1">Changes to Section 2</td><td rowspan="1" colspan="1">New scoring syntax introduced; rewritten most of 2.2. Corrected use
of weights in 2.2.1 (wrong default, wrong use of 1.5)</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-08-17</td><td rowspan="1" colspan="1">Changes to Section 3</td><td rowspan="1" colspan="1">Adapting the explanations to changed syntax for FTWindow,
FTThesaurusOption, FTStopwordOption and FTLanguageOption. Also
corrected a couple of example explanations. Removed FTIgnoreOption
from the list of match option defaults in 3.2 Corrected explanation
and example of FTLanguageOption (diacritics nor case are
language-specific!). Commented out last two examples of FTDistance,
because distance 15 does not work for phrases.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-08-17</td><td rowspan="1" colspan="1">Appendices A+B</td><td rowspan="1" colspan="1">Adapted introductory comment about which version of the
XQuery/XPath grammars we are aligned to.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-08-17</td><td rowspan="1" colspan="1">Dates in Header</td><td rowspan="1" colspan="1">Adapted current date and previous date and links in
full-text-query-language-semantics.xml and in tqheader.xml.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-08-19</td><td rowspan="1" colspan="1">Added Section 2.3, Changes in 3+4</td><td rowspan="1" colspan="1">Added Section 2.3 Extension to Static Context. Changed Sections 3.2
and 4.4.1.1 to refer to match option settings in the static context.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-08-19</td><td rowspan="1" colspan="1">Added Issue 63</td><td rowspan="1" colspan="1">Added Cluster G Issue 63: Distance constraints do not work on phrases.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-08-19</td><td rowspan="1" colspan="1">Changes in Section 4</td><td rowspan="1" colspan="1">Adapted semantics to new scoring feature (resolution of Issue 60),
changed FTWindow semantics according to resolution of Issue
51, and cleaned examples. </td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-08-19</td><td rowspan="1" colspan="1">Appendix G</td><td rowspan="1" colspan="1">Added lines for statically known thesauri and stop lists.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-08-25</td><td rowspan="1" colspan="1">Added Issue 64</td><td rowspan="1" colspan="1">Added Cluster E Issue 64:System Relative Operator Defaults (using wording proposed by Pat Case).</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-10-10</td><td rowspan="1" colspan="1">Changes in Section 3</td><td rowspan="1" colspan="1">Rephrased Section 3.2.7 FTIgnoreOption. Explanation and example adapted to simple (non-recursive) use of "ignore".</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-10-10</td><td rowspan="1" colspan="1">Changes in Section 4</td><td rowspan="1" colspan="1">Incorporated Section 4.3.1.4 Match and AllMatches Normal Form.</td></tr><tr><td rowspan="1" colspan="1">Sihem Amer-Yahia</td><td rowspan="1" colspan="1">2005-10-12</td><td rowspan="1" colspan="1">Incorporated comments</td><td rowspan="1" colspan="1">Incorporated Pat's comments at http://lists.w3.org/Archives/Member/member-query-fttf/2005Sep/0068.html</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2005-10-20</td><td rowspan="1" colspan="1">Changes in Sections 3 and 4</td><td rowspan="1" colspan="1">Properly marked up errors and inserted error summary appendix. Re-ordered appendices so normative appendices precede non-normative appendices.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-10-24</td><td rowspan="1" colspan="1">Final editings</td><td rowspan="1" colspan="1">Included corrections to examples in Section 3. Changed meaning of distance 0 for sentences (paragraphs) to mean adjacent. Rework of Appendix H Checklist of Implementation-Defined Features. Resolution texts to issues 45, 59, and 62.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-11-28</td><td rowspan="1" colspan="1">Restrict FTTimes to FTWords</td><td rowspan="1" colspan="1">Modified EBNF syntax to allow the FTTimes operation to be applicable only to simple FTWords.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2005-11-28</td><td rowspan="1" colspan="1">Re: Bug 2299: Changes to Section 4</td><td rowspan="1" colspan="1">The AllMatches model has been changed to allow the TokenInfo of a StringMatch to represent an interval of token positions, instead of single positions. Thus, a phrase is now modeled using a single StringMatch, and consequently distance constraints (which always apply to the individual StringMatches) can be used to constrain the entire phrase. In addition, this change allows to model overlapping tokens. The semantics functions for FTOrder (order now constrains the start positions of tokens), for FTScope, for FTDistance (a distance constraint requires a certain number of positions between the end of one token and the start of the next) and for FTWindows have been adapted.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2006-01-09</td><td rowspan="1" colspan="1">Issues List removed</td><td rowspan="1" colspan="1">Dropped Appendix I "Issues List", as issues are tracked in Bugzilla now.</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2006-02-01</td><td rowspan="1" colspan="1">Static context</td><td rowspan="1" colspan="1">Added known languages to static context.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2006-03-06</td><td rowspan="1" colspan="1">Bug 2776</td><td rowspan="1" colspan="1">Changed EBNF grammar to allow weights to be specified using RangeExpr.</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2006-03-30</td><td rowspan="1" colspan="1">Updated Tokenization 4.2.7</td><td rowspan="1" colspan="1">Expanded and clarified definition. Added examples.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2006-04-13</td><td rowspan="1" colspan="1">Replaced glossary</td><td rowspan="1" colspan="1">Removed glossary copied from the XQuery language document and inserted coding to produce a full-text glossary.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2006-04-24</td><td rowspan="1" colspan="1">Section 2</td><td rowspan="1" colspan="1">Added new Processing Model section.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2006-04-25</td><td rowspan="1" colspan="1">Section 4</td><td rowspan="1" colspan="1">Included the completely revised semantics schemata and  functions,
which now (i) correctly handle interval-based TokenInfos, (ii)
separate the representation of TokenInfos and SearchTokenInfos and
SearchItems, (iii) have been simplified regarding the semantics of
match options by no longer separating the implementation-defined
matching function from (most of) the implementation-defined
application of match options, and (iv) have been type- and syntax-checked.</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2006-05-31</td><td rowspan="1" colspan="1">Bug 2483</td><td rowspan="1" colspan="1">Clarified type constraints on full-text operator parameters in Section 3.
Revised EBNF to be more specific in some cases.
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2006-08-04</td><td rowspan="1" colspan="1">Bug 3374</td><td rowspan="1" colspan="1">Revised complete example in Section 4.3.3.</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2006-08-17</td><td rowspan="1" colspan="1">Added XQueryX support</td><td rowspan="1" colspan="1">Added new normative appendix defining the XML schemas and XSLT stylesheet
    necessary for XQuery and XPath Full Text 1.0 to integrate into XQueryX.</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2006-08-21</td><td rowspan="1" colspan="1">Bug 3439</td><td rowspan="1" colspan="1">Fixed FTMildNot semantics.</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2006-08-22</td><td rowspan="1" colspan="1">Conformance</td><td rowspan="1" colspan="1">Added new conformance section as section 5.  Add error code definitions to
appendix D.</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2006-08-22</td><td rowspan="1" colspan="1">FTWords</td><td rowspan="1" colspan="1">Fixed wording of FTWords with respect to type constraints.
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2006-10-05</td><td rowspan="1" colspan="1">Score Variables</td><td rowspan="1" colspan="1">Added more complex scoring examples as clarification for bug #3596.
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2006-10-05</td><td rowspan="1" colspan="1">FTSelection</td><td rowspan="1" colspan="1">Improved reading flow for examples. Make linkage of non-terminals
consistent. 
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2006-11-01</td><td rowspan="1" colspan="1">Overall</td><td rowspan="1" colspan="1">Reorganized structure of document to improve reading flow.
</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2006-12-26</td><td rowspan="1" colspan="1">FTLanguageOption</td><td rowspan="1" colspan="1">Revised text dealing with FTLanguageOption
values that do not identify a known, defined language in RFC 3066. 
Added reference to RFC 4646. 
</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2006-12-26</td><td rowspan="1" colspan="1">FTLanguageOption and FTContainsExpr</td><td rowspan="1" colspan="1">Added text saying that a full-text processor SHOULD use xml:lang information when
choosing collations and when processing FTMatchOptions.  Also added text saying that
an xml:lang specification SHOULD take precedence over an FTLanguageOption specification. 
</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2006-12-26</td><td rowspan="1" colspan="1">Tokenization</td><td rowspan="1" colspan="1">Made changes clarifying that tokenization SHOULD be implementation-defined (implicitly
permitting it to be implementation-dependent). 
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-01-22</td><td rowspan="1" colspan="1">Definitions for implementation-defined/ -dependent.</td><td rowspan="1" colspan="1">Added definitions for implementation-defined/dependent to
Introduction as in XQuery document. Added links throughout the paper.
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-02-17</td><td rowspan="1" colspan="1">Bug 3698</td><td rowspan="1" colspan="1">Removed options "with diacritics", "without diacritics".
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-02-17</td><td rowspan="1" colspan="1">Bug 3914</td><td rowspan="1" colspan="1">Changed syntax of Booleans to "ftand", "ftor", "ftnot".
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-02-17</td><td rowspan="1" colspan="1">Bug 3920</td><td rowspan="1" colspan="1">Changed 3rd example in 3.3.7 FTDistance and added a 4th.
</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2007-02-25</td><td rowspan="1" colspan="1">Bug 3935</td><td rowspan="1" colspan="1">Added text to define how wildcard characters can be escaped so they can be used in a search.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-02-26</td><td rowspan="1" colspan="1">Itemized sample tokens in 3 FTSelections</td><td rowspan="1" colspan="1">To resolve Bug 3913, added a sentence itemizing the first 5 tokens in the sample tokenization.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-02-26</td><td rowspan="1" colspan="1">Corrected example in 3.3.7 FTDistance</td><td rowspan="1" colspan="1">To resolve Bug 3920, corrected the first example and preceding text in 3.3.7 FTDistance to remove the "not in" operator and to use terms from the sample data.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-02-26</td><td rowspan="1" colspan="1">Inserted sentence into 3.2.6 FTLanguageOption</td><td rowspan="1" colspan="1">To resolve Bug 3926, inserted sentence into 3.2.6 FTLanguageOption saying that the "language" option MAY influence the behavior of other match options.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-02-26</td><td rowspan="1" colspan="1">Inserted a sentence into 3.2.5 FTStopWordOption</td><td rowspan="1" colspan="1">To resolve Bug 3930, inserted a sentence into 3.2.5 FTStopWordOption saying that "union" and "except" are applied from left to right.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-02-26</td><td rowspan="1" colspan="1">Added a note to 3.2.5 FTStopWordOption</td><td rowspan="1" colspan="1">To resolve Bug 3932, added a note to 3.2.5 FTStopWordOption saying Stop word lists MAY be applied during indexing. If applied during indexing asking for stop words to not be used during a query, will have no effect.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-02-26</td><td rowspan="1" colspan="1">Added a note to 3.4 FTIgnore</td><td rowspan="1" colspan="1">To resolve Bug 3936, added a note to 3..4 FTIgnore saying Nodes MAY be ignored during indexing and during query processing. Ignore option applies only to query processing. Whether and how indexing ignores nodes is out of scope for this specification.
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-02-26</td><td rowspan="1" colspan="1">Bug 3924</td><td rowspan="1" colspan="1">Changed grammar for match options: now precedence of match options is 
higher than Booleans. Included restriction to have at most one option of a 
group at a level.
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-02-27</td><td rowspan="1" colspan="1">Bug 3910, 3924, 3928</td><td rowspan="1" colspan="1">Reformulated what the case options mean. Added lower/uppercase as 
possible values for the case option to table in Appendix C (Static Context
Components) and put rules and alternatives in the grammar into a more logical 
order. Also ordered tables and lists in the text the same.
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-03-02</td><td rowspan="1" colspan="1">Bug 3737</td><td rowspan="1" colspan="1">Reformulated and restructured most of section 3. Added explanation of the
application structure of positional filters (formerly: FTProximities)
and how match options take effect. Renamed the following grammar
symbols:
FTWordsSelection to FTPrimary, FTWordsMatches to FTPrimaryWithOptions,
FTProximity to FTPosFilter.
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2007-04-02</td><td rowspan="1" colspan="1">Bugs 4345, 4355, 4358, 4445</td><td rowspan="1" colspan="1">Reworked description of the wildcard option and added a new example.  
Added note on the effect when
the lower bound of a range is greater than the upper bound.  Fixed FTContent
example to be "with wildcards".
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-04-09</td><td rowspan="1" colspan="1">Bug 3939</td><td rowspan="1" colspan="1">Added example for overlapping tokens in 4.1.
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-04-09</td><td rowspan="1" colspan="1">Bug 3931</td><td rowspan="1" colspan="1">Added match option application order, as agreed in FTTF-136.
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2007-04-19</td><td rowspan="1" colspan="1">Conformance</td><td rowspan="1" colspan="1">Made support for uppercase and lowercase FTCaseOptions optional.
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2007-04-19</td><td rowspan="1" colspan="1">Extensions</td><td rowspan="1" colspan="1">Added text to describe extension options and selections.
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-04-19</td><td rowspan="1" colspan="1">Bug 4386</td><td rowspan="1" colspan="1">And-selection description fixed in Sec. 3.
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-04-20</td><td rowspan="1" colspan="1">Bugs 3898, 4388</td><td rowspan="1" colspan="1">Finalized the additions needed to allow for nested FTDistance/FTWindow. 
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-04-23</td><td rowspan="1" colspan="1">Section 4</td><td rowspan="1" colspan="1">Simplifications to the match option schemata and processing. 
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2007-04-25</td><td rowspan="1" colspan="1">Schemas</td><td rowspan="1" colspan="1">Misc. editorial improvements to schemas.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-09-13</td><td rowspan="1" colspan="1">Definition of a token</td><td rowspan="1" colspan="1">Refined the definition of a token.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-09-13</td><td rowspan="1" colspan="1">Sections 1-2</td><td rowspan="1" colspan="1">Made editorial changes throughout Sections 1-2.
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2007-10-11</td><td rowspan="1" colspan="1">Semantics</td><td rowspan="1" colspan="1">Clarified definition of tokenization; fix-ups wrt overlapping tokens.</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2007-10-11</td><td rowspan="1" colspan="1">Conformance</td><td rowspan="1" colspan="1">Reinstated lost conformance item on negative weights; fixed up constraints
on scoring expressions.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-10-12</td><td rowspan="1" colspan="1">Reorganized Section 1.1</td><td rowspan="1" colspan="1">Reorganized Section 1.1, taking paragraphs out of the second ordered list, removing 2 sentences, reordering some of the paragraphs.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-10-12</td><td rowspan="1" colspan="1">Tokenization</td><td rowspan="1" colspan="1">Consolidated the early, informal introduction to tokenization into Section 1.1, moving what was in 2.1 Processing Model to Section 1.1. Removed some text and added a forward reference to the formal definition and constraints in 4.1.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-10-13</td><td rowspan="1" colspan="1">Using Weights</td><td rowspan="1" colspan="1">In 2.3.1. Using Weights, relabelled and reorganized the constraints pertaining to weights and scoring algorithms.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-10-15</td><td rowspan="1" colspan="1">Processing Model</td><td rowspan="1" colspan="1">In 2.1 Processing Model, made step 2, the new step 4a.
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-11-09</td><td rowspan="1" colspan="1">FTStopWords grammar and description</td><td rowspan="1" colspan="1">Renamed nonterminals: FTRefOrList to FTStopWords, 
FTInclExclStringLiteral to FTStopWordsInclExcl. Added negative stop words example: .../p ftcontains "propagating errors" 
with stop words ("few").
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-11-12</td><td rowspan="1" colspan="1">Chapter 3</td><td rowspan="1" colspan="1">Adapt text were it assumed that tokens have unique positions. Talk explicitly of covered token positions (in FTWords, FTContent).
</td></tr><tr><td rowspan="1" colspan="1">Jochen Doerre</td><td rowspan="1" colspan="1">2007-11-13</td><td rowspan="1" colspan="1">Chapter 3</td><td rowspan="1" colspan="1">More explanation for 2nd example for anchoring selection "at end" (3.6.5). Bug 4717. 
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2007-12-4</td><td rowspan="1" colspan="1">Title</td><td rowspan="1" colspan="1">Removed 1.0, 2.0, and hyphen from title and title references. 
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2008-01-24</td><td rowspan="1" colspan="1">Misc.</td><td rowspan="1" colspan="1">Bug fixes: 4714, 4715/2, 4717, 4728, 5415.
Replaced incorrect text in definition of FTWindow.
Eliminated notion of "adjacent" and "consecutive"
tokens; replaced with description in terms of token positions.
Made definition of Ignore option consistent with formal semantics: no new
context focus is generated.
Added additional examples.
Added informative reference to UAX29.
Consistent usage of the term "query string" etc.
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2008-01-24</td><td rowspan="1" colspan="1">Grammar.</td><td rowspan="1" colspan="1">Move ft-option to first part of prolog.
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2008-02-28</td><td rowspan="1" colspan="1">Semantics.</td><td rowspan="1" colspan="1">Clarify handling of overlapping tokens with respect to distance.
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2008-03-17</td><td rowspan="1" colspan="1">Semantics.</td><td rowspan="1" colspan="1">Minor fixes to function definitions to resolve issues: 5572, 5573, 5574,
and 5575. 
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2008-04-22</td><td rowspan="1" colspan="1">Naming conventions.</td><td rowspan="1" colspan="1">Use the case "StopWord" and "MildNot" consistently.
</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2008-08-26</td><td rowspan="1" colspan="1">Sections <specref ref="section-using-weights"/>, <specref ref="ftselections"/>,
and <specref ref="id-errors"/>
                  </td><td rowspan="1" colspan="1">Ensure that all description of weights, valid values, and errors related to invalid values
are captured in one place, and generalize the description of the error raised for invalid values. 
Resolves bug 5812. 
</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2008-08-26</td><td rowspan="1" colspan="1">Section <specref ref="id-extension-selections"/>
                  </td><td rowspan="1" colspan="1">Correct syntax of the second and third examples. 
Resolves bug 5879. 
</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2008-08-26</td><td rowspan="1" colspan="1">Section <specref ref="sec-ftnot"/>
                  </td><td rowspan="1" colspan="1">Rewrite the second example to correspond to the search document content. 
Resolves bug 5884. 
</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2008-08-26</td><td rowspan="1" colspan="1">Section <specref ref="sec-ftnot"/>
                  </td><td rowspan="1" colspan="1">Rewrite the third example to correspond to the search document structure. 
Resolves bug 5885. 
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2008-10-30</td><td rowspan="1" colspan="1">Miscellaneous</td><td rowspan="1" colspan="1">Add text to clarify status of attribute searches (bug 5975) and of
scope and constraints on score variables (bug 6094).
</td></tr><tr><td rowspan="1" colspan="1">Mary Holstege</td><td rowspan="1" colspan="1">2008-10-30</td><td rowspan="1" colspan="1">Full-Text Selections</td><td rowspan="1" colspan="1">Change scope of weight variables to FTPrimary rather than FTSelection to 
resolve bug 6178.
</td></tr><tr><td rowspan="1" colspan="1">Jim Melton</td><td rowspan="1" colspan="1">2008-11-12</td><td rowspan="1" colspan="1">Appendix <specref ref="id-xqft-xqueryx"/>
                  </td><td rowspan="1" colspan="1">Revise Schema and stylesheet to reflect change in position of "weight" in the grammar.
</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-23</td><td rowspan="1" colspan="1">Removed count &gt; 0 from examples</td><td rowspan="1" colspan="1">Removed count &gt; 0 from examples in 3.4.3 Thesaurus Option and 3.4.7 Stop Word Option.</td></tr><tr><td rowspan="1" colspan="1">Pat Case</td><td rowspan="1" colspan="1">2008-11-23</td><td rowspan="1" colspan="1">Corrected FTLanguage example</td><td rowspan="1" colspan="1">Corrected the FTLanguage example in Section 3.4.1 to search in content//p and to search for "salon de thé".</td></tr></tbody></table></inform-div1><!-- web35707.mail.mud.yahoo.com compressed/chunked Thu Sep 13 09:01:24 PDT 2007 --></back></spec>